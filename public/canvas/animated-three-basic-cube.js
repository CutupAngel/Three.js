(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

// Mark output/export as enabled for the client API scripts.
window['canvas-sketch-cli'] = window['canvas-sketch-cli'] || {};
window['canvas-sketch-cli'].output = true;

},{}],2:[function(require,module,exports){
"use strict";

const NAMESPACE = 'canvas-sketch-cli'; // Grab the CLI namespace

window[NAMESPACE] = window[NAMESPACE] || {};

if (!window[NAMESPACE].initialized) {
  initialize();
}

function initialize() {
  // Awaiting enable/disable event
  window[NAMESPACE].liveReloadEnabled = undefined;
  window[NAMESPACE].initialized = true;
  const defaultPostOptions = {
    method: 'POST',
    cache: 'no-cache',
    credentials: 'same-origin'
  }; // File saving utility

  window[NAMESPACE].saveBlob = (blob, opts) => {
    opts = opts || {};
    const form = new window.FormData();
    form.append('file', blob, opts.filename);
    return window.fetch('/canvas-sketch-cli/saveBlob', Object.assign({}, defaultPostOptions, {
      body: form
    })).then(res => {
      if (res.status === 200) {
        return res.json();
      } else {
        return res.text().then(text => {
          throw new Error(text);
        });
      }
    }).catch(err => {
      // Some issue, just bail out and return nil hash
      console.warn(`There was a problem exporting ${opts.filename}`);
      console.error(err);
      return undefined;
    });
  };

  const stream = (url, opts) => {
    opts = opts || {};
    return window.fetch(url, Object.assign({}, defaultPostOptions, {
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        save: opts.save,
        encoding: opts.encoding,
        timeStamp: opts.timeStamp,
        fps: opts.fps,
        filename: opts.filename
      })
    })).then(res => {
      if (res.status === 200) {
        return res.json();
      } else {
        return res.text().then(text => {
          throw new Error(text);
        });
      }
    }).catch(err => {
      // Some issue, just bail out and return nil hash
      console.warn(`There was a problem starting the stream export`);
      console.error(err);
      return undefined;
    });
  }; // File streaming utility


  window[NAMESPACE].streamStart = opts => {
    return stream('/canvas-sketch-cli/stream-start', opts);
  };

  window[NAMESPACE].streamEnd = opts => {
    return stream('/canvas-sketch-cli/stream-end', opts);
  }; // git commit utility


  window[NAMESPACE].commit = () => {
    return window.fetch('/canvas-sketch-cli/commit', defaultPostOptions).then(resp => resp.json()).then(result => {
      if (result.error) {
        if (result.error.toLowerCase().includes('not a git repository')) {
          console.warn(`Warning: ${result.error}`);
          return null;
        } else {
          throw new Error(result.error);
        }
      } // Notify user of changes


      console.log(result.changed ? `[git] ${result.hash} Committed changes` : `[git] ${result.hash} Nothing changed`);
      return result.hash;
    }).catch(err => {
      // Some issue, just bail out and return nil hash
      console.warn('Could not commit changes and fetch hash');
      console.error(err);
      return undefined;
    });
  };

  if ('budo-livereload' in window) {
    const client = window['budo-livereload'];
    client.listen(data => {
      if (data.event === 'hot-reload') {
        setupLiveReload(data.enabled);
      }
    }); // On first load, check to see if we should setup live reload or not

    if (window[NAMESPACE].hot) {
      setupLiveReload(true);
    } else {
      setupLiveReload(false);
    }
  }
}

function setupLiveReload(isEnabled) {
  const previousState = window[NAMESPACE].liveReloadEnabled;

  if (typeof previousState !== 'undefined' && isEnabled !== previousState) {
    // We need to reload the page to ensure the new sketch function is
    // named for hot reloading, and/or cleaned up after hot reloading is disabled
    window.location.reload(true);
    return;
  }

  if (isEnabled === window[NAMESPACE].liveReloadEnabled) {
    // No change in state
    return;
  } // Mark new state


  window[NAMESPACE].liveReloadEnabled = isEnabled;

  if (isEnabled) {
    if ('budo-livereload' in window) {
      console.log(`%c[canvas-sketch-cli]%c âœ¨ Hot Reload Enabled`, 'color: #8e8e8e;', 'color: initial;');
      const client = window['budo-livereload'];
      client.listen(onClientData);
    }
  }
}

function onClientData(data) {
  const client = window['budo-livereload'];
  if (!client) return;

  if (data.event === 'eval') {
    if (!data.error) {
      client.clearError();
    }

    try {
      eval(data.code);
      if (!data.error) console.log(`%c[canvas-sketch-cli]%c âœ¨ Hot Reloaded`, 'color: #8e8e8e;', 'color: initial;');
    } catch (err) {
      console.error(`%c[canvas-sketch-cli]%c ðŸš¨ Hot Reload error`, 'color: #8e8e8e;', 'color: initial;');
      client.showError(err.toString()); // This will also load up the problematic script so that stack traces with
      // source maps is visible

      const scriptElement = document.createElement('script');

      scriptElement.onload = () => {
        document.body.removeChild(scriptElement);
      };

      scriptElement.src = data.src;
      document.body.appendChild(scriptElement);
    }
  }
}

},{}],3:[function(require,module,exports){
(function (global){(function (){
/**
 * A basic ThreeJS cube scene.
 * @author Matt DesLauriers (@mattdesl)
 */

const canvasSketch = require('canvas-sketch');

// Ensure ThreeJS is in global scope for the 'examples/'
global.THREE = require('three');

// Include any additional ThreeJS examples below
require('three/examples/js/controls/OrbitControls');

const settings = {
  // Make the loop animated
  animate: true,
  // Get a WebGL canvas rather than 2D
  context: 'webgl',
  // Turn on MSAA
  attributes: { antialias: true }
};

const sketch = ({ context }) => {
  // Create a renderer
  const renderer = new THREE.WebGLRenderer({
    context
  });

  // WebGL background color
  renderer.setClearColor('#000', 1);

  // Setup a camera
  const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
  camera.position.set(2, 2, -4);
  camera.lookAt(new THREE.Vector3());

  // Setup camera controller
  const controls = new THREE.OrbitControls(camera, context.canvas);

  // Setup your scene
  const scene = new THREE.Scene();

  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshPhysicalMaterial({
      color: 'white',
      roughness: 0.75,
      flatShading: true
    })
  );
  scene.add(mesh);

  // Specify an ambient/unlit colour
  scene.add(new THREE.AmbientLight('#59314f'));

  // Add some light
  const light = new THREE.PointLight('#45caf7', 1, 15.5);
  light.position.set(2, 2, -4).multiplyScalar(1.5);
  scene.add(light);

  // draw each frame
  return {
    // Handle resize events here
    resize ({ pixelRatio, viewportWidth, viewportHeight }) {
      renderer.setPixelRatio(pixelRatio);
      renderer.setSize(viewportWidth, viewportHeight);
      camera.aspect = viewportWidth / viewportHeight;
      camera.updateProjectionMatrix();
    },
    // And render events here
    render ({ time, deltaTime }) {
      mesh.rotation.y = time * (10 * Math.PI / 180);
      controls.update();
      renderer.render(scene, camera);
    },
    // Dispose of WebGL context (optional)
    unload () {
      renderer.dispose();
    }
  };
};

canvasSketch(sketch, settings);

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"canvas-sketch":4,"three":5,"three/examples/js/controls/OrbitControls":6}],4:[function(require,module,exports){
(function (global){(function (){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.canvasSketch = factory());
}(this, (function () {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var browser =
	  commonjsGlobal.performance &&
	  commonjsGlobal.performance.now ? function now() {
	    return performance.now()
	  } : Date.now || function now() {
	    return +new Date
	  };

	var isPromise_1 = isPromise;

	function isPromise(obj) {
	  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
	}

	var isDom = isNode;

	function isNode (val) {
	  return (!val || typeof val !== 'object')
	    ? false
	    : (typeof window === 'object' && typeof window.Node === 'object')
	      ? (val instanceof window.Node)
	      : (typeof val.nodeType === 'number') &&
	        (typeof val.nodeName === 'string')
	}

	function getClientAPI() {
	    return typeof window !== 'undefined' && window['canvas-sketch-cli'];
	}

	function defined() {
	    var arguments$1 = arguments;

	    for (var i = 0;i < arguments.length; i++) {
	        if (arguments$1[i] != null) {
	            return arguments$1[i];
	        }
	    }
	    return undefined;
	}

	function isBrowser() {
	    return typeof document !== 'undefined';
	}

	function isWebGLContext(ctx) {
	    return typeof ctx.clear === 'function' && typeof ctx.clearColor === 'function' && typeof ctx.bufferData === 'function';
	}

	function isCanvas(element) {
	    return isDom(element) && /canvas/i.test(element.nodeName) && typeof element.getContext === 'function';
	}

	var keys = createCommonjsModule(function (module, exports) {
	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;

	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	});
	var keys_1 = keys.shim;

	var is_arguments = createCommonjsModule(function (module, exports) {
	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';

	exports = module.exports = supportsArgumentsClass ? supported : unsupported;

	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	}});
	var is_arguments_1 = is_arguments.supported;
	var is_arguments_2 = is_arguments.unsupported;

	var deepEqual_1 = createCommonjsModule(function (module) {
	var pSlice = Array.prototype.slice;



	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();

	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;

	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	};

	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}

	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}

	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (is_arguments(a)) {
	    if (!is_arguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = keys(a),
	        kb = keys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}
	});

	var dateformat = createCommonjsModule(function (module, exports) {
	/*
	 * Date Format 1.2.3
	 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
	 * MIT license
	 *
	 * Includes enhancements by Scott Trenda <scott.trenda.net>
	 * and Kris Kowal <cixar.com/~kris.kowal/>
	 *
	 * Accepts a date, a mask, or a date and a mask.
	 * Returns a formatted version of the given date.
	 * The date defaults to the current date/time.
	 * The mask defaults to dateFormat.masks.default.
	 */

	(function(global) {

	  var dateFormat = (function() {
	      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g;
	      var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
	      var timezoneClip = /[^-+\dA-Z]/g;
	  
	      // Regexes and supporting functions are cached through closure
	      return function (date, mask, utc, gmt) {
	  
	        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
	        if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
	          mask = date;
	          date = undefined;
	        }
	  
	        date = date || new Date;
	  
	        if(!(date instanceof Date)) {
	          date = new Date(date);
	        }
	  
	        if (isNaN(date)) {
	          throw TypeError('Invalid date');
	        }
	  
	        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);
	  
	        // Allow setting the utc/gmt argument via the mask
	        var maskSlice = mask.slice(0, 4);
	        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
	          mask = mask.slice(4);
	          utc = true;
	          if (maskSlice === 'GMT:') {
	            gmt = true;
	          }
	        }
	  
	        var _ = utc ? 'getUTC' : 'get';
	        var d = date[_ + 'Date']();
	        var D = date[_ + 'Day']();
	        var m = date[_ + 'Month']();
	        var y = date[_ + 'FullYear']();
	        var H = date[_ + 'Hours']();
	        var M = date[_ + 'Minutes']();
	        var s = date[_ + 'Seconds']();
	        var L = date[_ + 'Milliseconds']();
	        var o = utc ? 0 : date.getTimezoneOffset();
	        var W = getWeek(date);
	        var N = getDayOfWeek(date);
	        var flags = {
	          d:    d,
	          dd:   pad(d),
	          ddd:  dateFormat.i18n.dayNames[D],
	          dddd: dateFormat.i18n.dayNames[D + 7],
	          m:    m + 1,
	          mm:   pad(m + 1),
	          mmm:  dateFormat.i18n.monthNames[m],
	          mmmm: dateFormat.i18n.monthNames[m + 12],
	          yy:   String(y).slice(2),
	          yyyy: y,
	          h:    H % 12 || 12,
	          hh:   pad(H % 12 || 12),
	          H:    H,
	          HH:   pad(H),
	          M:    M,
	          MM:   pad(M),
	          s:    s,
	          ss:   pad(s),
	          l:    pad(L, 3),
	          L:    pad(Math.round(L / 10)),
	          t:    H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],
	          tt:   H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],
	          T:    H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],
	          TT:   H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],
	          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
	          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
	          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
	          W:    W,
	          N:    N
	        };
	  
	        return mask.replace(token, function (match) {
	          if (match in flags) {
	            return flags[match];
	          }
	          return match.slice(1, match.length - 1);
	        });
	      };
	    })();

	  dateFormat.masks = {
	    'default':               'ddd mmm dd yyyy HH:MM:ss',
	    'shortDate':             'm/d/yy',
	    'mediumDate':            'mmm d, yyyy',
	    'longDate':              'mmmm d, yyyy',
	    'fullDate':              'dddd, mmmm d, yyyy',
	    'shortTime':             'h:MM TT',
	    'mediumTime':            'h:MM:ss TT',
	    'longTime':              'h:MM:ss TT Z',
	    'isoDate':               'yyyy-mm-dd',
	    'isoTime':               'HH:MM:ss',
	    'isoDateTime':           'yyyy-mm-dd\'T\'HH:MM:sso',
	    'isoUtcDateTime':        'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
	    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'
	  };

	  // Internationalization strings
	  dateFormat.i18n = {
	    dayNames: [
	      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
	      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
	    ],
	    monthNames: [
	      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
	      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
	    ],
	    timeNames: [
	      'a', 'p', 'am', 'pm', 'A', 'P', 'AM', 'PM'
	    ]
	  };

	function pad(val, len) {
	  val = String(val);
	  len = len || 2;
	  while (val.length < len) {
	    val = '0' + val;
	  }
	  return val;
	}

	/**
	 * Get the ISO 8601 week number
	 * Based on comments from
	 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
	 *
	 * @param  {Object} `date`
	 * @return {Number}
	 */
	function getWeek(date) {
	  // Remove time components of date
	  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

	  // Change date to Thursday same week
	  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

	  // Take January 4th as it is always in week 1 (see ISO 8601)
	  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

	  // Change date to Thursday same week
	  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

	  // Check if daylight-saving-time-switch occurred and correct for it
	  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
	  targetThursday.setHours(targetThursday.getHours() - ds);

	  // Number of weeks between target Thursday and first Thursday
	  var weekDiff = (targetThursday - firstThursday) / (86400000*7);
	  return 1 + Math.floor(weekDiff);
	}

	/**
	 * Get ISO-8601 numeric representation of the day of the week
	 * 1 (for Monday) through 7 (for Sunday)
	 * 
	 * @param  {Object} `date`
	 * @return {Number}
	 */
	function getDayOfWeek(date) {
	  var dow = date.getDay();
	  if(dow === 0) {
	    dow = 7;
	  }
	  return dow;
	}

	/**
	 * kind-of shortcut
	 * @param  {*} val
	 * @return {String}
	 */
	function kindOf(val) {
	  if (val === null) {
	    return 'null';
	  }

	  if (val === undefined) {
	    return 'undefined';
	  }

	  if (typeof val !== 'object') {
	    return typeof val;
	  }

	  if (Array.isArray(val)) {
	    return 'array';
	  }

	  return {}.toString.call(val)
	    .slice(8, -1).toLowerCase();
	}


	  if (typeof undefined === 'function' && undefined.amd) {
	    undefined(function () {
	      return dateFormat;
	    });
	  } else {
	    module.exports = dateFormat;
	  }
	})(commonjsGlobal);
	});

	/*!
	 * repeat-string <https://github.com/jonschlinkert/repeat-string>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */

	/**
	 * Results cache
	 */

	var res = '';
	var cache;

	/**
	 * Expose `repeat`
	 */

	var repeatString = repeat;

	/**
	 * Repeat the given `string` the specified `number`
	 * of times.
	 *
	 * **Example:**
	 *
	 * ```js
	 * var repeat = require('repeat-string');
	 * repeat('A', 5);
	 * //=> AAAAA
	 * ```
	 *
	 * @param {String} `string` The string to repeat
	 * @param {Number} `number` The number of times to repeat the string
	 * @return {String} Repeated string
	 * @api public
	 */

	function repeat(str, num) {
	  if (typeof str !== 'string') {
	    throw new TypeError('expected a string');
	  }

	  // cover common, quick use cases
	  if (num === 1) return str;
	  if (num === 2) return str + str;

	  var max = str.length * num;
	  if (cache !== str || typeof cache === 'undefined') {
	    cache = str;
	    res = '';
	  } else if (res.length >= max) {
	    return res.substr(0, max);
	  }

	  while (max > res.length && num > 1) {
	    if (num & 1) {
	      res += str;
	    }

	    num >>= 1;
	    str += str;
	  }

	  res += str;
	  res = res.substr(0, max);
	  return res;
	}

	var padLeft = function padLeft(str, num, ch) {
	  str = str.toString();

	  if (typeof num === 'undefined') {
	    return str;
	  }

	  if (ch === 0) {
	    ch = '0';
	  } else if (ch) {
	    ch = ch.toString();
	  } else {
	    ch = ' ';
	  }

	  return repeatString(ch, num - str.length) + str;
	};

	var noop = function () {};
	var link;
	var defaultExts = {
	    extension: '',
	    prefix: '',
	    suffix: ''
	};
	var supportedEncodings = ['image/png','image/jpeg','image/webp'];
	function stream(isStart, opts) {
	    if ( opts === void 0 ) opts = {};

	    return new Promise(function (resolve, reject) {
	        opts = objectAssign({}, defaultExts, opts);
	        var filename = resolveFilename(Object.assign({}, opts, {
	            extension: '',
	            frame: undefined
	        }));
	        var func = isStart ? 'streamStart' : 'streamEnd';
	        var client = getClientAPI();
	        if (client && client.output && typeof client[func] === 'function') {
	            return client[func](objectAssign({}, opts, {
	                filename: filename
	            })).then(function (ev) { return resolve(ev); });
	        } else {
	            return resolve({
	                filename: filename,
	                client: false
	            });
	        }
	    });
	}

	function streamStart(opts) {
	    if ( opts === void 0 ) opts = {};

	    return stream(true, opts);
	}

	function streamEnd(opts) {
	    if ( opts === void 0 ) opts = {};

	    return stream(false, opts);
	}

	function exportCanvas(canvas, opt) {
	    if ( opt === void 0 ) opt = {};

	    var encoding = opt.encoding || 'image/png';
	    if (!supportedEncodings.includes(encoding)) 
	        { throw new Error(("Invalid canvas encoding " + encoding)); }
	    var extension = (encoding.split('/')[1] || '').replace(/jpeg/i, 'jpg');
	    if (extension) 
	        { extension = ("." + extension).toLowerCase(); }
	    return {
	        extension: extension,
	        type: encoding,
	        dataURL: canvas.toDataURL(encoding, opt.encodingQuality)
	    };
	}

	function createBlobFromDataURL(dataURL) {
	    return new Promise(function (resolve) {
	        var splitIndex = dataURL.indexOf(',');
	        if (splitIndex === -1) {
	            resolve(new window.Blob());
	            return;
	        }
	        var base64 = dataURL.slice(splitIndex + 1);
	        var byteString = window.atob(base64);
	        var type = dataURL.slice(0, splitIndex);
	        var mimeMatch = /data:([^;]+)/.exec(type);
	        var mime = (mimeMatch ? mimeMatch[1] : '') || undefined;
	        var ab = new ArrayBuffer(byteString.length);
	        var ia = new Uint8Array(ab);
	        for (var i = 0;i < byteString.length; i++) {
	            ia[i] = byteString.charCodeAt(i);
	        }
	        resolve(new window.Blob([ab], {
	            type: mime
	        }));
	    });
	}

	function saveDataURL(dataURL, opts) {
	    if ( opts === void 0 ) opts = {};

	    return createBlobFromDataURL(dataURL).then(function (blob) { return saveBlob(blob, opts); });
	}

	function saveBlob(blob, opts) {
	    if ( opts === void 0 ) opts = {};

	    return new Promise(function (resolve) {
	        opts = objectAssign({}, defaultExts, opts);
	        var filename = opts.filename;
	        var client = getClientAPI();
	        if (client && typeof client.saveBlob === 'function' && client.output) {
	            return client.saveBlob(blob, objectAssign({}, opts, {
	                filename: filename
	            })).then(function (ev) { return resolve(ev); });
	        } else {
	            if (!link) {
	                link = document.createElement('a');
	                link.style.visibility = 'hidden';
	                link.target = '_blank';
	            }
	            link.download = filename;
	            link.href = window.URL.createObjectURL(blob);
	            document.body.appendChild(link);
	            link.onclick = (function () {
	                link.onclick = noop;
	                setTimeout(function () {
	                    window.URL.revokeObjectURL(blob);
	                    if (link.parentElement) 
	                        { link.parentElement.removeChild(link); }
	                    link.removeAttribute('href');
	                    resolve({
	                        filename: filename,
	                        client: false
	                    });
	                });
	            });
	            link.click();
	        }
	    });
	}

	function saveFile(data, opts) {
	    if ( opts === void 0 ) opts = {};

	    var parts = Array.isArray(data) ? data : [data];
	    var blob = new window.Blob(parts, {
	        type: opts.type || ''
	    });
	    return saveBlob(blob, opts);
	}

	function getTimeStamp() {
	    var dateFormatStr = "yyyy.mm.dd-HH.MM.ss";
	    return dateformat(new Date(), dateFormatStr);
	}

	function resolveFilename(opt) {
	    if ( opt === void 0 ) opt = {};

	    opt = objectAssign({}, opt);
	    if (typeof opt.file === 'function') {
	        return opt.file(opt);
	    } else if (opt.file) {
	        return opt.file;
	    }
	    var frame = null;
	    var extension = '';
	    if (typeof opt.extension === 'string') 
	        { extension = opt.extension; }
	    if (typeof opt.frame === 'number') {
	        var totalFrames;
	        if (typeof opt.totalFrames === 'number') {
	            totalFrames = opt.totalFrames;
	        } else {
	            totalFrames = Math.max(10000, opt.frame);
	        }
	        frame = padLeft(String(opt.frame), String(totalFrames).length, '0');
	    }
	    var layerStr = isFinite(opt.totalLayers) && isFinite(opt.layer) && opt.totalLayers > 1 ? ("" + (opt.layer)) : '';
	    if (frame != null) {
	        return [layerStr,frame].filter(Boolean).join('-') + extension;
	    } else {
	        var defaultFileName = opt.timeStamp;
	        return [opt.prefix,opt.name || defaultFileName,layerStr,opt.hash,opt.suffix].filter(Boolean).join('-') + extension;
	    }
	}

	var commonTypos = {
	    dimension: 'dimensions',
	    animated: 'animate',
	    animating: 'animate',
	    unit: 'units',
	    P5: 'p5',
	    pixellated: 'pixelated',
	    looping: 'loop',
	    pixelPerInch: 'pixels'
	};
	var allKeys = ['dimensions','units','pixelsPerInch','orientation','scaleToFit',
	    'scaleToView','bleed','pixelRatio','exportPixelRatio','maxPixelRatio','scaleContext',
	    'resizeCanvas','styleCanvas','canvas','context','attributes','parent','file',
	    'name','prefix','suffix','animate','playing','loop','duration','totalFrames',
	    'fps','playbackRate','timeScale','frame','time','flush','pixelated','hotkeys',
	    'p5','id','scaleToFitPadding','data','params','encoding','encodingQuality'];
	var checkSettings = function (settings) {
	    var keys = Object.keys(settings);
	    keys.forEach(function (key) {
	        if (key in commonTypos) {
	            var actual = commonTypos[key];
	            console.warn(("[canvas-sketch] Could not recognize the setting \"" + key + "\", did you mean \"" + actual + "\"?"));
	        } else if (!allKeys.includes(key)) {
	            console.warn(("[canvas-sketch] Could not recognize the setting \"" + key + "\""));
	        }
	    });
	};

	function keyboardShortcuts (opt) {
	    if ( opt === void 0 ) opt = {};

	    var handler = function (ev) {
	        if (!opt.enabled()) 
	            { return; }
	        var client = getClientAPI();
	        if (ev.keyCode === 83 && !ev.altKey && (ev.metaKey || ev.ctrlKey)) {
	            ev.preventDefault();
	            opt.save(ev);
	        } else if (ev.keyCode === 32) {
	            opt.togglePlay(ev);
	        } else if (client && !ev.altKey && ev.keyCode === 75 && (ev.metaKey || ev.ctrlKey)) {
	            ev.preventDefault();
	            opt.commit(ev);
	        }
	    };
	    var attach = function () {
	        window.addEventListener('keydown', handler);
	    };
	    var detach = function () {
	        window.removeEventListener('keydown', handler);
	    };
	    return {
	        attach: attach,
	        detach: detach
	    };
	}

	var defaultUnits = 'mm';
	var data = [['postcard',101.6,152.4],['poster-small',280,430],['poster',460,610],
	    ['poster-large',610,910],['business-card',50.8,88.9],['2r',64,89],['3r',89,127],
	    ['4r',102,152],['5r',127,178],['6r',152,203],['8r',203,254],['10r',254,305],['11r',
	    279,356],['12r',305,381],['a0',841,1189],['a1',594,841],['a2',420,594],['a3',
	    297,420],['a4',210,297],['a5',148,210],['a6',105,148],['a7',74,105],['a8',52,
	    74],['a9',37,52],['a10',26,37],['2a0',1189,1682],['4a0',1682,2378],['b0',1000,
	    1414],['b1',707,1000],['b1+',720,1020],['b2',500,707],['b2+',520,720],['b3',353,
	    500],['b4',250,353],['b5',176,250],['b6',125,176],['b7',88,125],['b8',62,88],
	    ['b9',44,62],['b10',31,44],['b11',22,32],['b12',16,22],['c0',917,1297],['c1',
	    648,917],['c2',458,648],['c3',324,458],['c4',229,324],['c5',162,229],['c6',114,
	    162],['c7',81,114],['c8',57,81],['c9',40,57],['c10',28,40],['c11',22,32],['c12',
	    16,22],['half-letter',5.5,8.5,'in'],['letter',8.5,11,'in'],['legal',8.5,14,'in'],
	    ['junior-legal',5,8,'in'],['ledger',11,17,'in'],['tabloid',11,17,'in'],['ansi-a',
	    8.5,11.0,'in'],['ansi-b',11.0,17.0,'in'],['ansi-c',17.0,22.0,'in'],['ansi-d',
	    22.0,34.0,'in'],['ansi-e',34.0,44.0,'in'],['arch-a',9,12,'in'],['arch-b',12,18,
	    'in'],['arch-c',18,24,'in'],['arch-d',24,36,'in'],['arch-e',36,48,'in'],['arch-e1',
	    30,42,'in'],['arch-e2',26,38,'in'],['arch-e3',27,39,'in']];
	var paperSizes = data.reduce(function (dict, preset) {
	    var item = {
	        units: preset[3] || defaultUnits,
	        dimensions: [preset[1],preset[2]]
	    };
	    dict[preset[0]] = item;
	    dict[preset[0].replace(/-/g, ' ')] = item;
	    return dict;
	}, {})

	var defined$1 = function () {
	    for (var i = 0; i < arguments.length; i++) {
	        if (arguments[i] !== undefined) return arguments[i];
	    }
	};

	var units = [ 'mm', 'cm', 'm', 'pc', 'pt', 'in', 'ft', 'px' ];

	var conversions = {
	  // metric
	  m: {
	    system: 'metric',
	    factor: 1
	  },
	  cm: {
	    system: 'metric',
	    factor: 1 / 100
	  },
	  mm: {
	    system: 'metric',
	    factor: 1 / 1000
	  },
	  // imperial
	  pt: {
	    system: 'imperial',
	    factor: 1 / 72
	  },
	  pc: {
	    system: 'imperial',
	    factor: 1 / 6
	  },
	  in: {
	    system: 'imperial',
	    factor: 1
	  },
	  ft: {
	    system: 'imperial',
	    factor: 12
	  }
	};

	const anchors = {
	  metric: {
	    unit: 'm',
	    ratio: 1 / 0.0254
	  },
	  imperial: {
	    unit: 'in',
	    ratio: 0.0254
	  }
	};

	function round (value, decimals) {
	  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
	}

	function convertDistance (value, fromUnit, toUnit, opts) {
	  if (typeof value !== 'number' || !isFinite(value)) throw new Error('Value must be a finite number');
	  if (!fromUnit || !toUnit) throw new Error('Must specify from and to units');

	  opts = opts || {};
	  var pixelsPerInch = defined$1(opts.pixelsPerInch, 96);
	  var precision = opts.precision;
	  var roundPixel = opts.roundPixel !== false;

	  fromUnit = fromUnit.toLowerCase();
	  toUnit = toUnit.toLowerCase();

	  if (units.indexOf(fromUnit) === -1) throw new Error('Invalid from unit "' + fromUnit + '", must be one of: ' + units.join(', '));
	  if (units.indexOf(toUnit) === -1) throw new Error('Invalid from unit "' + toUnit + '", must be one of: ' + units.join(', '));

	  if (fromUnit === toUnit) {
	    // We don't need to convert from A to B since they are the same already
	    return value;
	  }

	  var toFactor = 1;
	  var fromFactor = 1;
	  var isToPixel = false;

	  if (fromUnit === 'px') {
	    fromFactor = 1 / pixelsPerInch;
	    fromUnit = 'in';
	  }
	  if (toUnit === 'px') {
	    isToPixel = true;
	    toFactor = pixelsPerInch;
	    toUnit = 'in';
	  }

	  var fromUnitData = conversions[fromUnit];
	  var toUnitData = conversions[toUnit];

	  // source to anchor inside source's system
	  var anchor = value * fromUnitData.factor * fromFactor;

	  // if systems differ, convert one to another
	  if (fromUnitData.system !== toUnitData.system) {
	    // regular 'm' to 'in' and so forth
	    anchor *= anchors[fromUnitData.system].ratio;
	  }

	  var result = anchor / toUnitData.factor * toFactor;
	  if (isToPixel && roundPixel) {
	    result = Math.round(result);
	  } else if (typeof precision === 'number' && isFinite(precision)) {
	    result = round(result, precision);
	  }
	  return result;
	}

	var convertLength = convertDistance;
	var units_1 = units;
	convertLength.units = units_1;

	function getDimensionsFromPreset(dimensions, unitsTo, pixelsPerInch) {
	    if ( unitsTo === void 0 ) unitsTo = 'px';
	    if ( pixelsPerInch === void 0 ) pixelsPerInch = 72;

	    if (typeof dimensions === 'string') {
	        var key = dimensions.toLowerCase();
	        if (!(key in paperSizes)) {
	            throw new Error(("The dimension preset \"" + dimensions + "\" is not supported or could not be found; try using a4, a3, postcard, letter, etc."));
	        }
	        var preset = paperSizes[key];
	        return preset.dimensions.map(function (d) { return convertDistance$1(d, preset.units, unitsTo, pixelsPerInch); });
	    } else {
	        return dimensions;
	    }
	}

	function convertDistance$1(dimension, unitsFrom, unitsTo, pixelsPerInch) {
	    if ( unitsFrom === void 0 ) unitsFrom = 'px';
	    if ( unitsTo === void 0 ) unitsTo = 'px';
	    if ( pixelsPerInch === void 0 ) pixelsPerInch = 72;

	    return convertLength(dimension, unitsFrom, unitsTo, {
	        pixelsPerInch: pixelsPerInch,
	        precision: 4,
	        roundPixel: true
	    });
	}

	function checkIfHasDimensions(settings) {
	    if (!settings.dimensions) 
	        { return false; }
	    if (typeof settings.dimensions === 'string') 
	        { return true; }
	    if (Array.isArray(settings.dimensions) && settings.dimensions.length >= 2) 
	        { return true; }
	    return false;
	}

	function getParentSize(props, settings) {
	    if (!isBrowser()) {
	        return [300,150];
	    }
	    var element = settings.parent || window;
	    if (element === window || element === document || element === document.body) {
	        return [window.innerWidth,window.innerHeight];
	    } else {
	        var ref = element.getBoundingClientRect();
	        var width = ref.width;
	        var height = ref.height;
	        return [width,height];
	    }
	}

	function resizeCanvas(props, settings) {
	    var width, height;
	    var styleWidth, styleHeight;
	    var canvasWidth, canvasHeight;
	    var browser = isBrowser();
	    var dimensions = settings.dimensions;
	    var hasDimensions = checkIfHasDimensions(settings);
	    var exporting = props.exporting;
	    var scaleToFit = hasDimensions ? settings.scaleToFit !== false : false;
	    var scaleToView = !exporting && hasDimensions ? settings.scaleToView : true;
	    if (!browser) 
	        { scaleToFit = (scaleToView = false); }
	    var units = settings.units;
	    var pixelsPerInch = typeof settings.pixelsPerInch === 'number' && isFinite(settings.pixelsPerInch) ? settings.pixelsPerInch : 72;
	    var bleed = defined(settings.bleed, 0);
	    var devicePixelRatio = browser ? window.devicePixelRatio : 1;
	    var basePixelRatio = scaleToView ? devicePixelRatio : 1;
	    var pixelRatio, exportPixelRatio;
	    if (typeof settings.pixelRatio === 'number' && isFinite(settings.pixelRatio)) {
	        pixelRatio = settings.pixelRatio;
	        exportPixelRatio = defined(settings.exportPixelRatio, pixelRatio);
	    } else {
	        if (hasDimensions) {
	            pixelRatio = basePixelRatio;
	            exportPixelRatio = defined(settings.exportPixelRatio, 1);
	        } else {
	            pixelRatio = devicePixelRatio;
	            exportPixelRatio = defined(settings.exportPixelRatio, pixelRatio);
	        }
	    }
	    if (typeof settings.maxPixelRatio === 'number' && isFinite(settings.maxPixelRatio)) {
	        pixelRatio = Math.min(settings.maxPixelRatio, pixelRatio);
	    }
	    if (exporting) {
	        pixelRatio = exportPixelRatio;
	    }
	    var ref = getParentSize(props, settings);
	    var parentWidth = ref[0];
	    var parentHeight = ref[1];
	    var trimWidth, trimHeight;
	    if (hasDimensions) {
	        var result = getDimensionsFromPreset(dimensions, units, pixelsPerInch);
	        var highest = Math.max(result[0], result[1]);
	        var lowest = Math.min(result[0], result[1]);
	        if (settings.orientation) {
	            var landscape = settings.orientation === 'landscape';
	            width = landscape ? highest : lowest;
	            height = landscape ? lowest : highest;
	        } else {
	            width = result[0];
	            height = result[1];
	        }
	        trimWidth = width;
	        trimHeight = height;
	        width += bleed * 2;
	        height += bleed * 2;
	    } else {
	        width = parentWidth;
	        height = parentHeight;
	        trimWidth = width;
	        trimHeight = height;
	    }
	    var realWidth = width;
	    var realHeight = height;
	    if (hasDimensions && units) {
	        realWidth = convertDistance$1(width, units, 'px', pixelsPerInch);
	        realHeight = convertDistance$1(height, units, 'px', pixelsPerInch);
	    }
	    styleWidth = Math.round(realWidth);
	    styleHeight = Math.round(realHeight);
	    if (scaleToFit && !exporting && hasDimensions) {
	        var aspect = width / height;
	        var windowAspect = parentWidth / parentHeight;
	        var scaleToFitPadding = defined(settings.scaleToFitPadding, 40);
	        var maxWidth = Math.round(parentWidth - scaleToFitPadding * 2);
	        var maxHeight = Math.round(parentHeight - scaleToFitPadding * 2);
	        if (styleWidth > maxWidth || styleHeight > maxHeight) {
	            if (windowAspect > aspect) {
	                styleHeight = maxHeight;
	                styleWidth = Math.round(styleHeight * aspect);
	            } else {
	                styleWidth = maxWidth;
	                styleHeight = Math.round(styleWidth / aspect);
	            }
	        }
	    }
	    canvasWidth = scaleToView ? Math.round(pixelRatio * styleWidth) : Math.round(pixelRatio * realWidth);
	    canvasHeight = scaleToView ? Math.round(pixelRatio * styleHeight) : Math.round(pixelRatio * realHeight);
	    var viewportWidth = scaleToView ? Math.round(styleWidth) : Math.round(realWidth);
	    var viewportHeight = scaleToView ? Math.round(styleHeight) : Math.round(realHeight);
	    var scaleX = canvasWidth / width;
	    var scaleY = canvasHeight / height;
	    return {
	        bleed: bleed,
	        pixelRatio: pixelRatio,
	        width: width,
	        height: height,
	        dimensions: [width,height],
	        units: units || 'px',
	        scaleX: scaleX,
	        scaleY: scaleY,
	        pixelsPerInch: pixelsPerInch,
	        viewportWidth: viewportWidth,
	        viewportHeight: viewportHeight,
	        canvasWidth: canvasWidth,
	        canvasHeight: canvasHeight,
	        trimWidth: trimWidth,
	        trimHeight: trimHeight,
	        styleWidth: styleWidth,
	        styleHeight: styleHeight
	    };
	}

	var getCanvasContext_1 = getCanvasContext;
	function getCanvasContext (type, opts) {
	  if (typeof type !== 'string') {
	    throw new TypeError('must specify type string')
	  }

	  opts = opts || {};

	  if (typeof document === 'undefined' && !opts.canvas) {
	    return null // check for Node
	  }

	  var canvas = opts.canvas || document.createElement('canvas');
	  if (typeof opts.width === 'number') {
	    canvas.width = opts.width;
	  }
	  if (typeof opts.height === 'number') {
	    canvas.height = opts.height;
	  }

	  var attribs = opts;
	  var gl;
	  try {
	    var names = [ type ];
	    // prefix GL contexts
	    if (type.indexOf('webgl') === 0) {
	      names.push('experimental-' + type);
	    }

	    for (var i = 0; i < names.length; i++) {
	      gl = canvas.getContext(names[i], attribs);
	      if (gl) return gl
	    }
	  } catch (e) {
	    gl = null;
	  }
	  return (gl || null) // ensure null on fail
	}

	function createCanvasElement() {
	    if (!isBrowser()) {
	        throw new Error('It appears you are runing from Node.js or a non-browser environment. Try passing in an existing { canvas } interface instead.');
	    }
	    return document.createElement('canvas');
	}

	function createCanvas(settings) {
	    if ( settings === void 0 ) settings = {};

	    var context, canvas;
	    var ownsCanvas = false;
	    if (settings.canvas !== false) {
	        context = settings.context;
	        if (!context || typeof context === 'string') {
	            var newCanvas = settings.canvas;
	            if (!newCanvas) {
	                newCanvas = createCanvasElement();
	                ownsCanvas = true;
	            }
	            var type = context || '2d';
	            if (typeof newCanvas.getContext !== 'function') {
	                throw new Error("The specified { canvas } element does not have a getContext() function, maybe it is not a <canvas> tag?");
	            }
	            context = getCanvasContext_1(type, objectAssign({}, settings.attributes, {
	                canvas: newCanvas
	            }));
	            if (!context) {
	                throw new Error(("Failed at canvas.getContext('" + type + "') - the browser may not support this context, or a different context may already be in use with this canvas."));
	            }
	        }
	        canvas = context.canvas;
	        if (settings.canvas && canvas !== settings.canvas) {
	            throw new Error('The { canvas } and { context } settings must point to the same underlying canvas element');
	        }
	        if (settings.pixelated) {
	            context.imageSmoothingEnabled = false;
	            context.mozImageSmoothingEnabled = false;
	            context.oImageSmoothingEnabled = false;
	            context.webkitImageSmoothingEnabled = false;
	            context.msImageSmoothingEnabled = false;
	            canvas.style['image-rendering'] = 'pixelated';
	        }
	    }
	    return {
	        canvas: canvas,
	        context: context,
	        ownsCanvas: ownsCanvas
	    };
	}

	var SketchManager = function SketchManager() {
	    var this$1 = this;

	    this._settings = {};
	    this._props = {};
	    this._sketch = undefined;
	    this._raf = null;
	    this._recordTimeout = null;
	    this._lastRedrawResult = undefined;
	    this._isP5Resizing = false;
	    this._keyboardShortcuts = keyboardShortcuts({
	        enabled: function () { return this$1.settings.hotkeys !== false; },
	        save: function (ev) {
	            if (ev.shiftKey) {
	                if (this$1.props.recording) {
	                    this$1.endRecord();
	                    this$1.run();
	                } else 
	                    { this$1.record(); }
	            } else if (!this$1.props.recording) {
	                this$1.exportFrame();
	            }
	        },
	        togglePlay: function () {
	            if (this$1.props.playing) 
	                { this$1.pause(); }
	             else 
	                { this$1.play(); }
	        },
	        commit: function (ev) {
	            this$1.exportFrame({
	                commit: true
	            });
	        }
	    });
	    this._animateHandler = (function () { return this$1.animate(); });
	    this._resizeHandler = (function () {
	        var changed = this$1.resize();
	        if (changed) {
	            this$1.render();
	        }
	    });
	};

	var prototypeAccessors = { sketch: { configurable: true },settings: { configurable: true },props: { configurable: true } };
	prototypeAccessors.sketch.get = function () {
	    return this._sketch;
	};
	prototypeAccessors.settings.get = function () {
	    return this._settings;
	};
	prototypeAccessors.props.get = function () {
	    return this._props;
	};
	SketchManager.prototype._computePlayhead = function _computePlayhead (currentTime, duration) {
	    var hasDuration = typeof duration === 'number' && isFinite(duration);
	    return hasDuration ? currentTime / duration : 0;
	};
	SketchManager.prototype._computeFrame = function _computeFrame (playhead, time, totalFrames, fps) {
	    return isFinite(totalFrames) && totalFrames > 1 ? Math.floor(playhead * (totalFrames - 1)) : Math.floor(fps * time);
	};
	SketchManager.prototype._computeCurrentFrame = function _computeCurrentFrame () {
	    return this._computeFrame(this.props.playhead, this.props.time, this.props.totalFrames, this.props.fps);
	};
	SketchManager.prototype._getSizeProps = function _getSizeProps () {
	    var props = this.props;
	    return {
	        width: props.width,
	        height: props.height,
	        pixelRatio: props.pixelRatio,
	        canvasWidth: props.canvasWidth,
	        canvasHeight: props.canvasHeight,
	        viewportWidth: props.viewportWidth,
	        viewportHeight: props.viewportHeight
	    };
	};
	SketchManager.prototype.run = function run () {
	    if (!this.sketch) 
	        { throw new Error('should wait until sketch is loaded before trying to play()'); }
	    if (this.settings.playing !== false) {
	        this.play();
	    }
	    if (typeof this.sketch.dispose === 'function') {
	        console.warn('In canvas-sketch@0.0.23 the dispose() event has been renamed to unload()');
	    }
	    if (!this.props.started) {
	        this._signalBegin();
	        this.props.started = true;
	    }
	    this.tick();
	    this.render();
	    return this;
	};
	SketchManager.prototype._cancelTimeouts = function _cancelTimeouts () {
	    if (this._raf != null && typeof window !== 'undefined' && typeof window.cancelAnimationFrame === 'function') {
	        window.cancelAnimationFrame(this._raf);
	        this._raf = null;
	    }
	    if (this._recordTimeout != null) {
	        clearTimeout(this._recordTimeout);
	        this._recordTimeout = null;
	    }
	};
	SketchManager.prototype.play = function play () {
	    var animate = this.settings.animate;
	    if ('animation' in this.settings) {
	        animate = true;
	        console.warn('[canvas-sketch] { animation } has been renamed to { animate }');
	    }
	    if (!animate) 
	        { return; }
	    if (!isBrowser()) {
	        console.error('[canvas-sketch] WARN: Using { animate } in Node.js is not yet supported');
	        return;
	    }
	    if (this.props.playing) 
	        { return; }
	    if (!this.props.started) {
	        this._signalBegin();
	        this.props.started = true;
	    }
	    this.props.playing = true;
	    this._cancelTimeouts();
	    this._lastTime = browser();
	    this._raf = window.requestAnimationFrame(this._animateHandler);
	};
	SketchManager.prototype.pause = function pause () {
	    if (this.props.recording) 
	        { this.endRecord(); }
	    this.props.playing = false;
	    this._cancelTimeouts();
	};
	SketchManager.prototype.togglePlay = function togglePlay () {
	    if (this.props.playing) 
	        { this.pause(); }
	     else 
	        { this.play(); }
	};
	SketchManager.prototype.stop = function stop () {
	    this.pause();
	    this.props.frame = 0;
	    this.props.playhead = 0;
	    this.props.time = 0;
	    this.props.deltaTime = 0;
	    this.props.started = false;
	    this.render();
	};
	SketchManager.prototype.record = function record () {
	        var this$1 = this;

	    if (this.props.recording) 
	        { return; }
	    if (!isBrowser()) {
	        console.error('[canvas-sketch] WARN: Recording from Node.js is not yet supported');
	        return;
	    }
	    this.stop();
	    this.props.playing = true;
	    this.props.recording = true;
	    var exportOpts = this._createExportOptions({
	        sequence: true
	    });
	    var frameInterval = 1 / this.props.fps;
	    this._cancelTimeouts();
	    var tick = function () {
	        if (!this$1.props.recording) 
	            { return Promise.resolve(); }
	        this$1.props.deltaTime = frameInterval;
	        this$1.tick();
	        return this$1.exportFrame(exportOpts).then(function () {
	            if (!this$1.props.recording) 
	                { return; }
	            this$1.props.deltaTime = 0;
	            this$1.props.frame++;
	            if (this$1.props.frame < this$1.props.totalFrames) {
	                this$1.props.time += frameInterval;
	                this$1.props.playhead = this$1._computePlayhead(this$1.props.time, this$1.props.duration);
	                this$1._recordTimeout = setTimeout(tick, 0);
	            } else {
	                console.log('Finished recording');
	                this$1._signalEnd();
	                this$1.endRecord();
	                this$1.stop();
	                this$1.run();
	            }
	        });
	    };
	    if (!this.props.started) {
	        this._signalBegin();
	        this.props.started = true;
	    }
	    if (this.sketch && typeof this.sketch.beginRecord === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.beginRecord(props); });
	    }
	    streamStart(exportOpts).catch(function (err) {
	        console.error(err);
	    }).then(function (response) {
	        this$1._raf = window.requestAnimationFrame(tick);
	    });
	};
	SketchManager.prototype._signalBegin = function _signalBegin () {
	        var this$1 = this;

	    if (this.sketch && typeof this.sketch.begin === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.begin(props); });
	    }
	};
	SketchManager.prototype._signalEnd = function _signalEnd () {
	        var this$1 = this;

	    if (this.sketch && typeof this.sketch.end === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.end(props); });
	    }
	};
	SketchManager.prototype.endRecord = function endRecord () {
	        var this$1 = this;

	    var wasRecording = this.props.recording;
	    this._cancelTimeouts();
	    this.props.recording = false;
	    this.props.deltaTime = 0;
	    this.props.playing = false;
	    return streamEnd().catch(function (err) {
	        console.error(err);
	    }).then(function () {
	        if (wasRecording && this$1.sketch && typeof this$1.sketch.endRecord === 'function') {
	            this$1._wrapContextScale(function (props) { return this$1.sketch.endRecord(props); });
	        }
	    });
	};
	SketchManager.prototype._createExportOptions = function _createExportOptions (opt) {
	        if ( opt === void 0 ) opt = {};

	    return {
	        sequence: opt.sequence,
	        save: opt.save,
	        fps: this.props.fps,
	        frame: opt.sequence ? this.props.frame : undefined,
	        file: this.settings.file,
	        name: this.settings.name,
	        prefix: this.settings.prefix,
	        suffix: this.settings.suffix,
	        encoding: this.settings.encoding,
	        encodingQuality: this.settings.encodingQuality,
	        timeStamp: opt.timeStamp || getTimeStamp(),
	        totalFrames: isFinite(this.props.totalFrames) ? Math.max(0, this.props.totalFrames) : 1000
	    };
	};
	SketchManager.prototype.exportFrame = function exportFrame (opt) {
	        var this$1 = this;
	        if ( opt === void 0 ) opt = {};

	    if (!this.sketch) 
	        { return Promise.all([]); }
	    if (typeof this.sketch.preExport === 'function') {
	        this.sketch.preExport();
	    }
	    var exportOpts = this._createExportOptions(opt);
	    var client = getClientAPI();
	    var p = Promise.resolve();
	    if (client && opt.commit && typeof client.commit === 'function') {
	        var commitOpts = objectAssign({}, exportOpts);
	        var hash = client.commit(commitOpts);
	        if (isPromise_1(hash)) 
	            { p = hash; }
	         else 
	            { p = Promise.resolve(hash); }
	    }
	    return p.then(function (hash) { return this$1._doExportFrame(objectAssign({}, exportOpts, {
	        hash: hash || ''
	    })); }).then(function (result) {
	        if (result.length === 1) 
	            { return result[0]; }
	         else 
	            { return result; }
	    });
	};
	SketchManager.prototype._doExportFrame = function _doExportFrame (exportOpts) {
	        var this$1 = this;
	        if ( exportOpts === void 0 ) exportOpts = {};

	    this._props.exporting = true;
	    this.resize();
	    var drawResult = this.render();
	    var canvas = this.props.canvas;
	    if (typeof drawResult === 'undefined') {
	        drawResult = [canvas];
	    }
	    drawResult = [].concat(drawResult).filter(Boolean);
	    drawResult = drawResult.map(function (result) {
	        var hasDataObject = typeof result === 'object' && result && ('data' in result || 'dataURL' in result);
	        var data = hasDataObject ? result.data : result;
	        var opts = hasDataObject ? objectAssign({}, result, {
	            data: data
	        }) : {
	            data: data
	        };
	        if (isCanvas(data)) {
	            var encoding = opts.encoding || exportOpts.encoding;
	            var encodingQuality = defined(opts.encodingQuality, exportOpts.encodingQuality, 0.95);
	            var ref = exportCanvas(data, {
	                encoding: encoding,
	                encodingQuality: encodingQuality
	            });
	                var dataURL = ref.dataURL;
	                var extension = ref.extension;
	                var type = ref.type;
	            return Object.assign(opts, {
	                dataURL: dataURL,
	                extension: extension,
	                type: type
	            });
	        } else {
	            return opts;
	        }
	    });
	    this._props.exporting = false;
	    this.resize();
	    this.render();
	    return Promise.all(drawResult.map(function (result, i, layerList) {
	        var curOpt = objectAssign({
	            extension: '',
	            prefix: '',
	            suffix: ''
	        }, exportOpts, result, {
	            layer: i,
	            totalLayers: layerList.length
	        });
	        var saveParam = exportOpts.save === false ? false : result.save;
	        curOpt.save = saveParam !== false;
	        curOpt.filename = resolveFilename(curOpt);
	        delete curOpt.encoding;
	        delete curOpt.encodingQuality;
	        for (var k in curOpt) {
	            if (typeof curOpt[k] === 'undefined') 
	                { delete curOpt[k]; }
	        }
	        var savePromise = Promise.resolve({});
	        if (curOpt.save) {
	            var data = curOpt.data;
	            if (curOpt.dataURL) {
	                var dataURL = curOpt.dataURL;
	                savePromise = saveDataURL(dataURL, curOpt);
	            } else {
	                savePromise = saveFile(data, curOpt);
	            }
	        }
	        return savePromise.then(function (saveResult) { return Object.assign({}, curOpt, saveResult); });
	    })).then(function (ev) {
	        var savedEvents = ev.filter(function (e) { return e.save; });
	        if (savedEvents.length > 0) {
	            var eventWithOutput = savedEvents.find(function (e) { return e.outputName; });
	            var isClient = savedEvents.some(function (e) { return e.client; });
	            var isStreaming = savedEvents.some(function (e) { return e.stream; });
	            var item;
	            if (savedEvents.length > 1) 
	                { item = savedEvents.length; }
	             else if (eventWithOutput) 
	                { item = (eventWithOutput.outputName) + "/" + (savedEvents[0].filename); }
	             else 
	                { item = "" + (savedEvents[0].filename); }
	            var ofSeq = '';
	            if (exportOpts.sequence) {
	                var hasTotalFrames = isFinite(this$1.props.totalFrames);
	                ofSeq = hasTotalFrames ? (" (frame " + (exportOpts.frame + 1) + " / " + (this$1.props.totalFrames) + ")") : (" (frame " + (exportOpts.frame) + ")");
	            } else if (savedEvents.length > 1) {
	                ofSeq = " files";
	            }
	            var client = isClient ? 'canvas-sketch-cli' : 'canvas-sketch';
	            var action = isStreaming ? 'Streaming into' : 'Exported';
	            console.log(("%c[" + client + "]%c " + action + " %c" + item + "%c" + ofSeq), 'color: #8e8e8e;', 'color: initial;', 'font-weight: bold;', 'font-weight: initial;');
	        }
	        if (typeof this$1.sketch.postExport === 'function') {
	            this$1.sketch.postExport();
	        }
	        return ev;
	    });
	};
	SketchManager.prototype._wrapContextScale = function _wrapContextScale (cb) {
	    this._preRender();
	    cb(this.props);
	    this._postRender();
	};
	SketchManager.prototype._preRender = function _preRender () {
	    var props = this.props;
	    if (!this.props.gl && props.context && !props.p5) {
	        props.context.save();
	        if (this.settings.scaleContext !== false) {
	            props.context.scale(props.scaleX, props.scaleY);
	        }
	    } else if (props.p5) {
	        props.p5.scale(props.scaleX / props.pixelRatio, props.scaleY / props.pixelRatio);
	    }
	};
	SketchManager.prototype._postRender = function _postRender () {
	    var props = this.props;
	    if (!this.props.gl && props.context && !props.p5) {
	        props.context.restore();
	    }
	    if (props.gl && this.settings.flush !== false && !props.p5) {
	        props.gl.flush();
	    }
	};
	SketchManager.prototype.tick = function tick () {
	    if (this.sketch && typeof this.sketch.tick === 'function') {
	        this._preRender();
	        this.sketch.tick(this.props);
	        this._postRender();
	    }
	};
	SketchManager.prototype.render = function render () {
	    if (this.props.p5) {
	        this._lastRedrawResult = undefined;
	        this.props.p5.redraw();
	        return this._lastRedrawResult;
	    } else {
	        return this.submitDrawCall();
	    }
	};
	SketchManager.prototype.submitDrawCall = function submitDrawCall () {
	    if (!this.sketch) 
	        { return; }
	    var props = this.props;
	    this._preRender();
	    var drawResult;
	    if (typeof this.sketch === 'function') {
	        drawResult = this.sketch(props);
	    } else if (typeof this.sketch.render === 'function') {
	        drawResult = this.sketch.render(props);
	    }
	    this._postRender();
	    return drawResult;
	};
	SketchManager.prototype.update = function update (opt) {
	        var this$1 = this;
	        if ( opt === void 0 ) opt = {};

	    var notYetSupported = ['animate'];
	    Object.keys(opt).forEach(function (key) {
	        if (notYetSupported.indexOf(key) >= 0) {
	            throw new Error(("Sorry, the { " + key + " } option is not yet supported with update()."));
	        }
	    });
	    var oldCanvas = this._settings.canvas;
	    var oldContext = this._settings.context;
	    for (var key in opt) {
	        var value = opt[key];
	        if (typeof value !== 'undefined') {
	            this$1._settings[key] = value;
	        }
	    }
	    var timeOpts = Object.assign({}, this._settings, opt);
	    if ('time' in opt && 'frame' in opt) 
	        { throw new Error('You should specify { time } or { frame } but not both'); }
	     else if ('time' in opt) 
	        { delete timeOpts.frame; }
	     else if ('frame' in opt) 
	        { delete timeOpts.time; }
	    if ('duration' in opt && 'totalFrames' in opt) 
	        { throw new Error('You should specify { duration } or { totalFrames } but not both'); }
	     else if ('duration' in opt) 
	        { delete timeOpts.totalFrames; }
	     else if ('totalFrames' in opt) 
	        { delete timeOpts.duration; }
	    if ('data' in opt) 
	        { this._props.data = opt.data; }
	    var timeProps = this.getTimeProps(timeOpts);
	    Object.assign(this._props, timeProps);
	    if (oldCanvas !== this._settings.canvas || oldContext !== this._settings.context) {
	        var ref = createCanvas(this._settings);
	            var canvas = ref.canvas;
	            var context = ref.context;
	        this.props.canvas = canvas;
	        this.props.context = context;
	        this._setupGLKey();
	        this._appendCanvasIfNeeded();
	    }
	    if (opt.p5 && typeof opt.p5 !== 'function') {
	        this.props.p5 = opt.p5;
	        this.props.p5.draw = (function () {
	            if (this$1._isP5Resizing) 
	                { return; }
	            this$1._lastRedrawResult = this$1.submitDrawCall();
	        });
	    }
	    if ('playing' in opt) {
	        if (opt.playing) 
	            { this.play(); }
	         else 
	            { this.pause(); }
	    }
	    checkSettings(this._settings);
	    this.resize();
	    this.render();
	    return this.props;
	};
	SketchManager.prototype.resize = function resize () {
	    var oldSizes = this._getSizeProps();
	    var settings = this.settings;
	    var props = this.props;
	    var newProps = resizeCanvas(props, settings);
	    Object.assign(this._props, newProps);
	    var ref = this.props;
	        var pixelRatio = ref.pixelRatio;
	        var canvasWidth = ref.canvasWidth;
	        var canvasHeight = ref.canvasHeight;
	        var styleWidth = ref.styleWidth;
	        var styleHeight = ref.styleHeight;
	    var canvas = this.props.canvas;
	    if (canvas && settings.resizeCanvas !== false) {
	        if (props.p5) {
	            if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
	                this._isP5Resizing = true;
	                props.p5.pixelDensity(pixelRatio);
	                props.p5.resizeCanvas(canvasWidth / pixelRatio, canvasHeight / pixelRatio, false);
	                this._isP5Resizing = false;
	            }
	        } else {
	            if (canvas.width !== canvasWidth) 
	                { canvas.width = canvasWidth; }
	            if (canvas.height !== canvasHeight) 
	                { canvas.height = canvasHeight; }
	        }
	        if (isBrowser() && settings.styleCanvas !== false) {
	            canvas.style.width = styleWidth + "px";
	            canvas.style.height = styleHeight + "px";
	        }
	    }
	    var newSizes = this._getSizeProps();
	    var changed = !deepEqual_1(oldSizes, newSizes);
	    if (changed) {
	        this._sizeChanged();
	    }
	    return changed;
	};
	SketchManager.prototype._sizeChanged = function _sizeChanged () {
	    if (this.sketch && typeof this.sketch.resize === 'function') {
	        this.sketch.resize(this.props);
	    }
	};
	SketchManager.prototype.animate = function animate () {
	    if (!this.props.playing) 
	        { return; }
	    if (!isBrowser()) {
	        console.error('[canvas-sketch] WARN: Animation in Node.js is not yet supported');
	        return;
	    }
	    this._raf = window.requestAnimationFrame(this._animateHandler);
	    var now = browser();
	    var fps = this.props.fps;
	    var frameIntervalMS = 1000 / fps;
	    var deltaTimeMS = now - this._lastTime;
	    var duration = this.props.duration;
	    var hasDuration = typeof duration === 'number' && isFinite(duration);
	    var isNewFrame = true;
	    var playbackRate = this.settings.playbackRate;
	    if (playbackRate === 'fixed') {
	        deltaTimeMS = frameIntervalMS;
	    } else if (playbackRate === 'throttle') {
	        if (deltaTimeMS > frameIntervalMS) {
	            now = now - deltaTimeMS % frameIntervalMS;
	            this._lastTime = now;
	        } else {
	            isNewFrame = false;
	        }
	    } else {
	        this._lastTime = now;
	    }
	    var deltaTime = deltaTimeMS / 1000;
	    var newTime = this.props.time + deltaTime * this.props.timeScale;
	    if (newTime < 0 && hasDuration) {
	        newTime = duration + newTime;
	    }
	    var isFinished = false;
	    var isLoopStart = false;
	    var looping = this.settings.loop !== false;
	    if (hasDuration && newTime >= duration) {
	        if (looping) {
	            isNewFrame = true;
	            newTime = newTime % duration;
	            isLoopStart = true;
	        } else {
	            isNewFrame = false;
	            newTime = duration;
	            isFinished = true;
	        }
	        this._signalEnd();
	    }
	    if (isNewFrame) {
	        this.props.deltaTime = deltaTime;
	        this.props.time = newTime;
	        this.props.playhead = this._computePlayhead(newTime, duration);
	        var lastFrame = this.props.frame;
	        this.props.frame = this._computeCurrentFrame();
	        if (isLoopStart) 
	            { this._signalBegin(); }
	        if (lastFrame !== this.props.frame) 
	            { this.tick(); }
	        this.render();
	        this.props.deltaTime = 0;
	    }
	    if (isFinished) {
	        this.pause();
	    }
	};
	SketchManager.prototype.dispatch = function dispatch (cb) {
	    if (typeof cb !== 'function') 
	        { throw new Error('must pass function into dispatch()'); }
	    cb(this.props);
	    this.render();
	};
	SketchManager.prototype.mount = function mount () {
	    this._appendCanvasIfNeeded();
	};
	SketchManager.prototype.unmount = function unmount () {
	    if (isBrowser()) {
	        window.removeEventListener('resize', this._resizeHandler);
	        this._keyboardShortcuts.detach();
	    }
	    if (this.props.canvas.parentElement) {
	        this.props.canvas.parentElement.removeChild(this.props.canvas);
	    }
	};
	SketchManager.prototype._appendCanvasIfNeeded = function _appendCanvasIfNeeded () {
	    if (!isBrowser()) 
	        { return; }
	    if (this.settings.parent !== false && (this.props.canvas && !this.props.canvas.parentElement)) {
	        var defaultParent = this.settings.parent || document.body;
	        defaultParent.appendChild(this.props.canvas);
	    }
	};
	SketchManager.prototype._setupGLKey = function _setupGLKey () {
	    if (this.props.context) {
	        if (isWebGLContext(this.props.context)) {
	            this._props.gl = this.props.context;
	        } else {
	            delete this._props.gl;
	        }
	    }
	};
	SketchManager.prototype.getTimeProps = function getTimeProps (settings) {
	        if ( settings === void 0 ) settings = {};

	    var duration = settings.duration;
	    var totalFrames = settings.totalFrames;
	    var timeScale = defined(settings.timeScale, 1);
	    var fps = defined(settings.fps, 24);
	    var hasDuration = typeof duration === 'number' && isFinite(duration);
	    var hasTotalFrames = typeof totalFrames === 'number' && isFinite(totalFrames);
	    var totalFramesFromDuration = hasDuration ? Math.floor(fps * duration) : undefined;
	    var durationFromTotalFrames = hasTotalFrames ? totalFrames / fps : undefined;
	    if (hasDuration && hasTotalFrames && totalFramesFromDuration !== totalFrames) {
	        throw new Error('You should specify either duration or totalFrames, but not both. Or, they must match exactly.');
	    }
	    if (typeof settings.dimensions === 'undefined' && typeof settings.units !== 'undefined') {
	        console.warn("You've specified a { units } setting but no { dimension }, so the units will be ignored.");
	    }
	    totalFrames = defined(totalFrames, totalFramesFromDuration, Infinity);
	    duration = defined(duration, durationFromTotalFrames, Infinity);
	    var startTime = settings.time;
	    var startFrame = settings.frame;
	    var hasStartTime = typeof startTime === 'number' && isFinite(startTime);
	    var hasStartFrame = typeof startFrame === 'number' && isFinite(startFrame);
	    var time = 0;
	    var frame = 0;
	    var playhead = 0;
	    if (hasStartTime && hasStartFrame) {
	        throw new Error('You should specify either start frame or time, but not both.');
	    } else if (hasStartTime) {
	        time = startTime;
	        playhead = this._computePlayhead(time, duration);
	        frame = this._computeFrame(playhead, time, totalFrames, fps);
	    } else if (hasStartFrame) {
	        frame = startFrame;
	        time = frame / fps;
	        playhead = this._computePlayhead(time, duration);
	    }
	    return {
	        playhead: playhead,
	        time: time,
	        frame: frame,
	        duration: duration,
	        totalFrames: totalFrames,
	        fps: fps,
	        timeScale: timeScale
	    };
	};
	SketchManager.prototype.setup = function setup (settings) {
	        var this$1 = this;
	        if ( settings === void 0 ) settings = {};

	    if (this.sketch) 
	        { throw new Error('Multiple setup() calls not yet supported.'); }
	    this._settings = Object.assign({}, settings, this._settings);
	    checkSettings(this._settings);
	    var ref = createCanvas(this._settings);
	        var context = ref.context;
	        var canvas = ref.canvas;
	    var timeProps = this.getTimeProps(this._settings);
	    this._props = Object.assign({}, timeProps,
	        {canvas: canvas,
	        context: context,
	        deltaTime: 0,
	        started: false,
	        exporting: false,
	        playing: false,
	        recording: false,
	        settings: this.settings,
	        data: this.settings.data,
	        render: function () { return this$1.render(); },
	        togglePlay: function () { return this$1.togglePlay(); },
	        dispatch: function (cb) { return this$1.dispatch(cb); },
	        tick: function () { return this$1.tick(); },
	        resize: function () { return this$1.resize(); },
	        update: function (opt) { return this$1.update(opt); },
	        exportFrame: function (opt) { return this$1.exportFrame(opt); },
	        record: function () { return this$1.record(); },
	        play: function () { return this$1.play(); },
	        pause: function () { return this$1.pause(); },
	        stop: function () { return this$1.stop(); }});
	    this._setupGLKey();
	    this.resize();
	};
	SketchManager.prototype.loadAndRun = function loadAndRun (canvasSketch, newSettings) {
	        var this$1 = this;

	    return this.load(canvasSketch, newSettings).then(function () {
	        this$1.run();
	        return this$1;
	    });
	};
	SketchManager.prototype.unload = function unload () {
	        var this$1 = this;

	    this.pause();
	    if (!this.sketch) 
	        { return; }
	    if (typeof this.sketch.unload === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.unload(props); });
	    }
	    this._sketch = null;
	};
	SketchManager.prototype.destroy = function destroy () {
	    this.unload();
	    this.unmount();
	};
	SketchManager.prototype.load = function load (createSketch, newSettings) {
	        var this$1 = this;

	    if (typeof createSketch !== 'function') {
	        throw new Error('The function must take in a function as the first parameter. Example:\n  canvasSketcher(() => { ... }, settings)');
	    }
	    if (this.sketch) {
	        this.unload();
	    }
	    if (typeof newSettings !== 'undefined') {
	        this.update(newSettings);
	    }
	    this._preRender();
	    var preload = Promise.resolve();
	    if (this.settings.p5) {
	        if (!isBrowser()) {
	            throw new Error('[canvas-sketch] ERROR: Using p5.js in Node.js is not supported');
	        }
	        preload = new Promise(function (resolve) {
	            var P5Constructor = this$1.settings.p5;
	            var preload;
	            if (P5Constructor.p5) {
	                preload = P5Constructor.preload;
	                P5Constructor = P5Constructor.p5;
	            }
	            var p5Sketch = function (p5) {
	                if (preload) 
	                    { p5.preload = (function () { return preload(p5); }); }
	                p5.setup = (function () {
	                    var props = this$1.props;
	                    var isGL = this$1.settings.context === 'webgl';
	                    var renderer = isGL ? p5.WEBGL : p5.P2D;
	                    p5.noLoop();
	                    p5.pixelDensity(props.pixelRatio);
	                    p5.createCanvas(props.viewportWidth, props.viewportHeight, renderer);
	                    if (isGL && this$1.settings.attributes) {
	                        p5.setAttributes(this$1.settings.attributes);
	                    }
	                    this$1.update({
	                        p5: p5,
	                        canvas: p5.canvas,
	                        context: p5._renderer.drawingContext
	                    });
	                    resolve();
	                });
	            };
	            if (typeof P5Constructor === 'function') {
	                new P5Constructor(p5Sketch);
	            } else {
	                if (typeof window.createCanvas !== 'function') {
	                    throw new Error("{ p5 } setting is passed but can't find p5.js in global (window) scope. Maybe you did not create it globally?\nnew p5(); // <-- attaches to global scope");
	                }
	                p5Sketch(window);
	            }
	        });
	    }
	    return preload.then(function () {
	        var loader = createSketch(this$1.props);
	        if (!isPromise_1(loader)) {
	            loader = Promise.resolve(loader);
	        }
	        return loader;
	    }).then(function (sketch) {
	        if (!sketch) 
	            { sketch = {}; }
	        this$1._sketch = sketch;
	        if (isBrowser()) {
	            this$1._keyboardShortcuts.attach();
	            window.addEventListener('resize', this$1._resizeHandler);
	        }
	        this$1._postRender();
	        this$1._sizeChanged();
	        return this$1;
	    }).catch(function (err) {
	        console.warn('Could not start sketch, the async loading function rejected with an error:\n    Error: ' + err.message);
	        throw err;
	    });
	};

	Object.defineProperties( SketchManager.prototype, prototypeAccessors );

	var CACHE = 'hot-id-cache';
	var runtimeCollisions = [];
	function isHotReload() {
	    var client = getClientAPI();
	    return client && client.hot;
	}

	function cacheGet(id) {
	    var client = getClientAPI();
	    if (!client) 
	        { return undefined; }
	    client[CACHE] = client[CACHE] || {};
	    return client[CACHE][id];
	}

	function cachePut(id, data) {
	    var client = getClientAPI();
	    if (!client) 
	        { return undefined; }
	    client[CACHE] = client[CACHE] || {};
	    client[CACHE][id] = data;
	}

	function getTimeProp(oldManager, newSettings) {
	    return newSettings.animate ? {
	        time: oldManager.props.time
	    } : undefined;
	}

	function canvasSketch(sketch, settings) {
	    if ( settings === void 0 ) settings = {};

	    if (settings.p5) {
	        if (settings.canvas || settings.context && typeof settings.context !== 'string') {
	            throw new Error("In { p5 } mode, you can't pass your own canvas or context, unless the context is a \"webgl\" or \"2d\" string");
	        }
	        var context = typeof settings.context === 'string' ? settings.context : false;
	        settings = Object.assign({}, settings, {
	            canvas: false,
	            context: context
	        });
	    }
	    var isHot = isHotReload();
	    var hotID;
	    if (isHot) {
	        hotID = defined(settings.id, '$__DEFAULT_CANVAS_SKETCH_ID__$');
	    }
	    var isInjecting = isHot && typeof hotID === 'string';
	    if (isInjecting && runtimeCollisions.includes(hotID)) {
	        console.warn("Warning: You have multiple calls to canvasSketch() in --hot mode. You must pass unique { id } strings in settings to enable hot reload across multiple sketches. ", hotID);
	        isInjecting = false;
	    }
	    var preload = Promise.resolve();
	    if (isInjecting) {
	        runtimeCollisions.push(hotID);
	        var previousData = cacheGet(hotID);
	        if (previousData) {
	            var next = function () {
	                var newProps = getTimeProp(previousData.manager, settings);
	                previousData.manager.destroy();
	                return newProps;
	            };
	            preload = previousData.load.then(next).catch(next);
	        }
	    }
	    return preload.then(function (newProps) {
	        var manager = new SketchManager();
	        var result;
	        if (sketch) {
	            settings = Object.assign({}, settings, newProps);
	            manager.setup(settings);
	            manager.mount();
	            result = manager.loadAndRun(sketch);
	        } else {
	            result = Promise.resolve(manager);
	        }
	        if (isInjecting) {
	            cachePut(hotID, {
	                load: result,
	                manager: manager
	            });
	        }
	        return result;
	    });
	}

	canvasSketch.canvasSketch = canvasSketch;
	canvasSketch.PaperSizes = paperSizes;

	return canvasSketch;

})));


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));
}(this, (function (exports) { 'use strict';

	const REVISION = '131';
	const MOUSE = {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2
	};
	const TOUCH = {
		ROTATE: 0,
		PAN: 1,
		DOLLY_PAN: 2,
		DOLLY_ROTATE: 3
	};
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const CullFaceFrontBack = 3;
	const BasicShadowMap = 0;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const FlatShading = 1;
	const SmoothShading = 2;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;
	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const CubeUVRefractionMapping = 307;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipMapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const NearestMipMapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipMapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const LinearMipMapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedShort565Type = 1019;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBFormat = 1022;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const RGBEFormat = RGBAFormat;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBIntegerFormat = 1032;
	const RGBAIntegerFormat = 1033;
	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	const LoopOnce = 2200;
	const LoopRepeat = 2201;
	const LoopPingPong = 2202;
	const InterpolateDiscrete = 2300;
	const InterpolateLinear = 2301;
	const InterpolateSmooth = 2302;
	const ZeroCurvatureEnding = 2400;
	const ZeroSlopeEnding = 2401;
	const WrapAroundEnding = 2402;
	const NormalAnimationBlendMode = 2500;
	const AdditiveAnimationBlendMode = 2501;
	const TrianglesDrawMode = 0;
	const TriangleStripDrawMode = 1;
	const TriangleFanDrawMode = 2;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const GammaEncoding = 3007;
	const RGBEEncoding = 3002;
	const LogLuvEncoding = 3003;
	const RGBM7Encoding = 3004;
	const RGBM16Encoding = 3005;
	const RGBDEncoding = 3006;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;
	const ZeroStencilOp = 0;
	const KeepStencilOp = 7680;
	const ReplaceStencilOp = 7681;
	const IncrementStencilOp = 7682;
	const DecrementStencilOp = 7683;
	const IncrementWrapStencilOp = 34055;
	const DecrementWrapStencilOp = 34056;
	const InvertStencilOp = 5386;
	const NeverStencilFunc = 512;
	const LessStencilFunc = 513;
	const EqualStencilFunc = 514;
	const LessEqualStencilFunc = 515;
	const GreaterStencilFunc = 516;
	const NotEqualStencilFunc = 517;
	const GreaterEqualStencilFunc = 518;
	const AlwaysStencilFunc = 519;
	const StaticDrawUsage = 35044;
	const DynamicDrawUsage = 35048;
	const StreamDrawUsage = 35040;
	const StaticReadUsage = 35045;
	const DynamicReadUsage = 35049;
	const StreamReadUsage = 35041;
	const StaticCopyUsage = 35046;
	const DynamicCopyUsage = 35050;
	const StreamCopyUsage = 35042;
	const GLSL1 = '100';
	const GLSL3 = '300 es';

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	class EventDispatcher {
		addEventListener(type, listener) {
			if (this._listeners === undefined) this._listeners = {};
			const listeners = this._listeners;

			if (listeners[type] === undefined) {
				listeners[type] = [];
			}

			if (listeners[type].indexOf(listener) === -1) {
				listeners[type].push(listener);
			}
		}

		hasEventListener(type, listener) {
			if (this._listeners === undefined) return false;
			const listeners = this._listeners;
			return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
		}

		removeEventListener(type, listener) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[type];

			if (listenerArray !== undefined) {
				const index = listenerArray.indexOf(listener);

				if (index !== -1) {
					listenerArray.splice(index, 1);
				}
			}
		}

		dispatchEvent(event) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[event.type];

			if (listenerArray !== undefined) {
				event.target = this; // Make a copy, in case listeners are removed while iterating.

				const array = listenerArray.slice(0);

				for (let i = 0, l = array.length; i < l; i++) {
					array[i].call(this, event);
				}

				event.target = null;
			}
		}

	}

	const _lut = [];

	for (let i = 0; i < 256; i++) {
		_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
	}

	let _seed = 1234567;
	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	function generateUUID() {
		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

		return uuid.toUpperCase();
	}

	function clamp(value, min, max) {
		return Math.max(min, Math.min(max, value));
	} // compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation


	function euclideanModulo(n, m) {
		return (n % m + m) % m;
	} // Linear mapping from range <a1, a2> to range <b1, b2>


	function mapLinear(x, a1, a2, b1, b2) {
		return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


	function inverseLerp(x, y, value) {
		if (x !== y) {
			return (value - x) / (y - x);
		} else {
			return 0;
		}
	} // https://en.wikipedia.org/wiki/Linear_interpolation


	function lerp(x, y, t) {
		return (1 - t) * x + t * y;
	} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


	function damp(x, y, lambda, dt) {
		return lerp(x, y, 1 - Math.exp(-lambda * dt));
	} // https://www.desmos.com/calculator/vcsjnyz7x4


	function pingpong(x, length = 1) {
		return length - Math.abs(euclideanModulo(x, length * 2) - length);
	} // http://en.wikipedia.org/wiki/Smoothstep


	function smoothstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * (3 - 2 * x);
	}

	function smootherstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * x * (x * (x * 6 - 15) + 10);
	} // Random integer from <low, high> interval


	function randInt(low, high) {
		return low + Math.floor(Math.random() * (high - low + 1));
	} // Random float from <low, high> interval


	function randFloat(low, high) {
		return low + Math.random() * (high - low);
	} // Random float from <-range/2, range/2> interval


	function randFloatSpread(range) {
		return range * (0.5 - Math.random());
	} // Deterministic pseudo-random float in the interval [ 0, 1 ]


	function seededRandom(s) {
		if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647;
		return (_seed - 1) / 2147483646;
	}

	function degToRad(degrees) {
		return degrees * DEG2RAD;
	}

	function radToDeg(radians) {
		return radians * RAD2DEG;
	}

	function isPowerOfTwo(value) {
		return (value & value - 1) === 0 && value !== 0;
	}

	function ceilPowerOfTwo(value) {
		return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
	}

	function floorPowerOfTwo(value) {
		return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
	}

	function setQuaternionFromProperEuler(q, a, b, c, order) {
		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians
		const cos = Math.cos;
		const sin = Math.sin;
		const c2 = cos(b / 2);
		const s2 = sin(b / 2);
		const c13 = cos((a + c) / 2);
		const s13 = sin((a + c) / 2);
		const c1_3 = cos((a - c) / 2);
		const s1_3 = sin((a - c) / 2);
		const c3_1 = cos((c - a) / 2);
		const s3_1 = sin((c - a) / 2);

		switch (order) {
			case 'XYX':
				q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
				break;

			case 'YZY':
				q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
				break;

			case 'ZXZ':
				q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
				break;

			case 'XZX':
				q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
				break;

			case 'YXY':
				q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
				break;

			case 'ZYZ':
				q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
				break;

			default:
				console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
		}
	}

	var MathUtils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID,
		clamp: clamp,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler
	});

	class Vector2 {
		constructor(x = 0, y = 0) {
			this.x = x;
			this.y = y;
		}

		get width() {
			return this.x;
		}

		set width(value) {
			this.x = value;
		}

		get height() {
			return this.y;
		}

		set height(value) {
			this.y = value;
		}

		set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;
		}

		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		}

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		applyMatrix3(m) {
			const x = this.x,
						y = this.y;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6];
			this.y = e[1] * x + e[4] * y + e[7];
			return this;
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y;
		}

		cross(v) {
			return this.x * v.y - this.y * v.x;
		}

		lengthSq() {
			return this.x * this.x + this.y * this.y;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		angle() {
			// computes the angle in radians with respect to the positive x-axis
			const angle = Math.atan2(-this.y, -this.x) + Math.PI;
			return angle;
		}

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}

		distanceToSquared(v) {
			const dx = this.x - v.x,
						dy = this.y - v.y;
			return dx * dx + dy * dy;
		}

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			return this;
		}

		equals(v) {
			return v.x === this.x && v.y === this.y;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			return this;
		}

		rotateAround(center, angle) {
			const c = Math.cos(angle),
						s = Math.sin(angle);
			const x = this.x - center.x;
			const y = this.y - center.y;
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			return this;
		}

	}

	Vector2.prototype.isVector2 = true;

	class Matrix3 {
		constructor() {
			this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
			const te = this.elements;
			te[0] = n11;
			te[1] = n21;
			te[2] = n31;
			te[3] = n12;
			te[4] = n22;
			te[5] = n32;
			te[6] = n13;
			te[7] = n23;
			te[8] = n33;
			return this;
		}

		identity() {
			this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
			return this;
		}

		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			return this;
		}

		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrix3Column(this, 0);
			yAxis.setFromMatrix3Column(this, 1);
			zAxis.setFromMatrix3Column(this, 2);
			return this;
		}

		setFromMatrix4(m) {
			const me = m.elements;
			this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
			return this;
		}

		multiply(m) {
			return this.multiplyMatrices(this, m);
		}

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
						a12 = ae[3],
						a13 = ae[6];
			const a21 = ae[1],
						a22 = ae[4],
						a23 = ae[7];
			const a31 = ae[2],
						a32 = ae[5],
						a33 = ae[8];
			const b11 = be[0],
						b12 = be[3],
						b13 = be[6];
			const b21 = be[1],
						b22 = be[4],
						b23 = be[7];
			const b31 = be[2],
						b32 = be[5],
						b33 = be[8];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31;
			te[3] = a11 * b12 + a12 * b22 + a13 * b32;
			te[6] = a11 * b13 + a12 * b23 + a13 * b33;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31;
			te[4] = a21 * b12 + a22 * b22 + a23 * b32;
			te[7] = a21 * b13 + a22 * b23 + a23 * b33;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31;
			te[5] = a31 * b12 + a32 * b22 + a33 * b32;
			te[8] = a31 * b13 + a32 * b23 + a33 * b33;
			return this;
		}

		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[3] *= s;
			te[6] *= s;
			te[1] *= s;
			te[4] *= s;
			te[7] *= s;
			te[2] *= s;
			te[5] *= s;
			te[8] *= s;
			return this;
		}

		determinant() {
			const te = this.elements;
			const a = te[0],
						b = te[1],
						c = te[2],
						d = te[3],
						e = te[4],
						f = te[5],
						g = te[6],
						h = te[7],
						i = te[8];
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
		}

		invert() {
			const te = this.elements,
						n11 = te[0],
						n21 = te[1],
						n31 = te[2],
						n12 = te[3],
						n22 = te[4],
						n32 = te[5],
						n13 = te[6],
						n23 = te[7],
						n33 = te[8],
						t11 = n33 * n22 - n32 * n23,
						t12 = n32 * n13 - n33 * n12,
						t13 = n23 * n12 - n22 * n13,
						det = n11 * t11 + n21 * t12 + n31 * t13;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n31 * n23 - n33 * n21) * detInv;
			te[2] = (n32 * n21 - n31 * n22) * detInv;
			te[3] = t12 * detInv;
			te[4] = (n33 * n11 - n31 * n13) * detInv;
			te[5] = (n31 * n12 - n32 * n11) * detInv;
			te[6] = t13 * detInv;
			te[7] = (n21 * n13 - n23 * n11) * detInv;
			te[8] = (n22 * n11 - n21 * n12) * detInv;
			return this;
		}

		transpose() {
			let tmp;
			const m = this.elements;
			tmp = m[1];
			m[1] = m[3];
			m[3] = tmp;
			tmp = m[2];
			m[2] = m[6];
			m[6] = tmp;
			tmp = m[5];
			m[5] = m[7];
			m[7] = tmp;
			return this;
		}

		getNormalMatrix(matrix4) {
			return this.setFromMatrix4(matrix4).invert().transpose();
		}

		transposeIntoArray(r) {
			const m = this.elements;
			r[0] = m[0];
			r[1] = m[3];
			r[2] = m[6];
			r[3] = m[1];
			r[4] = m[4];
			r[5] = m[7];
			r[6] = m[2];
			r[7] = m[5];
			r[8] = m[8];
			return this;
		}

		setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
			const c = Math.cos(rotation);
			const s = Math.sin(rotation);
			this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
			return this;
		}

		scale(sx, sy) {
			const te = this.elements;
			te[0] *= sx;
			te[3] *= sx;
			te[6] *= sx;
			te[1] *= sy;
			te[4] *= sy;
			te[7] *= sy;
			return this;
		}

		rotate(theta) {
			const c = Math.cos(theta);
			const s = Math.sin(theta);
			const te = this.elements;
			const a11 = te[0],
						a12 = te[3],
						a13 = te[6];
			const a21 = te[1],
						a22 = te[4],
						a23 = te[7];
			te[0] = c * a11 + s * a21;
			te[3] = c * a12 + s * a22;
			te[6] = c * a13 + s * a23;
			te[1] = -s * a11 + c * a21;
			te[4] = -s * a12 + c * a22;
			te[7] = -s * a13 + c * a23;
			return this;
		}

		translate(tx, ty) {
			const te = this.elements;
			te[0] += tx * te[2];
			te[3] += tx * te[5];
			te[6] += tx * te[8];
			te[1] += ty * te[2];
			te[4] += ty * te[5];
			te[7] += ty * te[8];
			return this;
		}

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 9; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		}

		fromArray(array, offset = 0) {
			for (let i = 0; i < 9; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			return array;
		}

		clone() {
			return new this.constructor().fromArray(this.elements);
		}

	}

	Matrix3.prototype.isMatrix3 = true;

	let _canvas;

	class ImageUtils {
		static getDataURL(image) {
			if (/^data:/i.test(image.src)) {
				return image.src;
			}

			if (typeof HTMLCanvasElement == 'undefined') {
				return image.src;
			}

			let canvas;

			if (image instanceof HTMLCanvasElement) {
				canvas = image;
			} else {
				if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext('2d');

				if (image instanceof ImageData) {
					context.putImageData(image, 0, 0);
				} else {
					context.drawImage(image, 0, 0, image.width, image.height);
				}

				canvas = _canvas;
			}

			if (canvas.width > 2048 || canvas.height > 2048) {
				console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
				return canvas.toDataURL('image/jpeg', 0.6);
			} else {
				return canvas.toDataURL('image/png');
			}
		}

	}

	let textureId = 0;

	class Texture extends EventDispatcher {
		constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
			super();
			Object.defineProperty(this, 'id', {
				value: textureId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.image = image;
			this.mipmaps = [];
			this.mapping = mapping;
			this.wrapS = wrapS;
			this.wrapT = wrapT;
			this.magFilter = magFilter;
			this.minFilter = minFilter;
			this.anisotropy = anisotropy;
			this.format = format;
			this.internalFormat = null;
			this.type = type;
			this.offset = new Vector2(0, 0);
			this.repeat = new Vector2(1, 1);
			this.center = new Vector2(0, 0);
			this.rotation = 0;
			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();
			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

			this.encoding = encoding;
			this.version = 0;
			this.onUpdate = null;
			this.isRenderTargetTexture = false;
		}

		updateMatrix() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.name = source.name;
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice(0);
			this.mapping = source.mapping;
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
			this.anisotropy = source.anisotropy;
			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;
			this.offset.copy(source.offset);
			this.repeat.copy(source.repeat);
			this.center.copy(source.center);
			this.rotation = source.rotation;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy(source.matrix);
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
			return this;
		}

		toJSON(meta) {
			const isRootObject = meta === undefined || typeof meta === 'string';

			if (!isRootObject && meta.textures[this.uuid] !== undefined) {
				return meta.textures[this.uuid];
			}

			const output = {
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
				uuid: this.uuid,
				name: this.name,
				mapping: this.mapping,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				type: this.type,
				encoding: this.encoding,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};

			if (this.image !== undefined) {
				// TODO: Move to THREE.Image
				const image = this.image;

				if (image.uuid === undefined) {
					image.uuid = generateUUID(); // UGH
				}

				if (!isRootObject && meta.images[image.uuid] === undefined) {
					let url;

					if (Array.isArray(image)) {
						// process array of images e.g. CubeTexture
						url = [];

						for (let i = 0, l = image.length; i < l; i++) {
							// check cube texture with data textures
							if (image[i].isDataTexture) {
								url.push(serializeImage(image[i].image));
							} else {
								url.push(serializeImage(image[i]));
							}
						}
					} else {
						// process single image
						url = serializeImage(image);
					}

					meta.images[image.uuid] = {
						uuid: image.uuid,
						url: url
					};
				}

				output.image = image.uuid;
			}

			if (!isRootObject) {
				meta.textures[this.uuid] = output;
			}

			return output;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

		transformUv(uv) {
			if (this.mapping !== UVMapping) return uv;
			uv.applyMatrix3(this.matrix);

			if (uv.x < 0 || uv.x > 1) {
				switch (this.wrapS) {
					case RepeatWrapping:
						uv.x = uv.x - Math.floor(uv.x);
						break;

					case ClampToEdgeWrapping:
						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.x) % 2) === 1) {
							uv.x = Math.ceil(uv.x) - uv.x;
						} else {
							uv.x = uv.x - Math.floor(uv.x);
						}

						break;
				}
			}

			if (uv.y < 0 || uv.y > 1) {
				switch (this.wrapT) {
					case RepeatWrapping:
						uv.y = uv.y - Math.floor(uv.y);
						break;

					case ClampToEdgeWrapping:
						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.y) % 2) === 1) {
							uv.y = Math.ceil(uv.y) - uv.y;
						} else {
							uv.y = uv.y - Math.floor(uv.y);
						}

						break;
				}
			}

			if (this.flipY) {
				uv.y = 1 - uv.y;
			}

			return uv;
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.prototype.isTexture = true;

	function serializeImage(image) {
		if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
			// default images
			return ImageUtils.getDataURL(image);
		} else {
			if (image.data) {
				// images of DataTexture
				return {
					data: Array.prototype.slice.call(image.data),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};
			} else {
				console.warn('THREE.Texture: Unable to serialize Texture.');
				return {};
			}
		}
	}

	class Vector4 {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		get width() {
			return this.z;
		}

		set width(value) {
			this.z = value;
		}

		get height() {
			return this.w;
		}

		set height(value) {
			this.w = value;
		}

		set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setZ(z) {
			this.z = z;
			return this;
		}

		setW(w) {
			this.w = w;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				case 3:
					this.w = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				case 3:
					return this.w;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y, this.z, this.w);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = v.w !== undefined ? v.w : 1;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
			return this;
		}

		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		}

		applyMatrix4(m) {
			const x = this.x,
						y = this.y,
						z = this.z,
						w = this.w;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		setAxisAngleFromQuaternion(q) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
			// q is assumed to be normalized
			this.w = 2 * Math.acos(q.w);
			const s = Math.sqrt(1 - q.w * q.w);

			if (s < 0.0001) {
				this.x = 1;
				this.y = 0;
				this.z = 0;
			} else {
				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
			}

			return this;
		}

		setAxisAngleFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			let angle, x, y, z; // variables for result

			const epsilon = 0.01,
						// margin to allow for rounding errors
			epsilon2 = 0.1,
						// margin to distinguish between 0 and 180 degrees
			te = m.elements,
						m11 = te[0],
						m12 = te[4],
						m13 = te[8],
						m21 = te[1],
						m22 = te[5],
						m23 = te[9],
						m31 = te[2],
						m32 = te[6],
						m33 = te[10];

			if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
				if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
					// this singularity is identity matrix so angle = 0
					this.set(1, 0, 0, 0);
					return this; // zero angle, arbitrary axis
				} // otherwise this singularity is angle = 180


				angle = Math.PI;
				const xx = (m11 + 1) / 2;
				const yy = (m22 + 1) / 2;
				const zz = (m33 + 1) / 2;
				const xy = (m12 + m21) / 4;
				const xz = (m13 + m31) / 4;
				const yz = (m23 + m32) / 4;

				if (xx > yy && xx > zz) {
					// m11 is the largest diagonal term
					if (xx < epsilon) {
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
					} else {
						x = Math.sqrt(xx);
						y = xy / x;
						z = xz / x;
					}
				} else if (yy > zz) {
					// m22 is the largest diagonal term
					if (yy < epsilon) {
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
					} else {
						y = Math.sqrt(yy);
						x = xy / y;
						z = yz / y;
					}
				} else {
					// m33 is the largest diagonal term so base result on this
					if (zz < epsilon) {
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
					} else {
						z = Math.sqrt(zz);
						x = xz / z;
						y = yz / z;
					}
				}

				this.set(x, y, z, angle);
				return this; // return 180 deg rotation
			} // as we have reached here there are no singularities so we can handle normally


			let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

			if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = (m32 - m23) / s;
			this.y = (m13 - m31) / s;
			this.z = (m21 - m12) / s;
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
			return this;
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			this.w = Math.min(this.w, v.w);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			this.w = Math.max(this.w, v.w);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			this.w = Math.max(min.w, Math.min(max.w, this.w));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			this.w = Math.max(minVal, Math.min(maxVal, this.w));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
		}

		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			this.w += (v.w - this.w) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			this.w = v1.w + (v2.w - v1.w) * alpha;
			return this;
		}

		equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			this.w = array[offset + 3];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			array[offset + 3] = this.w;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			this.w = attribute.getW(index);
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();
			return this;
		}

	}

	Vector4.prototype.isVector4 = true;

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/

	class WebGLRenderTarget extends EventDispatcher {
		constructor(width, height, options = {}) {
			super();
			this.width = width;
			this.height = height;
			this.depth = 1;
			this.scissor = new Vector4(0, 0, width, height);
			this.scissorTest = false;
			this.viewport = new Vector4(0, 0, width, height);
			this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			this.texture.isRenderTargetTexture = true;
			this.texture.image = {
				width: width,
				height: height,
				depth: 1
			};
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
		}

		setTexture(texture) {
			texture.image = {
				width: this.width,
				height: this.height,
				depth: this.depth
			};
			this.texture = texture;
		}

		setSize(width, height, depth = 1) {
			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;
				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;
				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.copy(source.viewport);
			this.texture = source.texture.clone();
			this.texture.image = { ...this.texture.image
			}; // See #20328.

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

	class WebGLMultipleRenderTargets extends WebGLRenderTarget {
		constructor(width, height, count) {
			super(width, height);
			const texture = this.texture;
			this.texture = [];

			for (let i = 0; i < count; i++) {
				this.texture[i] = texture.clone();
			}
		}

		setSize(width, height, depth = 1) {
			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;

				for (let i = 0, il = this.texture.length; i < il; i++) {
					this.texture[i].image.width = width;
					this.texture[i].image.height = height;
					this.texture[i].image.depth = depth;
				}

				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
			return this;
		}

		copy(source) {
			this.dispose();
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.set(0, 0, this.width, this.height);
			this.scissor.set(0, 0, this.width, this.height);
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			this.texture.length = 0;

			for (let i = 0, il = source.texture.length; i < il; i++) {
				this.texture[i] = source.texture[i].clone();
			}

			return this;
		}

	}

	WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

	class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
		constructor(width, height, options) {
			super(width, height, options);
			this.samples = 4;
		}

		copy(source) {
			super.copy.call(this, source);
			this.samples = source.samples;
			return this;
		}

	}

	WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

	class Quaternion {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
		}

		static slerp(qa, qb, qm, t) {
			console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
			return qm.slerpQuaternions(qa, qb, t);
		}

		static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
			// fuzz-free, array-based Quaternion SLERP operation
			let x0 = src0[srcOffset0 + 0],
					y0 = src0[srcOffset0 + 1],
					z0 = src0[srcOffset0 + 2],
					w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1 + 0],
						y1 = src1[srcOffset1 + 1],
						z1 = src1[srcOffset1 + 2],
						w1 = src1[srcOffset1 + 3];

			if (t === 0) {
				dst[dstOffset + 0] = x0;
				dst[dstOffset + 1] = y0;
				dst[dstOffset + 2] = z0;
				dst[dstOffset + 3] = w0;
				return;
			}

			if (t === 1) {
				dst[dstOffset + 0] = x1;
				dst[dstOffset + 1] = y1;
				dst[dstOffset + 2] = z1;
				dst[dstOffset + 3] = w1;
				return;
			}

			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
							dir = cos >= 0 ? 1 : -1,
							sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

				if (sqrSin > Number.EPSILON) {
					const sin = Math.sqrt(sqrSin),
								len = Math.atan2(sin, cos * dir);
					s = Math.sin(s * len) / sin;
					t = Math.sin(t * len) / sin;
				}

				const tDir = t * dir;
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

				if (s === 1 - t) {
					const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
				}
			}

			dst[dstOffset] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
		}

		static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
			const x0 = src0[srcOffset0];
			const y0 = src0[srcOffset0 + 1];
			const z0 = src0[srcOffset0 + 2];
			const w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1];
			const y1 = src1[srcOffset1 + 1];
			const z1 = src1[srcOffset1 + 2];
			const w1 = src1[srcOffset1 + 3];
			dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
			return dst;
		}

		get x() {
			return this._x;
		}

		set x(value) {
			this._x = value;

			this._onChangeCallback();
		}

		get y() {
			return this._y;
		}

		set y(value) {
			this._y = value;

			this._onChangeCallback();
		}

		get z() {
			return this._z;
		}

		set z(value) {
			this._z = value;

			this._onChangeCallback();
		}

		get w() {
			return this._w;
		}

		set w(value) {
			this._w = value;

			this._onChangeCallback();
		}

		set(x, y, z, w) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;
		}

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._w);
		}

		copy(quaternion) {
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;
		}

		setFromEuler(euler, update) {
			if (!(euler && euler.isEuler)) {
				throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			const x = euler._x,
						y = euler._y,
						z = euler._z,
						order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;
			const c1 = cos(x / 2);
			const c2 = cos(y / 2);
			const c3 = cos(z / 2);
			const s1 = sin(x / 2);
			const s2 = sin(y / 2);
			const s3 = sin(z / 2);

			switch (order) {
				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
			}

			if (update !== false) this._onChangeCallback();
			return this;
		}

		setFromAxisAngle(axis, angle) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
			// assumes axis is normalized
			const halfAngle = angle / 2,
						s = Math.sin(halfAngle);
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos(halfAngle);

			this._onChangeCallback();

			return this;
		}

		setFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements,
						m11 = te[0],
						m12 = te[4],
						m13 = te[8],
						m21 = te[1],
						m22 = te[5],
						m23 = te[9],
						m31 = te[2],
						m32 = te[6],
						m33 = te[10],
						trace = m11 + m22 + m33;

			if (trace > 0) {
				const s = 0.5 / Math.sqrt(trace + 1.0);
				this._w = 0.25 / s;
				this._x = (m32 - m23) * s;
				this._y = (m13 - m31) * s;
				this._z = (m21 - m12) * s;
			} else if (m11 > m22 && m11 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
				this._w = (m32 - m23) / s;
				this._x = 0.25 * s;
				this._y = (m12 + m21) / s;
				this._z = (m13 + m31) / s;
			} else if (m22 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
				this._w = (m13 - m31) / s;
				this._x = (m12 + m21) / s;
				this._y = 0.25 * s;
				this._z = (m23 + m32) / s;
			} else {
				const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
				this._w = (m21 - m12) / s;
				this._x = (m13 + m31) / s;
				this._y = (m23 + m32) / s;
				this._z = 0.25 * s;
			}

			this._onChangeCallback();

			return this;
		}

		setFromUnitVectors(vFrom, vTo) {
			// assumes direction vectors vFrom and vTo are normalized
			let r = vFrom.dot(vTo) + 1;

			if (r < Number.EPSILON) {
				// vFrom and vTo point in opposite directions
				r = 0;

				if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
					this._x = -vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;
				} else {
					this._x = 0;
					this._y = -vFrom.z;
					this._z = vFrom.y;
					this._w = r;
				}
			} else {
				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;
			}

			return this.normalize();
		}

		angleTo(q) {
			return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
		}

		rotateTowards(q, step) {
			const angle = this.angleTo(q);
			if (angle === 0) return this;
			const t = Math.min(1, step / angle);
			this.slerp(q, t);
			return this;
		}

		identity() {
			return this.set(0, 0, 0, 1);
		}

		invert() {
			// quaternion is assumed to have unit length
			return this.conjugate();
		}

		conjugate() {
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;

			this._onChangeCallback();

			return this;
		}

		dot(v) {
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
		}

		lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		}

		length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		}

		normalize() {
			let l = this.length();

			if (l === 0) {
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
			} else {
				l = 1 / l;
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
			}

			this._onChangeCallback();

			return this;
		}

		multiply(q, p) {
			if (p !== undefined) {
				console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
				return this.multiplyQuaternions(q, p);
			}

			return this.multiplyQuaternions(this, q);
		}

		premultiply(q) {
			return this.multiplyQuaternions(q, this);
		}

		multiplyQuaternions(a, b) {
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
			const qax = a._x,
						qay = a._y,
						qaz = a._z,
						qaw = a._w;
			const qbx = b._x,
						qby = b._y,
						qbz = b._z,
						qbw = b._w;
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;
		}

		slerp(qb, t) {
			if (t === 0) return this;
			if (t === 1) return this.copy(qb);
			const x = this._x,
						y = this._y,
						z = this._z,
						w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if (cosHalfTheta < 0) {
				this._w = -qb._w;
				this._x = -qb._x;
				this._y = -qb._y;
				this._z = -qb._z;
				cosHalfTheta = -cosHalfTheta;
			} else {
				this.copy(qb);
			}

			if (cosHalfTheta >= 1.0) {
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
				return this;
			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if (sqrSinHalfTheta <= Number.EPSILON) {
				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;
				this.normalize();

				this._onChangeCallback();

				return this;
			}

			const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
			const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
			const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
						ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
			this._w = w * ratioA + this._w * ratioB;
			this._x = x * ratioA + this._x * ratioB;
			this._y = y * ratioA + this._y * ratioB;
			this._z = z * ratioA + this._z * ratioB;

			this._onChangeCallback();

			return this;
		}

		slerpQuaternions(qa, qb, t) {
			this.copy(qa).slerp(qb, t);
		}

		equals(quaternion) {
			return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
		}

		fromArray(array, offset = 0) {
			this._x = array[offset];
			this._y = array[offset + 1];
			this._z = array[offset + 2];
			this._w = array[offset + 3];

			this._onChangeCallback();

			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._w;
			return array;
		}

		fromBufferAttribute(attribute, index) {
			this._x = attribute.getX(index);
			this._y = attribute.getY(index);
			this._z = attribute.getZ(index);
			this._w = attribute.getW(index);
			return this;
		}

		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}

		_onChangeCallback() {}

	}

	Quaternion.prototype.isQuaternion = true;

	class Vector3 {
		constructor(x = 0, y = 0, z = 0) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		set(x, y, z) {
			if (z === undefined) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setZ(z) {
			this.z = z;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y, this.z);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			return this;
		}

		multiply(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
				return this.multiplyVectors(v, w);
			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		}

		multiplyVectors(a, b) {
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
			return this;
		}

		applyEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
		}

		applyAxisAngle(axis, angle) {
			return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
		}

		applyMatrix3(m) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;
			return this;
		}

		applyNormalMatrix(m) {
			return this.applyMatrix3(m).normalize();
		}

		applyMatrix4(m) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
			return this;
		}

		applyQuaternion(q) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const qx = q.x,
						qy = q.y,
						qz = q.z,
						qw = q.w; // calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return this;
		}

		project(camera) {
			return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
		}

		unproject(camera) {
			return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
		}

		transformDirection(m) {
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z;
			this.y = e[1] * x + e[5] * y + e[9] * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;
			return this.normalize();
		}

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z;
		} // TODO lengthSquared?


		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			return this;
		}

		cross(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
				return this.crossVectors(v, w);
			}

			return this.crossVectors(this, v);
		}

		crossVectors(a, b) {
			const ax = a.x,
						ay = a.y,
						az = a.z;
			const bx = b.x,
						by = b.y,
						bz = b.z;
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
			return this;
		}

		projectOnVector(v) {
			const denominator = v.lengthSq();
			if (denominator === 0) return this.set(0, 0, 0);
			const scalar = v.dot(this) / denominator;
			return this.copy(v).multiplyScalar(scalar);
		}

		projectOnPlane(planeNormal) {
			_vector$c.copy(this).projectOnVector(planeNormal);

			return this.sub(_vector$c);
		}

		reflect(normal) {
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
			return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
		}

		angleTo(v) {
			const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
			if (denominator === 0) return Math.PI / 2;
			const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

			return Math.acos(clamp(theta, -1, 1));
		}

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}

		distanceToSquared(v) {
			const dx = this.x - v.x,
						dy = this.y - v.y,
						dz = this.z - v.z;
			return dx * dx + dy * dy + dz * dz;
		}

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
		}

		setFromSpherical(s) {
			return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
		}

		setFromSphericalCoords(radius, phi, theta) {
			const sinPhiRadius = Math.sin(phi) * radius;
			this.x = sinPhiRadius * Math.sin(theta);
			this.y = Math.cos(phi) * radius;
			this.z = sinPhiRadius * Math.cos(theta);
			return this;
		}

		setFromCylindrical(c) {
			return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
		}

		setFromCylindricalCoords(radius, theta, y) {
			this.x = radius * Math.sin(theta);
			this.y = y;
			this.z = radius * Math.cos(theta);
			return this;
		}

		setFromMatrixPosition(m) {
			const e = m.elements;
			this.x = e[12];
			this.y = e[13];
			this.z = e[14];
			return this;
		}

		setFromMatrixScale(m) {
			const sx = this.setFromMatrixColumn(m, 0).length();
			const sy = this.setFromMatrixColumn(m, 1).length();
			const sz = this.setFromMatrixColumn(m, 2).length();
			this.x = sx;
			this.y = sy;
			this.z = sz;
			return this;
		}

		setFromMatrixColumn(m, index) {
			return this.fromArray(m.elements, index * 4);
		}

		setFromMatrix3Column(m, index) {
			return this.fromArray(m.elements, index * 3);
		}

		equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			return this;
		}

	}

	Vector3.prototype.isVector3 = true;

	const _vector$c = /*@__PURE__*/new Vector3();

	const _quaternion$4 = /*@__PURE__*/new Quaternion();

	class Box3 {
		constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
			this.min = min;
			this.max = max;
		}

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}

		setFromArray(array) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = array.length; i < l; i += 3) {
				const x = array[i];
				const y = array[i + 1];
				const z = array[i + 2];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}

		setFromBufferAttribute(attribute) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = attribute.count; i < l; i++) {
				const x = attribute.getX(i);
				const y = attribute.getY(i);
				const z = attribute.getZ(i);
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		}

		setFromCenterAndSize(center, size) {
			const halfSize = _vector$b.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}

		setFromObject(object) {
			this.makeEmpty();
			return this.expandByObject(object);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}

		makeEmpty() {
			this.min.x = this.min.y = this.min.z = +Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
			return this;
		}

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
		}

		getCenter(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}

		getSize(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
		}

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}

		expandByObject(object) {
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
			object.updateWorldMatrix(false, false);
			const geometry = object.geometry;

			if (geometry !== undefined) {
				if (geometry.boundingBox === null) {
					geometry.computeBoundingBox();
				}

				_box$3.copy(geometry.boundingBox);

				_box$3.applyMatrix4(object.matrixWorld);

				this.union(_box$3);
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				this.expandByObject(children[i]);
			}

			return this;
		}

		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
		}

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
		}

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
		}

		intersectsBox(box) {
			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
		}

		intersectsSphere(sphere) {
			// Find the point on the AABB closest to the sphere center.
			this.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.

			return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
		}

		intersectsPlane(plane) {
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
			let min, max;

			if (plane.normal.x > 0) {
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
			} else {
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
			}

			if (plane.normal.y > 0) {
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
			} else {
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
			}

			if (plane.normal.z > 0) {
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
			} else {
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
			}

			return min <= -plane.constant && max >= -plane.constant;
		}

		intersectsTriangle(triangle) {
			if (this.isEmpty()) {
				return false;
			} // compute box center and extents


			this.getCenter(_center);

			_extents.subVectors(this.max, _center); // translate triangle to aabb origin


			_v0$2.subVectors(triangle.a, _center);

			_v1$7.subVectors(triangle.b, _center);

			_v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle


			_f0.subVectors(_v1$7, _v0$2);

			_f1.subVectors(_v2$3, _v1$7);

			_f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


			let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
				return false;
			} // test 3 face normals from the aabb


			axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
				return false;
			} // finally testing the face normal of the triangle
			// use already existing triangle edge vectors here


			_triangleNormal.crossVectors(_f0, _f1);

			axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
			return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
		}

		clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		}

		distanceToPoint(point) {
			const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		}

		getBoundingSphere(target) {
			this.getCenter(target.center);
			target.radius = this.getSize(_vector$b).length() * 0.5;
			return target;
		}

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

			if (this.isEmpty()) this.makeEmpty();
			return this;
		}

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}

		applyMatrix4(matrix) {
			// transform of empty box is an empty box.
			if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

			_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


			_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


			_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


			_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


			_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


			_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


			_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


			_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


			this.setFromPoints(_points);
			return this;
		}

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}

	}

	Box3.prototype.isBox3 = true;
	const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];

	const _vector$b = /*@__PURE__*/new Vector3();

	const _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices


	const _v0$2 = /*@__PURE__*/new Vector3();

	const _v1$7 = /*@__PURE__*/new Vector3();

	const _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors


	const _f0 = /*@__PURE__*/new Vector3();

	const _f1 = /*@__PURE__*/new Vector3();

	const _f2 = /*@__PURE__*/new Vector3();

	const _center = /*@__PURE__*/new Vector3();

	const _extents = /*@__PURE__*/new Vector3();

	const _triangleNormal = /*@__PURE__*/new Vector3();

	const _testAxis = /*@__PURE__*/new Vector3();

	function satForAxes(axes, v0, v1, v2, extents) {
		for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
			_testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


			const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

			const p0 = v0.dot(_testAxis);
			const p1 = v1.dot(_testAxis);
			const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

			if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;
			}
		}

		return true;
	}

	const _box$2 = /*@__PURE__*/new Box3();

	const _v1$6 = /*@__PURE__*/new Vector3();

	const _toFarthestPoint = /*@__PURE__*/new Vector3();

	const _toPoint = /*@__PURE__*/new Vector3();

	class Sphere {
		constructor(center = new Vector3(), radius = -1) {
			this.center = center;
			this.radius = radius;
		}

		set(center, radius) {
			this.center.copy(center);
			this.radius = radius;
			return this;
		}

		setFromPoints(points, optionalCenter) {
			const center = this.center;

			if (optionalCenter !== undefined) {
				center.copy(optionalCenter);
			} else {
				_box$2.setFromPoints(points).getCenter(center);
			}

			let maxRadiusSq = 0;

			for (let i = 0, il = points.length; i < il; i++) {
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
			}

			this.radius = Math.sqrt(maxRadiusSq);
			return this;
		}

		copy(sphere) {
			this.center.copy(sphere.center);
			this.radius = sphere.radius;
			return this;
		}

		isEmpty() {
			return this.radius < 0;
		}

		makeEmpty() {
			this.center.set(0, 0, 0);
			this.radius = -1;
			return this;
		}

		containsPoint(point) {
			return point.distanceToSquared(this.center) <= this.radius * this.radius;
		}

		distanceToPoint(point) {
			return point.distanceTo(this.center) - this.radius;
		}

		intersectsSphere(sphere) {
			const radiusSum = this.radius + sphere.radius;
			return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
		}

		intersectsBox(box) {
			return box.intersectsSphere(this);
		}

		intersectsPlane(plane) {
			return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
		}

		clampPoint(point, target) {
			const deltaLengthSq = this.center.distanceToSquared(point);
			target.copy(point);

			if (deltaLengthSq > this.radius * this.radius) {
				target.sub(this.center).normalize();
				target.multiplyScalar(this.radius).add(this.center);
			}

			return target;
		}

		getBoundingBox(target) {
			if (this.isEmpty()) {
				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;
			}

			target.set(this.center, this.center);
			target.expandByScalar(this.radius);
			return target;
		}

		applyMatrix4(matrix) {
			this.center.applyMatrix4(matrix);
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
			return this;
		}

		translate(offset) {
			this.center.add(offset);
			return this;
		}

		expandByPoint(point) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
			_toPoint.subVectors(point, this.center);

			const lengthSq = _toPoint.lengthSq();

			if (lengthSq > this.radius * this.radius) {
				const length = Math.sqrt(lengthSq);
				const missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,
				// and the other half to position. This gives a tighter enclosure, instead of if
				// the whole missing distance were just added to radius.

				this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
				this.radius += missingRadiusHalf;
			}

			return this;
		}

		union(sphere) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
			// To enclose another sphere into this sphere, we only need to enclose two points:
			// 1) Enclose the farthest point on the other sphere into this sphere.
			// 2) Enclose the opposite point of the farthest point into this sphere.
			_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);

			this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
			this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
			return this;
		}

		equals(sphere) {
			return sphere.center.equals(this.center) && sphere.radius === this.radius;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	const _vector$a = /*@__PURE__*/new Vector3();

	const _segCenter = /*@__PURE__*/new Vector3();

	const _segDir = /*@__PURE__*/new Vector3();

	const _diff = /*@__PURE__*/new Vector3();

	const _edge1 = /*@__PURE__*/new Vector3();

	const _edge2 = /*@__PURE__*/new Vector3();

	const _normal$1 = /*@__PURE__*/new Vector3();

	class Ray {
		constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
			this.origin = origin;
			this.direction = direction;
		}

		set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		}

		copy(ray) {
			this.origin.copy(ray.origin);
			this.direction.copy(ray.direction);
			return this;
		}

		at(t, target) {
			return target.copy(this.direction).multiplyScalar(t).add(this.origin);
		}

		lookAt(v) {
			this.direction.copy(v).sub(this.origin).normalize();
			return this;
		}

		recast(t) {
			this.origin.copy(this.at(t, _vector$a));
			return this;
		}

		closestPointToPoint(point, target) {
			target.subVectors(point, this.origin);
			const directionDistance = target.dot(this.direction);

			if (directionDistance < 0) {
				return target.copy(this.origin);
			}

			return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		}

		distanceToPoint(point) {
			return Math.sqrt(this.distanceSqToPoint(point));
		}

		distanceSqToPoint(point) {
			const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray


			if (directionDistance < 0) {
				return this.origin.distanceToSquared(point);
			}

			_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

			return _vector$a.distanceToSquared(point);
		}

		distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment
			_segCenter.copy(v0).add(v1).multiplyScalar(0.5);

			_segDir.copy(v1).sub(v0).normalize();

			_diff.copy(this.origin).sub(_segCenter);

			const segExtent = v0.distanceTo(v1) * 0.5;
			const a01 = -this.direction.dot(_segDir);

			const b0 = _diff.dot(this.direction);

			const b1 = -_diff.dot(_segDir);

			const c = _diff.lengthSq();

			const det = Math.abs(1 - a01 * a01);
			let s0, s1, sqrDist, extDet;

			if (det > 0) {
				// The ray and segment are not parallel.
				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if (s0 >= 0) {
					if (s1 >= -extDet) {
						if (s1 <= extDet) {
							// region 0
							// Minimum at interior points of ray and segment.
							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
						} else {
							// region 1
							s1 = segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}
					} else {
						// region 5
						s1 = -segExtent;
						s0 = Math.max(0, -(a01 * s1 + b0));
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					if (s1 <= -extDet) {
						// region 4
						s0 = Math.max(0, -(-a01 * segExtent + b0));
						s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					} else if (s1 <= extDet) {
						// region 3
						s0 = 0;
						s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = s1 * (s1 + 2 * b1) + c;
					} else {
						// region 2
						s0 = Math.max(0, -(a01 * segExtent + b0));
						s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				}
			} else {
				// Ray and segment are parallel.
				s1 = a01 > 0 ? -segExtent : segExtent;
				s0 = Math.max(0, -(a01 * s1 + b0));
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
			}

			if (optionalPointOnRay) {
				optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
			}

			if (optionalPointOnSegment) {
				optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
			}

			return sqrDist;
		}

		intersectSphere(sphere, target) {
			_vector$a.subVectors(sphere.center, this.origin);

			const tca = _vector$a.dot(this.direction);

			const d2 = _vector$a.dot(_vector$a) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;
			if (d2 > radius2) return null;
			const thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

			const t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

			const t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

			if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.

			if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

			return this.at(t0, target);
		}

		intersectsSphere(sphere) {
			return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
		}

		distanceToPlane(plane) {
			const denominator = plane.normal.dot(this.direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {
					return 0;
				} // Null is preferable to undefined since undefined means.... it is undefined


				return null;
			}

			const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

			return t >= 0 ? t : null;
		}

		intersectPlane(plane, target) {
			const t = this.distanceToPlane(plane);

			if (t === null) {
				return null;
			}

			return this.at(t, target);
		}

		intersectsPlane(plane) {
			// check if the ray lies on the plane first
			const distToPoint = plane.distanceToPoint(this.origin);

			if (distToPoint === 0) {
				return true;
			}

			const denominator = plane.normal.dot(this.direction);

			if (denominator * distToPoint < 0) {
				return true;
			} // ray origin is behind the plane (and is pointing behind it)


			return false;
		}

		intersectBox(box, target) {
			let tmin, tmax, tymin, tymax, tzmin, tzmax;
			const invdirx = 1 / this.direction.x,
						invdiry = 1 / this.direction.y,
						invdirz = 1 / this.direction.z;
			const origin = this.origin;

			if (invdirx >= 0) {
				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;
			} else {
				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;
			}

			if (invdiry >= 0) {
				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;
			} else {
				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;
			}

			if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if (tymin > tmin || tmin !== tmin) tmin = tymin;
			if (tymax < tmax || tmax !== tmax) tmax = tymax;

			if (invdirz >= 0) {
				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;
			} else {
				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;
			}

			if (tmin > tzmax || tzmin > tmax) return null;
			if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
			if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

			if (tmax < 0) return null;
			return this.at(tmin >= 0 ? tmin : tmax, target);
		}

		intersectsBox(box) {
			return this.intersectBox(box, _vector$a) !== null;
		}

		intersectTriangle(a, b, c, backfaceCulling, target) {
			// Compute the offset origin, edges, and normal.
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
			_edge1.subVectors(b, a);

			_edge2.subVectors(c, a);

			_normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


			let DdN = this.direction.dot(_normal$1);
			let sign;

			if (DdN > 0) {
				if (backfaceCulling) return null;
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_diff.subVectors(this.origin, a);

			const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

			if (DdQxE2 < 0) {
				return null;
			}

			const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

			if (DdE1xQ < 0) {
				return null;
			} // b1+b2 > 1, no intersection


			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			} // Line intersects triangle, check if ray does.


			const QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection


			if (QdN < 0) {
				return null;
			} // Ray intersects triangle.


			return this.at(QdN / DdN, target);
		}

		applyMatrix4(matrix4) {
			this.origin.applyMatrix4(matrix4);
			this.direction.transformDirection(matrix4);
			return this;
		}

		equals(ray) {
			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	class Matrix4 {
		constructor() {
			this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
			const te = this.elements;
			te[0] = n11;
			te[4] = n12;
			te[8] = n13;
			te[12] = n14;
			te[1] = n21;
			te[5] = n22;
			te[9] = n23;
			te[13] = n24;
			te[2] = n31;
			te[6] = n32;
			te[10] = n33;
			te[14] = n34;
			te[3] = n41;
			te[7] = n42;
			te[11] = n43;
			te[15] = n44;
			return this;
		}

		identity() {
			this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		}

		clone() {
			return new Matrix4().fromArray(this.elements);
		}

		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			te[9] = me[9];
			te[10] = me[10];
			te[11] = me[11];
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			te[15] = me[15];
			return this;
		}

		copyPosition(m) {
			const te = this.elements,
						me = m.elements;
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			return this;
		}

		setFromMatrix3(m) {
			const me = m.elements;
			this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
			return this;
		}

		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrixColumn(this, 0);
			yAxis.setFromMatrixColumn(this, 1);
			zAxis.setFromMatrixColumn(this, 2);
			return this;
		}

		makeBasis(xAxis, yAxis, zAxis) {
			this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
			return this;
		}

		extractRotation(m) {
			// this method does not support reflection matrices
			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();

			const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();

			const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;
			te[3] = 0;
			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;
			te[7] = 0;
			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;
			te[11] = 0;
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}

		makeRotationFromEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
			}

			const te = this.elements;
			const x = euler.x,
						y = euler.y,
						z = euler.z;
			const a = Math.cos(x),
						b = Math.sin(x);
			const c = Math.cos(y),
						d = Math.sin(y);
			const e = Math.cos(z),
						f = Math.sin(z);

			if (euler.order === 'XYZ') {
				const ae = a * e,
							af = a * f,
							be = b * e,
							bf = b * f;
				te[0] = c * e;
				te[4] = -c * f;
				te[8] = d;
				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = -b * c;
				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
			} else if (euler.order === 'YXZ') {
				const ce = c * e,
							cf = c * f,
							de = d * e,
							df = d * f;
				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;
				te[1] = a * f;
				te[5] = a * e;
				te[9] = -b;
				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
			} else if (euler.order === 'ZXY') {
				const ce = c * e,
							cf = c * f,
							de = d * e,
							df = d * f;
				te[0] = ce - df * b;
				te[4] = -a * f;
				te[8] = de + cf * b;
				te[1] = cf + de * b;
				te[5] = a * e;
				te[9] = df - ce * b;
				te[2] = -a * d;
				te[6] = b;
				te[10] = a * c;
			} else if (euler.order === 'ZYX') {
				const ae = a * e,
							af = a * f,
							be = b * e,
							bf = b * f;
				te[0] = c * e;
				te[4] = be * d - af;
				te[8] = ae * d + bf;
				te[1] = c * f;
				te[5] = bf * d + ae;
				te[9] = af * d - be;
				te[2] = -d;
				te[6] = b * c;
				te[10] = a * c;
			} else if (euler.order === 'YZX') {
				const ac = a * c,
							ad = a * d,
							bc = b * c,
							bd = b * d;
				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;
				te[1] = f;
				te[5] = a * e;
				te[9] = -b * e;
				te[2] = -d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
			} else if (euler.order === 'XZY') {
				const ac = a * c,
							ad = a * d,
							bc = b * c,
							bd = b * d;
				te[0] = c * e;
				te[4] = -f;
				te[8] = d * e;
				te[1] = ac * f + bd;
				te[5] = a * e;
				te[9] = ad * f - bc;
				te[2] = bc * f - ad;
				te[6] = b * e;
				te[10] = bd * f + ac;
			} // bottom row


			te[3] = 0;
			te[7] = 0;
			te[11] = 0; // last column

			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}

		makeRotationFromQuaternion(q) {
			return this.compose(_zero, q, _one);
		}

		lookAt(eye, target, up) {
			const te = this.elements;

			_z.subVectors(eye, target);

			if (_z.lengthSq() === 0) {
				// eye and target are in the same position
				_z.z = 1;
			}

			_z.normalize();

			_x.crossVectors(up, _z);

			if (_x.lengthSq() === 0) {
				// up and z are parallel
				if (Math.abs(up.z) === 1) {
					_z.x += 0.0001;
				} else {
					_z.z += 0.0001;
				}

				_z.normalize();

				_x.crossVectors(up, _z);
			}

			_x.normalize();

			_y.crossVectors(_z, _x);

			te[0] = _x.x;
			te[4] = _y.x;
			te[8] = _z.x;
			te[1] = _x.y;
			te[5] = _y.y;
			te[9] = _z.y;
			te[2] = _x.z;
			te[6] = _y.z;
			te[10] = _z.z;
			return this;
		}

		multiply(m, n) {
			if (n !== undefined) {
				console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
				return this.multiplyMatrices(m, n);
			}

			return this.multiplyMatrices(this, m);
		}

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
						a12 = ae[4],
						a13 = ae[8],
						a14 = ae[12];
			const a21 = ae[1],
						a22 = ae[5],
						a23 = ae[9],
						a24 = ae[13];
			const a31 = ae[2],
						a32 = ae[6],
						a33 = ae[10],
						a34 = ae[14];
			const a41 = ae[3],
						a42 = ae[7],
						a43 = ae[11],
						a44 = ae[15];
			const b11 = be[0],
						b12 = be[4],
						b13 = be[8],
						b14 = be[12];
			const b21 = be[1],
						b22 = be[5],
						b23 = be[9],
						b24 = be[13];
			const b31 = be[2],
						b32 = be[6],
						b33 = be[10],
						b34 = be[14];
			const b41 = be[3],
						b42 = be[7],
						b43 = be[11],
						b44 = be[15];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
			return this;
		}

		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[4] *= s;
			te[8] *= s;
			te[12] *= s;
			te[1] *= s;
			te[5] *= s;
			te[9] *= s;
			te[13] *= s;
			te[2] *= s;
			te[6] *= s;
			te[10] *= s;
			te[14] *= s;
			te[3] *= s;
			te[7] *= s;
			te[11] *= s;
			te[15] *= s;
			return this;
		}

		determinant() {
			const te = this.elements;
			const n11 = te[0],
						n12 = te[4],
						n13 = te[8],
						n14 = te[12];
			const n21 = te[1],
						n22 = te[5],
						n23 = te[9],
						n24 = te[13];
			const n31 = te[2],
						n32 = te[6],
						n33 = te[10],
						n34 = te[14];
			const n41 = te[3],
						n42 = te[7],
						n43 = te[11],
						n44 = te[15]; //TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
		}

		transpose() {
			const te = this.elements;
			let tmp;
			tmp = te[1];
			te[1] = te[4];
			te[4] = tmp;
			tmp = te[2];
			te[2] = te[8];
			te[8] = tmp;
			tmp = te[6];
			te[6] = te[9];
			te[9] = tmp;
			tmp = te[3];
			te[3] = te[12];
			te[12] = tmp;
			tmp = te[7];
			te[7] = te[13];
			te[13] = tmp;
			tmp = te[11];
			te[11] = te[14];
			te[14] = tmp;
			return this;
		}

		setPosition(x, y, z) {
			const te = this.elements;

			if (x.isVector3) {
				te[12] = x.x;
				te[13] = x.y;
				te[14] = x.z;
			} else {
				te[12] = x;
				te[13] = y;
				te[14] = z;
			}

			return this;
		}

		invert() {
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,
						n11 = te[0],
						n21 = te[1],
						n31 = te[2],
						n41 = te[3],
						n12 = te[4],
						n22 = te[5],
						n32 = te[6],
						n42 = te[7],
						n13 = te[8],
						n23 = te[9],
						n33 = te[10],
						n43 = te[11],
						n14 = te[12],
						n24 = te[13],
						n34 = te[14],
						n44 = te[15],
						t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
						t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
						t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
						t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
			te[4] = t12 * detInv;
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
			te[8] = t13 * detInv;
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
			te[12] = t14 * detInv;
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
			return this;
		}

		scale(v) {
			const te = this.elements;
			const x = v.x,
						y = v.y,
						z = v.z;
			te[0] *= x;
			te[4] *= y;
			te[8] *= z;
			te[1] *= x;
			te[5] *= y;
			te[9] *= z;
			te[2] *= x;
			te[6] *= y;
			te[10] *= z;
			te[3] *= x;
			te[7] *= y;
			te[11] *= z;
			return this;
		}

		getMaxScaleOnAxis() {
			const te = this.elements;
			const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
		}

		makeTranslation(x, y, z) {
			this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
			return this;
		}

		makeRotationX(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationY(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationZ(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationAxis(axis, angle) {
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
			const c = Math.cos(angle);
			const s = Math.sin(angle);
			const t = 1 - c;
			const x = axis.x,
						y = axis.y,
						z = axis.z;
			const tx = t * x,
						ty = t * y;
			this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
			return this;
		}

		makeScale(x, y, z) {
			this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
			return this;
		}

		makeShear(xy, xz, yx, yz, zx, zy) {
			this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
			return this;
		}

		compose(position, quaternion, scale) {
			const te = this.elements;
			const x = quaternion._x,
						y = quaternion._y,
						z = quaternion._z,
						w = quaternion._w;
			const x2 = x + x,
						y2 = y + y,
						z2 = z + z;
			const xx = x * x2,
						xy = x * y2,
						xz = x * z2;
			const yy = y * y2,
						yz = y * z2,
						zz = z * z2;
			const wx = w * x2,
						wy = w * y2,
						wz = w * z2;
			const sx = scale.x,
						sy = scale.y,
						sz = scale.z;
			te[0] = (1 - (yy + zz)) * sx;
			te[1] = (xy + wz) * sx;
			te[2] = (xz - wy) * sx;
			te[3] = 0;
			te[4] = (xy - wz) * sy;
			te[5] = (1 - (xx + zz)) * sy;
			te[6] = (yz + wx) * sy;
			te[7] = 0;
			te[8] = (xz + wy) * sz;
			te[9] = (yz - wx) * sz;
			te[10] = (1 - (xx + yy)) * sz;
			te[11] = 0;
			te[12] = position.x;
			te[13] = position.y;
			te[14] = position.z;
			te[15] = 1;
			return this;
		}

		decompose(position, quaternion, scale) {
			const te = this.elements;

			let sx = _v1$5.set(te[0], te[1], te[2]).length();

			const sy = _v1$5.set(te[4], te[5], te[6]).length();

			const sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


			const det = this.determinant();
			if (det < 0) sx = -sx;
			position.x = te[12];
			position.y = te[13];
			position.z = te[14]; // scale the rotation part

			_m1$2.copy(this);

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;
			_m1$2.elements[0] *= invSX;
			_m1$2.elements[1] *= invSX;
			_m1$2.elements[2] *= invSX;
			_m1$2.elements[4] *= invSY;
			_m1$2.elements[5] *= invSY;
			_m1$2.elements[6] *= invSY;
			_m1$2.elements[8] *= invSZ;
			_m1$2.elements[9] *= invSZ;
			_m1$2.elements[10] *= invSZ;
			quaternion.setFromRotationMatrix(_m1$2);
			scale.x = sx;
			scale.y = sy;
			scale.z = sz;
			return this;
		}

		makePerspective(left, right, top, bottom, near, far) {
			if (far === undefined) {
				console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
			}

			const te = this.elements;
			const x = 2 * near / (right - left);
			const y = 2 * near / (top - bottom);
			const a = (right + left) / (right - left);
			const b = (top + bottom) / (top - bottom);
			const c = -(far + near) / (far - near);
			const d = -2 * far * near / (far - near);
			te[0] = x;
			te[4] = 0;
			te[8] = a;
			te[12] = 0;
			te[1] = 0;
			te[5] = y;
			te[9] = b;
			te[13] = 0;
			te[2] = 0;
			te[6] = 0;
			te[10] = c;
			te[14] = d;
			te[3] = 0;
			te[7] = 0;
			te[11] = -1;
			te[15] = 0;
			return this;
		}

		makeOrthographic(left, right, top, bottom, near, far) {
			const te = this.elements;
			const w = 1.0 / (right - left);
			const h = 1.0 / (top - bottom);
			const p = 1.0 / (far - near);
			const x = (right + left) * w;
			const y = (top + bottom) * h;
			const z = (far + near) * p;
			te[0] = 2 * w;
			te[4] = 0;
			te[8] = 0;
			te[12] = -x;
			te[1] = 0;
			te[5] = 2 * h;
			te[9] = 0;
			te[13] = -y;
			te[2] = 0;
			te[6] = 0;
			te[10] = -2 * p;
			te[14] = -z;
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
			te[15] = 1;
			return this;
		}

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 16; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		}

		fromArray(array, offset = 0) {
			for (let i = 0; i < 16; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			array[offset + 9] = te[9];
			array[offset + 10] = te[10];
			array[offset + 11] = te[11];
			array[offset + 12] = te[12];
			array[offset + 13] = te[13];
			array[offset + 14] = te[14];
			array[offset + 15] = te[15];
			return array;
		}

	}

	Matrix4.prototype.isMatrix4 = true;

	const _v1$5 = /*@__PURE__*/new Vector3();

	const _m1$2 = /*@__PURE__*/new Matrix4();

	const _zero = /*@__PURE__*/new Vector3(0, 0, 0);

	const _one = /*@__PURE__*/new Vector3(1, 1, 1);

	const _x = /*@__PURE__*/new Vector3();

	const _y = /*@__PURE__*/new Vector3();

	const _z = /*@__PURE__*/new Vector3();

	const _matrix$1 = /*@__PURE__*/new Matrix4();

	const _quaternion$3 = /*@__PURE__*/new Quaternion();

	class Euler {
		constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;
		}

		get x() {
			return this._x;
		}

		set x(value) {
			this._x = value;

			this._onChangeCallback();
		}

		get y() {
			return this._y;
		}

		set y(value) {
			this._y = value;

			this._onChangeCallback();
		}

		get z() {
			return this._z;
		}

		set z(value) {
			this._z = value;

			this._onChangeCallback();
		}

		get order() {
			return this._order;
		}

		set order(value) {
			this._order = value;

			this._onChangeCallback();
		}

		set(x, y, z, order = this._order) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

			this._onChangeCallback();

			return this;
		}

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._order);
		}

		copy(euler) {
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;
		}

		setFromRotationMatrix(m, order = this._order, update = true) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements;
			const m11 = te[0],
						m12 = te[4],
						m13 = te[8];
			const m21 = te[1],
						m22 = te[5],
						m23 = te[9];
			const m31 = te[2],
						m32 = te[6],
						m33 = te[10];

			switch (order) {
				case 'XYZ':
					this._y = Math.asin(clamp(m13, -1, 1));

					if (Math.abs(m13) < 0.9999999) {
						this._x = Math.atan2(-m23, m33);
						this._z = Math.atan2(-m12, m11);
					} else {
						this._x = Math.atan2(m32, m22);
						this._z = 0;
					}

					break;

				case 'YXZ':
					this._x = Math.asin(-clamp(m23, -1, 1));

					if (Math.abs(m23) < 0.9999999) {
						this._y = Math.atan2(m13, m33);
						this._z = Math.atan2(m21, m22);
					} else {
						this._y = Math.atan2(-m31, m11);
						this._z = 0;
					}

					break;

				case 'ZXY':
					this._x = Math.asin(clamp(m32, -1, 1));

					if (Math.abs(m32) < 0.9999999) {
						this._y = Math.atan2(-m31, m33);
						this._z = Math.atan2(-m12, m22);
					} else {
						this._y = 0;
						this._z = Math.atan2(m21, m11);
					}

					break;

				case 'ZYX':
					this._y = Math.asin(-clamp(m31, -1, 1));

					if (Math.abs(m31) < 0.9999999) {
						this._x = Math.atan2(m32, m33);
						this._z = Math.atan2(m21, m11);
					} else {
						this._x = 0;
						this._z = Math.atan2(-m12, m22);
					}

					break;

				case 'YZX':
					this._z = Math.asin(clamp(m21, -1, 1));

					if (Math.abs(m21) < 0.9999999) {
						this._x = Math.atan2(-m23, m22);
						this._y = Math.atan2(-m31, m11);
					} else {
						this._x = 0;
						this._y = Math.atan2(m13, m33);
					}

					break;

				case 'XZY':
					this._z = Math.asin(-clamp(m12, -1, 1));

					if (Math.abs(m12) < 0.9999999) {
						this._x = Math.atan2(m32, m22);
						this._y = Math.atan2(m13, m11);
					} else {
						this._x = Math.atan2(-m23, m33);
						this._y = 0;
					}

					break;

				default:
					console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
			}

			this._order = order;
			if (update === true) this._onChangeCallback();
			return this;
		}

		setFromQuaternion(q, order, update) {
			_matrix$1.makeRotationFromQuaternion(q);

			return this.setFromRotationMatrix(_matrix$1, order, update);
		}

		setFromVector3(v, order = this._order) {
			return this.set(v.x, v.y, v.z, order);
		}

		reorder(newOrder) {
			// WARNING: this discards revolution information -bhouston
			_quaternion$3.setFromEuler(this);

			return this.setFromQuaternion(_quaternion$3, newOrder);
		}

		equals(euler) {
			return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
		}

		fromArray(array) {
			this._x = array[0];
			this._y = array[1];
			this._z = array[2];
			if (array[3] !== undefined) this._order = array[3];

			this._onChangeCallback();

			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._order;
			return array;
		}

		toVector3(optionalResult) {
			if (optionalResult) {
				return optionalResult.set(this._x, this._y, this._z);
			} else {
				return new Vector3(this._x, this._y, this._z);
			}
		}

		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}

		_onChangeCallback() {}

	}

	Euler.prototype.isEuler = true;
	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

	class Layers {
		constructor() {
			this.mask = 1 | 0;
		}

		set(channel) {
			this.mask = 1 << channel | 0;
		}

		enable(channel) {
			this.mask |= 1 << channel | 0;
		}

		enableAll() {
			this.mask = 0xffffffff | 0;
		}

		toggle(channel) {
			this.mask ^= 1 << channel | 0;
		}

		disable(channel) {
			this.mask &= ~(1 << channel | 0);
		}

		disableAll() {
			this.mask = 0;
		}

		test(layers) {
			return (this.mask & layers.mask) !== 0;
		}

	}

	let _object3DId = 0;

	const _v1$4 = /*@__PURE__*/new Vector3();

	const _q1 = /*@__PURE__*/new Quaternion();

	const _m1$1 = /*@__PURE__*/new Matrix4();

	const _target = /*@__PURE__*/new Vector3();

	const _position$3 = /*@__PURE__*/new Vector3();

	const _scale$2 = /*@__PURE__*/new Vector3();

	const _quaternion$2 = /*@__PURE__*/new Quaternion();

	const _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);

	const _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);

	const _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);

	const _addedEvent = {
		type: 'added'
	};
	const _removedEvent = {
		type: 'removed'
	};

	class Object3D extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: _object3DId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'Object3D';
			this.parent = null;
			this.children = [];
			this.up = Object3D.DefaultUp.clone();
			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion();
			const scale = new Vector3(1, 1, 1);

			function onRotationChange() {
				quaternion.setFromEuler(rotation, false);
			}

			function onQuaternionChange() {
				rotation.setFromQuaternion(quaternion, undefined, false);
			}

			rotation._onChange(onRotationChange);

			quaternion._onChange(onQuaternionChange);

			Object.defineProperties(this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			});
			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();
			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;
			this.layers = new Layers();
			this.visible = true;
			this.castShadow = false;
			this.receiveShadow = false;
			this.frustumCulled = true;
			this.renderOrder = 0;
			this.animations = [];
			this.userData = {};
		}

		onBeforeRender() {}

		onAfterRender() {}

		applyMatrix4(matrix) {
			if (this.matrixAutoUpdate) this.updateMatrix();
			this.matrix.premultiply(matrix);
			this.matrix.decompose(this.position, this.quaternion, this.scale);
		}

		applyQuaternion(q) {
			this.quaternion.premultiply(q);
			return this;
		}

		setRotationFromAxisAngle(axis, angle) {
			// assumes axis is normalized
			this.quaternion.setFromAxisAngle(axis, angle);
		}

		setRotationFromEuler(euler) {
			this.quaternion.setFromEuler(euler, true);
		}

		setRotationFromMatrix(m) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			this.quaternion.setFromRotationMatrix(m);
		}

		setRotationFromQuaternion(q) {
			// assumes q is normalized
			this.quaternion.copy(q);
		}

		rotateOnAxis(axis, angle) {
			// rotate object on axis in object space
			// axis is assumed to be normalized
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.multiply(_q1);
			return this;
		}

		rotateOnWorldAxis(axis, angle) {
			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.premultiply(_q1);
			return this;
		}

		rotateX(angle) {
			return this.rotateOnAxis(_xAxis, angle);
		}

		rotateY(angle) {
			return this.rotateOnAxis(_yAxis, angle);
		}

		rotateZ(angle) {
			return this.rotateOnAxis(_zAxis, angle);
		}

		translateOnAxis(axis, distance) {
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
			_v1$4.copy(axis).applyQuaternion(this.quaternion);

			this.position.add(_v1$4.multiplyScalar(distance));
			return this;
		}

		translateX(distance) {
			return this.translateOnAxis(_xAxis, distance);
		}

		translateY(distance) {
			return this.translateOnAxis(_yAxis, distance);
		}

		translateZ(distance) {
			return this.translateOnAxis(_zAxis, distance);
		}

		localToWorld(vector) {
			return vector.applyMatrix4(this.matrixWorld);
		}

		worldToLocal(vector) {
			return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
		}

		lookAt(x, y, z) {
			// This method does not support objects having non-uniformly-scaled parent(s)
			if (x.isVector3) {
				_target.copy(x);
			} else {
				_target.set(x, y, z);
			}

			const parent = this.parent;
			this.updateWorldMatrix(true, false);

			_position$3.setFromMatrixPosition(this.matrixWorld);

			if (this.isCamera || this.isLight) {
				_m1$1.lookAt(_position$3, _target, this.up);
			} else {
				_m1$1.lookAt(_target, _position$3, this.up);
			}

			this.quaternion.setFromRotationMatrix(_m1$1);

			if (parent) {
				_m1$1.extractRotation(parent.matrixWorld);

				_q1.setFromRotationMatrix(_m1$1);

				this.quaternion.premultiply(_q1.invert());
			}
		}

		add(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.add(arguments[i]);
				}

				return this;
			}

			if (object === this) {
				console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
				return this;
			}

			if (object && object.isObject3D) {
				if (object.parent !== null) {
					object.parent.remove(object);
				}

				object.parent = this;
				this.children.push(object);
				object.dispatchEvent(_addedEvent);
			} else {
				console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
			}

			return this;
		}

		remove(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.remove(arguments[i]);
				}

				return this;
			}

			const index = this.children.indexOf(object);

			if (index !== -1) {
				object.parent = null;
				this.children.splice(index, 1);
				object.dispatchEvent(_removedEvent);
			}

			return this;
		}

		removeFromParent() {
			const parent = this.parent;

			if (parent !== null) {
				parent.remove(this);
			}

			return this;
		}

		clear() {
			for (let i = 0; i < this.children.length; i++) {
				const object = this.children[i];
				object.parent = null;
				object.dispatchEvent(_removedEvent);
			}

			this.children.length = 0;
			return this;
		}

		attach(object) {
			// adds object as a child of this, while maintaining the object's world transform
			this.updateWorldMatrix(true, false);

			_m1$1.copy(this.matrixWorld).invert();

			if (object.parent !== null) {
				object.parent.updateWorldMatrix(true, false);

				_m1$1.multiply(object.parent.matrixWorld);
			}

			object.applyMatrix4(_m1$1);
			this.add(object);
			object.updateWorldMatrix(false, true);
			return this;
		}

		getObjectById(id) {
			return this.getObjectByProperty('id', id);
		}

		getObjectByName(name) {
			return this.getObjectByProperty('name', name);
		}

		getObjectByProperty(name, value) {
			if (this[name] === value) return this;

			for (let i = 0, l = this.children.length; i < l; i++) {
				const child = this.children[i];
				const object = child.getObjectByProperty(name, value);

				if (object !== undefined) {
					return object;
				}
			}

			return undefined;
		}

		getWorldPosition(target) {
			this.updateWorldMatrix(true, false);
			return target.setFromMatrixPosition(this.matrixWorld);
		}

		getWorldQuaternion(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, target, _scale$2);
			return target;
		}

		getWorldScale(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, _quaternion$2, target);
			return target;
		}

		getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(e[8], e[9], e[10]).normalize();
		}

		raycast() {}

		traverse(callback) {
			callback(this);
			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverse(callback);
			}
		}

		traverseVisible(callback) {
			if (this.visible === false) return;
			callback(this);
			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverseVisible(callback);
			}
		}

		traverseAncestors(callback) {
			const parent = this.parent;

			if (parent !== null) {
				callback(parent);
				parent.traverseAncestors(callback);
			}
		}

		updateMatrix() {
			this.matrix.compose(this.position, this.quaternion, this.scale);
			this.matrixWorldNeedsUpdate = true;
		}

		updateMatrixWorld(force) {
			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.matrixWorldNeedsUpdate || force) {
				if (this.parent === null) {
					this.matrixWorld.copy(this.matrix);
				} else {
					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
				}

				this.matrixWorldNeedsUpdate = false;
				force = true;
			} // update children


			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].updateMatrixWorld(force);
			}
		}

		updateWorldMatrix(updateParents, updateChildren) {
			const parent = this.parent;

			if (updateParents === true && parent !== null) {
				parent.updateWorldMatrix(true, false);
			}

			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			} // update children


			if (updateChildren === true) {
				const children = this.children;

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateWorldMatrix(false, true);
				}
			}
		}

		toJSON(meta) {
			// meta is a string when called from JSON.stringify
			const isRootObject = meta === undefined || typeof meta === 'string';
			const output = {}; // meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.

			if (isRootObject) {
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				};
				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
			} // standard Object3D serialization


			const object = {};
			object.uuid = this.uuid;
			object.type = this.type;
			if (this.name !== '') object.name = this.name;
			if (this.castShadow === true) object.castShadow = true;
			if (this.receiveShadow === true) object.receiveShadow = true;
			if (this.visible === false) object.visible = false;
			if (this.frustumCulled === false) object.frustumCulled = false;
			if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
			if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

			if (this.isInstancedMesh) {
				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
			} //


			function serialize(library, element) {
				if (library[element.uuid] === undefined) {
					library[element.uuid] = element.toJSON(meta);
				}

				return element.uuid;
			}

			if (this.isScene) {
				if (this.background) {
					if (this.background.isColor) {
						object.background = this.background.toJSON();
					} else if (this.background.isTexture) {
						object.background = this.background.toJSON(meta).uuid;
					}
				}

				if (this.environment && this.environment.isTexture) {
					object.environment = this.environment.toJSON(meta).uuid;
				}
			} else if (this.isMesh || this.isLine || this.isPoints) {
				object.geometry = serialize(meta.geometries, this.geometry);
				const parameters = this.geometry.parameters;

				if (parameters !== undefined && parameters.shapes !== undefined) {
					const shapes = parameters.shapes;

					if (Array.isArray(shapes)) {
						for (let i = 0, l = shapes.length; i < l; i++) {
							const shape = shapes[i];
							serialize(meta.shapes, shape);
						}
					} else {
						serialize(meta.shapes, shapes);
					}
				}
			}

			if (this.isSkinnedMesh) {
				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if (this.skeleton !== undefined) {
					serialize(meta.skeletons, this.skeleton);
					object.skeleton = this.skeleton.uuid;
				}
			}

			if (this.material !== undefined) {
				if (Array.isArray(this.material)) {
					const uuids = [];

					for (let i = 0, l = this.material.length; i < l; i++) {
						uuids.push(serialize(meta.materials, this.material[i]));
					}

					object.material = uuids;
				} else {
					object.material = serialize(meta.materials, this.material);
				}
			} //


			if (this.children.length > 0) {
				object.children = [];

				for (let i = 0; i < this.children.length; i++) {
					object.children.push(this.children[i].toJSON(meta).object);
				}
			} //


			if (this.animations.length > 0) {
				object.animations = [];

				for (let i = 0; i < this.animations.length; i++) {
					const animation = this.animations[i];
					object.animations.push(serialize(meta.animations, animation));
				}
			}

			if (isRootObject) {
				const geometries = extractFromCache(meta.geometries);
				const materials = extractFromCache(meta.materials);
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				const shapes = extractFromCache(meta.shapes);
				const skeletons = extractFromCache(meta.skeletons);
				const animations = extractFromCache(meta.animations);
				if (geometries.length > 0) output.geometries = geometries;
				if (materials.length > 0) output.materials = materials;
				if (textures.length > 0) output.textures = textures;
				if (images.length > 0) output.images = images;
				if (shapes.length > 0) output.shapes = shapes;
				if (skeletons.length > 0) output.skeletons = skeletons;
				if (animations.length > 0) output.animations = animations;
			}

			output.object = object;
			return output; // extract data from the cache hash
			// remove metadata on each item
			// and return as array

			function extractFromCache(cache) {
				const values = [];

				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}
		}

		clone(recursive) {
			return new this.constructor().copy(this, recursive);
		}

		copy(source, recursive = true) {
			this.name = source.name;
			this.up.copy(source.up);
			this.position.copy(source.position);
			this.rotation.order = source.rotation.order;
			this.quaternion.copy(source.quaternion);
			this.scale.copy(source.scale);
			this.matrix.copy(source.matrix);
			this.matrixWorld.copy(source.matrixWorld);
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
			this.layers.mask = source.layers.mask;
			this.visible = source.visible;
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
			this.userData = JSON.parse(JSON.stringify(source.userData));

			if (recursive === true) {
				for (let i = 0; i < source.children.length; i++) {
					const child = source.children[i];
					this.add(child.clone());
				}
			}

			return this;
		}

	}

	Object3D.DefaultUp = new Vector3(0, 1, 0);
	Object3D.DefaultMatrixAutoUpdate = true;
	Object3D.prototype.isObject3D = true;

	const _v0$1 = /*@__PURE__*/new Vector3();

	const _v1$3 = /*@__PURE__*/new Vector3();

	const _v2$2 = /*@__PURE__*/new Vector3();

	const _v3$1 = /*@__PURE__*/new Vector3();

	const _vab = /*@__PURE__*/new Vector3();

	const _vac = /*@__PURE__*/new Vector3();

	const _vbc = /*@__PURE__*/new Vector3();

	const _vap = /*@__PURE__*/new Vector3();

	const _vbp = /*@__PURE__*/new Vector3();

	const _vcp = /*@__PURE__*/new Vector3();

	class Triangle {
		constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
			this.a = a;
			this.b = b;
			this.c = c;
		}

		static getNormal(a, b, c, target) {
			target.subVectors(c, b);

			_v0$1.subVectors(a, b);

			target.cross(_v0$1);
			const targetLengthSq = target.lengthSq();

			if (targetLengthSq > 0) {
				return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
			}

			return target.set(0, 0, 0);
		} // static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html


		static getBarycoord(point, a, b, c, target) {
			_v0$1.subVectors(c, a);

			_v1$3.subVectors(b, a);

			_v2$2.subVectors(point, a);

			const dot00 = _v0$1.dot(_v0$1);

			const dot01 = _v0$1.dot(_v1$3);

			const dot02 = _v0$1.dot(_v2$2);

			const dot11 = _v1$3.dot(_v1$3);

			const dot12 = _v1$3.dot(_v2$2);

			const denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle

			if (denom === 0) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set(-2, -1, -1);
			}

			const invDenom = 1 / denom;
			const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

			return target.set(1 - u - v, v, u);
		}

		static containsPoint(point, a, b, c) {
			this.getBarycoord(point, a, b, c, _v3$1);
			return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
		}

		static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
			this.getBarycoord(point, p1, p2, p3, _v3$1);
			target.set(0, 0);
			target.addScaledVector(uv1, _v3$1.x);
			target.addScaledVector(uv2, _v3$1.y);
			target.addScaledVector(uv3, _v3$1.z);
			return target;
		}

		static isFrontFacing(a, b, c, direction) {
			_v0$1.subVectors(c, b);

			_v1$3.subVectors(a, b); // strictly front facing


			return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
		}

		set(a, b, c) {
			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);
			return this;
		}

		setFromPointsAndIndices(points, i0, i1, i2) {
			this.a.copy(points[i0]);
			this.b.copy(points[i1]);
			this.c.copy(points[i2]);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(triangle) {
			this.a.copy(triangle.a);
			this.b.copy(triangle.b);
			this.c.copy(triangle.c);
			return this;
		}

		getArea() {
			_v0$1.subVectors(this.c, this.b);

			_v1$3.subVectors(this.a, this.b);

			return _v0$1.cross(_v1$3).length() * 0.5;
		}

		getMidpoint(target) {
			return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
		}

		getNormal(target) {
			return Triangle.getNormal(this.a, this.b, this.c, target);
		}

		getPlane(target) {
			return target.setFromCoplanarPoints(this.a, this.b, this.c);
		}

		getBarycoord(point, target) {
			return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
		}

		getUV(point, uv1, uv2, uv3, target) {
			return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
		}

		containsPoint(point) {
			return Triangle.containsPoint(point, this.a, this.b, this.c);
		}

		isFrontFacing(direction) {
			return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
		}

		intersectsBox(box) {
			return box.intersectsTriangle(this);
		}

		closestPointToPoint(p, target) {
			const a = this.a,
						b = this.b,
						c = this.c;
			let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors(b, a);

			_vac.subVectors(c, a);

			_vap.subVectors(p, a);

			const d1 = _vab.dot(_vap);

			const d2 = _vac.dot(_vap);

			if (d1 <= 0 && d2 <= 0) {
				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy(a);
			}

			_vbp.subVectors(p, b);

			const d3 = _vab.dot(_vbp);

			const d4 = _vac.dot(_vbp);

			if (d3 >= 0 && d4 <= d3) {
				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy(b);
			}

			const vc = d1 * d4 - d3 * d2;

			if (vc <= 0 && d1 >= 0 && d3 <= 0) {
				v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

				return target.copy(a).addScaledVector(_vab, v);
			}

			_vcp.subVectors(p, c);

			const d5 = _vab.dot(_vcp);

			const d6 = _vac.dot(_vcp);

			if (d6 >= 0 && d5 <= d6) {
				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy(c);
			}

			const vb = d5 * d2 - d1 * d6;

			if (vb <= 0 && d2 >= 0 && d6 <= 0) {
				w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

				return target.copy(a).addScaledVector(_vac, w);
			}

			const va = d3 * d6 - d5 * d4;

			if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
				_vbc.subVectors(c, b);

				w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

				return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
			} // face region


			const denom = 1 / (va + vb + vc); // u = va * denom

			v = vb * denom;
			w = vc * denom;
			return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
		}

		equals(triangle) {
			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
		}

	}

	let materialId = 0;

	class Material extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: materialId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'Material';
			this.fog = true;
			this.blending = NormalBlending;
			this.side = FrontSide;
			this.vertexColors = false;
			this.opacity = 1;
			this.transparent = false;
			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;
			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;
			this.stencilWriteMask = 0xff;
			this.stencilFunc = AlwaysStencilFunc;
			this.stencilRef = 0;
			this.stencilFuncMask = 0xff;
			this.stencilFail = KeepStencilOp;
			this.stencilZFail = KeepStencilOp;
			this.stencilZPass = KeepStencilOp;
			this.stencilWrite = false;
			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;
			this.shadowSide = null;
			this.colorWrite = true;
			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;
			this.dithering = false;
			this.alphaTest = 0;
			this.alphaToCoverage = false;
			this.premultipliedAlpha = false;
			this.visible = true;
			this.toneMapped = true;
			this.userData = {};
			this.version = 0;
		}

		onBuild()
		/* shaderobject, renderer */
		{}

		onBeforeCompile()
		/* shaderobject, renderer */
		{}

		customProgramCacheKey() {
			return this.onBeforeCompile.toString();
		}

		setValues(values) {
			if (values === undefined) return;

			for (const key in values) {
				const newValue = values[key];

				if (newValue === undefined) {
					console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
					continue;
				} // for backward compatability if shading is set in the constructor


				if (key === 'shading') {
					console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
					this.flatShading = newValue === FlatShading ? true : false;
					continue;
				}

				const currentValue = this[key];

				if (currentValue === undefined) {
					console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
					continue;
				}

				if (currentValue && currentValue.isColor) {
					currentValue.set(newValue);
				} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
					currentValue.copy(newValue);
				} else {
					this[key] = newValue;
				}
			}
		}

		toJSON(meta) {
			const isRoot = meta === undefined || typeof meta === 'string';

			if (isRoot) {
				meta = {
					textures: {},
					images: {}
				};
			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			}; // standard Material serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (this.color && this.color.isColor) data.color = this.color.getHex();
			if (this.roughness !== undefined) data.roughness = this.roughness;
			if (this.metalness !== undefined) data.metalness = this.metalness;
			if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
			if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
			if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
			if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
			if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
			if (this.specularTint && this.specularTint.isColor) data.specularTint = this.specularTint.getHex();
			if (this.shininess !== undefined) data.shininess = this.shininess;
			if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
			if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

			if (this.clearcoatMap && this.clearcoatMap.isTexture) {
				data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
			}

			if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
			}

			if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
			}

			if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
			if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
			if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;

			if (this.lightMap && this.lightMap.isTexture) {
				data.lightMap = this.lightMap.toJSON(meta).uuid;
				data.lightMapIntensity = this.lightMapIntensity;
			}

			if (this.aoMap && this.aoMap.isTexture) {
				data.aoMap = this.aoMap.toJSON(meta).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
			}

			if (this.bumpMap && this.bumpMap.isTexture) {
				data.bumpMap = this.bumpMap.toJSON(meta).uuid;
				data.bumpScale = this.bumpScale;
			}

			if (this.normalMap && this.normalMap.isTexture) {
				data.normalMap = this.normalMap.toJSON(meta).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
			}

			if (this.displacementMap && this.displacementMap.isTexture) {
				data.displacementMap = this.displacementMap.toJSON(meta).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
			}

			if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
			if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
			if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
			if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
			if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
			if (this.specularTintMap && this.specularTintMap.isTexture) data.specularTintMap = this.specularTintMap.toJSON(meta).uuid;

			if (this.envMap && this.envMap.isTexture) {
				data.envMap = this.envMap.toJSON(meta).uuid;
				if (this.combine !== undefined) data.combine = this.combine;
			}

			if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
			if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
			if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;

			if (this.gradientMap && this.gradientMap.isTexture) {
				data.gradientMap = this.gradientMap.toJSON(meta).uuid;
			}

			if (this.transmission !== undefined) data.transmission = this.transmission;
			if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
			if (this.thickness !== undefined) data.thickness = this.thickness;
			if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
			if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;
			if (this.attenuationTint !== undefined) data.attenuationTint = this.attenuationTint.getHex();
			if (this.size !== undefined) data.size = this.size;
			if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
			if (this.blending !== NormalBlending) data.blending = this.blending;
			if (this.side !== FrontSide) data.side = this.side;
			if (this.vertexColors) data.vertexColors = true;
			if (this.opacity < 1) data.opacity = this.opacity;
			if (this.transparent === true) data.transparent = this.transparent;
			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;
			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

			if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
			if (this.polygonOffset === true) data.polygonOffset = true;
			if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
			if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
			if (this.dashSize !== undefined) data.dashSize = this.dashSize;
			if (this.gapSize !== undefined) data.gapSize = this.gapSize;
			if (this.scale !== undefined) data.scale = this.scale;
			if (this.dithering === true) data.dithering = true;
			if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
			if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
			if (this.wireframe === true) data.wireframe = this.wireframe;
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
			if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
			if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
			if (this.flatShading === true) data.flatShading = this.flatShading;
			if (this.visible === false) data.visible = false;
			if (this.toneMapped === false) data.toneMapped = false;
			if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

			function extractFromCache(cache) {
				const values = [];

				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}

			if (isRoot) {
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				if (textures.length > 0) data.textures = textures;
				if (images.length > 0) data.images = images;
			}

			return data;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.name = source.name;
			this.fog = source.fog;
			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;
			this.opacity = source.opacity;
			this.transparent = source.transparent;
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;
			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if (srcPlanes !== null) {
				const n = srcPlanes.length;
				dstPlanes = new Array(n);

				for (let i = 0; i !== n; ++i) {
					dstPlanes[i] = srcPlanes[i].clone();
				}
			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;
			this.shadowSide = source.shadowSide;
			this.colorWrite = source.colorWrite;
			this.precision = source.precision;
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
			this.dithering = source.dithering;
			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.visible = source.visible;
			this.toneMapped = source.toneMapped;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

	}

	Material.prototype.isMaterial = true;

	const _colorKeywords = {
		'aliceblue': 0xF0F8FF,
		'antiquewhite': 0xFAEBD7,
		'aqua': 0x00FFFF,
		'aquamarine': 0x7FFFD4,
		'azure': 0xF0FFFF,
		'beige': 0xF5F5DC,
		'bisque': 0xFFE4C4,
		'black': 0x000000,
		'blanchedalmond': 0xFFEBCD,
		'blue': 0x0000FF,
		'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A,
		'burlywood': 0xDEB887,
		'cadetblue': 0x5F9EA0,
		'chartreuse': 0x7FFF00,
		'chocolate': 0xD2691E,
		'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED,
		'cornsilk': 0xFFF8DC,
		'crimson': 0xDC143C,
		'cyan': 0x00FFFF,
		'darkblue': 0x00008B,
		'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B,
		'darkgray': 0xA9A9A9,
		'darkgreen': 0x006400,
		'darkgrey': 0xA9A9A9,
		'darkkhaki': 0xBDB76B,
		'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F,
		'darkorange': 0xFF8C00,
		'darkorchid': 0x9932CC,
		'darkred': 0x8B0000,
		'darksalmon': 0xE9967A,
		'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B,
		'darkslategray': 0x2F4F4F,
		'darkslategrey': 0x2F4F4F,
		'darkturquoise': 0x00CED1,
		'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493,
		'deepskyblue': 0x00BFFF,
		'dimgray': 0x696969,
		'dimgrey': 0x696969,
		'dodgerblue': 0x1E90FF,
		'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0,
		'forestgreen': 0x228B22,
		'fuchsia': 0xFF00FF,
		'gainsboro': 0xDCDCDC,
		'ghostwhite': 0xF8F8FF,
		'gold': 0xFFD700,
		'goldenrod': 0xDAA520,
		'gray': 0x808080,
		'green': 0x008000,
		'greenyellow': 0xADFF2F,
		'grey': 0x808080,
		'honeydew': 0xF0FFF0,
		'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C,
		'indigo': 0x4B0082,
		'ivory': 0xFFFFF0,
		'khaki': 0xF0E68C,
		'lavender': 0xE6E6FA,
		'lavenderblush': 0xFFF0F5,
		'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD,
		'lightblue': 0xADD8E6,
		'lightcoral': 0xF08080,
		'lightcyan': 0xE0FFFF,
		'lightgoldenrodyellow': 0xFAFAD2,
		'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90,
		'lightgrey': 0xD3D3D3,
		'lightpink': 0xFFB6C1,
		'lightsalmon': 0xFFA07A,
		'lightseagreen': 0x20B2AA,
		'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899,
		'lightslategrey': 0x778899,
		'lightsteelblue': 0xB0C4DE,
		'lightyellow': 0xFFFFE0,
		'lime': 0x00FF00,
		'limegreen': 0x32CD32,
		'linen': 0xFAF0E6,
		'magenta': 0xFF00FF,
		'maroon': 0x800000,
		'mediumaquamarine': 0x66CDAA,
		'mediumblue': 0x0000CD,
		'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB,
		'mediumseagreen': 0x3CB371,
		'mediumslateblue': 0x7B68EE,
		'mediumspringgreen': 0x00FA9A,
		'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585,
		'midnightblue': 0x191970,
		'mintcream': 0xF5FFFA,
		'mistyrose': 0xFFE4E1,
		'moccasin': 0xFFE4B5,
		'navajowhite': 0xFFDEAD,
		'navy': 0x000080,
		'oldlace': 0xFDF5E6,
		'olive': 0x808000,
		'olivedrab': 0x6B8E23,
		'orange': 0xFFA500,
		'orangered': 0xFF4500,
		'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA,
		'palegreen': 0x98FB98,
		'paleturquoise': 0xAFEEEE,
		'palevioletred': 0xDB7093,
		'papayawhip': 0xFFEFD5,
		'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F,
		'pink': 0xFFC0CB,
		'plum': 0xDDA0DD,
		'powderblue': 0xB0E0E6,
		'purple': 0x800080,
		'rebeccapurple': 0x663399,
		'red': 0xFF0000,
		'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1,
		'saddlebrown': 0x8B4513,
		'salmon': 0xFA8072,
		'sandybrown': 0xF4A460,
		'seagreen': 0x2E8B57,
		'seashell': 0xFFF5EE,
		'sienna': 0xA0522D,
		'silver': 0xC0C0C0,
		'skyblue': 0x87CEEB,
		'slateblue': 0x6A5ACD,
		'slategray': 0x708090,
		'slategrey': 0x708090,
		'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F,
		'steelblue': 0x4682B4,
		'tan': 0xD2B48C,
		'teal': 0x008080,
		'thistle': 0xD8BFD8,
		'tomato': 0xFF6347,
		'turquoise': 0x40E0D0,
		'violet': 0xEE82EE,
		'wheat': 0xF5DEB3,
		'white': 0xFFFFFF,
		'whitesmoke': 0xF5F5F5,
		'yellow': 0xFFFF00,
		'yellowgreen': 0x9ACD32
	};
	const _hslA = {
		h: 0,
		s: 0,
		l: 0
	};
	const _hslB = {
		h: 0,
		s: 0,
		l: 0
	};

	function hue2rgb(p, q, t) {
		if (t < 0) t += 1;
		if (t > 1) t -= 1;
		if (t < 1 / 6) return p + (q - p) * 6 * t;
		if (t < 1 / 2) return q;
		if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
		return p;
	}

	function SRGBToLinear(c) {
		return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
	}

	function LinearToSRGB(c) {
		return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
	}

	class Color {
		constructor(r, g, b) {
			if (g === undefined && b === undefined) {
				// r is THREE.Color, hex or string
				return this.set(r);
			}

			return this.setRGB(r, g, b);
		}

		set(value) {
			if (value && value.isColor) {
				this.copy(value);
			} else if (typeof value === 'number') {
				this.setHex(value);
			} else if (typeof value === 'string') {
				this.setStyle(value);
			}

			return this;
		}

		setScalar(scalar) {
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
			return this;
		}

		setHex(hex) {
			hex = Math.floor(hex);
			this.r = (hex >> 16 & 255) / 255;
			this.g = (hex >> 8 & 255) / 255;
			this.b = (hex & 255) / 255;
			return this;
		}

		setRGB(r, g, b) {
			this.r = r;
			this.g = g;
			this.b = b;
			return this;
		}

		setHSL(h, s, l) {
			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo(h, 1);
			s = clamp(s, 0, 1);
			l = clamp(l, 0, 1);

			if (s === 0) {
				this.r = this.g = this.b = l;
			} else {
				const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
				const q = 2 * l - p;
				this.r = hue2rgb(q, p, h + 1 / 3);
				this.g = hue2rgb(q, p, h);
				this.b = hue2rgb(q, p, h - 1 / 3);
			}

			return this;
		}

		setStyle(style) {
			function handleAlpha(string) {
				if (string === undefined) return;

				if (parseFloat(string) < 1) {
					console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
				}
			}

			let m;

			if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
				// rgb / hsl
				let color;
				const name = m[1];
				const components = m[2];

				switch (name) {
					case 'rgb':
					case 'rgba':
						if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min(255, parseInt(color[1], 10)) / 255;
							this.g = Math.min(255, parseInt(color[2], 10)) / 255;
							this.b = Math.min(255, parseInt(color[3], 10)) / 255;
							handleAlpha(color[4]);
							return this;
						}

						if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min(100, parseInt(color[1], 10)) / 100;
							this.g = Math.min(100, parseInt(color[2], 10)) / 100;
							this.b = Math.min(100, parseInt(color[3], 10)) / 100;
							handleAlpha(color[4]);
							return this;
						}

						break;

					case 'hsl':
					case 'hsla':
						if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat(color[1]) / 360;
							const s = parseInt(color[2], 10) / 100;
							const l = parseInt(color[3], 10) / 100;
							handleAlpha(color[4]);
							return this.setHSL(h, s, l);
						}

						break;
				}
			} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
				// hex color
				const hex = m[1];
				const size = hex.length;

				if (size === 3) {
					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
					return this;
				} else if (size === 6) {
					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
					return this;
				}
			}

			if (style && style.length > 0) {
				return this.setColorName(style);
			}

			return this;
		}

		setColorName(style) {
			// color keywords
			const hex = _colorKeywords[style.toLowerCase()];

			if (hex !== undefined) {
				// red
				this.setHex(hex);
			} else {
				// unknown color
				console.warn('THREE.Color: Unknown color ' + style);
			}

			return this;
		}

		clone() {
			return new this.constructor(this.r, this.g, this.b);
		}

		copy(color) {
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
			return this;
		}

		copyGammaToLinear(color, gammaFactor = 2.0) {
			this.r = Math.pow(color.r, gammaFactor);
			this.g = Math.pow(color.g, gammaFactor);
			this.b = Math.pow(color.b, gammaFactor);
			return this;
		}

		copyLinearToGamma(color, gammaFactor = 2.0) {
			const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
			this.r = Math.pow(color.r, safeInverse);
			this.g = Math.pow(color.g, safeInverse);
			this.b = Math.pow(color.b, safeInverse);
			return this;
		}

		convertGammaToLinear(gammaFactor) {
			this.copyGammaToLinear(this, gammaFactor);
			return this;
		}

		convertLinearToGamma(gammaFactor) {
			this.copyLinearToGamma(this, gammaFactor);
			return this;
		}

		copySRGBToLinear(color) {
			this.r = SRGBToLinear(color.r);
			this.g = SRGBToLinear(color.g);
			this.b = SRGBToLinear(color.b);
			return this;
		}

		copyLinearToSRGB(color) {
			this.r = LinearToSRGB(color.r);
			this.g = LinearToSRGB(color.g);
			this.b = LinearToSRGB(color.b);
			return this;
		}

		convertSRGBToLinear() {
			this.copySRGBToLinear(this);
			return this;
		}

		convertLinearToSRGB() {
			this.copyLinearToSRGB(this);
			return this;
		}

		getHex() {
			return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
		}

		getHexString() {
			return ('000000' + this.getHex().toString(16)).slice(-6);
		}

		getHSL(target) {
			// h,s,l ranges are in 0.0 - 1.0
			const r = this.r,
						g = this.g,
						b = this.b;
			const max = Math.max(r, g, b);
			const min = Math.min(r, g, b);
			let hue, saturation;
			const lightness = (min + max) / 2.0;

			if (min === max) {
				hue = 0;
				saturation = 0;
			} else {
				const delta = max - min;
				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

				switch (max) {
					case r:
						hue = (g - b) / delta + (g < b ? 6 : 0);
						break;

					case g:
						hue = (b - r) / delta + 2;
						break;

					case b:
						hue = (r - g) / delta + 4;
						break;
				}

				hue /= 6;
			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;
			return target;
		}

		getStyle() {
			return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
		}

		offsetHSL(h, s, l) {
			this.getHSL(_hslA);
			_hslA.h += h;
			_hslA.s += s;
			_hslA.l += l;
			this.setHSL(_hslA.h, _hslA.s, _hslA.l);
			return this;
		}

		add(color) {
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
			return this;
		}

		addColors(color1, color2) {
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
			return this;
		}

		addScalar(s) {
			this.r += s;
			this.g += s;
			this.b += s;
			return this;
		}

		sub(color) {
			this.r = Math.max(0, this.r - color.r);
			this.g = Math.max(0, this.g - color.g);
			this.b = Math.max(0, this.b - color.b);
			return this;
		}

		multiply(color) {
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
			return this;
		}

		multiplyScalar(s) {
			this.r *= s;
			this.g *= s;
			this.b *= s;
			return this;
		}

		lerp(color, alpha) {
			this.r += (color.r - this.r) * alpha;
			this.g += (color.g - this.g) * alpha;
			this.b += (color.b - this.b) * alpha;
			return this;
		}

		lerpColors(color1, color2, alpha) {
			this.r = color1.r + (color2.r - color1.r) * alpha;
			this.g = color1.g + (color2.g - color1.g) * alpha;
			this.b = color1.b + (color2.b - color1.b) * alpha;
			return this;
		}

		lerpHSL(color, alpha) {
			this.getHSL(_hslA);
			color.getHSL(_hslB);
			const h = lerp(_hslA.h, _hslB.h, alpha);
			const s = lerp(_hslA.s, _hslB.s, alpha);
			const l = lerp(_hslA.l, _hslB.l, alpha);
			this.setHSL(h, s, l);
			return this;
		}

		equals(c) {
			return c.r === this.r && c.g === this.g && c.b === this.b;
		}

		fromArray(array, offset = 0) {
			this.r = array[offset];
			this.g = array[offset + 1];
			this.b = array[offset + 2];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.r;
			array[offset + 1] = this.g;
			array[offset + 2] = this.b;
			return array;
		}

		fromBufferAttribute(attribute, index) {
			this.r = attribute.getX(index);
			this.g = attribute.getY(index);
			this.b = attribute.getZ(index);

			if (attribute.normalized === true) {
				// assuming Uint8Array
				this.r /= 255;
				this.g /= 255;
				this.b /= 255;
			}

			return this;
		}

		toJSON() {
			return this.getHex();
		}

	}

	Color.NAMES = _colorKeywords;
	Color.prototype.isColor = true;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	depthTest: <bool>,
	 *	depthWrite: <bool>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 * }
	 */

	class MeshBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshBasicMaterial';
			this.color = new Color(0xffffff); // emissive

			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		}

	}

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	const _vector$9 = /*@__PURE__*/new Vector3();

	const _vector2$1 = /*@__PURE__*/new Vector2();

	class BufferAttribute {
		constructor(array, itemSize, normalized) {
			if (Array.isArray(array)) {
				throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
			}

			this.name = '';
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
		}

		onUploadCallback() {}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setUsage(value) {
			this.usage = value;
			return this;
		}

		copy(source) {
			this.name = source.name;
			this.array = new source.array.constructor(source.array);
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;
			this.usage = source.usage;
			return this;
		}

		copyAt(index1, attribute, index2) {
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for (let i = 0, l = this.itemSize; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		}

		copyArray(array) {
			this.array.set(array);
			return this;
		}

		copyColorsArray(colors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = colors.length; i < l; i++) {
				let color = colors[i];

				if (color === undefined) {
					console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
					color = new Color();
				}

				array[offset++] = color.r;
				array[offset++] = color.g;
				array[offset++] = color.b;
			}

			return this;
		}

		copyVector2sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
					vector = new Vector2();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
			}

			return this;
		}

		copyVector3sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
					vector = new Vector3();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
			}

			return this;
		}

		copyVector4sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
					vector = new Vector4();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
				array[offset++] = vector.w;
			}

			return this;
		}

		applyMatrix3(m) {
			if (this.itemSize === 2) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector2$1.fromBufferAttribute(this, i);

					_vector2$1.applyMatrix3(m);

					this.setXY(i, _vector2$1.x, _vector2$1.y);
				}
			} else if (this.itemSize === 3) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector$9.fromBufferAttribute(this, i);

					_vector$9.applyMatrix3(m);

					this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
				}
			}

			return this;
		}

		applyMatrix4(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.applyMatrix4(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.applyNormalMatrix(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.transformDirection(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		set(value, offset = 0) {
			this.array.set(value, offset);
			return this;
		}

		getX(index) {
			return this.array[index * this.itemSize];
		}

		setX(index, x) {
			this.array[index * this.itemSize] = x;
			return this;
		}

		getY(index) {
			return this.array[index * this.itemSize + 1];
		}

		setY(index, y) {
			this.array[index * this.itemSize + 1] = y;
			return this;
		}

		getZ(index) {
			return this.array[index * this.itemSize + 2];
		}

		setZ(index, z) {
			this.array[index * this.itemSize + 2] = z;
			return this;
		}

		getW(index) {
			return this.array[index * this.itemSize + 3];
		}

		setW(index, w) {
			this.array[index * this.itemSize + 3] = w;
			return this;
		}

		setXY(index, x, y) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			return this;
		}

		setXYZ(index, x, y, z) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			return this;
		}

		setXYZW(index, x, y, z, w) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			this.array[index + 3] = w;
			return this;
		}

		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}

		clone() {
			return new this.constructor(this.array, this.itemSize).copy(this);
		}

		toJSON() {
			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call(this.array),
				normalized: this.normalized
			};
			if (this.name !== '') data.name = this.name;
			if (this.usage !== StaticDrawUsage) data.usage = this.usage;
			if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
			return data;
		}

	}

	BufferAttribute.prototype.isBufferAttribute = true; //

	class Int8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int8Array(array), itemSize, normalized);
		}

	}

	class Uint8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8Array(array), itemSize, normalized);
		}

	}

	class Uint8ClampedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8ClampedArray(array), itemSize, normalized);
		}

	}

	class Int16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int16Array(array), itemSize, normalized);
		}

	}

	class Uint16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
		}

	}

	class Int32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int32Array(array), itemSize, normalized);
		}

	}

	class Uint32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint32Array(array), itemSize, normalized);
		}

	}

	class Float16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
		}

	}

	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	class Float32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float32Array(array), itemSize, normalized);
		}

	}

	class Float64BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float64Array(array), itemSize, normalized);
		}

	} //

	function arrayMax(array) {
		if (array.length === 0) return -Infinity;
		let max = array[0];

		for (let i = 1, l = array.length; i < l; ++i) {
			if (array[i] > max) max = array[i];
		}

		return max;
	}

	const TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: Uint8ClampedArray,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	function getTypedArray(type, buffer) {
		return new TYPED_ARRAYS[type](buffer);
	}

	let _id = 0;

	const _m1 = /*@__PURE__*/new Matrix4();

	const _obj = /*@__PURE__*/new Object3D();

	const _offset = /*@__PURE__*/new Vector3();

	const _box$1 = /*@__PURE__*/new Box3();

	const _boxMorphTargets = /*@__PURE__*/new Box3();

	const _vector$8 = /*@__PURE__*/new Vector3();

	class BufferGeometry extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: _id++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'BufferGeometry';
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.morphTargetsRelative = false;
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;
			this.drawRange = {
				start: 0,
				count: Infinity
			};
			this.userData = {};
		}

		getIndex() {
			return this.index;
		}

		setIndex(index) {
			if (Array.isArray(index)) {
				this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
			} else {
				this.index = index;
			}

			return this;
		}

		getAttribute(name) {
			return this.attributes[name];
		}

		setAttribute(name, attribute) {
			this.attributes[name] = attribute;
			return this;
		}

		deleteAttribute(name) {
			delete this.attributes[name];
			return this;
		}

		hasAttribute(name) {
			return this.attributes[name] !== undefined;
		}

		addGroup(start, count, materialIndex = 0) {
			this.groups.push({
				start: start,
				count: count,
				materialIndex: materialIndex
			});
		}

		clearGroups() {
			this.groups = [];
		}

		setDrawRange(start, count) {
			this.drawRange.start = start;
			this.drawRange.count = count;
		}

		applyMatrix4(matrix) {
			const position = this.attributes.position;

			if (position !== undefined) {
				position.applyMatrix4(matrix);
				position.needsUpdate = true;
			}

			const normal = this.attributes.normal;

			if (normal !== undefined) {
				const normalMatrix = new Matrix3().getNormalMatrix(matrix);
				normal.applyNormalMatrix(normalMatrix);
				normal.needsUpdate = true;
			}

			const tangent = this.attributes.tangent;

			if (tangent !== undefined) {
				tangent.transformDirection(matrix);
				tangent.needsUpdate = true;
			}

			if (this.boundingBox !== null) {
				this.computeBoundingBox();
			}

			if (this.boundingSphere !== null) {
				this.computeBoundingSphere();
			}

			return this;
		}

		applyQuaternion(q) {
			_m1.makeRotationFromQuaternion(q);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateX(angle) {
			// rotate geometry around world x-axis
			_m1.makeRotationX(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateY(angle) {
			// rotate geometry around world y-axis
			_m1.makeRotationY(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateZ(angle) {
			// rotate geometry around world z-axis
			_m1.makeRotationZ(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		translate(x, y, z) {
			// translate geometry
			_m1.makeTranslation(x, y, z);

			this.applyMatrix4(_m1);
			return this;
		}

		scale(x, y, z) {
			// scale geometry
			_m1.makeScale(x, y, z);

			this.applyMatrix4(_m1);
			return this;
		}

		lookAt(vector) {
			_obj.lookAt(vector);

			_obj.updateMatrix();

			this.applyMatrix4(_obj.matrix);
			return this;
		}

		center() {
			this.computeBoundingBox();
			this.boundingBox.getCenter(_offset).negate();
			this.translate(_offset.x, _offset.y, _offset.z);
			return this;
		}

		setFromPoints(points) {
			const position = [];

			for (let i = 0, l = points.length; i < l; i++) {
				const point = points[i];
				position.push(point.x, point.y, point.z || 0);
			}

			this.setAttribute('position', new Float32BufferAttribute(position, 3));
			return this;
		}

		computeBoundingBox() {
			if (this.boundingBox === null) {
				this.boundingBox = new Box3();
			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
				return;
			}

			if (position !== undefined) {
				this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];

						_box$1.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$8.addVectors(this.boundingBox.min, _box$1.min);

							this.boundingBox.expandByPoint(_vector$8);

							_vector$8.addVectors(this.boundingBox.max, _box$1.max);

							this.boundingBox.expandByPoint(_vector$8);
						} else {
							this.boundingBox.expandByPoint(_box$1.min);
							this.boundingBox.expandByPoint(_box$1.max);
						}
					}
				}
			} else {
				this.boundingBox.makeEmpty();
			}

			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
			}
		}

		computeBoundingSphere() {
			if (this.boundingSphere === null) {
				this.boundingSphere = new Sphere();
			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingSphere.set(new Vector3(), Infinity);
				return;
			}

			if (position) {
				// first, find the center of the bounding sphere
				const center = this.boundingSphere.center;

				_box$1.setFromBufferAttribute(position); // process morph attributes if present


				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];

						_boxMorphTargets.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);

							_box$1.expandByPoint(_vector$8);

							_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);

							_box$1.expandByPoint(_vector$8);
						} else {
							_box$1.expandByPoint(_boxMorphTargets.min);

							_box$1.expandByPoint(_boxMorphTargets.max);
						}
					}
				}

				_box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case


				let maxRadiusSq = 0;

				for (let i = 0, il = position.count; i < il; i++) {
					_vector$8.fromBufferAttribute(position, i);

					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
				} // process morph attributes if present


				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];
						const morphTargetsRelative = this.morphTargetsRelative;

						for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
							_vector$8.fromBufferAttribute(morphAttribute, j);

							if (morphTargetsRelative) {
								_offset.fromBufferAttribute(position, j);

								_vector$8.add(_offset);
							}

							maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
						}
					}
				}

				this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

				if (isNaN(this.boundingSphere.radius)) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
				}
			}
		}

		computeFaceNormals() {// backwards compatibility
		}

		computeTangents() {
			const index = this.index;
			const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
				console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
				return;
			}

			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;
			const nVertices = positions.length / 3;

			if (attributes.tangent === undefined) {
				this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
			}

			const tangents = attributes.tangent.array;
			const tan1 = [],
						tan2 = [];

			for (let i = 0; i < nVertices; i++) {
				tan1[i] = new Vector3();
				tan2[i] = new Vector3();
			}

			const vA = new Vector3(),
						vB = new Vector3(),
						vC = new Vector3(),
						uvA = new Vector2(),
						uvB = new Vector2(),
						uvC = new Vector2(),
						sdir = new Vector3(),
						tdir = new Vector3();

			function handleTriangle(a, b, c) {
				vA.fromArray(positions, a * 3);
				vB.fromArray(positions, b * 3);
				vC.fromArray(positions, c * 3);
				uvA.fromArray(uvs, a * 2);
				uvB.fromArray(uvs, b * 2);
				uvC.fromArray(uvs, c * 2);
				vB.sub(vA);
				vC.sub(vA);
				uvB.sub(uvA);
				uvC.sub(uvA);
				const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

				if (!isFinite(r)) return;
				sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
				tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
				tan1[a].add(sdir);
				tan1[b].add(sdir);
				tan1[c].add(sdir);
				tan2[a].add(tdir);
				tan2[b].add(tdir);
				tan2[c].add(tdir);
			}

			let groups = this.groups;

			if (groups.length === 0) {
				groups = [{
					start: 0,
					count: indices.length
				}];
			}

			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;

				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
				}
			}

			const tmp = new Vector3(),
						tmp2 = new Vector3();
			const n = new Vector3(),
						n2 = new Vector3();

			function handleVertex(v) {
				n.fromArray(normals, v * 3);
				n2.copy(n);
				const t = tan1[v]; // Gram-Schmidt orthogonalize

				tmp.copy(t);
				tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

				tmp2.crossVectors(n2, t);
				const test = tmp2.dot(tan2[v]);
				const w = test < 0.0 ? -1.0 : 1.0;
				tangents[v * 4] = tmp.x;
				tangents[v * 4 + 1] = tmp.y;
				tangents[v * 4 + 2] = tmp.z;
				tangents[v * 4 + 3] = w;
			}

			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;

				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleVertex(indices[j + 0]);
					handleVertex(indices[j + 1]);
					handleVertex(indices[j + 2]);
				}
			}
		}

		computeVertexNormals() {
			const index = this.index;
			const positionAttribute = this.getAttribute('position');

			if (positionAttribute !== undefined) {
				let normalAttribute = this.getAttribute('normal');

				if (normalAttribute === undefined) {
					normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
					this.setAttribute('normal', normalAttribute);
				} else {
					// reset existing normals to zero
					for (let i = 0, il = normalAttribute.count; i < il; i++) {
						normalAttribute.setXYZ(i, 0, 0, 0);
					}
				}

				const pA = new Vector3(),
							pB = new Vector3(),
							pC = new Vector3();
				const nA = new Vector3(),
							nB = new Vector3(),
							nC = new Vector3();
				const cb = new Vector3(),
							ab = new Vector3(); // indexed elements

				if (index) {
					for (let i = 0, il = index.count; i < il; i += 3) {
						const vA = index.getX(i + 0);
						const vB = index.getX(i + 1);
						const vC = index.getX(i + 2);
						pA.fromBufferAttribute(positionAttribute, vA);
						pB.fromBufferAttribute(positionAttribute, vB);
						pC.fromBufferAttribute(positionAttribute, vC);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						nA.fromBufferAttribute(normalAttribute, vA);
						nB.fromBufferAttribute(normalAttribute, vB);
						nC.fromBufferAttribute(normalAttribute, vC);
						nA.add(cb);
						nB.add(cb);
						nC.add(cb);
						normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
						normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
						normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
					}
				} else {
					// non-indexed elements (unconnected triangle soup)
					for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
						pA.fromBufferAttribute(positionAttribute, i + 0);
						pB.fromBufferAttribute(positionAttribute, i + 1);
						pC.fromBufferAttribute(positionAttribute, i + 2);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
					}
				}

				this.normalizeNormals();
				normalAttribute.needsUpdate = true;
			}
		}

		merge(geometry, offset) {
			if (!(geometry && geometry.isBufferGeometry)) {
				console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
				return;
			}

			if (offset === undefined) {
				offset = 0;
				console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
			}

			const attributes = this.attributes;

			for (const key in attributes) {
				if (geometry.attributes[key] === undefined) continue;
				const attribute1 = attributes[key];
				const attributeArray1 = attribute1.array;
				const attribute2 = geometry.attributes[key];
				const attributeArray2 = attribute2.array;
				const attributeOffset = attribute2.itemSize * offset;
				const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

				for (let i = 0, j = attributeOffset; i < length; i++, j++) {
					attributeArray1[j] = attributeArray2[i];
				}
			}

			return this;
		}

		normalizeNormals() {
			const normals = this.attributes.normal;

			for (let i = 0, il = normals.count; i < il; i++) {
				_vector$8.fromBufferAttribute(normals, i);

				_vector$8.normalize();

				normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
			}
		}

		toNonIndexed() {
			function convertBufferAttribute(attribute, indices) {
				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;
				const array2 = new array.constructor(indices.length * itemSize);
				let index = 0,
						index2 = 0;

				for (let i = 0, l = indices.length; i < l; i++) {
					if (attribute.isInterleavedBufferAttribute) {
						index = indices[i] * attribute.data.stride + attribute.offset;
					} else {
						index = indices[i] * itemSize;
					}

					for (let j = 0; j < itemSize; j++) {
						array2[index2++] = array[index++];
					}
				}

				return new BufferAttribute(array2, itemSize, normalized);
			} //


			if (this.index === null) {
				console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
				return this;
			}

			const geometry2 = new BufferGeometry();
			const indices = this.index.array;
			const attributes = this.attributes; // attributes

			for (const name in attributes) {
				const attribute = attributes[name];
				const newAttribute = convertBufferAttribute(attribute, indices);
				geometry2.setAttribute(name, newAttribute);
			} // morph attributes


			const morphAttributes = this.morphAttributes;

			for (const name in morphAttributes) {
				const morphArray = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, il = morphAttribute.length; i < il; i++) {
					const attribute = morphAttribute[i];
					const newAttribute = convertBufferAttribute(attribute, indices);
					morphArray.push(newAttribute);
				}

				geometry2.morphAttributes[name] = morphArray;
			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

			const groups = this.groups;

			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				geometry2.addGroup(group.start, group.count, group.materialIndex);
			}

			return geometry2;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			}; // standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (Object.keys(this.userData).length > 0) data.userData = this.userData;

			if (this.parameters !== undefined) {
				const parameters = this.parameters;

				for (const key in parameters) {
					if (parameters[key] !== undefined) data[key] = parameters[key];
				}

				return data;
			} // for simplicity the code assumes attributes are not shared across geometries, see #15811


			data.data = {
				attributes: {}
			};
			const index = this.index;

			if (index !== null) {
				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call(index.array)
				};
			}

			const attributes = this.attributes;

			for (const key in attributes) {
				const attribute = attributes[key];
				data.data.attributes[key] = attribute.toJSON(data.data);
			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for (const key in this.morphAttributes) {
				const attributeArray = this.morphAttributes[key];
				const array = [];

				for (let i = 0, il = attributeArray.length; i < il; i++) {
					const attribute = attributeArray[i];
					array.push(attribute.toJSON(data.data));
				}

				if (array.length > 0) {
					morphAttributes[key] = array;
					hasMorphAttributes = true;
				}
			}

			if (hasMorphAttributes) {
				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;
			}

			const groups = this.groups;

			if (groups.length > 0) {
				data.data.groups = JSON.parse(JSON.stringify(groups));
			}

			const boundingSphere = this.boundingSphere;

			if (boundingSphere !== null) {
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
			}

			return data;
		}

		clone() {
			/*
			 // Handle primitives
				 const parameters = this.parameters;
				 if ( parameters !== undefined ) {
				 const values = [];
				 for ( const key in parameters ) {
				 values.push( parameters[ key ] );
				 }
				 const geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;
				 }
				 return new this.constructor().copy( this );
			 */
			return new BufferGeometry().copy(this);
		}

		copy(source) {
			// reset
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null; // used for storing cloned, shared data

			const data = {}; // name

			this.name = source.name; // index

			const index = source.index;

			if (index !== null) {
				this.setIndex(index.clone(data));
			} // attributes


			const attributes = source.attributes;

			for (const name in attributes) {
				const attribute = attributes[name];
				this.setAttribute(name, attribute.clone(data));
			} // morph attributes


			const morphAttributes = source.morphAttributes;

			for (const name in morphAttributes) {
				const array = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, l = morphAttribute.length; i < l; i++) {
					array.push(morphAttribute[i].clone(data));
				}

				this.morphAttributes[name] = array;
			}

			this.morphTargetsRelative = source.morphTargetsRelative; // groups

			const groups = source.groups;

			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				this.addGroup(group.start, group.count, group.materialIndex);
			} // bounding box


			const boundingBox = source.boundingBox;

			if (boundingBox !== null) {
				this.boundingBox = boundingBox.clone();
			} // bounding sphere


			const boundingSphere = source.boundingSphere;

			if (boundingSphere !== null) {
				this.boundingSphere = boundingSphere.clone();
			} // draw range


			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count; // user data

			this.userData = source.userData;
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	BufferGeometry.prototype.isBufferGeometry = true;

	const _inverseMatrix$2 = /*@__PURE__*/new Matrix4();

	const _ray$2 = /*@__PURE__*/new Ray();

	const _sphere$3 = /*@__PURE__*/new Sphere();

	const _vA$1 = /*@__PURE__*/new Vector3();

	const _vB$1 = /*@__PURE__*/new Vector3();

	const _vC$1 = /*@__PURE__*/new Vector3();

	const _tempA = /*@__PURE__*/new Vector3();

	const _tempB = /*@__PURE__*/new Vector3();

	const _tempC = /*@__PURE__*/new Vector3();

	const _morphA = /*@__PURE__*/new Vector3();

	const _morphB = /*@__PURE__*/new Vector3();

	const _morphC = /*@__PURE__*/new Vector3();

	const _uvA$1 = /*@__PURE__*/new Vector2();

	const _uvB$1 = /*@__PURE__*/new Vector2();

	const _uvC$1 = /*@__PURE__*/new Vector2();

	const _intersectionPoint = /*@__PURE__*/new Vector3();

	const _intersectionPointWorld = /*@__PURE__*/new Vector3();

	class Mesh extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
			super();
			this.type = 'Mesh';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);

			if (source.morphTargetInfluences !== undefined) {
				this.morphTargetInfluences = source.morphTargetInfluences.slice();
			}

			if (source.morphTargetDictionary !== undefined) {
				this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
			}

			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;
			if (material === undefined) return; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$3.copy(geometry.boundingSphere);

			_sphere$3.applyMatrix4(matrixWorld);

			if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

			_inverseMatrix$2.copy(matrixWorld).invert();

			_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing


			if (geometry.boundingBox !== null) {
				if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
			}

			let intersection;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const position = geometry.attributes.position;
				const morphPosition = geometry.morphAttributes.position;
				const morphTargetsRelative = geometry.morphTargetsRelative;
				const uv = geometry.attributes.uv;
				const uv2 = geometry.attributes.uv2;
				const groups = geometry.groups;
				const drawRange = geometry.drawRange;

				if (index !== null) {
					// indexed buffer geometry
					if (Array.isArray(material)) {
						for (let i = 0, il = groups.length; i < il; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							const start = Math.max(group.start, drawRange.start);
							const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

							for (let j = start, jl = end; j < jl; j += 3) {
								const a = index.getX(j);
								const b = index.getX(j + 1);
								const c = index.getX(j + 2);
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						const start = Math.max(0, drawRange.start);
						const end = Math.min(index.count, drawRange.start + drawRange.count);

						for (let i = start, il = end; i < il; i += 3) {
							const a = index.getX(i);
							const b = index.getX(i + 1);
							const c = index.getX(i + 2);
							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

							if (intersection) {
								intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				} else if (position !== undefined) {
					// non-indexed buffer geometry
					if (Array.isArray(material)) {
						for (let i = 0, il = groups.length; i < il; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							const start = Math.max(group.start, drawRange.start);
							const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

							for (let j = start, jl = end; j < jl; j += 3) {
								const a = j;
								const b = j + 1;
								const c = j + 2;
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						const start = Math.max(0, drawRange.start);
						const end = Math.min(position.count, drawRange.start + drawRange.count);

						for (let i = start, il = end; i < il; i += 3) {
							const a = i;
							const b = i + 1;
							const c = i + 2;
							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

							if (intersection) {
								intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

	}

	Mesh.prototype.isMesh = true;

	function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
		let intersect;

		if (material.side === BackSide) {
			intersect = ray.intersectTriangle(pC, pB, pA, true, point);
		} else {
			intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
		}

		if (intersect === null) return null;

		_intersectionPointWorld.copy(point);

		_intersectionPointWorld.applyMatrix4(object.matrixWorld);

		const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
		if (distance < raycaster.near || distance > raycaster.far) return null;
		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};
	}

	function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
		_vA$1.fromBufferAttribute(position, a);

		_vB$1.fromBufferAttribute(position, b);

		_vC$1.fromBufferAttribute(position, c);

		const morphInfluences = object.morphTargetInfluences;

		if (morphPosition && morphInfluences) {
			_morphA.set(0, 0, 0);

			_morphB.set(0, 0, 0);

			_morphC.set(0, 0, 0);

			for (let i = 0, il = morphPosition.length; i < il; i++) {
				const influence = morphInfluences[i];
				const morphAttribute = morphPosition[i];
				if (influence === 0) continue;

				_tempA.fromBufferAttribute(morphAttribute, a);

				_tempB.fromBufferAttribute(morphAttribute, b);

				_tempC.fromBufferAttribute(morphAttribute, c);

				if (morphTargetsRelative) {
					_morphA.addScaledVector(_tempA, influence);

					_morphB.addScaledVector(_tempB, influence);

					_morphC.addScaledVector(_tempC, influence);
				} else {
					_morphA.addScaledVector(_tempA.sub(_vA$1), influence);

					_morphB.addScaledVector(_tempB.sub(_vB$1), influence);

					_morphC.addScaledVector(_tempC.sub(_vC$1), influence);
				}
			}

			_vA$1.add(_morphA);

			_vB$1.add(_morphB);

			_vC$1.add(_morphC);
		}

		if (object.isSkinnedMesh) {
			object.boneTransform(a, _vA$1);
			object.boneTransform(b, _vB$1);
			object.boneTransform(c, _vC$1);
		}

		const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);

		if (intersection) {
			if (uv) {
				_uvA$1.fromBufferAttribute(uv, a);

				_uvB$1.fromBufferAttribute(uv, b);

				_uvC$1.fromBufferAttribute(uv, c);

				intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}

			if (uv2) {
				_uvA$1.fromBufferAttribute(uv2, a);

				_uvB$1.fromBufferAttribute(uv2, b);

				_uvC$1.fromBufferAttribute(uv2, c);

				intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};
			Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
			intersection.face = face;
		}

		return intersection;
	}

	class BoxGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
			super();
			this.type = 'BoxGeometry';
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
			const scope = this; // segments

			widthSegments = Math.floor(widthSegments);
			heightSegments = Math.floor(heightSegments);
			depthSegments = Math.floor(depthSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let numberOfVertices = 0;
			let groupStart = 0; // build each side of the box geometry

			buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

			buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

			buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

			buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

			buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

			buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
			// build geometry

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;
				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;
				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;
				let vertexCounter = 0;
				let groupCount = 0;
				const vector = new Vector3(); // generate vertices, normals and uvs

				for (let iy = 0; iy < gridY1; iy++) {
					const y = iy * segmentHeight - heightHalf;

					for (let ix = 0; ix < gridX1; ix++) {
						const x = ix * segmentWidth - widthHalf; // set values to correct vector component

						vector[u] = x * udir;
						vector[v] = y * vdir;
						vector[w] = depthHalf; // now apply vector to vertex buffer

						vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

						vector[u] = 0;
						vector[v] = 0;
						vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

						normals.push(vector.x, vector.y, vector.z); // uvs

						uvs.push(ix / gridX);
						uvs.push(1 - iy / gridY); // counters

						vertexCounter += 1;
					}
				} // indices
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment


				for (let iy = 0; iy < gridY; iy++) {
					for (let ix = 0; ix < gridX; ix++) {
						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * (iy + 1);
						const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
						const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // increase counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

				groupStart += groupCount; // update total number of vertices

				numberOfVertices += vertexCounter;
			}
		}

		static fromJSON(data) {
			return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
		}

	}

	/**
	 * Uniform Utilities
	 */
	function cloneUniforms(src) {
		const dst = {};

		for (const u in src) {
			dst[u] = {};

			for (const p in src[u]) {
				const property = src[u][p];

				if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
					dst[u][p] = property.clone();
				} else if (Array.isArray(property)) {
					dst[u][p] = property.slice();
				} else {
					dst[u][p] = property;
				}
			}
		}

		return dst;
	}
	function mergeUniforms(uniforms) {
		const merged = {};

		for (let u = 0; u < uniforms.length; u++) {
			const tmp = cloneUniforms(uniforms[u]);

			for (const p in tmp) {
				merged[p] = tmp[p];
			}
		}

		return merged;
	} // Legacy

	const UniformsUtils = {
		clone: cloneUniforms,
		merge: mergeUniforms
	};

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * parameters = {
	 *	defines: { "label" : "value" },
	 *	uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *	fragmentShader: <string>,
	 *	vertexShader: <string>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	lights: <bool>
	 * }
	 */

	class ShaderMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'ShaderMaterial';
			this.defines = {};
			this.uniforms = {};
			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;
			this.linewidth = 1;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false; // set to use scene fog

			this.lights = false; // set to use scene lights

			this.clipping = false; // set to use user-defined clipping planes

			this.extensions = {
				derivatives: false,
				// set to use derivatives
				fragDepth: false,
				// set to use fragment depth values
				drawBuffers: false,
				// set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD

			}; // When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.

			this.defaultAttributeValues = {
				'color': [1, 1, 1],
				'uv': [0, 0],
				'uv2': [0, 0]
			};
			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;
			this.glslVersion = null;

			if (parameters !== undefined) {
				if (parameters.attributes !== undefined) {
					console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
				}

				this.setValues(parameters);
			}
		}

		copy(source) {
			super.copy(source);
			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
			this.uniforms = cloneUniforms(source.uniforms);
			this.defines = Object.assign({}, source.defines);
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.lights = source.lights;
			this.clipping = source.clipping;
			this.extensions = Object.assign({}, source.extensions);
			this.glslVersion = source.glslVersion;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for (const name in this.uniforms) {
				const uniform = this.uniforms[name];
				const value = uniform.value;

				if (value && value.isTexture) {
					data.uniforms[name] = {
						type: 't',
						value: value.toJSON(meta).uuid
					};
				} else if (value && value.isColor) {
					data.uniforms[name] = {
						type: 'c',
						value: value.getHex()
					};
				} else if (value && value.isVector2) {
					data.uniforms[name] = {
						type: 'v2',
						value: value.toArray()
					};
				} else if (value && value.isVector3) {
					data.uniforms[name] = {
						type: 'v3',
						value: value.toArray()
					};
				} else if (value && value.isVector4) {
					data.uniforms[name] = {
						type: 'v4',
						value: value.toArray()
					};
				} else if (value && value.isMatrix3) {
					data.uniforms[name] = {
						type: 'm3',
						value: value.toArray()
					};
				} else if (value && value.isMatrix4) {
					data.uniforms[name] = {
						type: 'm4',
						value: value.toArray()
					};
				} else {
					data.uniforms[name] = {
						value: value
					}; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
				}
			}

			if (Object.keys(this.defines).length > 0) data.defines = this.defines;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
			const extensions = {};

			for (const key in this.extensions) {
				if (this.extensions[key] === true) extensions[key] = true;
			}

			if (Object.keys(extensions).length > 0) data.extensions = extensions;
			return data;
		}

	}

	ShaderMaterial.prototype.isShaderMaterial = true;

	class Camera extends Object3D {
		constructor() {
			super();
			this.type = 'Camera';
			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.matrixWorldInverse.copy(source.matrixWorldInverse);
			this.projectionMatrix.copy(source.projectionMatrix);
			this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
			return this;
		}

		getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(-e[8], -e[9], -e[10]).normalize();
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}

		updateWorldMatrix(updateParents, updateChildren) {
			super.updateWorldMatrix(updateParents, updateChildren);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	Camera.prototype.isCamera = true;

	class PerspectiveCamera extends Camera {
		constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
			super();
			this.type = 'PerspectiveCamera';
			this.fov = fov;
			this.zoom = 1;
			this.near = near;
			this.far = far;
			this.focus = 10;
			this.aspect = aspect;
			this.view = null;
			this.filmGauge = 35; // width of the film (default in millimeters)

			this.filmOffset = 0; // horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.fov = source.fov;
			this.zoom = source.zoom;
			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
			return this;
		}
		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */


		setFocalLength(focalLength) {
			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
			this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
			this.updateProjectionMatrix();
		}
		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */


		getFocalLength() {
			const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
			return 0.5 * this.getFilmHeight() / vExtentSlope;
		}

		getEffectiveFOV() {
			return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
		}

		getFilmWidth() {
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1);
		}

		getFilmHeight() {
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1);
		}
		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *	 +---+---+---+
		 *	 | A | B | C |
		 *	 +---+---+---+
		 *	 | D | E | F |
		 *	 +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *	 const w = 1920;
		 *	 const h = 1080;
		 *	 const fullWidth = w * 3;
		 *	 const fullHeight = h * 2;
		 *
		 *	 --A--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *	 --B--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *	 --C--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *	 --D--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *	 --E--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *	 --F--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *	 Note there is no reason monitors have to be the same size or in a grid.
		 */


		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			this.aspect = fullWidth / fullHeight;

			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		}

		updateProjectionMatrix() {
			const near = this.near;
			let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = -0.5 * width;
			const view = this.view;

			if (this.view !== null && this.view.enabled) {
				const fullWidth = view.fullWidth,
							fullHeight = view.fullHeight;
				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
			}

			const skew = this.filmOffset;
			if (skew !== 0) left += near * skew / this.getFilmWidth();
			this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
			data.object.aspect = this.aspect;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
			return data;
		}

	}

	PerspectiveCamera.prototype.isPerspectiveCamera = true;

	const fov = 90,
				aspect = 1;

	class CubeCamera extends Object3D {
		constructor(near, far, renderTarget) {
			super();
			this.type = 'CubeCamera';

			if (renderTarget.isWebGLCubeRenderTarget !== true) {
				console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
				return;
			}

			this.renderTarget = renderTarget;
			const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
			cameraPX.layers = this.layers;
			cameraPX.up.set(0, -1, 0);
			cameraPX.lookAt(new Vector3(1, 0, 0));
			this.add(cameraPX);
			const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
			cameraNX.layers = this.layers;
			cameraNX.up.set(0, -1, 0);
			cameraNX.lookAt(new Vector3(-1, 0, 0));
			this.add(cameraNX);
			const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
			cameraPY.layers = this.layers;
			cameraPY.up.set(0, 0, 1);
			cameraPY.lookAt(new Vector3(0, 1, 0));
			this.add(cameraPY);
			const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
			cameraNY.layers = this.layers;
			cameraNY.up.set(0, 0, -1);
			cameraNY.lookAt(new Vector3(0, -1, 0));
			this.add(cameraNY);
			const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraPZ.layers = this.layers;
			cameraPZ.up.set(0, -1, 0);
			cameraPZ.lookAt(new Vector3(0, 0, 1));
			this.add(cameraPZ);
			const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraNZ.layers = this.layers;
			cameraNZ.up.set(0, -1, 0);
			cameraNZ.lookAt(new Vector3(0, 0, -1));
			this.add(cameraNZ);
		}

		update(renderer, scene) {
			if (this.parent === null) this.updateMatrixWorld();
			const renderTarget = this.renderTarget;
			const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
			const currentXrEnabled = renderer.xr.enabled;
			const currentRenderTarget = renderer.getRenderTarget();
			renderer.xr.enabled = false;
			const generateMipmaps = renderTarget.texture.generateMipmaps;
			renderTarget.texture.generateMipmaps = false;
			renderer.setRenderTarget(renderTarget, 0);
			renderer.render(scene, cameraPX);
			renderer.setRenderTarget(renderTarget, 1);
			renderer.render(scene, cameraNX);
			renderer.setRenderTarget(renderTarget, 2);
			renderer.render(scene, cameraPY);
			renderer.setRenderTarget(renderTarget, 3);
			renderer.render(scene, cameraNY);
			renderer.setRenderTarget(renderTarget, 4);
			renderer.render(scene, cameraPZ);
			renderTarget.texture.generateMipmaps = generateMipmaps;
			renderer.setRenderTarget(renderTarget, 5);
			renderer.render(scene, cameraNZ);
			renderer.setRenderTarget(currentRenderTarget);
			renderer.xr.enabled = currentXrEnabled;
		}

	}

	class CubeTexture extends Texture {
		constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
			format = format !== undefined ? format : RGBFormat;
			super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.flipY = false;
		}

		get images() {
			return this.image;
		}

		set images(value) {
			this.image = value;
		}

	}

	CubeTexture.prototype.isCubeTexture = true;

	class WebGLCubeRenderTarget extends WebGLRenderTarget {
		constructor(size, options, dummy) {
			if (Number.isInteger(options)) {
				console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
				options = dummy;
			}

			super(size, size, options);
			options = options || {}; // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			this.texture.isRenderTargetTexture = true;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			this.texture._needsFlipEnvMap = false;
		}

		fromEquirectangularTexture(renderer, texture) {
			this.texture.type = texture.type;
			this.texture.format = RGBAFormat; // see #18859

			this.texture.encoding = texture.encoding;
			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;
			const shader = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader:
				/* glsl */
				`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
				fragmentShader:
				/* glsl */
				`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};
			const geometry = new BoxGeometry(5, 5, 5);
			const material = new ShaderMaterial({
				name: 'CubemapFromEquirect',
				uniforms: cloneUniforms(shader.uniforms),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending
			});
			material.uniforms.tEquirect.value = texture;
			const mesh = new Mesh(geometry, material);
			const currentMinFilter = texture.minFilter; // Avoid blurred poles

			if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
			const camera = new CubeCamera(1, 10, this);
			camera.update(renderer, mesh);
			texture.minFilter = currentMinFilter;
			mesh.geometry.dispose();
			mesh.material.dispose();
			return this;
		}

		clear(renderer, color, depth, stencil) {
			const currentRenderTarget = renderer.getRenderTarget();

			for (let i = 0; i < 6; i++) {
				renderer.setRenderTarget(this, i);
				renderer.clear(color, depth, stencil);
			}

			renderer.setRenderTarget(currentRenderTarget);
		}

	}

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

	const _vector1 = /*@__PURE__*/new Vector3();

	const _vector2 = /*@__PURE__*/new Vector3();

	const _normalMatrix = /*@__PURE__*/new Matrix3();

	class Plane {
		constructor(normal = new Vector3(1, 0, 0), constant = 0) {
			// normal is assumed to be normalized
			this.normal = normal;
			this.constant = constant;
		}

		set(normal, constant) {
			this.normal.copy(normal);
			this.constant = constant;
			return this;
		}

		setComponents(x, y, z, w) {
			this.normal.set(x, y, z);
			this.constant = w;
			return this;
		}

		setFromNormalAndCoplanarPoint(normal, point) {
			this.normal.copy(normal);
			this.constant = -point.dot(this.normal);
			return this;
		}

		setFromCoplanarPoints(a, b, c) {
			const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


			this.setFromNormalAndCoplanarPoint(normal, a);
			return this;
		}

		copy(plane) {
			this.normal.copy(plane.normal);
			this.constant = plane.constant;
			return this;
		}

		normalize() {
			// Note: will lead to a divide by zero if the plane is invalid.
			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar(inverseNormalLength);
			this.constant *= inverseNormalLength;
			return this;
		}

		negate() {
			this.constant *= -1;
			this.normal.negate();
			return this;
		}

		distanceToPoint(point) {
			return this.normal.dot(point) + this.constant;
		}

		distanceToSphere(sphere) {
			return this.distanceToPoint(sphere.center) - sphere.radius;
		}

		projectPoint(point, target) {
			return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
		}

		intersectLine(line, target) {
			const direction = line.delta(_vector1);
			const denominator = this.normal.dot(direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (this.distanceToPoint(line.start) === 0) {
					return target.copy(line.start);
				} // Unsure if this is the correct method to handle this case.


				return null;
			}

			const t = -(line.start.dot(this.normal) + this.constant) / denominator;

			if (t < 0 || t > 1) {
				return null;
			}

			return target.copy(direction).multiplyScalar(t).add(line.start);
		}

		intersectsLine(line) {
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
			const startSign = this.distanceToPoint(line.start);
			const endSign = this.distanceToPoint(line.end);
			return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
		}

		intersectsBox(box) {
			return box.intersectsPlane(this);
		}

		intersectsSphere(sphere) {
			return sphere.intersectsPlane(this);
		}

		coplanarPoint(target) {
			return target.copy(this.normal).multiplyScalar(-this.constant);
		}

		applyMatrix4(matrix, optionalNormalMatrix) {
			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

			const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
			const normal = this.normal.applyMatrix3(normalMatrix).normalize();
			this.constant = -referencePoint.dot(normal);
			return this;
		}

		translate(offset) {
			this.constant -= offset.dot(this.normal);
			return this;
		}

		equals(plane) {
			return plane.normal.equals(this.normal) && plane.constant === this.constant;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	Plane.prototype.isPlane = true;

	const _sphere$2 = /*@__PURE__*/new Sphere();

	const _vector$7 = /*@__PURE__*/new Vector3();

	class Frustum {
		constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
			this.planes = [p0, p1, p2, p3, p4, p5];
		}

		set(p0, p1, p2, p3, p4, p5) {
			const planes = this.planes;
			planes[0].copy(p0);
			planes[1].copy(p1);
			planes[2].copy(p2);
			planes[3].copy(p3);
			planes[4].copy(p4);
			planes[5].copy(p5);
			return this;
		}

		copy(frustum) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				planes[i].copy(frustum.planes[i]);
			}

			return this;
		}

		setFromProjectionMatrix(m) {
			const planes = this.planes;
			const me = m.elements;
			const me0 = me[0],
						me1 = me[1],
						me2 = me[2],
						me3 = me[3];
			const me4 = me[4],
						me5 = me[5],
						me6 = me[6],
						me7 = me[7];
			const me8 = me[8],
						me9 = me[9],
						me10 = me[10],
						me11 = me[11];
			const me12 = me[12],
						me13 = me[13],
						me14 = me[14],
						me15 = me[15];
			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
			return this;
		}

		intersectsObject(object) {
			const geometry = object.geometry;
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

			return this.intersectsSphere(_sphere$2);
		}

		intersectsSprite(sprite) {
			_sphere$2.center.set(0, 0, 0);

			_sphere$2.radius = 0.7071067811865476;

			_sphere$2.applyMatrix4(sprite.matrixWorld);

			return this.intersectsSphere(_sphere$2);
		}

		intersectsSphere(sphere) {
			const planes = this.planes;
			const center = sphere.center;
			const negRadius = -sphere.radius;

			for (let i = 0; i < 6; i++) {
				const distance = planes[i].distanceToPoint(center);

				if (distance < negRadius) {
					return false;
				}
			}

			return true;
		}

		intersectsBox(box) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				const plane = planes[i]; // corner at max distance

				_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if (plane.distanceToPoint(_vector$7) < 0) {
					return false;
				}
			}

			return true;
		}

		containsPoint(point) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				if (planes[i].distanceToPoint(point) < 0) {
					return false;
				}
			}

			return true;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	function WebGLAnimation() {
		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame(time, frame) {
			animationLoop(time, frame);
			requestId = context.requestAnimationFrame(onAnimationFrame);
		}

		return {
			start: function () {
				if (isAnimating === true) return;
				if (animationLoop === null) return;
				requestId = context.requestAnimationFrame(onAnimationFrame);
				isAnimating = true;
			},
			stop: function () {
				context.cancelAnimationFrame(requestId);
				isAnimating = false;
			},
			setAnimationLoop: function (callback) {
				animationLoop = callback;
			},
			setContext: function (value) {
				context = value;
			}
		};
	}

	function WebGLAttributes(gl, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		const buffers = new WeakMap();

		function createBuffer(attribute, bufferType) {
			const array = attribute.array;
			const usage = attribute.usage;
			const buffer = gl.createBuffer();
			gl.bindBuffer(bufferType, buffer);
			gl.bufferData(bufferType, array, usage);
			attribute.onUploadCallback();
			let type = gl.FLOAT;

			if (array instanceof Float32Array) {
				type = gl.FLOAT;
			} else if (array instanceof Float64Array) {
				console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
			} else if (array instanceof Uint16Array) {
				if (attribute.isFloat16BufferAttribute) {
					if (isWebGL2) {
						type = gl.HALF_FLOAT;
					} else {
						console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
					}
				} else {
					type = gl.UNSIGNED_SHORT;
				}
			} else if (array instanceof Int16Array) {
				type = gl.SHORT;
			} else if (array instanceof Uint32Array) {
				type = gl.UNSIGNED_INT;
			} else if (array instanceof Int32Array) {
				type = gl.INT;
			} else if (array instanceof Int8Array) {
				type = gl.BYTE;
			} else if (array instanceof Uint8Array) {
				type = gl.UNSIGNED_BYTE;
			} else if (array instanceof Uint8ClampedArray) {
				type = gl.UNSIGNED_BYTE;
			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};
		}

		function updateBuffer(buffer, attribute, bufferType) {
			const array = attribute.array;
			const updateRange = attribute.updateRange;
			gl.bindBuffer(bufferType, buffer);

			if (updateRange.count === -1) {
				// Not using update ranges
				gl.bufferSubData(bufferType, 0, array);
			} else {
				if (isWebGL2) {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
				} else {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
				}

				updateRange.count = -1; // reset range
			}
		} //


		function get(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			return buffers.get(attribute);
		}

		function remove(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);

			if (data) {
				gl.deleteBuffer(data.buffer);
				buffers.delete(attribute);
			}
		}

		function update(attribute, bufferType) {
			if (attribute.isGLBufferAttribute) {
				const cached = buffers.get(attribute);

				if (!cached || cached.version < attribute.version) {
					buffers.set(attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					});
				}

				return;
			}

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);

			if (data === undefined) {
				buffers.set(attribute, createBuffer(attribute, bufferType));
			} else if (data.version < attribute.version) {
				updateBuffer(data.buffer, attribute, bufferType);
				data.version = attribute.version;
			}
		}

		return {
			get: get,
			remove: remove,
			update: update
		};
	}

	class PlaneGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
			super();
			this.type = 'PlaneGeometry';
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
			const width_half = width / 2;
			const height_half = height / 2;
			const gridX = Math.floor(widthSegments);
			const gridY = Math.floor(heightSegments);
			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;
			const segment_width = width / gridX;
			const segment_height = height / gridY; //

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for (let iy = 0; iy < gridY1; iy++) {
				const y = iy * segment_height - height_half;

				for (let ix = 0; ix < gridX1; ix++) {
					const x = ix * segment_width - width_half;
					vertices.push(x, -y, 0);
					normals.push(0, 0, 1);
					uvs.push(ix / gridX);
					uvs.push(1 - iy / gridY);
				}
			}

			for (let iy = 0; iy < gridY; iy++) {
				for (let ix = 0; ix < gridX; ix++) {
					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * (iy + 1);
					const c = ix + 1 + gridX1 * (iy + 1);
					const d = ix + 1 + gridX1 * iy;
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
		}

	}

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif";

	var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t\t#ifdef USE_TANGENT\n\t\t\tvTangent = normalize( transformedTangent );\n\t\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t\t#endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,
		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshtoon_frag: meshtoon_frag,
		meshtoon_vert: meshtoon_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {
		common: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			map: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			},
			uv2Transform: {
				value: new Matrix3()
			},
			alphaMap: {
				value: null
			}
		},
		specularmap: {
			specularMap: {
				value: null
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1.0
			},
			refractionRatio: {
				value: 0.98
			},
			maxMipLevel: {
				value: 0
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalScale: {
				value: new Vector2(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 0.00025
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2000
			},
			fogColor: {
				value: new Color(0xffffff)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotShadowMap: {
				value: []
			},
			spotShadowMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			size: {
				value: 1.0
			},
			scale: {
				value: 1.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			}
		},
		sprite: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			center: {
				value: new Vector2(0.5, 0.5)
			},
			rotation: {
				value: 0.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			}
		}
	};

	const ShaderLib = {
		basic: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},
		lambert: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},
		phong: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				specular: {
					value: new Color(0x111111)
				},
				shininess: {
					value: 30
				}
			}]),
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},
		standard: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				roughness: {
					value: 1.0
				},
				metalness: {
					value: 0.0
				},
				envMapIntensity: {
					value: 1
				} // temporary

			}]),
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},
		toon: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},
		matcap: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
				matcap: {
					value: null
				}
			}]),
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},
		points: {
			uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},
		dashed: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},
		depth: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},
		normal: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag
		},
		sprite: {
			uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new Matrix3()
				},
				t2D: {
					value: null
				}
			},
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
		cube: {
			uniforms: mergeUniforms([UniformsLib.envmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},
		distanceRGBA: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
				referencePosition: {
					value: new Vector3()
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1000
				}
			}]),
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},
		shadow: {
			uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
				color: {
					value: new Color(0x00000)
				},
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	};
	ShaderLib.physical = {
		uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
			clearcoat: {
				value: 0
			},
			clearcoatMap: {
				value: null
			},
			clearcoatRoughness: {
				value: 0
			},
			clearcoatRoughnessMap: {
				value: null
			},
			clearcoatNormalScale: {
				value: new Vector2(1, 1)
			},
			clearcoatNormalMap: {
				value: null
			},
			sheen: {
				value: new Color(0x000000)
			},
			transmission: {
				value: 0
			},
			transmissionMap: {
				value: null
			},
			transmissionSamplerSize: {
				value: new Vector2()
			},
			transmissionSamplerMap: {
				value: null
			},
			thickness: {
				value: 0
			},
			thicknessMap: {
				value: null
			},
			attenuationDistance: {
				value: 0
			},
			attenuationTint: {
				value: new Color(0x000000)
			},
			specularIntensity: {
				value: 0
			},
			specularIntensityMap: {
				value: null
			},
			specularTint: {
				value: new Color(1, 1, 1)
			},
			specularTintMap: {
				value: null
			}
		}]),
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	};

	function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
		const clearColor = new Color(0x000000);
		let clearAlpha = 0;
		let planeMesh;
		let boxMesh;
		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render(renderList, scene) {
			let forceClear = false;
			let background = scene.isScene === true ? scene.background : null;

			if (background && background.isTexture) {
				background = cubemaps.get(background);
			} // Ignore background in AR
			// TODO: Reconsider this.


			const xr = renderer.xr;
			const session = xr.getSession && xr.getSession();

			if (session && session.environmentBlendMode === 'additive') {
				background = null;
			}

			if (background === null) {
				setClear(clearColor, clearAlpha);
			} else if (background && background.isColor) {
				setClear(background, 1);
				forceClear = true;
			}

			if (renderer.autoClear || forceClear) {
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			}

			if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
				if (boxMesh === undefined) {
					boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms(ShaderLib.cube.uniforms),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					boxMesh.geometry.deleteAttribute('normal');
					boxMesh.geometry.deleteAttribute('uv');

					boxMesh.onBeforeRender = function (renderer, scene, camera) {
						this.matrixWorld.copyPosition(camera.matrixWorld);
					}; // enable code injection for non-built-in material


					Object.defineProperty(boxMesh.material, 'envMap', {
						get: function () {
							return this.uniforms.envMap.value;
						}
					});
					objects.update(boxMesh);
				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					boxMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
			} else if (background && background.isTexture) {
				if (planeMesh === undefined) {
					planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms(ShaderLib.background.uniforms),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

					Object.defineProperty(planeMesh.material, 'map', {
						get: function () {
							return this.uniforms.t2D.value;
						}
					});
					objects.update(planeMesh);
				}

				planeMesh.material.uniforms.t2D.value = background;

				if (background.matrixAutoUpdate === true) {
					background.updateMatrix();
				}

				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					planeMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
			}
		}

		function setClear(color, alpha) {
			state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
		}

		return {
			getClearColor: function () {
				return clearColor;
			},
			setClearColor: function (color, alpha = 1) {
				clearColor.set(color);
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			getClearAlpha: function () {
				return clearAlpha;
			},
			setClearAlpha: function (alpha) {
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			render: render
		};
	}

	function WebGLBindingStates(gl, extensions, attributes, capabilities) {
		const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;
		const bindingStates = {};
		const defaultState = createBindingState(null);
		let currentState = defaultState;

		function setup(object, material, program, geometry, index) {
			let updateBuffers = false;

			if (vaoAvailable) {
				const state = getBindingState(geometry, program, material);

				if (currentState !== state) {
					currentState = state;
					bindVertexArrayObject(currentState.object);
				}

				updateBuffers = needsUpdate(geometry, index);
				if (updateBuffers) saveCache(geometry, index);
			} else {
				const wireframe = material.wireframe === true;

				if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;
					updateBuffers = true;
				}
			}

			if (object.isInstancedMesh === true) {
				updateBuffers = true;
			}

			if (index !== null) {
				attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
			}

			if (updateBuffers) {
				setupVertexAttributes(object, material, program, geometry);

				if (index !== null) {
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
				}
			}
		}

		function createVertexArrayObject() {
			if (capabilities.isWebGL2) return gl.createVertexArray();
			return extension.createVertexArrayOES();
		}

		function bindVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
			return extension.bindVertexArrayOES(vao);
		}

		function deleteVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
			return extension.deleteVertexArrayOES(vao);
		}

		function getBindingState(geometry, program, material) {
			const wireframe = material.wireframe === true;
			let programMap = bindingStates[geometry.id];

			if (programMap === undefined) {
				programMap = {};
				bindingStates[geometry.id] = programMap;
			}

			let stateMap = programMap[program.id];

			if (stateMap === undefined) {
				stateMap = {};
				programMap[program.id] = stateMap;
			}

			let state = stateMap[wireframe];

			if (state === undefined) {
				state = createBindingState(createVertexArrayObject());
				stateMap[wireframe] = state;
			}

			return state;
		}

		function createBindingState(vao) {
			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for (let i = 0; i < maxVertexAttributes; i++) {
				newAttributes[i] = 0;
				enabledAttributes[i] = 0;
				attributeDivisors[i] = 0;
			}

			return {
				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,
				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null
			};
		}

		function needsUpdate(geometry, index) {
			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;
			let attributesNum = 0;

			for (const key in geometryAttributes) {
				const cachedAttribute = cachedAttributes[key];
				const geometryAttribute = geometryAttributes[key];
				if (cachedAttribute === undefined) return true;
				if (cachedAttribute.attribute !== geometryAttribute) return true;
				if (cachedAttribute.data !== geometryAttribute.data) return true;
				attributesNum++;
			}

			if (currentState.attributesNum !== attributesNum) return true;
			if (currentState.index !== index) return true;
			return false;
		}

		function saveCache(geometry, index) {
			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			for (const key in attributes) {
				const attribute = attributes[key];
				const data = {};
				data.attribute = attribute;

				if (attribute.data) {
					data.data = attribute.data;
				}

				cache[key] = data;
				attributesNum++;
			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;
			currentState.index = index;
		}

		function initAttributes() {
			const newAttributes = currentState.newAttributes;

			for (let i = 0, il = newAttributes.length; i < il; i++) {
				newAttributes[i] = 0;
			}
		}

		function enableAttribute(attribute) {
			enableAttributeAndDivisor(attribute, 0);
		}

		function enableAttributeAndDivisor(attribute, meshPerAttribute) {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;
			newAttributes[attribute] = 1;

			if (enabledAttributes[attribute] === 0) {
				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;
			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {
				const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
				extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
				attributeDivisors[attribute] = meshPerAttribute;
			}
		}

		function disableUnusedAttributes() {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for (let i = 0, il = enabledAttributes.length; i < il; i++) {
				if (enabledAttributes[i] !== newAttributes[i]) {
					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;
				}
			}
		}

		function vertexAttribPointer(index, size, type, normalized, stride, offset) {
			if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
				gl.vertexAttribIPointer(index, size, type, stride, offset);
			} else {
				gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
			}
		}

		function setupVertexAttributes(object, material, program, geometry) {
			if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
				if (extensions.get('ANGLE_instanced_arrays') === null) return;
			}

			initAttributes();
			const geometryAttributes = geometry.attributes;
			const programAttributes = program.getAttributes();
			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for (const name in programAttributes) {
				const programAttribute = programAttributes[name];

				if (programAttribute >= 0) {
					const geometryAttribute = geometryAttributes[name];

					if (geometryAttribute !== undefined) {
						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;
						const attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						if (geometryAttribute.isInterleavedBufferAttribute) {
							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if (data && data.isInstancedInterleavedBuffer) {
								enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

								if (geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = data.meshPerAttribute * data.count;
								}
							} else {
								enableAttribute(programAttribute);
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
							vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
						} else {
							if (geometryAttribute.isInstancedBufferAttribute) {
								enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

								if (geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
								}
							} else {
								enableAttribute(programAttribute);
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
							vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
						}
					} else if (name === 'instanceMatrix') {
						const attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						enableAttributeAndDivisor(programAttribute + 0, 1);
						enableAttributeAndDivisor(programAttribute + 1, 1);
						enableAttributeAndDivisor(programAttribute + 2, 1);
						enableAttributeAndDivisor(programAttribute + 3, 1);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
						gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
						gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
						gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
					} else if (name === 'instanceColor') {
						const attribute = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						enableAttributeAndDivisor(programAttribute, 1);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
					} else if (materialDefaultAttributeValues !== undefined) {
						const value = materialDefaultAttributeValues[name];

						if (value !== undefined) {
							switch (value.length) {
								case 2:
									gl.vertexAttrib2fv(programAttribute, value);
									break;

								case 3:
									gl.vertexAttrib3fv(programAttribute, value);
									break;

								case 4:
									gl.vertexAttrib4fv(programAttribute, value);
									break;

								default:
									gl.vertexAttrib1fv(programAttribute, value);
							}
						}
					}
				}
			}

			disableUnusedAttributes();
		}

		function dispose() {
			reset();

			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];

				for (const programId in programMap) {
					const stateMap = programMap[programId];

					for (const wireframe in stateMap) {
						deleteVertexArrayObject(stateMap[wireframe].object);
						delete stateMap[wireframe];
					}

					delete programMap[programId];
				}

				delete bindingStates[geometryId];
			}
		}

		function releaseStatesOfGeometry(geometry) {
			if (bindingStates[geometry.id] === undefined) return;
			const programMap = bindingStates[geometry.id];

			for (const programId in programMap) {
				const stateMap = programMap[programId];

				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[programId];
			}

			delete bindingStates[geometry.id];
		}

		function releaseStatesOfProgram(program) {
			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];
				if (programMap[program.id] === undefined) continue;
				const stateMap = programMap[program.id];

				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[program.id];
			}
		}

		function reset() {
			resetDefaultState();
			if (currentState === defaultState) return;
			currentState = defaultState;
			bindVertexArrayObject(currentState.object);
		} // for backward-compatilibity


		function resetDefaultState() {
			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;
		}

		return {
			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,
			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes
		};
	}

	function WebGLBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}

		function render(start, count) {
			gl.drawArrays(mode, start, count);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawArraysInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawArraysInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, start, count, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLCapabilities(gl, extensions, parameters) {
		let maxAnisotropy;

		function getMaxAnisotropy() {
			if (maxAnisotropy !== undefined) return maxAnisotropy;

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			} else {
				maxAnisotropy = 0;
			}

			return maxAnisotropy;
		}

		function getMaxPrecision(precision) {
			if (precision === 'highp') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
					return 'highp';
				}

				precision = 'mediump';
			}

			if (precision === 'mediump') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
					return 'mediump';
				}
			}

			return 'lowp';
		}
		/* eslint-disable no-undef */


		const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
		/* eslint-enable no-undef */

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision(precision);

		if (maxPrecision !== precision) {
			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
			precision = maxPrecision;
		}

		const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
		const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
		const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
		const floatVertexTextures = vertexTextures && floatFragmentTextures;
		const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
		return {
			isWebGL2: isWebGL2,
			drawBuffers: drawBuffers,
			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,
			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,
			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,
			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,
			maxSamples: maxSamples
		};
	}

	function WebGLClipping(properties) {
		const scope = this;
		let globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false;
		const plane = new Plane(),
					viewNormalMatrix = new Matrix3(),
					uniform = {
			value: null,
			needsUpdate: false
		};
		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function (planes, enableLocalClipping, camera) {
			const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 || localClippingEnabled;
			localClippingEnabled = enableLocalClipping;
			globalState = projectPlanes(planes, camera, 0);
			numGlobalPlanes = planes.length;
			return enabled;
		};

		this.beginShadows = function () {
			renderingShadows = true;
			projectPlanes(null);
		};

		this.endShadows = function () {
			renderingShadows = false;
			resetGlobalState();
		};

		this.setState = function (material, camera, useCache) {
			const planes = material.clippingPlanes,
						clipIntersection = material.clipIntersection,
						clipShadows = material.clipShadows;
			const materialProperties = properties.get(material);

			if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
				// there's no local clipping
				if (renderingShadows) {
					// there's no global clipping
					projectPlanes(null);
				} else {
					resetGlobalState();
				}
			} else {
				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
							lGlobal = nGlobal * 4;
				let dstArray = materialProperties.clippingState || null;
				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, useCache);

				for (let i = 0; i !== lGlobal; ++i) {
					dstArray[i] = globalState[i];
				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
			}
		};

		function resetGlobalState() {
			if (uniform.value !== globalState) {
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {
			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if (nPlanes !== 0) {
				dstArray = uniform.value;

				if (skipTransform !== true || dstArray === null) {
					const flatSize = dstOffset + nPlanes * 4,
								viewMatrix = camera.matrixWorldInverse;
					viewNormalMatrix.getNormalMatrix(viewMatrix);

					if (dstArray === null || dstArray.length < flatSize) {
						dstArray = new Float32Array(flatSize);
					}

					for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
						plane.normal.toArray(dstArray, i4);
						dstArray[i4 + 3] = plane.constant;
					}
				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;
			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;
			return dstArray;
		}
	}

	function WebGLCubeMaps(renderer) {
		let cubemaps = new WeakMap();

		function mapTextureMapping(texture, mapping) {
			if (mapping === EquirectangularReflectionMapping) {
				texture.mapping = CubeReflectionMapping;
			} else if (mapping === EquirectangularRefractionMapping) {
				texture.mapping = CubeRefractionMapping;
			}

			return texture;
		}

		function get(texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				const mapping = texture.mapping;

				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
					if (cubemaps.has(texture)) {
						const cubemap = cubemaps.get(texture).texture;
						return mapTextureMapping(cubemap, texture.mapping);
					} else {
						const image = texture.image;

						if (image && image.height > 0) {
							const currentRenderTarget = renderer.getRenderTarget();
							const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
							renderTarget.fromEquirectangularTexture(renderer, texture);
							cubemaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return mapTextureMapping(renderTarget.texture, texture.mapping);
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			const cubemap = cubemaps.get(texture);

			if (cubemap !== undefined) {
				cubemaps.delete(texture);
				cubemap.dispose();
			}
		}

		function dispose() {
			cubemaps = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	class OrthographicCamera extends Camera {
		constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
			super();
			this.type = 'OrthographicCamera';
			this.zoom = 1;
			this.view = null;
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			this.near = near;
			this.far = far;
			this.updateProjectionMatrix();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			return this;
		}

		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		}

		updateProjectionMatrix() {
			const dx = (this.right - this.left) / (2 * this.zoom);
			const dy = (this.top - this.bottom) / (2 * this.zoom);
			const cx = (this.right + this.left) / 2;
			const cy = (this.top + this.bottom) / 2;
			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if (this.view !== null && this.view.enabled) {
				const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
				const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;
			}

			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			return data;
		}

	}

	OrthographicCamera.prototype.isOrthographicCamera = true;

	class RawShaderMaterial extends ShaderMaterial {
		constructor(parameters) {
			super(parameters);
			this.type = 'RawShaderMaterial';
		}

	}

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	const LOD_MIN = 4;
	const LOD_MAX = 8;
	const SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.

	const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
	const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.

	const MAX_SAMPLES = 20;
	const ENCODINGS = {
		[LinearEncoding]: 0,
		[sRGBEncoding]: 1,
		[RGBEEncoding]: 2,
		[RGBM7Encoding]: 3,
		[RGBM16Encoding]: 4,
		[RGBDEncoding]: 5,
		[GammaEncoding]: 6
	};
	const backgroundMaterial = new MeshBasicMaterial({
		side: BackSide,
		depthWrite: false,
		depthTest: false
	});
	const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);

	const _flatCamera = /*@__PURE__*/new OrthographicCamera();

	const {
		_lodPlanes,
		_sizeLods,
		_sigmas
	} = /*@__PURE__*/_createPlanes();

	const _clearColor = /*@__PURE__*/new Color();

	let _oldTarget = null; // Golden Ratio

	const PHI = (1 + Math.sqrt(5)) / 2;
	const INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.

	const _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];
	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	function convertLinearToRGBE(color) {
		const maxComponent = Math.max(color.r, color.g, color.b);
		const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
		color.multiplyScalar(Math.pow(2.0, -fExp));
		const alpha = (fExp + 128.0) / 255.0;
		return alpha;
	}

	class PMREMGenerator {
		constructor(renderer) {
			this._renderer = renderer;
			this._pingPongRenderTarget = null;
			this._blurMaterial = _getBlurShader(MAX_SAMPLES);
			this._equirectShader = null;
			this._cubemapShader = null;

			this._compileMaterial(this._blurMaterial);
		}
		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */


		fromScene(scene, sigma = 0, near = 0.1, far = 100) {
			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = this._allocateTargets();

			this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

			if (sigma > 0) {
				this._blur(cubeUVRenderTarget, 0, 0, sigma);
			}

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}
		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */


		fromEquirectangular(equirectangular) {
			return this._fromTexture(equirectangular);
		}
		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */


		fromCubemap(cubemap) {
			return this._fromTexture(cubemap);
		}
		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */


		compileCubemapShader() {
			if (this._cubemapShader === null) {
				this._cubemapShader = _getCubemapShader();

				this._compileMaterial(this._cubemapShader);
			}
		}
		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */


		compileEquirectangularShader() {
			if (this._equirectShader === null) {
				this._equirectShader = _getEquirectShader();

				this._compileMaterial(this._equirectShader);
			}
		}
		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */


		dispose() {
			this._blurMaterial.dispose();

			if (this._cubemapShader !== null) this._cubemapShader.dispose();
			if (this._equirectShader !== null) this._equirectShader.dispose();

			for (let i = 0; i < _lodPlanes.length; i++) {
				_lodPlanes[i].dispose();
			}
		} // private interface


		_cleanup(outputTarget) {
			this._pingPongRenderTarget.dispose();

			this._renderer.setRenderTarget(_oldTarget);

			outputTarget.scissorTest = false;

			_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
		}

		_fromTexture(texture) {
			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = this._allocateTargets(texture);

			this._textureToCubeUV(texture, cubeUVRenderTarget);

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}

		_allocateTargets(texture) {
			// warning: null texture is valid
			const params = {
				magFilter: NearestFilter,
				minFilter: NearestFilter,
				generateMipmaps: false,
				type: UnsignedByteType,
				format: RGBEFormat,
				encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
				depthBuffer: false
			};

			const cubeUVRenderTarget = _createRenderTarget(params);

			cubeUVRenderTarget.depthBuffer = texture ? false : true;
			this._pingPongRenderTarget = _createRenderTarget(params);
			return cubeUVRenderTarget;
		}

		_compileMaterial(material) {
			const tmpMesh = new Mesh(_lodPlanes[0], material);

			this._renderer.compile(tmpMesh, _flatCamera);
		}

		_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
			const upSign = [1, -1, 1, 1, 1, 1];
			const forwardSign = [1, 1, 1, -1, -1, -1];
			const renderer = this._renderer;
			const originalAutoClear = renderer.autoClear;
			const outputEncoding = renderer.outputEncoding;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor(_clearColor);
			renderer.toneMapping = NoToneMapping;
			renderer.outputEncoding = LinearEncoding;
			renderer.autoClear = false;
			let useSolidColor = false;
			const background = scene.background;

			if (background) {
				if (background.isColor) {
					backgroundMaterial.color.copy(background).convertSRGBToLinear();
					scene.background = null;
					const alpha = convertLinearToRGBE(backgroundMaterial.color);
					backgroundMaterial.opacity = alpha;
					useSolidColor = true;
				}
			} else {
				backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
				const alpha = convertLinearToRGBE(backgroundMaterial.color);
				backgroundMaterial.opacity = alpha;
				useSolidColor = true;
			}

			for (let i = 0; i < 6; i++) {
				const col = i % 3;

				if (col == 0) {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(forwardSign[i], 0, 0);
				} else if (col == 1) {
					cubeCamera.up.set(0, 0, upSign[i]);
					cubeCamera.lookAt(0, forwardSign[i], 0);
				} else {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(0, 0, forwardSign[i]);
				}

				_setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);

				renderer.setRenderTarget(cubeUVRenderTarget);

				if (useSolidColor) {
					renderer.render(backgroundBox, cubeCamera);
				}

				renderer.render(scene, cubeCamera);
			}

			renderer.toneMapping = toneMapping;
			renderer.outputEncoding = outputEncoding;
			renderer.autoClear = originalAutoClear;
		}

		_textureToCubeUV(texture, cubeUVRenderTarget) {
			const renderer = this._renderer;

			if (texture.isCubeTexture) {
				if (this._cubemapShader == null) {
					this._cubemapShader = _getCubemapShader();
				}
			} else {
				if (this._equirectShader == null) {
					this._equirectShader = _getEquirectShader();
				}
			}

			const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
			const mesh = new Mesh(_lodPlanes[0], material);
			const uniforms = material.uniforms;
			uniforms['envMap'].value = texture;

			if (!texture.isCubeTexture) {
				uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
			}

			uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
			uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];

			_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

			renderer.setRenderTarget(cubeUVRenderTarget);
			renderer.render(mesh, _flatCamera);
		}

		_applyPMREM(cubeUVRenderTarget) {
			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for (let i = 1; i < TOTAL_LODS; i++) {
				const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
				const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

				this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
			}

			renderer.autoClear = autoClear;
		}
		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */


		_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
			const pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

			this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
		}

		_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;

			if (direction !== 'latitudinal' && direction !== 'longitudinal') {
				console.error('blur direction must be either latitudinal or longitudinal!');
			} // Number of standard deviations at which to cut off the discrete approximation.


			const STANDARD_DEVIATIONS = 3;
			const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
			const blurUniforms = blurMaterial.uniforms;
			const pixels = _sizeLods[lodIn] - 1;
			const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

			if (samples > MAX_SAMPLES) {
				console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
			}

			const weights = [];
			let sum = 0;

			for (let i = 0; i < MAX_SAMPLES; ++i) {
				const x = i / sigmaPixels;
				const weight = Math.exp(-x * x / 2);
				weights.push(weight);

				if (i == 0) {
					sum += weight;
				} else if (i < samples) {
					sum += 2 * weight;
				}
			}

			for (let i = 0; i < weights.length; i++) {
				weights[i] = weights[i] / sum;
			}

			blurUniforms['envMap'].value = targetIn.texture;
			blurUniforms['samples'].value = samples;
			blurUniforms['weights'].value = weights;
			blurUniforms['latitudinal'].value = direction === 'latitudinal';

			if (poleAxis) {
				blurUniforms['poleAxis'].value = poleAxis;
			}

			blurUniforms['dTheta'].value = radiansPerPixel;
			blurUniforms['mipInt'].value = LOD_MAX - lodIn;
			blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
			blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
			const outputSize = _sizeLods[lodOut];
			const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
			const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

			_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

			renderer.setRenderTarget(targetOut);
			renderer.render(blurMesh, _flatCamera);
		}

	}

	function _isLDR(texture) {
		if (texture === undefined || texture.type !== UnsignedByteType) return false;
		return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
	}

	function _createPlanes() {
		const _lodPlanes = [];
		const _sizeLods = [];
		const _sigmas = [];
		let lod = LOD_MAX;

		for (let i = 0; i < TOTAL_LODS; i++) {
			const sizeLod = Math.pow(2, lod);

			_sizeLods.push(sizeLod);

			let sigma = 1.0 / sizeLod;

			if (i > LOD_MAX - LOD_MIN) {
				sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
			} else if (i == 0) {
				sigma = 0;
			}

			_sigmas.push(sigma);

			const texelSize = 1.0 / (sizeLod - 1);
			const min = -texelSize / 2;
			const max = 1 + texelSize / 2;
			const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;
			const position = new Float32Array(positionSize * vertices * cubeFaces);
			const uv = new Float32Array(uvSize * vertices * cubeFaces);
			const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

			for (let face = 0; face < cubeFaces; face++) {
				const x = face % 3 * 2 / 3 - 1;
				const y = face > 2 ? 0 : -1;
				const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
				position.set(coordinates, positionSize * vertices * face);
				uv.set(uv1, uvSize * vertices * face);
				const fill = [face, face, face, face, face, face];
				faceIndex.set(fill, faceIndexSize * vertices * face);
			}

			const planes = new BufferGeometry();
			planes.setAttribute('position', new BufferAttribute(position, positionSize));
			planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
			planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

			_lodPlanes.push(planes);

			if (lod > LOD_MIN) {
				lod--;
			}
		}

		return {
			_lodPlanes,
			_sizeLods,
			_sigmas
		};
	}

	function _createRenderTarget(params) {
		const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;
	}

	function _setViewport(target, x, y, width, height) {
		target.viewport.set(x, y, width, height);
		target.scissor.set(x, y, width, height);
	}

	function _getBlurShader(maxSamples) {
		const weights = new Float32Array(maxSamples);
		const poleAxis = new Vector3(0, 1, 0);
		const shaderMaterial = new RawShaderMaterial({
			name: 'SphericalGaussianBlur',
			defines: {
				'n': maxSamples
			},
			uniforms: {
				'envMap': {
					value: null
				},
				'samples': {
					value: 1
				},
				'weights': {
					value: weights
				},
				'latitudinal': {
					value: false
				},
				'dTheta': {
					value: 0
				},
				'mipInt': {
					value: 0
				},
				'poleAxis': {
					value: poleAxis
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getEquirectShader() {
		const texelSize = new Vector2(1, 1);
		const shaderMaterial = new RawShaderMaterial({
			name: 'EquirectangularToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'texelSize': {
					value: texelSize
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCubemapShader() {
		const shaderMaterial = new RawShaderMaterial({
			name: 'CubemapToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCommonVertexShader() {
		return (
			/* glsl */
			`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
		);
	}

	function _getEncodings() {
		return (
			/* glsl */
			`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
		);
	}

	function WebGLCubeUVMaps(renderer) {
		let cubeUVmaps = new WeakMap();
		let pmremGenerator = null;

		function get(texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				const mapping = texture.mapping;
				const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
				const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;

				if (isEquirectMap || isCubeMap) {
					// equirect/cube map to cubeUV conversion
					if (cubeUVmaps.has(texture)) {
						return cubeUVmaps.get(texture).texture;
					} else {
						const image = texture.image;

						if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
							const currentRenderTarget = renderer.getRenderTarget();
							if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
							cubeUVmaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return renderTarget.texture;
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function isCubeTextureComplete(image) {
			let count = 0;
			const length = 6;

			for (let i = 0; i < length; i++) {
				if (image[i] !== undefined) count++;
			}

			return count === length;
		}

		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			const cubemapUV = cubeUVmaps.get(texture);

			if (cubemapUV !== undefined) {
				cubemapUV.delete(texture);
				cubemapUV.dispose();
			}
		}

		function dispose() {
			cubeUVmaps = new WeakMap();

			if (pmremGenerator !== null) {
				pmremGenerator.dispose();
				pmremGenerator = null;
			}
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function WebGLExtensions(gl) {
		const extensions = {};

		function getExtension(name) {
			if (extensions[name] !== undefined) {
				return extensions[name];
			}

			let extension;

			switch (name) {
				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
					break;

				default:
					extension = gl.getExtension(name);
			}

			extensions[name] = extension;
			return extension;
		}

		return {
			has: function (name) {
				return getExtension(name) !== null;
			},
			init: function (capabilities) {
				if (capabilities.isWebGL2) {
					getExtension('EXT_color_buffer_float');
				} else {
					getExtension('WEBGL_depth_texture');
					getExtension('OES_texture_float');
					getExtension('OES_texture_half_float');
					getExtension('OES_texture_half_float_linear');
					getExtension('OES_standard_derivatives');
					getExtension('OES_element_index_uint');
					getExtension('OES_vertex_array_object');
					getExtension('ANGLE_instanced_arrays');
				}

				getExtension('OES_texture_float_linear');
				getExtension('EXT_color_buffer_half_float');
			},
			get: function (name) {
				const extension = getExtension(name);

				if (extension === null) {
					console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
				}

				return extension;
			}
		};
	}

	function WebGLGeometries(gl, attributes, info, bindingStates) {
		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose(event) {
			const geometry = event.target;

			if (geometry.index !== null) {
				attributes.remove(geometry.index);
			}

			for (const name in geometry.attributes) {
				attributes.remove(geometry.attributes[name]);
			}

			geometry.removeEventListener('dispose', onGeometryDispose);
			delete geometries[geometry.id];
			const attribute = wireframeAttributes.get(geometry);

			if (attribute) {
				attributes.remove(attribute);
				wireframeAttributes.delete(geometry);
			}

			bindingStates.releaseStatesOfGeometry(geometry);

			if (geometry.isInstancedBufferGeometry === true) {
				delete geometry._maxInstanceCount;
			} //


			info.memory.geometries--;
		}

		function get(object, geometry) {
			if (geometries[geometry.id] === true) return geometry;
			geometry.addEventListener('dispose', onGeometryDispose);
			geometries[geometry.id] = true;
			info.memory.geometries++;
			return geometry;
		}

		function update(geometry) {
			const geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

			for (const name in geometryAttributes) {
				attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
			} // morph targets


			const morphAttributes = geometry.morphAttributes;

			for (const name in morphAttributes) {
				const array = morphAttributes[name];

				for (let i = 0, l = array.length; i < l; i++) {
					attributes.update(array[i], gl.ARRAY_BUFFER);
				}
			}
		}

		function updateWireframeAttribute(geometry) {
			const indices = [];
			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if (geometryIndex !== null) {
				const array = geometryIndex.array;
				version = geometryIndex.version;

				for (let i = 0, l = array.length; i < l; i += 3) {
					const a = array[i + 0];
					const b = array[i + 1];
					const c = array[i + 2];
					indices.push(a, b, b, c, c, a);
				}
			} else {
				const array = geometryPosition.array;
				version = geometryPosition.version;

				for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
					const a = i + 0;
					const b = i + 1;
					const c = i + 2;
					indices.push(a, b, b, c, c, a);
				}
			}

			const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
			attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
			//

			const previousAttribute = wireframeAttributes.get(geometry);
			if (previousAttribute) attributes.remove(previousAttribute); //

			wireframeAttributes.set(geometry, attribute);
		}

		function getWireframeAttribute(geometry) {
			const currentAttribute = wireframeAttributes.get(geometry);

			if (currentAttribute) {
				const geometryIndex = geometry.index;

				if (geometryIndex !== null) {
					// if the attribute is obsolete, create a new one
					if (currentAttribute.version < geometryIndex.version) {
						updateWireframeAttribute(geometry);
					}
				}
			} else {
				updateWireframeAttribute(geometry);
			}

			return wireframeAttributes.get(geometry);
		}

		return {
			get: get,
			update: update,
			getWireframeAttribute: getWireframeAttribute
		};
	}

	function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}

		let type, bytesPerElement;

		function setIndex(value) {
			type = value.type;
			bytesPerElement = value.bytesPerElement;
		}

		function render(start, count) {
			gl.drawElements(mode, count, type, start * bytesPerElement);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawElementsInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawElementsInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, count, type, start * bytesPerElement, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLInfo(gl) {
		const memory = {
			geometries: 0,
			textures: 0
		};
		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update(count, mode, instanceCount) {
			render.calls++;

			switch (mode) {
				case gl.TRIANGLES:
					render.triangles += instanceCount * (count / 3);
					break;

				case gl.LINES:
					render.lines += instanceCount * (count / 2);
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * (count - 1);
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
					break;
			}
		}

		function reset() {
			render.frame++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};
	}

	function numericalSort(a, b) {
		return a[0] - b[0];
	}

	function absNumericalSort(a, b) {
		return Math.abs(b[1]) - Math.abs(a[1]);
	}

	function WebGLMorphtargets(gl) {
		const influencesList = {};
		const morphInfluences = new Float32Array(8);
		const workInfluences = [];

		for (let i = 0; i < 8; i++) {
			workInfluences[i] = [i, 0];
		}

		function update(object, geometry, material, program) {
			const objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;
			let influences = influencesList[geometry.id];

			if (influences === undefined || influences.length !== length) {
				// initialise list
				influences = [];

				for (let i = 0; i < length; i++) {
					influences[i] = [i, 0];
				}

				influencesList[geometry.id] = influences;
			} // Collect influences


			for (let i = 0; i < length; i++) {
				const influence = influences[i];
				influence[0] = i;
				influence[1] = objectInfluences[i];
			}

			influences.sort(absNumericalSort);

			for (let i = 0; i < 8; i++) {
				if (i < length && influences[i][1]) {
					workInfluences[i][0] = influences[i][0];
					workInfluences[i][1] = influences[i][1];
				} else {
					workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
					workInfluences[i][1] = 0;
				}
			}

			workInfluences.sort(numericalSort);
			const morphTargets = geometry.morphAttributes.position;
			const morphNormals = geometry.morphAttributes.normal;
			let morphInfluencesSum = 0;

			for (let i = 0; i < 8; i++) {
				const influence = workInfluences[i];
				const index = influence[0];
				const value = influence[1];

				if (index !== Number.MAX_SAFE_INTEGER && value) {
					if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
						geometry.setAttribute('morphTarget' + i, morphTargets[index]);
					}

					if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
						geometry.setAttribute('morphNormal' + i, morphNormals[index]);
					}

					morphInfluences[i] = value;
					morphInfluencesSum += value;
				} else {
					if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
						geometry.deleteAttribute('morphTarget' + i);
					}

					if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
						geometry.deleteAttribute('morphNormal' + i);
					}

					morphInfluences[i] = 0;
				}
			} // GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
			program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
		}

		return {
			update: update
		};
	}

	function WebGLObjects(gl, geometries, attributes, info) {
		let updateMap = new WeakMap();

		function update(object) {
			const frame = info.render.frame;
			const geometry = object.geometry;
			const buffergeometry = geometries.get(object, geometry); // Update once per frame

			if (updateMap.get(buffergeometry) !== frame) {
				geometries.update(buffergeometry);
				updateMap.set(buffergeometry, frame);
			}

			if (object.isInstancedMesh) {
				if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
					object.addEventListener('dispose', onInstancedMeshDispose);
				}

				attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);

				if (object.instanceColor !== null) {
					attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
				}
			}

			return buffergeometry;
		}

		function dispose() {
			updateMap = new WeakMap();
		}

		function onInstancedMeshDispose(event) {
			const instancedMesh = event.target;
			instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
			attributes.remove(instancedMesh.instanceMatrix);
			if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
		}

		return {
			update: update,
			dispose: dispose
		};
	}

	class DataTexture2DArray extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			super(null);
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	class DataTexture3D extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839
			super(null);
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *		the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with	name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */
	const emptyTexture = new Texture();
	const emptyTexture2dArray = new DataTexture2DArray();
	const emptyTexture3d = new DataTexture3D();
	const emptyCubeTexture = new CubeTexture(); // --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array(16);
	const mat3array = new Float32Array(9);
	const mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

	function flatten(array, nBlocks, blockSize) {
		const firstElem = array[0];
		if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[n];

		if (r === undefined) {
			r = new Float32Array(n);
			arrayCacheF32[n] = r;
		}

		if (nBlocks !== 0) {
			firstElem.toArray(r, 0);

			for (let i = 1, offset = 0; i !== nBlocks; ++i) {
				offset += blockSize;
				array[i].toArray(r, offset);
			}
		}

		return r;
	}

	function arraysEqual(a, b) {
		if (a.length !== b.length) return false;

		for (let i = 0, l = a.length; i < l; i++) {
			if (a[i] !== b[i]) return false;
		}

		return true;
	}

	function copyArray(a, b) {
		for (let i = 0, l = b.length; i < l; i++) {
			a[i] = b[i];
		}
	} // Texture unit allocation


	function allocTexUnits(textures, n) {
		let r = arrayCacheI32[n];

		if (r === undefined) {
			r = new Int32Array(n);
			arrayCacheI32[n] = r;
		}

		for (let i = 0; i !== n; ++i) {
			r[i] = textures.allocateTextureUnit();
		}

		return r;
	} // --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar


	function setValueV1f(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1f(this.addr, v);
		cache[0] = v;
	} // Single float vector (from flat array or THREE.VectorN)


	function setValueV2f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2f(this.addr, v.x, v.y);
				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform2fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV3f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3f(this.addr, v.x, v.y, v.z);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else if (v.r !== undefined) {
			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
				gl.uniform3f(this.addr, v.r, v.g, v.b);
				cache[0] = v.r;
				cache[1] = v.g;
				cache[2] = v.b;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform3fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV4f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform4fv(this.addr, v);
			copyArray(cache, v);
		}
	} // Single matrix (from flat array or THREE.MatrixN)


	function setValueM2(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix2fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat2array.set(elements);
			gl.uniformMatrix2fv(this.addr, false, mat2array);
			copyArray(cache, elements);
		}
	}

	function setValueM3(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix3fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat3array.set(elements);
			gl.uniformMatrix3fv(this.addr, false, mat3array);
			copyArray(cache, elements);
		}
	}

	function setValueM4(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix4fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat4array.set(elements);
			gl.uniformMatrix4fv(this.addr, false, mat4array);
			copyArray(cache, elements);
		}
	} // Single integer / boolean


	function setValueV1i(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1i(this.addr, v);
		cache[0] = v;
	} // Single integer / boolean vector (from flat array)


	function setValueV2i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4iv(this.addr, v);
		copyArray(cache, v);
	} // Single unsigned integer


	function setValueV1ui(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1ui(this.addr, v);
		cache[0] = v;
	} // Single unsigned integer vector (from flat array)


	function setValueV2ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4uiv(this.addr, v);
		copyArray(cache, v);
	} // Single texture (2D / Cube)


	function setValueT1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTexture2D(v || emptyTexture, unit);
	}

	function setValueT3D1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture3D(v || emptyTexture3d, unit);
	}

	function setValueT6(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTextureCube(v || emptyCubeTexture, unit);
	}

	function setValueT2DArray1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture2DArray(v || emptyTexture2dArray, unit);
	} // Helper to pick the right setter for the singular case


	function getSingularSetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1f;
			// FLOAT

			case 0x8b50:
				return setValueV2f;
			// _VEC2

			case 0x8b51:
				return setValueV3f;
			// _VEC3

			case 0x8b52:
				return setValueV4f;
			// _VEC4

			case 0x8b5a:
				return setValueM2;
			// _MAT2

			case 0x8b5b:
				return setValueM3;
			// _MAT3

			case 0x8b5c:
				return setValueM4;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1i;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2i;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3i;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4i;
			// _VEC4

			case 0x1405:
				return setValueV1ui;
			// UINT

			case 0x8dc6:
				return setValueV2ui;
			// _VEC2

			case 0x8dc7:
				return setValueV3ui;
			// _VEC3

			case 0x8dc8:
				return setValueV4ui;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D

			case 0x8dcb: // INT_SAMPLER_3D

			case 0x8dd3:
				// UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY

			case 0x8dcf: // INT_SAMPLER_2D_ARRAY

			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

			case 0x8dc4:
				// SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;
		}
	} // Array of scalars


	function setValueV1fArray(gl, v) {
		gl.uniform1fv(this.addr, v);
	} // Array of vectors (from flat array or array of THREE.VectorN)


	function setValueV2fArray(gl, v) {
		const data = flatten(v, this.size, 2);
		gl.uniform2fv(this.addr, data);
	}

	function setValueV3fArray(gl, v) {
		const data = flatten(v, this.size, 3);
		gl.uniform3fv(this.addr, data);
	}

	function setValueV4fArray(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniform4fv(this.addr, data);
	} // Array of matrices (from flat array or array of THREE.MatrixN)


	function setValueM2Array(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniformMatrix2fv(this.addr, false, data);
	}

	function setValueM3Array(gl, v) {
		const data = flatten(v, this.size, 9);
		gl.uniformMatrix3fv(this.addr, false, data);
	}

	function setValueM4Array(gl, v) {
		const data = flatten(v, this.size, 16);
		gl.uniformMatrix4fv(this.addr, false, data);
	} // Array of integer / boolean


	function setValueV1iArray(gl, v) {
		gl.uniform1iv(this.addr, v);
	} // Array of integer / boolean vectors (from flat array)


	function setValueV2iArray(gl, v) {
		gl.uniform2iv(this.addr, v);
	}

	function setValueV3iArray(gl, v) {
		gl.uniform3iv(this.addr, v);
	}

	function setValueV4iArray(gl, v) {
		gl.uniform4iv(this.addr, v);
	} // Array of unsigned integer


	function setValueV1uiArray(gl, v) {
		gl.uniform1uiv(this.addr, v);
	} // Array of unsigned integer vectors (from flat array)


	function setValueV2uiArray(gl, v) {
		gl.uniform2uiv(this.addr, v);
	}

	function setValueV3uiArray(gl, v) {
		gl.uniform3uiv(this.addr, v);
	}

	function setValueV4uiArray(gl, v) {
		gl.uniform4uiv(this.addr, v);
	} // Array of textures (2D / Cube)


	function setValueT1Array(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
		}
	}

	function setValueT6Array(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
		}
	} // Helper to pick the right setter for a pure (bottom-level) array


	function getPureArraySetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1fArray;
			// FLOAT

			case 0x8b50:
				return setValueV2fArray;
			// _VEC2

			case 0x8b51:
				return setValueV3fArray;
			// _VEC3

			case 0x8b52:
				return setValueV4fArray;
			// _VEC4

			case 0x8b5a:
				return setValueM2Array;
			// _MAT2

			case 0x8b5b:
				return setValueM3Array;
			// _MAT3

			case 0x8b5c:
				return setValueM4Array;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1iArray;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2iArray;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3iArray;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4iArray;
			// _VEC4

			case 0x1405:
				return setValueV1uiArray;
			// UINT

			case 0x8dc6:
				return setValueV2uiArray;
			// _VEC2

			case 0x8dc7:
				return setValueV3uiArray;
			// _VEC3

			case 0x8dc8:
				return setValueV4uiArray;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6Array;
		}
	} // --- Uniform Classes ---


	function SingleUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	function PureArrayUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	PureArrayUniform.prototype.updateCache = function (data) {
		const cache = this.cache;

		if (data instanceof Float32Array && cache.length !== data.length) {
			this.cache = new Float32Array(data.length);
		}

		copyArray(cache, data);
	};

	function StructuredUniform(id) {
		this.id = id;
		this.seq = [];
		this.map = {};
	}

	StructuredUniform.prototype.setValue = function (gl, value, textures) {
		const seq = this.seq;

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			u.setValue(gl, value[u.id], textures);
		}
	}; // --- Top-level ---
	// Parser - builds up the property tree from the path strings


	const RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
	// 	- the identifier (member name or array index)
	//	- followed by an optional right bracket (found when array index)
	//	- followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform(container, uniformObject) {
		container.seq.push(uniformObject);
		container.map[uniformObject.id] = uniformObject;
	}

	function parseUniform(activeInfo, addr, container) {
		const path = activeInfo.name,
					pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

		RePathPart.lastIndex = 0;

		while (true) {
			const match = RePathPart.exec(path),
						matchEnd = RePathPart.lastIndex;
			let id = match[1];
			const idIsIndex = match[2] === ']',
						subscript = match[3];
			if (idIsIndex) id = id | 0; // convert to integer

			if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
				// bare name or "pure" bottom-level array "[0]" suffix
				addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
				break;
			} else {
				// step into inner node / create it in case it doesn't exist
				const map = container.map;
				let next = map[id];

				if (next === undefined) {
					next = new StructuredUniform(id);
					addUniform(container, next);
				}

				container = next;
			}
		}
	} // Root Container


	function WebGLUniforms(gl, program) {
		this.seq = [];
		this.map = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

		for (let i = 0; i < n; ++i) {
			const info = gl.getActiveUniform(program, i),
						addr = gl.getUniformLocation(program, info.name);
			parseUniform(info, addr, this);
		}
	}

	WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
		const u = this.map[name];
		if (u !== undefined) u.setValue(gl, value, textures);
	};

	WebGLUniforms.prototype.setOptional = function (gl, object, name) {
		const v = object[name];
		if (v !== undefined) this.setValue(gl, name, v);
	}; // Static interface


	WebGLUniforms.upload = function (gl, seq, values, textures) {
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i],
						v = values[u.id];

			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures);
			}
		}
	};

	WebGLUniforms.seqWithValue = function (seq, values) {
		const r = [];

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			if (u.id in values) r.push(u);
		}

		return r;
	};

	function WebGLShader(gl, type, string) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, string);
		gl.compileShader(shader);
		return shader;
	}

	let programIdCount = 0;

	function addLineNumbers(string) {
		const lines = string.split('\n');

		for (let i = 0; i < lines.length; i++) {
			lines[i] = i + 1 + ': ' + lines[i];
		}

		return lines.join('\n');
	}

	function getEncodingComponents(encoding) {
		switch (encoding) {
			case LinearEncoding:
				return ['Linear', '( value )'];

			case sRGBEncoding:
				return ['sRGB', '( value )'];

			case RGBEEncoding:
				return ['RGBE', '( value )'];

			case RGBM7Encoding:
				return ['RGBM', '( value, 7.0 )'];

			case RGBM16Encoding:
				return ['RGBM', '( value, 16.0 )'];

			case RGBDEncoding:
				return ['RGBD', '( value, 256.0 )'];

			case GammaEncoding:
				return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

			case LogLuvEncoding:
				return ['LogLuv', '( value )'];

			default:
				console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
				return ['Linear', '( value )'];
		}
	}

	function getShaderErrors(gl, shader, type) {
		const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		const log = gl.getShaderInfoLog(shader).trim();
		if (status && log === '') return ''; // --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const source = gl.getShaderSource(shader);
		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
	}

	function getTexelDecodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
	}

	function getTexelEncodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
	}

	function getToneMappingFunction(functionName, toneMapping) {
		let toneMappingName;

		switch (toneMapping) {
			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
				toneMappingName = 'Linear';
		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
	}

	function generateExtensions(parameters) {
		const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
		return chunks.filter(filterEmptyLine).join('\n');
	}

	function generateDefines(defines) {
		const chunks = [];

		for (const name in defines) {
			const value = defines[name];
			if (value === false) continue;
			chunks.push('#define ' + name + ' ' + value);
		}

		return chunks.join('\n');
	}

	function fetchAttributeLocations(gl, program) {
		const attributes = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

		for (let i = 0; i < n; i++) {
			const info = gl.getActiveAttrib(program, i);
			const name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[name] = gl.getAttribLocation(program, name);
		}

		return attributes;
	}

	function filterEmptyLine(string) {
		return string !== '';
	}

	function replaceLightNums(string, parameters) {
		return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
	}

	function replaceClippingPlaneNums(string, parameters) {
		return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
	} // Resolve Includes


	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes(string) {
		return string.replace(includePattern, includeReplacer);
	}

	function includeReplacer(match, include) {
		const string = ShaderChunk[include];

		if (string === undefined) {
			throw new Error('Can not resolve #include <' + include + '>');
		}

		return resolveIncludes(string);
	} // Unroll Loops


	const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops(string) {
		return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
	}

	function deprecatedLoopReplacer(match, start, end, snippet) {
		console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
		return loopReplacer(match, start, end, snippet);
	}

	function loopReplacer(match, start, end, snippet) {
		let string = '';

		for (let i = parseInt(start); i < parseInt(end); i++) {
			string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
		}

		return string;
	} //


	function generatePrecision(parameters) {
		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if (parameters.precision === 'highp') {
			precisionstring += '\n#define HIGH_PRECISION';
		} else if (parameters.precision === 'mediump') {
			precisionstring += '\n#define MEDIUM_PRECISION';
		} else if (parameters.precision === 'lowp') {
			precisionstring += '\n#define LOW_PRECISION';
		}

		return precisionstring;
	}

	function generateShadowMapTypeDefine(parameters) {
		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if (parameters.shadowMapType === PCFShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
		} else if (parameters.shadowMapType === PCFSoftShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
		} else if (parameters.shadowMapType === VSMShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
		}

		return shadowMapTypeDefine;
	}

	function generateEnvMapTypeDefine(parameters) {
		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;
			}
		}

		return envMapTypeDefine;
	}

	function generateEnvMapModeDefine(parameters) {
		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeRefractionMapping:
				case CubeUVRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;
			}
		}

		return envMapModeDefine;
	}

	function generateEnvMapBlendingDefine(parameters) {
		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if (parameters.envMap) {
			switch (parameters.combine) {
				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;
			}
		}

		return envMapBlendingDefine;
	}

	function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
		const gl = renderer.getContext();
		const defines = parameters.defines;
		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;
		const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
		const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
		const envMapModeDefine = generateEnvMapModeDefine(parameters);
		const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
		const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
		const customDefines = generateDefines(defines);
		const program = gl.createProgram();
		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if (parameters.isRawShaderMaterial) {
			prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

			if (prefixVertex.length > 0) {
				prefixVertex += '\n';
			}

			prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

			if (prefixFragment.length > 0) {
				prefixFragment += '\n';
			}
		} else {
			prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
			prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
			'#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
			parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.specularTintMap ? getTexelDecodingFunction('specularTintMapTexelToLinear', parameters.specularTintMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
		}

		vertexShader = resolveIncludes(vertexShader);
		vertexShader = replaceLightNums(vertexShader, parameters);
		vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
		fragmentShader = resolveIncludes(fragmentShader);
		fragmentShader = replaceLightNums(fragmentShader, parameters);
		fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
		vertexShader = unrollLoops(vertexShader);
		fragmentShader = unrollLoops(fragmentShader);

		if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
			// GLSL 3.0 conversion for built-in materials and ShaderMaterial
			versionString = '#version 300 es\n';
			prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
			prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
		const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
		gl.attachShader(program, glVertexShader);
		gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

		if (parameters.index0AttributeName !== undefined) {
			gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
		} else if (parameters.morphTargets === true) {
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position');
		}

		gl.linkProgram(program); // check for link errors

		if (renderer.debug.checkShaderErrors) {
			const programLog = gl.getProgramInfoLog(program).trim();
			const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
			const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
			let runnable = true;
			let haveDiagnostics = true;

			if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
				runnable = false;
				const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
				const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
				console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
			} else if (programLog !== '') {
				console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
			} else if (vertexLog === '' || fragmentLog === '') {
				haveDiagnostics = false;
			}

			if (haveDiagnostics) {
				this.diagnostics = {
					runnable: runnable,
					programLog: programLog,
					vertexShader: {
						log: vertexLog,
						prefix: prefixVertex
					},
					fragmentShader: {
						log: fragmentLog,
						prefix: prefixFragment
					}
				};
			}
		} // Clean up
		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );


		gl.deleteShader(glVertexShader);
		gl.deleteShader(glFragmentShader); // set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {
			if (cachedUniforms === undefined) {
				cachedUniforms = new WebGLUniforms(gl, program);
			}

			return cachedUniforms;
		}; // set up caching for attribute locations


		let cachedAttributes;

		this.getAttributes = function () {
			if (cachedAttributes === undefined) {
				cachedAttributes = fetchAttributeLocations(gl, program);
			}

			return cachedAttributes;
		}; // free resource


		this.destroy = function () {
			bindingStates.releaseStatesOfProgram(this);
			gl.deleteProgram(program);
			this.program = undefined;
		}; //


		this.name = parameters.shaderName;
		this.id = programIdCount++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;
		return this;
	}

	function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
		const programs = [];
		const isWebGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const floatVertexTextures = capabilities.floatVertexTextures;
		const maxVertexUniforms = capabilities.maxVertexUniforms;
		const vertexTextures = capabilities.vertexTextures;
		let precision = capabilities.precision;
		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};
		const parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'specularIntensityMap', 'specularTintMap', 'specularTintMapEncoding', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'];

		function getMaxBones(object) {
			const skeleton = object.skeleton;
			const bones = skeleton.bones;

			if (floatVertexTextures) {
				return 1024;
			} else {
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//	- leave some extra space for other uniforms
				//	- limit here is ANGLE's 254 max uniform vectors
				//		(up to 54 should be safe)
				const nVertexUniforms = maxVertexUniforms;
				const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
				const maxBones = Math.min(nVertexMatrices, bones.length);

				if (maxBones < bones.length) {
					console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
					return 0;
				}

				return maxBones;
			}
		}

		function getTextureEncodingFromMap(map) {
			let encoding;

			if (map && map.isTexture) {
				encoding = map.encoding;
			} else if (map && map.isWebGLRenderTarget) {
				console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
				encoding = map.texture.encoding;
			} else {
				encoding = LinearEncoding;
			}

			return encoding;
		}

		function getParameters(material, lights, shadows, scene, object) {
			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			const shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

			if (material.precision !== null) {
				precision = capabilities.getMaxPrecision(material.precision);

				if (precision !== material.precision) {
					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
				}
			}

			let vertexShader, fragmentShader;

			if (shaderID) {
				const shader = ShaderLib[shaderID];
				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;
			} else {
				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;
			}

			const currentRenderTarget = renderer.getRenderTarget();
			const parameters = {
				isWebGL2: isWebGL2,
				shaderID: shaderID,
				shaderName: material.type,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,
				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,
				precision: precision,
				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
				supportsVertexTextures: vertexTextures,
				outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map),
				matcap: !!material.matcap,
				matcapEncoding: getTextureEncodingFromMap(material.matcap),
				envMap: !!envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(envMap),
				envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
				lightMap: !!material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatMap: !!material.clearcoatMap,
				clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
				clearcoatNormalMap: !!material.clearcoatNormalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				specularIntensityMap: !!material.specularIntensityMap,
				specularTintMap: !!material.specularTintMap,
				specularTintMapEncoding: getTextureEncodingFromMap(material.specularTintMap),
				alphaMap: !!material.alphaMap,
				gradientMap: !!material.gradientMap,
				sheen: !!material.sheen,
				transmission: !!material.transmission,
				transmissionMap: !!material.transmissionMap,
				thicknessMap: !!material.thicknessMap,
				combine: material.combine,
				vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
				vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap,
				uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap) && !!material.displacementMap,
				fog: !!fog,
				useFog: material.fog,
				fogExp2: fog && fog.isFogExp2,
				flatShading: !!material.flatShading,
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
				skinning: object.isSkinnedMesh === true && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,
				morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
				morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,
				dithering: material.dithering,
				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,
				premultipliedAlpha: material.premultipliedAlpha,
				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,
				depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
				index0AttributeName: material.index0AttributeName,
				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
				rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
				customProgramCacheKey: material.customProgramCacheKey()
			};
			return parameters;
		}

		function getProgramCacheKey(parameters) {
			const array = [];

			if (parameters.shaderID) {
				array.push(parameters.shaderID);
			} else {
				array.push(parameters.fragmentShader);
				array.push(parameters.vertexShader);
			}

			if (parameters.defines !== undefined) {
				for (const name in parameters.defines) {
					array.push(name);
					array.push(parameters.defines[name]);
				}
			}

			if (parameters.isRawShaderMaterial === false) {
				for (let i = 0; i < parameterNames.length; i++) {
					array.push(parameters[parameterNames[i]]);
				}

				array.push(renderer.outputEncoding);
				array.push(renderer.gammaFactor);
			}

			array.push(parameters.customProgramCacheKey);
			return array.join();
		}

		function getUniforms(material) {
			const shaderID = shaderIDs[material.type];
			let uniforms;

			if (shaderID) {
				const shader = ShaderLib[shaderID];
				uniforms = UniformsUtils.clone(shader.uniforms);
			} else {
				uniforms = material.uniforms;
			}

			return uniforms;
		}

		function acquireProgram(parameters, cacheKey) {
			let program; // Check if code has been already compiled

			for (let p = 0, pl = programs.length; p < pl; p++) {
				const preexistingProgram = programs[p];

				if (preexistingProgram.cacheKey === cacheKey) {
					program = preexistingProgram;
					++program.usedTimes;
					break;
				}
			}

			if (program === undefined) {
				program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
				programs.push(program);
			}

			return program;
		}

		function releaseProgram(program) {
			if (--program.usedTimes === 0) {
				// Remove from unordered set
				const i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1];
				programs.pop(); // Free WebGL resources

				program.destroy();
			}
		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		};
	}

	function WebGLProperties() {
		let properties = new WeakMap();

		function get(object) {
			let map = properties.get(object);

			if (map === undefined) {
				map = {};
				properties.set(object, map);
			}

			return map;
		}

		function remove(object) {
			properties.delete(object);
		}

		function update(object, key, value) {
			properties.get(object)[key] = value;
		}

		function dispose() {
			properties = new WeakMap();
		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};
	}

	function painterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.program !== b.program) {
			return a.program.id - b.program.id;
		} else if (a.material.id !== b.material.id) {
			return a.material.id - b.material.id;
		} else if (a.z !== b.z) {
			return a.z - b.z;
		} else {
			return a.id - b.id;
		}
	}

	function reversePainterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.z !== b.z) {
			return b.z - a.z;
		} else {
			return a.id - b.id;
		}
	}

	function WebGLRenderList(properties) {
		const renderItems = [];
		let renderItemsIndex = 0;
		const opaque = [];
		const transmissive = [];
		const transparent = [];
		const defaultProgram = {
			id: -1
		};

		function init() {
			renderItemsIndex = 0;
			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;
		}

		function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
			let renderItem = renderItems[renderItemsIndex];
			const materialProperties = properties.get(material);

			if (renderItem === undefined) {
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};
				renderItems[renderItemsIndex] = renderItem;
			} else {
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = materialProperties.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
			}

			renderItemsIndex++;
			return renderItem;
		}

		function push(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

			if (material.transmission > 0.0) {
				transmissive.push(renderItem);
			} else if (material.transparent === true) {
				transparent.push(renderItem);
			} else {
				opaque.push(renderItem);
			}
		}

		function unshift(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

			if (material.transmission > 0.0) {
				transmissive.unshift(renderItem);
			} else if (material.transparent === true) {
				transparent.unshift(renderItem);
			} else {
				opaque.unshift(renderItem);
			}
		}

		function sort(customOpaqueSort, customTransparentSort) {
			if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
			if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
			if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
		}

		function finish() {
			// Clear references from inactive renderItems in the list
			for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
				const renderItem = renderItems[i];
				if (renderItem.id === null) break;
				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;
			}
		}

		return {
			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,
			init: init,
			push: push,
			unshift: unshift,
			finish: finish,
			sort: sort
		};
	}

	function WebGLRenderLists(properties) {
		let lists = new WeakMap();

		function get(scene, renderCallDepth) {
			let list;

			if (lists.has(scene) === false) {
				list = new WebGLRenderList(properties);
				lists.set(scene, [list]);
			} else {
				if (renderCallDepth >= lists.get(scene).length) {
					list = new WebGLRenderList(properties);
					lists.get(scene).push(list);
				} else {
					list = lists.get(scene)[renderCallDepth];
				}
			}

			return list;
		}

		function dispose() {
			lists = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function UniformsCache() {
		const lights = {};
		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				let uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	function ShadowUniformsCache() {
		const lights = {};
		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				let uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;
					// TODO (abelnation): set RectAreaLight shadow uniforms
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	let nextVersion = 0;

	function shadowCastingLightsFirst(lightA, lightB) {
		return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
	}

	function WebGLLights(extensions, capabilities) {
		const cache = new UniformsCache();
		const shadowCache = ShadowUniformsCache();
		const state = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
		};

		for (let i = 0; i < 9; i++) state.probe.push(new Vector3());

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup(lights) {
			let r = 0,
					g = 0,
					b = 0;

			for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;
			lights.sort(shadowCastingLightsFirst);

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];
				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;
				const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

				if (light.isAmbientLight) {
					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
				} else if (light.isLightProbe) {
					for (let j = 0; j < 9; j++) {
						state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
					}
				} else if (light.isDirectionalLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity);

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.directionalShadow[directionalLength] = shadowUniforms;
						state.directionalShadowMap[directionalLength] = shadowMap;
						state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
						numDirectionalShadows++;
					}

					state.directional[directionalLength] = uniforms;
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = cache.get(light);
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.distance = distance;
					uniforms.coneCos = Math.cos(light.angle);
					uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
					uniforms.decay = light.decay;

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.spotShadow[spotLength] = shadowUniforms;
						state.spotShadowMap[spotLength] = shadowMap;
						state.spotShadowMatrix[spotLength] = light.shadow.matrix;
						numSpotShadows++;
					}

					state.spot[spotLength] = uniforms;
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = cache.get(light); // (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
					// (b) intensity is the brightness of the light

					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					state.rectArea[rectAreaLength] = uniforms;
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity);
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;
						state.pointShadow[pointLength] = shadowUniforms;
						state.pointShadowMap[pointLength] = shadowMap;
						state.pointShadowMatrix[pointLength] = light.shadow.matrix;
						numPointShadows++;
					}

					state.point[pointLength] = uniforms;
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = cache.get(light);
					uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
					uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
					state.hemi[hemiLength] = uniforms;
					hemiLength++;
				}
			}

			if (rectAreaLength > 0) {
				if (capabilities.isWebGL2) {
					// WebGL 2
					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
				} else {
					// WebGL 1
					if (extensions.has('OES_texture_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
					} else if (extensions.has('OES_texture_half_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
					} else {
						console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
					}
				}
			}

			state.ambient[0] = r;
			state.ambient[1] = g;
			state.ambient[2] = b;
			const hash = state.hash;

			if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;
				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;
				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;
				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				state.version = nextVersion++;
			}
		}

		function setupView(lights, camera) {
			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			const viewMatrix = camera.matrixWorldInverse;

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];

				if (light.isDirectionalLight) {
					const uniforms = state.directional[directionalLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = state.spot[spotLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = state.rectArea[rectAreaLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

					matrix42.identity();
					matrix4.copy(light.matrixWorld);
					matrix4.premultiply(viewMatrix);
					matrix42.extractRotation(matrix4);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					uniforms.halfWidth.applyMatrix4(matrix42);
					uniforms.halfHeight.applyMatrix4(matrix42);
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = state.point[pointLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = state.hemi[hemiLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					uniforms.direction.transformDirection(viewMatrix);
					uniforms.direction.normalize();
					hemiLength++;
				}
			}
		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};
	}

	function WebGLRenderState(extensions, capabilities) {
		const lights = new WebGLLights(extensions, capabilities);
		const lightsArray = [];
		const shadowsArray = [];

		function init() {
			lightsArray.length = 0;
			shadowsArray.length = 0;
		}

		function pushLight(light) {
			lightsArray.push(light);
		}

		function pushShadow(shadowLight) {
			shadowsArray.push(shadowLight);
		}

		function setupLights() {
			lights.setup(lightsArray);
		}

		function setupLightsView(camera) {
			lights.setupView(lightsArray, camera);
		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			lights: lights
		};
		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,
			pushLight: pushLight,
			pushShadow: pushShadow
		};
	}

	function WebGLRenderStates(extensions, capabilities) {
		let renderStates = new WeakMap();

		function get(scene, renderCallDepth = 0) {
			let renderState;

			if (renderStates.has(scene) === false) {
				renderState = new WebGLRenderState(extensions, capabilities);
				renderStates.set(scene, [renderState]);
			} else {
				if (renderCallDepth >= renderStates.get(scene).length) {
					renderState = new WebGLRenderState(extensions, capabilities);
					renderStates.get(scene).push(renderState);
				} else {
					renderState = renderStates.get(scene)[renderCallDepth];
				}
			}

			return renderState;
		}

		function dispose() {
			renderStates = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	/**
	 * parameters = {
	 *
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 * }
	 */

	class MeshDepthMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshDepthMaterial';
			this.depthPacking = BasicDepthPacking;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.depthPacking = source.depthPacking;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			return this;
		}

	}

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	/**
	 * parameters = {
	 *
	 *	referencePosition: <float>,
	 *	nearDistance: <float>,
	 *	farDistance: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>
	 *
	 * }
	 */

	class MeshDistanceMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshDistanceMaterial';
			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.fog = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.referencePosition.copy(source.referencePosition);
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			return this;
		}

	}

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	function WebGLShadowMap(_renderer, _objects, _capabilities) {
		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
					_viewportSize = new Vector2(),
					_viewport = new Vector4(),
					_depthMaterial = new MeshDepthMaterial({
			depthPacking: RGBADepthPacking
		}),
					_distanceMaterial = new MeshDistanceMaterial(),
					_materialCache = {},
					_maxTextureSize = _capabilities.maxTextureSize;

		const shadowSide = {
			0: BackSide,
			1: FrontSide,
			2: DoubleSide
		};
		const shadowMaterialVertical = new ShaderMaterial({
			defines: {
				SAMPLE_RATE: 2.0 / 8.0,
				HALF_SAMPLE_RATE: 1.0 / 8.0
			},
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Vector2()
				},
				radius: {
					value: 4.0
				}
			},
			vertexShader: vsm_vert,
			fragmentShader: vsm_frag
		});
		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
		const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
		const scope = this;
		this.enabled = false;
		this.autoUpdate = true;
		this.needsUpdate = false;
		this.type = PCFShadowMap;

		this.render = function (lights, scene, camera) {
			if (scope.enabled === false) return;
			if (scope.autoUpdate === false && scope.needsUpdate === false) return;
			if (lights.length === 0) return;

			const currentRenderTarget = _renderer.getRenderTarget();

			const activeCubeFace = _renderer.getActiveCubeFace();

			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state; // Set GL state for depth map.

			_state.setBlending(NoBlending);

			_state.buffers.color.setClear(1, 1, 1, 1);

			_state.buffers.depth.setTest(true);

			_state.setScissorTest(false); // render depth map


			for (let i = 0, il = lights.length; i < il; i++) {
				const light = lights[i];
				const shadow = light.shadow;

				if (shadow === undefined) {
					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
					continue;
				}

				if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

				_shadowMapSize.copy(shadow.mapSize);

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply(shadowFrameExtents);

				_viewportSize.copy(shadow.mapSize);

				if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
					if (_shadowMapSize.x > _maxTextureSize) {
						_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;
					}

					if (_shadowMapSize.y > _maxTextureSize) {
						_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;
					}
				}

				if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
					const pars = {
						minFilter: LinearFilter,
						magFilter: LinearFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.camera.updateProjectionMatrix();
				}

				if (shadow.map === null) {
					const pars = {
						minFilter: NearestFilter,
						magFilter: NearestFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.camera.updateProjectionMatrix();
				}

				_renderer.setRenderTarget(shadow.map);

				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for (let vp = 0; vp < viewportCount; vp++) {
					const viewport = shadow.getViewport(vp);

					_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

					_state.viewport(_viewport);

					shadow.updateMatrices(light, vp);
					_frustum = shadow.getFrustum();
					renderObject(scene, camera, shadow.camera, light, this.type);
				} // do blur pass for VSM


				if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
					VSMPass(shadow, camera);
				}

				shadow.needsUpdate = false;
			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
		};

		function VSMPass(shadow, camera) {
			const geometry = _objects.update(fullScreenMesh); // vertical pass


			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.mapPass);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass


			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.map);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
		}

		function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
			let result = null;
			const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;

			if (customMaterial !== undefined) {
				result = customMaterial;
			} else {
				result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
			}

			if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
				// in this case we need a unique material instance reflecting the
				// appropriate state
				const keyA = result.uuid,
							keyB = material.uuid;
				let materialsForVariant = _materialCache[keyA];

				if (materialsForVariant === undefined) {
					materialsForVariant = {};
					_materialCache[keyA] = materialsForVariant;
				}

				let cachedMaterial = materialsForVariant[keyB];

				if (cachedMaterial === undefined) {
					cachedMaterial = result.clone();
					materialsForVariant[keyB] = cachedMaterial;
				}

				result = cachedMaterial;
			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if (type === VSMShadowMap) {
				result.side = material.shadowSide !== null ? material.shadowSide : material.side;
			} else {
				result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
			}

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;
			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
				result.referencePosition.setFromMatrixPosition(light.matrixWorld);
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
			}

			return result;
		}

		function renderObject(object, camera, shadowCamera, light, type) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);

			if (visible && (object.isMesh || object.isLine || object.isPoints)) {
				if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

					const geometry = _objects.update(object);

					const material = object.material;

					if (Array.isArray(material)) {
						const groups = geometry.groups;

						for (let k = 0, kl = groups.length; k < kl; k++) {
							const group = groups[k];
							const groupMaterial = material[group.materialIndex];

							if (groupMaterial && groupMaterial.visible) {
								const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
							}
						}
					} else if (material.visible) {
						const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

						_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
					}
				}
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				renderObject(children[i], camera, shadowCamera, light, type);
			}
		}
	}

	function WebGLState(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {
			let locked = false;
			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4(0, 0, 0, 0);
			return {
				setMask: function (colorMask) {
					if (currentColorMask !== colorMask && !locked) {
						gl.colorMask(colorMask, colorMask, colorMask, colorMask);
						currentColorMask = colorMask;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (r, g, b, a, premultipliedAlpha) {
					if (premultipliedAlpha === true) {
						r *= a;
						g *= a;
						b *= a;
					}

					color.set(r, g, b, a);

					if (currentColorClear.equals(color) === false) {
						gl.clearColor(r, g, b, a);
						currentColorClear.copy(color);
					}
				},
				reset: function () {
					locked = false;
					currentColorMask = null;
					currentColorClear.set(-1, 0, 0, 0); // set to invalid state
				}
			};
		}

		function DepthBuffer() {
			let locked = false;
			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;
			return {
				setTest: function (depthTest) {
					if (depthTest) {
						enable(gl.DEPTH_TEST);
					} else {
						disable(gl.DEPTH_TEST);
					}
				},
				setMask: function (depthMask) {
					if (currentDepthMask !== depthMask && !locked) {
						gl.depthMask(depthMask);
						currentDepthMask = depthMask;
					}
				},
				setFunc: function (depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						if (depthFunc) {
							switch (depthFunc) {
								case NeverDepth:
									gl.depthFunc(gl.NEVER);
									break;

								case AlwaysDepth:
									gl.depthFunc(gl.ALWAYS);
									break;

								case LessDepth:
									gl.depthFunc(gl.LESS);
									break;

								case LessEqualDepth:
									gl.depthFunc(gl.LEQUAL);
									break;

								case EqualDepth:
									gl.depthFunc(gl.EQUAL);
									break;

								case GreaterEqualDepth:
									gl.depthFunc(gl.GEQUAL);
									break;

								case GreaterDepth:
									gl.depthFunc(gl.GREATER);
									break;

								case NotEqualDepth:
									gl.depthFunc(gl.NOTEQUAL);
									break;

								default:
									gl.depthFunc(gl.LEQUAL);
							}
						} else {
							gl.depthFunc(gl.LEQUAL);
						}

						currentDepthFunc = depthFunc;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (depth) {
					if (currentDepthClear !== depth) {
						gl.clearDepth(depth);
						currentDepthClear = depth;
					}
				},
				reset: function () {
					locked = false;
					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
				}
			};
		}

		function StencilBuffer() {
			let locked = false;
			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;
			return {
				setTest: function (stencilTest) {
					if (!locked) {
						if (stencilTest) {
							enable(gl.STENCIL_TEST);
						} else {
							disable(gl.STENCIL_TEST);
						}
					}
				},
				setMask: function (stencilMask) {
					if (currentStencilMask !== stencilMask && !locked) {
						gl.stencilMask(stencilMask);
						currentStencilMask = stencilMask;
					}
				},
				setFunc: function (stencilFunc, stencilRef, stencilMask) {
					if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
						gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
					}
				},
				setOp: function (stencilFail, stencilZFail, stencilZPass) {
					if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
						gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (stencil) {
					if (currentStencilClear !== stencil) {
						gl.clearStencil(stencil);
						currentStencilClear = stencil;
					}
				},
				reset: function () {
					locked = false;
					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
				}
			};
		} //


		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();
		let enabledCapabilities = {};
		let xrFramebuffer = null;
		let currentBoundFramebuffers = {};
		let currentProgram = null;
		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;
		let currentFlipSided = null;
		let currentCullFace = null;
		let currentLineWidth = null;
		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;
		const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter(gl.VERSION);

		if (glVersion.indexOf('WebGL') !== -1) {
			version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 1.0;
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {
			version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 2.0;
		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};
		const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
		const viewportParam = gl.getParameter(gl.VIEWPORT);
		const currentScissor = new Vector4().fromArray(scissorParam);
		const currentViewport = new Vector4().fromArray(viewportParam);

		function createTexture(type, target, count) {
			const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

			const texture = gl.createTexture();
			gl.bindTexture(type, texture);
			gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			for (let i = 0; i < count; i++) {
				gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
			}

			return texture;
		}

		const emptyTextures = {};
		emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
		emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init

		colorBuffer.setClear(0, 0, 0, 1);
		depthBuffer.setClear(1);
		stencilBuffer.setClear(0);
		enable(gl.DEPTH_TEST);
		depthBuffer.setFunc(LessEqualDepth);
		setFlipSided(false);
		setCullFace(CullFaceBack);
		enable(gl.CULL_FACE);
		setBlending(NoBlending); //

		function enable(id) {
			if (enabledCapabilities[id] !== true) {
				gl.enable(id);
				enabledCapabilities[id] = true;
			}
		}

		function disable(id) {
			if (enabledCapabilities[id] !== false) {
				gl.disable(id);
				enabledCapabilities[id] = false;
			}
		}

		function bindXRFramebuffer(framebuffer) {
			if (framebuffer !== xrFramebuffer) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
				xrFramebuffer = framebuffer;
			}
		}

		function bindFramebuffer(target, framebuffer) {
			if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available

			if (currentBoundFramebuffers[target] !== framebuffer) {
				gl.bindFramebuffer(target, framebuffer);
				currentBoundFramebuffers[target] = framebuffer;

				if (isWebGL2) {
					// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER
					if (target === gl.DRAW_FRAMEBUFFER) {
						currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
					}

					if (target === gl.FRAMEBUFFER) {
						currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
					}
				}

				return true;
			}

			return false;
		}

		function useProgram(program) {
			if (currentProgram !== program) {
				gl.useProgram(program);
				currentProgram = program;
				return true;
			}

			return false;
		}

		const equationToGL = {
			[AddEquation]: gl.FUNC_ADD,
			[SubtractEquation]: gl.FUNC_SUBTRACT,
			[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
		};

		if (isWebGL2) {
			equationToGL[MinEquation] = gl.MIN;
			equationToGL[MaxEquation] = gl.MAX;
		} else {
			const extension = extensions.get('EXT_blend_minmax');

			if (extension !== null) {
				equationToGL[MinEquation] = extension.MIN_EXT;
				equationToGL[MaxEquation] = extension.MAX_EXT;
			}
		}

		const factorToGL = {
			[ZeroFactor]: gl.ZERO,
			[OneFactor]: gl.ONE,
			[SrcColorFactor]: gl.SRC_COLOR,
			[SrcAlphaFactor]: gl.SRC_ALPHA,
			[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
			[DstColorFactor]: gl.DST_COLOR,
			[DstAlphaFactor]: gl.DST_ALPHA,
			[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
			[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
			[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
			[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
		};

		function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
			if (blending === NoBlending) {
				if (currentBlendingEnabled === true) {
					disable(gl.BLEND);
					currentBlendingEnabled = false;
				}

				return;
			}

			if (currentBlendingEnabled === false) {
				enable(gl.BLEND);
				currentBlendingEnabled = true;
			}

			if (blending !== CustomBlending) {
				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
						gl.blendEquation(gl.FUNC_ADD);
						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
					}

					if (premultipliedAlpha) {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.ONE, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					} else {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
								break;

							case MultiplyBlending:
								gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
				}

				return;
			} // custom blending


			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
				gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
			}

			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
				gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
			}

			currentBlending = blending;
			currentPremultipledAlpha = null;
		}

		function setMaterial(material, frontFaceCW) {
			material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
			let flipSided = material.side === BackSide;
			if (frontFaceCW) flipSided = !flipSided;
			setFlipSided(flipSided);
			material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
			depthBuffer.setFunc(material.depthFunc);
			depthBuffer.setTest(material.depthTest);
			depthBuffer.setMask(material.depthWrite);
			colorBuffer.setMask(material.colorWrite);
			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest(stencilWrite);

			if (stencilWrite) {
				stencilBuffer.setMask(material.stencilWriteMask);
				stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
				stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
			}

			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
			material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		} //


		function setFlipSided(flipSided) {
			if (currentFlipSided !== flipSided) {
				if (flipSided) {
					gl.frontFace(gl.CW);
				} else {
					gl.frontFace(gl.CCW);
				}

				currentFlipSided = flipSided;
			}
		}

		function setCullFace(cullFace) {
			if (cullFace !== CullFaceNone) {
				enable(gl.CULL_FACE);

				if (cullFace !== currentCullFace) {
					if (cullFace === CullFaceBack) {
						gl.cullFace(gl.BACK);
					} else if (cullFace === CullFaceFront) {
						gl.cullFace(gl.FRONT);
					} else {
						gl.cullFace(gl.FRONT_AND_BACK);
					}
				}
			} else {
				disable(gl.CULL_FACE);
			}

			currentCullFace = cullFace;
		}

		function setLineWidth(width) {
			if (width !== currentLineWidth) {
				if (lineWidthAvailable) gl.lineWidth(width);
				currentLineWidth = width;
			}
		}

		function setPolygonOffset(polygonOffset, factor, units) {
			if (polygonOffset) {
				enable(gl.POLYGON_OFFSET_FILL);

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
					gl.polygonOffset(factor, units);
					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
				}
			} else {
				disable(gl.POLYGON_OFFSET_FILL);
			}
		}

		function setScissorTest(scissorTest) {
			if (scissorTest) {
				enable(gl.SCISSOR_TEST);
			} else {
				disable(gl.SCISSOR_TEST);
			}
		} // texture


		function activeTexture(webglSlot) {
			if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
		}

		function bindTexture(webglType, webglTexture) {
			if (currentTextureSlot === null) {
				activeTexture();
			}

			let boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture === undefined) {
				boundTexture = {
					type: undefined,
					texture: undefined
				};
				currentBoundTextures[currentTextureSlot] = boundTexture;
			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
			}
		}

		function unbindTexture() {
			const boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture !== undefined && boundTexture.type !== undefined) {
				gl.bindTexture(boundTexture.type, null);
				boundTexture.type = undefined;
				boundTexture.texture = undefined;
			}
		}

		function compressedTexImage2D() {
			try {
				gl.compressedTexImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage2D() {
			try {
				gl.texImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage3D() {
			try {
				gl.texImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		} //


		function scissor(scissor) {
			if (currentScissor.equals(scissor) === false) {
				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
				currentScissor.copy(scissor);
			}
		}

		function viewport(viewport) {
			if (currentViewport.equals(viewport) === false) {
				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
				currentViewport.copy(viewport);
			}
		} //


		function reset() {
			// reset state
			gl.disable(gl.BLEND);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.POLYGON_OFFSET_FILL);
			gl.disable(gl.SCISSOR_TEST);
			gl.disable(gl.STENCIL_TEST);
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
			gl.blendEquation(gl.FUNC_ADD);
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
			gl.colorMask(true, true, true, true);
			gl.clearColor(0, 0, 0, 0);
			gl.depthMask(true);
			gl.depthFunc(gl.LESS);
			gl.clearDepth(1);
			gl.stencilMask(0xffffffff);
			gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.clearStencil(0);
			gl.cullFace(gl.BACK);
			gl.frontFace(gl.CCW);
			gl.polygonOffset(0, 0);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			if (isWebGL2 === true) {
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
			}

			gl.useProgram(null);
			gl.lineWidth(1);
			gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals

			enabledCapabilities = {};
			currentTextureSlot = null;
			currentBoundTextures = {};
			xrFramebuffer = null;
			currentBoundFramebuffers = {};
			currentProgram = null;
			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;
			currentFlipSided = null;
			currentCullFace = null;
			currentLineWidth = null;
			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;
			currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
			currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
		}

		return {
			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},
			enable: enable,
			disable: disable,
			bindFramebuffer: bindFramebuffer,
			bindXRFramebuffer: bindXRFramebuffer,
			useProgram: useProgram,
			setBlending: setBlending,
			setMaterial: setMaterial,
			setFlipSided: setFlipSided,
			setCullFace: setCullFace,
			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,
			setScissorTest: setScissorTest,
			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,
			scissor: scissor,
			viewport: viewport,
			reset: reset
		};
	}

	function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;

		const _videoTextures = new WeakMap();

		let _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


		let useOffscreenCanvas = false;

		try {
			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
		} catch (err) {// Ignore any errors
		}

		function createCanvas(width, height) {
			// Use OffscreenCanvas when available. Specially needed in web workers
			return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		}

		function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
			let scale = 1; // handle case if texture exceeds max size

			if (image.width > maxSize || image.height > maxSize) {
				scale = maxSize / Math.max(image.width, image.height);
			} // only perform resize if necessary


			if (scale < 1 || needsPowerOfTwo === true) {
				// only perform resize for certain image types
				if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
					const width = floor(scale * image.width);
					const height = floor(scale * image.height);
					if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
					canvas.width = width;
					canvas.height = height;
					const context = canvas.getContext('2d');
					context.drawImage(image, 0, 0, width, height);
					console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
					return canvas;
				} else {
					if ('data' in image) {
						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
					}

					return image;
				}
			}

			return image;
		}

		function isPowerOfTwo$1(image) {
			return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
		}

		function textureNeedsPowerOfTwo(texture) {
			if (isWebGL2) return false;
			return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function textureNeedsGenerateMipmaps(texture, supportsMips) {
			return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function generateMipmap(target, texture, width, height, depth = 1) {
			_gl.generateMipmap(target);

			const textureProperties = properties.get(texture);
			textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));
		}

		function getInternalFormat(internalFormatName, glFormat, glType) {
			if (isWebGL2 === false) return glFormat;

			if (internalFormatName !== null) {
				if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
				console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
			}

			let internalFormat = glFormat;

			if (glFormat === _gl.RED) {
				if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
			}

			if (glFormat === _gl.RGB) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
			}

			if (glFormat === _gl.RGBA) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
			}

			if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
				extensions.get('EXT_color_buffer_float');
			}

			return internalFormat;
		} // Fallback filters for non-power-of-2 textures


		function filterFallback(f) {
			if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
				return _gl.NEAREST;
			}

			return _gl.LINEAR;
		} //


		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			deallocateTexture(texture);

			if (texture.isVideoTexture) {
				_videoTextures.delete(texture);
			}

			info.memory.textures--;
		}

		function onRenderTargetDispose(event) {
			const renderTarget = event.target;
			renderTarget.removeEventListener('dispose', onRenderTargetDispose);
			deallocateRenderTarget(renderTarget);
		} //


		function deallocateTexture(texture) {
			const textureProperties = properties.get(texture);
			if (textureProperties.__webglInit === undefined) return;

			_gl.deleteTexture(textureProperties.__webglTexture);

			properties.remove(texture);
		}

		function deallocateRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			if (!renderTarget) return;

			if (textureProperties.__webglTexture !== undefined) {
				_gl.deleteTexture(textureProperties.__webglTexture);

				info.memory.textures--;
			}

			if (renderTarget.depthTexture) {
				renderTarget.depthTexture.dispose();
			}

			if (renderTarget.isWebGLCubeRenderTarget) {
				for (let i = 0; i < 6; i++) {
					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
				}
			} else {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
				if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
				if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
				if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
			}

			if (renderTarget.isWebGLMultipleRenderTargets) {
				for (let i = 0, il = texture.length; i < il; i++) {
					const attachmentProperties = properties.get(texture[i]);

					if (attachmentProperties.__webglTexture) {
						_gl.deleteTexture(attachmentProperties.__webglTexture);

						info.memory.textures--;
					}

					properties.remove(texture[i]);
				}
			}

			properties.remove(texture);
			properties.remove(renderTarget);
		} //


		let textureUnits = 0;

		function resetTextureUnits() {
			textureUnits = 0;
		}

		function allocateTextureUnit() {
			const textureUnit = textureUnits;

			if (textureUnit >= maxTextures) {
				console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
			}

			textureUnits += 1;
			return textureUnit;
		} //


		function setTexture2D(texture, slot) {
			const textureProperties = properties.get(texture);
			if (texture.isVideoTexture) updateVideoTexture(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				const image = texture.image;

				if (image === undefined) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
				} else if (image.complete === false) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
				} else {
					uploadTexture(textureProperties, texture, slot);
					return;
				}
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
		}

		function setTexture2DArray(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
		}

		function setTexture3D(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
		}

		function setTextureCube(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadCubeTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
		}

		const wrappingToGL = {
			[RepeatWrapping]: _gl.REPEAT,
			[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
			[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
		};
		const filterToGL = {
			[NearestFilter]: _gl.NEAREST,
			[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
			[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
			[LinearFilter]: _gl.LINEAR,
			[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
			[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
		};

		function setTextureParameters(textureType, texture, supportsMips) {
			if (supportsMips) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
			} else {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
				}

				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
				}
			}

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2

				if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

					properties.get(texture).__currentAnisotropy = texture.anisotropy;
				}
			}
		}

		function initTexture(textureProperties, texture) {
			if (textureProperties.__webglInit === undefined) {
				textureProperties.__webglInit = true;
				texture.addEventListener('dispose', onTextureDispose);
				textureProperties.__webglTexture = _gl.createTexture();
				info.memory.textures++;
			}
		}

		function uploadTexture(textureProperties, texture, slot) {
			let textureType = _gl.TEXTURE_2D;
			if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
			if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(textureType, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
			const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
			const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
						glFormat = utils.convert(texture.format);
			let glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
			setTextureParameters(textureType, texture, supportsMips);
			let mipmap;
			const mipmaps = texture.mipmaps;

			if (texture.isDepthTexture) {
				// populate depth texture with dummy data
				glInternalFormat = _gl.DEPTH_COMPONENT;

				if (isWebGL2) {
					if (texture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F;
					} else if (texture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24;
					} else if (texture.type === UnsignedInt248Type) {
						glInternalFormat = _gl.DEPTH24_STENCIL8;
					} else {
						glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
					}
				} else {
					if (texture.type === FloatType) {
						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
					}
				} // validation checks for WebGL 1


				if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
						texture.type = UnsignedShortType;
						glType = utils.convert(texture.type);
					}
				}

				if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
						texture.type = UnsignedInt248Type;
						glType = utils.convert(texture.type);
					}
				} //


				state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
					textureProperties.__maxMipLevel = 0;
				}
			} else if (texture.isCompressedTexture) {
				for (let i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i];

					if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
						if (glFormat !== null) {
							state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
						} else {
							console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
						}
					} else {
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else if (texture.isDataTexture2DArray) {
				state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else if (texture.isDataTexture3D) {
				state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else {
				// regular Texture (image, video, canvas)
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
					textureProperties.__maxMipLevel = 0;
				}
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(textureType, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}

		function uploadCubeTexture(textureProperties, texture, slot) {
			if (texture.image.length !== 6) return;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
			const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
			const cubeImage = [];

			for (let i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) {
					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
				} else {
					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
				}
			}

			const image = cubeImage[0],
						supportsMips = isPowerOfTwo$1(image) || isWebGL2,
						glFormat = utils.convert(texture.format),
						glType = utils.convert(texture.type),
						glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			let mipmaps;

			if (isCompressed) {
				for (let i = 0; i < 6; i++) {
					mipmaps = cubeImage[i].mipmaps;

					for (let j = 0; j < mipmaps.length; j++) {
						const mipmap = mipmaps[j];

						if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
							if (glFormat !== null) {
								state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
							}
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else {
				mipmaps = texture.mipmaps;

				for (let i = 0; i < 6; i++) {
					if (isDataTexture) {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							const mipmapImage = mipmap.image[i].image;
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
						}
					} else {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length;
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				// We assume images for cube map have the same size.
				generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		} // Render targets
		// Setup storage for target texture and bind it to correct framebuffer


		function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
			const glFormat = utils.convert(texture.format);
			const glType = utils.convert(texture.type);
			const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

			if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
				state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
			} else {
				state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


		function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
			_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
				let glInternalFormat = _gl.DEPTH_COMPONENT16;

				if (isMultisample) {
					const depthTexture = renderTarget.depthTexture;

					if (depthTexture && depthTexture.isDepthTexture) {
						if (depthTexture.type === FloatType) {
							glInternalFormat = _gl.DEPTH_COMPONENT32F;
						} else if (depthTexture.type === UnsignedIntType) {
							glInternalFormat = _gl.DEPTH_COMPONENT24;
						}
					}

					const samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
				if (isMultisample) {
					const samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else {
				// Use the first texture for MRT so far
				const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
				const glFormat = utils.convert(texture.format);
				const glType = utils.convert(texture.type);
				const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

				if (isMultisample) {
					const samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}
			}

			_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
		} // Setup resources for a Depth Texture for a FBO (needs an extension)


		function setupDepthTexture(framebuffer, renderTarget) {
			const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
			} // upload an empty depth texture with framebuffer size


			if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}

			setTexture2D(renderTarget.depthTexture, 0);

			const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

			if (renderTarget.depthTexture.format === DepthFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			} else {
				throw new Error('Unknown depthTexture format');
			}
		} // Setup GL resources for a non-texture depth buffer


		function setupDepthRenderbuffer(renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			const isCube = renderTarget.isWebGLCubeRenderTarget === true;

			if (renderTarget.depthTexture) {
				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
			} else {
				if (isCube) {
					renderTargetProperties.__webglDepthbuffer = [];

					for (let i = 0; i < 6; i++) {
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
					}
				} else {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
				}
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // Set up GL resources for the render target


		function setupRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			renderTarget.addEventListener('dispose', onRenderTargetDispose);

			if (renderTarget.isWebGLMultipleRenderTargets !== true) {
				textureProperties.__webglTexture = _gl.createTexture();
				textureProperties.__version = texture.version;
				info.memory.textures++;
			}

			const isCube = renderTarget.isWebGLCubeRenderTarget === true;
			const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
			const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
			const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858

			if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
				texture.format = RGBAFormat;
				console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
			} // Setup framebuffer


			if (isCube) {
				renderTargetProperties.__webglFramebuffer = [];

				for (let i = 0; i < 6; i++) {
					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
				}
			} else {
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if (isMultipleRenderTargets) {
					if (capabilities.drawBuffers) {
						const textures = renderTarget.texture;

						for (let i = 0, il = textures.length; i < il; i++) {
							const attachmentProperties = properties.get(textures[i]);

							if (attachmentProperties.__webglTexture === undefined) {
								attachmentProperties.__webglTexture = _gl.createTexture();
								info.memory.textures++;
							}
						}
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
					}
				} else if (isMultisample) {
					if (isWebGL2) {
						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						const glFormat = utils.convert(texture.format);
						const glType = utils.convert(texture.type);
						const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
						const samples = getRenderTargetSamples(renderTarget);

						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);

						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);

						_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

						if (renderTarget.depthBuffer) {
							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
						}

						state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
					}
				}
			} // Setup color buffer


			if (isCube) {
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);

				for (let i = 0; i < 6; i++) {
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
				}

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height);
				}

				state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
			} else if (isMultipleRenderTargets) {
				const textures = renderTarget.texture;

				for (let i = 0, il = textures.length; i < il; i++) {
					const attachment = textures[i];
					const attachmentProperties = properties.get(attachment);
					state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
					setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);

					if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
						generateMipmap(_gl.TEXTURE_2D, attachment, renderTarget.width, renderTarget.height);
					}
				}

				state.bindTexture(_gl.TEXTURE_2D, null);
			} else {
				let glTextureType = _gl.TEXTURE_2D;

				if (isRenderTarget3D) {
					// Render targets containing layers, i.e: Texture 3D and 2d arrays
					if (isWebGL2) {
						const isTexture3D = texture.isDataTexture3D;
						glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
					} else {
						console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');
					}
				}

				state.bindTexture(glTextureType, textureProperties.__webglTexture);
				setTextureParameters(glTextureType, texture, supportsMips);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);
				}

				state.bindTexture(glTextureType, null);
			} // Setup depth and stencil buffers


			if (renderTarget.depthBuffer) {
				setupDepthRenderbuffer(renderTarget);
			}
		}

		function updateRenderTargetMipmap(renderTarget) {
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];

			for (let i = 0, il = textures.length; i < il; i++) {
				const texture = textures[i];

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;

					const webglTexture = properties.get(texture).__webglTexture;

					state.bindTexture(target, webglTexture);
					generateMipmap(target, texture, renderTarget.width, renderTarget.height);
					state.bindTexture(target, null);
				}
			}
		}

		function updateMultisampleRenderTarget(renderTarget) {
			if (renderTarget.isWebGLMultisampleRenderTarget) {
				if (isWebGL2) {
					const width = renderTarget.width;
					const height = renderTarget.height;
					let mask = _gl.COLOR_BUFFER_BIT;
					if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
					if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
					const renderTargetProperties = properties.get(renderTarget);
					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);

					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);

					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				} else {
					console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
				}
			}
		}

		function getRenderTargetSamples(renderTarget) {
			return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
		}

		function updateVideoTexture(texture) {
			const frame = info.render.frame; // Check the last frame we updated the VideoTexture

			if (_videoTextures.get(texture) !== frame) {
				_videoTextures.set(texture, frame);

				texture.update();
			}
		} // backwards compatibility


		let warnedTexture2D = false;
		let warnedTextureCube = false;

		function safeSetTexture2D(texture, slot) {
			if (texture && texture.isWebGLRenderTarget) {
				if (warnedTexture2D === false) {
					console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
					warnedTexture2D = true;
				}

				texture = texture.texture;
			}

			setTexture2D(texture, slot);
		}

		function safeSetTextureCube(texture, slot) {
			if (texture && texture.isWebGLCubeRenderTarget) {
				if (warnedTextureCube === false) {
					console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
					warnedTextureCube = true;
				}

				texture = texture.texture;
			}

			setTextureCube(texture, slot);
		} //


		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;
		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;
	}

	function WebGLUtils(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function convert(p) {
			let extension;
			if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
			if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
			if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
			if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
			if (p === ByteType) return gl.BYTE;
			if (p === ShortType) return gl.SHORT;
			if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
			if (p === IntType) return gl.INT;
			if (p === UnsignedIntType) return gl.UNSIGNED_INT;
			if (p === FloatType) return gl.FLOAT;

			if (p === HalfFloatType) {
				if (isWebGL2) return gl.HALF_FLOAT;
				extension = extensions.get('OES_texture_half_float');

				if (extension !== null) {
					return extension.HALF_FLOAT_OES;
				} else {
					return null;
				}
			}

			if (p === AlphaFormat) return gl.ALPHA;
			if (p === RGBFormat) return gl.RGB;
			if (p === RGBAFormat) return gl.RGBA;
			if (p === LuminanceFormat) return gl.LUMINANCE;
			if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
			if (p === DepthFormat) return gl.DEPTH_COMPONENT;
			if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
			if (p === RedFormat) return gl.RED; // WebGL2 formats.

			if (p === RedIntegerFormat) return gl.RED_INTEGER;
			if (p === RGFormat) return gl.RG;
			if (p === RGIntegerFormat) return gl.RG_INTEGER;
			if (p === RGBIntegerFormat) return gl.RGB_INTEGER;
			if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc');

				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			}

			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_pvrtc');

				if (extension !== null) {
					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc1');

				if (extension !== null) {
					return extension.COMPRESSED_RGB_ETC1_WEBGL;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc');

				if (extension !== null) {
					if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
					if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
				}
			}

			if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
				extension = extensions.get('WEBGL_compressed_texture_astc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === RGBA_BPTC_Format) {
				extension = extensions.get('EXT_texture_compression_bptc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === UnsignedInt248Type) {
				if (isWebGL2) return gl.UNSIGNED_INT_24_8;
				extension = extensions.get('WEBGL_depth_texture');

				if (extension !== null) {
					return extension.UNSIGNED_INT_24_8_WEBGL;
				} else {
					return null;
				}
			}
		}

		return {
			convert: convert
		};
	}

	class ArrayCamera extends PerspectiveCamera {
		constructor(array = []) {
			super();
			this.cameras = array;
		}

	}

	ArrayCamera.prototype.isArrayCamera = true;

	class Group extends Object3D {
		constructor() {
			super();
			this.type = 'Group';
		}

	}

	Group.prototype.isGroup = true;

	const _moveEvent = {
		type: 'move'
	};

	class WebXRController {
		constructor() {
			this._targetRay = null;
			this._grip = null;
			this._hand = null;
		}

		getHandSpace() {
			if (this._hand === null) {
				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;
				this._hand.joints = {};
				this._hand.inputState = {
					pinching: false
				};
			}

			return this._hand;
		}

		getTargetRaySpace() {
			if (this._targetRay === null) {
				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();
			}

			return this._targetRay;
		}

		getGripSpace() {
			if (this._grip === null) {
				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();
			}

			return this._grip;
		}

		dispatchEvent(event) {
			if (this._targetRay !== null) {
				this._targetRay.dispatchEvent(event);
			}

			if (this._grip !== null) {
				this._grip.dispatchEvent(event);
			}

			if (this._hand !== null) {
				this._hand.dispatchEvent(event);
			}

			return this;
		}

		disconnect(inputSource) {
			this.dispatchEvent({
				type: 'disconnected',
				data: inputSource
			});

			if (this._targetRay !== null) {
				this._targetRay.visible = false;
			}

			if (this._grip !== null) {
				this._grip.visible = false;
			}

			if (this._hand !== null) {
				this._hand.visible = false;
			}

			return this;
		}

		update(inputSource, frame, referenceSpace) {
			let inputPose = null;
			let gripPose = null;
			let handPose = null;
			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
				if (targetRay !== null) {
					inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

					if (inputPose !== null) {
						targetRay.matrix.fromArray(inputPose.transform.matrix);
						targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);

						if (inputPose.linearVelocity) {
							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy(inputPose.linearVelocity);
						} else {
							targetRay.hasLinearVelocity = false;
						}

						if (inputPose.angularVelocity) {
							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy(inputPose.angularVelocity);
						} else {
							targetRay.hasAngularVelocity = false;
						}

						this.dispatchEvent(_moveEvent);
					}
				}

				if (hand && inputSource.hand) {
					handPose = true;

					for (const inputjoint of inputSource.hand.values()) {
						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose(inputjoint, referenceSpace);

						if (hand.joints[inputjoint.jointName] === undefined) {
							// The transform of this joint will be updated with the joint pose on each frame
							const joint = new Group();
							joint.matrixAutoUpdate = false;
							joint.visible = false;
							hand.joints[inputjoint.jointName] = joint; // ??

							hand.add(joint);
						}

						const joint = hand.joints[inputjoint.jointName];

						if (jointPose !== null) {
							joint.matrix.fromArray(jointPose.transform.matrix);
							joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
							joint.jointRadius = jointPose.radius;
						}

						joint.visible = jointPose !== null;
					} // Custom events
					// Check pinchz


					const indexTip = hand.joints['index-finger-tip'];
					const thumbTip = hand.joints['thumb-tip'];
					const distance = indexTip.position.distanceTo(thumbTip.position);
					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
						hand.inputState.pinching = false;
						this.dispatchEvent({
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						});
					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
						hand.inputState.pinching = true;
						this.dispatchEvent({
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						});
					}
				} else {
					if (grip !== null && inputSource.gripSpace) {
						gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

						if (gripPose !== null) {
							grip.matrix.fromArray(gripPose.transform.matrix);
							grip.matrix.decompose(grip.position, grip.rotation, grip.scale);

							if (gripPose.linearVelocity) {
								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy(gripPose.linearVelocity);
							} else {
								grip.hasLinearVelocity = false;
							}

							if (gripPose.angularVelocity) {
								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy(gripPose.angularVelocity);
							} else {
								grip.hasAngularVelocity = false;
							}
						}
					}
				}
			}

			if (targetRay !== null) {
				targetRay.visible = inputPose !== null;
			}

			if (grip !== null) {
				grip.visible = gripPose !== null;
			}

			if (hand !== null) {
				hand.visible = handPose !== null;
			}

			return this;
		}

	}

	class WebXRManager extends EventDispatcher {
		constructor(renderer, gl) {
			super();
			const scope = this;
			const state = renderer.state;
			let session = null;
			let framebufferScaleFactor = 1.0;
			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';
			let pose = null;
			let glBinding = null;
			let glFramebuffer = null;
			let glProjLayer = null;
			let glBaseLayer = null;
			const controllers = [];
			const inputSourcesMap = new Map(); //

			const cameraL = new PerspectiveCamera();
			cameraL.layers.enable(1);
			cameraL.viewport = new Vector4();
			const cameraR = new PerspectiveCamera();
			cameraR.layers.enable(2);
			cameraR.viewport = new Vector4();
			const cameras = [cameraL, cameraR];
			const cameraVR = new ArrayCamera();
			cameraVR.layers.enable(1);
			cameraVR.layers.enable(2);
			let _currentDepthNear = null;
			let _currentDepthFar = null; //

			this.cameraAutoUpdate = true;
			this.enabled = false;
			this.isPresenting = false;

			this.getController = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getTargetRaySpace();
			};

			this.getControllerGrip = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getGripSpace();
			};

			this.getHand = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getHandSpace();
			}; //


			function onSessionEvent(event) {
				const controller = inputSourcesMap.get(event.inputSource);

				if (controller) {
					controller.dispatchEvent({
						type: event.type,
						data: event.inputSource
					});
				}
			}

			function onSessionEnd() {
				inputSourcesMap.forEach(function (controller, inputSource) {
					controller.disconnect(inputSource);
				});
				inputSourcesMap.clear();
				_currentDepthNear = null;
				_currentDepthFar = null; // restore framebuffer/rendering state

				state.bindXRFramebuffer(null);
				renderer.setRenderTarget(renderer.getRenderTarget()); //

				animation.stop();
				scope.isPresenting = false;
				scope.dispatchEvent({
					type: 'sessionend'
				});
			}

			this.setFramebufferScaleFactor = function (value) {
				framebufferScaleFactor = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
				}
			};

			this.setReferenceSpaceType = function (value) {
				referenceSpaceType = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
				}
			};

			this.getReferenceSpace = function () {
				return referenceSpace;
			};

			this.getSession = function () {
				return session;
			};

			this.setSession = async function (value) {
				session = value;

				if (session !== null) {
					session.addEventListener('select', onSessionEvent);
					session.addEventListener('selectstart', onSessionEvent);
					session.addEventListener('selectend', onSessionEvent);
					session.addEventListener('squeeze', onSessionEvent);
					session.addEventListener('squeezestart', onSessionEvent);
					session.addEventListener('squeezeend', onSessionEvent);
					session.addEventListener('end', onSessionEnd);
					session.addEventListener('inputsourceschange', onInputSourcesChange);
					const attributes = gl.getContextAttributes();

					if (attributes.xrCompatible !== true) {
						await gl.makeXRCompatible();
					}

					if (session.renderState.layers === undefined) {
						const layerInit = {
							antialias: attributes.antialias,
							alpha: attributes.alpha,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						};
						glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
						session.updateRenderState({
							baseLayer: glBaseLayer
						});
					} else {
						let depthFormat = 0; // for anti-aliased output, use classic webgllayer for now

						if (attributes.antialias) {
							const layerInit = {
								antialias: true,
								alpha: attributes.alpha,
								depth: attributes.depth,
								stencil: attributes.stencil,
								framebufferScaleFactor: framebufferScaleFactor
							};
							glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
							session.updateRenderState({
								layers: [glBaseLayer]
							});
						} else {
							if (attributes.depth) {
								depthFormat = attributes.stencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
							}

							const projectionlayerInit = {
								colorFormat: attributes.alpha ? gl.RGBA : gl.RGB,
								depthFormat: depthFormat,
								scaleFactor: framebufferScaleFactor
							};
							glBinding = new XRWebGLBinding(session, gl);
							glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
							glFramebuffer = gl.createFramebuffer();
							session.updateRenderState({
								layers: [glProjLayer]
							});
						}
					}

					referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
					animation.setContext(session);
					animation.start();
					scope.isPresenting = true;
					scope.dispatchEvent({
						type: 'sessionstart'
					});
				}
			};

			function onInputSourcesChange(event) {
				const inputSources = session.inputSources; // Assign inputSources to available controllers

				for (let i = 0; i < controllers.length; i++) {
					inputSourcesMap.set(inputSources[i], controllers[i]);
				} // Notify disconnected


				for (let i = 0; i < event.removed.length; i++) {
					const inputSource = event.removed[i];
					const controller = inputSourcesMap.get(inputSource);

					if (controller) {
						controller.dispatchEvent({
							type: 'disconnected',
							data: inputSource
						});
						inputSourcesMap.delete(inputSource);
					}
				} // Notify connected


				for (let i = 0; i < event.added.length; i++) {
					const inputSource = event.added[i];
					const controller = inputSourcesMap.get(inputSource);

					if (controller) {
						controller.dispatchEvent({
							type: 'connected',
							data: inputSource
						});
					}
				}
			} //


			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();
			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */

			function setProjectionFromUnion(camera, cameraL, cameraR) {
				cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
				cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
				const ipd = cameraLPos.distanceTo(cameraRPos);
				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.

				const near = projL[14] / (projL[10] - 1);
				const far = projL[14] / (projL[10] + 1);
				const topFov = (projL[9] + 1) / projL[5];
				const bottomFov = (projL[9] - 1) / projL[5];
				const leftFov = (projL[8] - 1) / projL[0];
				const rightFov = (projR[8] + 1) / projR[0];
				const left = near * leftFov;
				const right = near * rightFov; // Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.

				const zOffset = ipd / (-leftFov + rightFov);
				const xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

				cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
				camera.translateX(xOffset);
				camera.translateZ(zOffset);
				camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
				camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.

				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + (ipd - xOffset);
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;
				camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
			}

			function updateCamera(camera, parent) {
				if (parent === null) {
					camera.matrixWorld.copy(camera.matrix);
				} else {
					camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
				}

				camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
			}

			this.updateCamera = function (camera) {
				if (session === null) return;
				cameraVR.near = cameraR.near = cameraL.near = camera.near;
				cameraVR.far = cameraR.far = cameraL.far = camera.far;

				if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
					// Note that the new renderState won't apply until the next frame. See #18320
					session.updateRenderState({
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					});
					_currentDepthNear = cameraVR.near;
					_currentDepthFar = cameraVR.far;
				}

				const parent = camera.parent;
				const cameras = cameraVR.cameras;
				updateCamera(cameraVR, parent);

				for (let i = 0; i < cameras.length; i++) {
					updateCamera(cameras[i], parent);
				}

				cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children

				camera.position.copy(cameraVR.position);
				camera.quaternion.copy(cameraVR.quaternion);
				camera.scale.copy(cameraVR.scale);
				camera.matrix.copy(cameraVR.matrix);
				camera.matrixWorld.copy(cameraVR.matrixWorld);
				const children = camera.children;

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateMatrixWorld(true);
				} // update projection matrix for proper view frustum culling


				if (cameras.length === 2) {
					setProjectionFromUnion(cameraVR, cameraL, cameraR);
				} else {
					// assume single camera setup (AR)
					cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
				}
			};

			this.getCamera = function () {
				return cameraVR;
			};

			this.getFoveation = function () {
				if (glProjLayer !== null) {
					return glProjLayer.fixedFoveation;
				}

				if (glBaseLayer !== null) {
					return glBaseLayer.fixedFoveation;
				}

				return undefined;
			};

			this.setFoveation = function (foveation) {
				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution
				if (glProjLayer !== null) {
					glProjLayer.fixedFoveation = foveation;
				}

				if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
					glBaseLayer.fixedFoveation = foveation;
				}
			}; // Animation Loop


			let onAnimationFrameCallback = null;

			function onAnimationFrame(time, frame) {
				pose = frame.getViewerPose(referenceSpace);

				if (pose !== null) {
					const views = pose.views;

					if (glBaseLayer !== null) {
						state.bindXRFramebuffer(glBaseLayer.framebuffer);
					}

					let cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

					if (views.length !== cameraVR.cameras.length) {
						cameraVR.cameras.length = 0;
						cameraVRNeedsUpdate = true;
					}

					for (let i = 0; i < views.length; i++) {
						const view = views[i];
						let viewport = null;

						if (glBaseLayer !== null) {
							viewport = glBaseLayer.getViewport(view);
						} else {
							const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
							state.bindXRFramebuffer(glFramebuffer);

							if (glSubImage.depthStencilTexture !== undefined) {
								gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, glSubImage.depthStencilTexture, 0);
							}

							gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glSubImage.colorTexture, 0);
							viewport = glSubImage.viewport;
						}

						const camera = cameras[i];
						camera.matrix.fromArray(view.transform.matrix);
						camera.projectionMatrix.fromArray(view.projectionMatrix);
						camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

						if (i === 0) {
							cameraVR.matrix.copy(camera.matrix);
						}

						if (cameraVRNeedsUpdate === true) {
							cameraVR.cameras.push(camera);
						}
					}
				} //


				const inputSources = session.inputSources;

				for (let i = 0; i < controllers.length; i++) {
					const controller = controllers[i];
					const inputSource = inputSources[i];
					controller.update(inputSource, frame, referenceSpace);
				}

				if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
			}

			const animation = new WebGLAnimation();
			animation.setAnimationLoop(onAnimationFrame);

			this.setAnimationLoop = function (callback) {
				onAnimationFrameCallback = callback;
			};

			this.dispose = function () {};
		}

	}

	function WebGLMaterials(properties) {
		function refreshFogUniforms(uniforms, fog) {
			uniforms.fogColor.value.copy(fog.color);

			if (fog.isFog) {
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
			} else if (fog.isFogExp2) {
				uniforms.fogDensity.value = fog.density;
			}
		}

		function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
			if (material.isMeshBasicMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isMeshLambertMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsLambert(uniforms, material);
			} else if (material.isMeshToonMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsToon(uniforms, material);
			} else if (material.isMeshPhongMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsPhong(uniforms, material);
			} else if (material.isMeshStandardMaterial) {
				refreshUniformsCommon(uniforms, material);

				if (material.isMeshPhysicalMaterial) {
					refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
				} else {
					refreshUniformsStandard(uniforms, material);
				}
			} else if (material.isMeshMatcapMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsMatcap(uniforms, material);
			} else if (material.isMeshDepthMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDepth(uniforms, material);
			} else if (material.isMeshDistanceMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDistance(uniforms, material);
			} else if (material.isMeshNormalMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsNormal(uniforms, material);
			} else if (material.isLineBasicMaterial) {
				refreshUniformsLine(uniforms, material);

				if (material.isLineDashedMaterial) {
					refreshUniformsDash(uniforms, material);
				}
			} else if (material.isPointsMaterial) {
				refreshUniformsPoints(uniforms, material, pixelRatio, height);
			} else if (material.isSpriteMaterial) {
				refreshUniformsSprites(uniforms, material);
			} else if (material.isShadowMaterial) {
				uniforms.color.value.copy(material.color);
				uniforms.opacity.value = material.opacity;
			} else if (material.isShaderMaterial) {
				material.uniformsNeedUpdate = false; // #15581
			}
		}

		function refreshUniformsCommon(uniforms, material) {
			uniforms.opacity.value = material.opacity;

			if (material.color) {
				uniforms.diffuse.value.copy(material.color);
			}

			if (material.emissive) {
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
			}

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.specularMap) {
				uniforms.specularMap.value = material.specularMap;
			}

			const envMap = properties.get(material).envMap;

			if (envMap) {
				uniforms.envMap.value = envMap;
				uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				const maxMipLevel = properties.get(envMap).__maxMipLevel;

				if (maxMipLevel !== undefined) {
					uniforms.maxMipLevel.value = maxMipLevel;
				}
			}

			if (material.lightMap) {
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
			}

			if (material.aoMap) {
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map
			// 13. specular intensity map
			// 14. specular tint map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.specularMap) {
				uvScaleMap = material.specularMap;
			} else if (material.displacementMap) {
				uvScaleMap = material.displacementMap;
			} else if (material.normalMap) {
				uvScaleMap = material.normalMap;
			} else if (material.bumpMap) {
				uvScaleMap = material.bumpMap;
			} else if (material.roughnessMap) {
				uvScaleMap = material.roughnessMap;
			} else if (material.metalnessMap) {
				uvScaleMap = material.metalnessMap;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			} else if (material.emissiveMap) {
				uvScaleMap = material.emissiveMap;
			} else if (material.clearcoatMap) {
				uvScaleMap = material.clearcoatMap;
			} else if (material.clearcoatNormalMap) {
				uvScaleMap = material.clearcoatNormalMap;
			} else if (material.clearcoatRoughnessMap) {
				uvScaleMap = material.clearcoatRoughnessMap;
			} else if (material.specularIntensityMap) {
				uvScaleMap = material.specularIntensityMap;
			} else if (material.specularTintMap) {
				uvScaleMap = material.specularTintMap;
			}

			if (uvScaleMap !== undefined) {
				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {
					uvScaleMap = uvScaleMap.texture;
				}

				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			} // uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map


			let uv2ScaleMap;

			if (material.aoMap) {
				uv2ScaleMap = material.aoMap;
			} else if (material.lightMap) {
				uv2ScaleMap = material.lightMap;
			}

			if (uv2ScaleMap !== undefined) {
				// backwards compatibility
				if (uv2ScaleMap.isWebGLRenderTarget) {
					uv2ScaleMap = uv2ScaleMap.texture;
				}

				if (uv2ScaleMap.matrixAutoUpdate === true) {
					uv2ScaleMap.updateMatrix();
				}

				uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
			}
		}

		function refreshUniformsLine(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		}

		function refreshUniformsDash(uniforms, material) {
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
		}

		function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsSprites(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsLambert(uniforms, material) {
			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}
		}

		function refreshUniformsPhong(uniforms, material) {
			uniforms.specular.value.copy(material.specular);
			uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsToon(uniforms, material) {
			if (material.gradientMap) {
				uniforms.gradientMap.value = material.gradientMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsStandard(uniforms, material) {
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if (material.roughnessMap) {
				uniforms.roughnessMap.value = material.roughnessMap;
			}

			if (material.metalnessMap) {
				uniforms.metalnessMap.value = material.metalnessMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			const envMap = properties.get(material).envMap;

			if (envMap) {
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
			}
		}

		function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
			refreshUniformsStandard(uniforms, material);
			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if (material.sheen) uniforms.sheen.value.copy(material.sheen);

			if (material.clearcoatMap) {
				uniforms.clearcoatMap.value = material.clearcoatMap;
			}

			if (material.clearcoatRoughnessMap) {
				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
			}

			if (material.clearcoatNormalMap) {
				uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if (material.side === BackSide) {
					uniforms.clearcoatNormalScale.value.negate();
				}
			}

			uniforms.transmission.value = material.transmission;

			if (material.transmissionMap) {
				uniforms.transmissionMap.value = material.transmissionMap;
			}

			if (material.transmission > 0.0) {
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
			}

			uniforms.thickness.value = material.thickness;

			if (material.thicknessMap) {
				uniforms.thicknessMap.value = material.thicknessMap;
			}

			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationTint.value.copy(material.attenuationTint);
			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularTint.value.copy(material.specularTint);

			if (material.specularIntensityMap) {
				uniforms.specularIntensityMap.value = material.specularIntensityMap;
			}

			if (material.specularTintMap) {
				uniforms.specularTintMap.value = material.specularTintMap;
			}
		}

		function refreshUniformsMatcap(uniforms, material) {
			if (material.matcap) {
				uniforms.matcap.value = material.matcap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDepth(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDistance(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			uniforms.referencePosition.value.copy(material.referencePosition);
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
		}

		function refreshUniformsNormal(uniforms, material) {
			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};
	}

	function createCanvasElement() {
		const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		canvas.style.display = 'block';
		return canvas;
	}

	function WebGLRenderer(parameters = {}) {
		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
					_context = parameters.context !== undefined ? parameters.context : null,
					_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
					_depth = parameters.depth !== undefined ? parameters.depth : true,
					_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
					_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
					_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
					_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
					_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
					_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		let currentRenderList = null;
		let currentRenderState = null; // render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = []; // public properties

		this.domElement = _canvas; // Debug configuration container

		this.debug = {
			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		}; // clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true; // scene graph

		this.sortObjects = true; // user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false; // physically based shading

		this.gammaFactor = 2.0; // for backwards compatibility

		this.outputEncoding = LinearEncoding; // physical lights

		this.physicallyCorrectLights = false; // tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0; // internal properties

		const _this = this;

		let _isContextLost = false; // internal state cache

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;

		let _currentMaterialId = -1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();

		const _currentScissor = new Vector4();

		let _currentScissorTest = null; //

		let _width = _canvas.width;
		let _height = _canvas.height;
		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4(0, 0, _width, _height);

		const _scissor = new Vector4(0, 0, _width, _height);

		let _scissorTest = false; //

		const _currentDrawBuffers = []; // frustum

		const _frustum = new Frustum(); // clipping


		let _clippingEnabled = false;
		let _localClippingEnabled = false; // transmission

		let _transmissionRenderTarget = null; // camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		const _emptyScene = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: true
		};

		function getTargetPixelRatio() {
			return _currentRenderTarget === null ? _pixelRatio : 1;
		} // initialize


		let _gl = _context;

		function getContext(contextNames, contextAttributes) {
			for (let i = 0; i < contextNames.length; i++) {
				const contextName = contextNames[i];

				const context = _canvas.getContext(contextName, contextAttributes);

				if (context !== null) return context;
			}

			return null;
		}

		try {
			const contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			}; // event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener('webglcontextlost', onContextLost, false);

			_canvas.addEventListener('webglcontextrestored', onContextRestore, false);

			if (_gl === null) {
				const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

				if (_this.isWebGL1Renderer === true) {
					contextNames.shift();
				}

				_gl = getContext(contextNames, contextAttributes);

				if (_gl === null) {
					if (getContext(contextNames)) {
						throw new Error('Error creating WebGL context with your selected attributes.');
					} else {
						throw new Error('Error creating WebGL context.');
					}
				}
			} // Some experimental-webgl implementations do not have getShaderPrecisionFormat


			if (_gl.getShaderPrecisionFormat === undefined) {
				_gl.getShaderPrecisionFormat = function () {
					return {
						'rangeMin': 1,
						'rangeMax': 1,
						'precision': 1
					};
				};
			}
		} catch (error) {
			console.error('THREE.WebGLRenderer: ' + error.message);
			throw error;
		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;
		let background, morphtargets, bufferRenderer, indexedBufferRenderer;
		let utils, bindingStates;

		function initGLContext() {
			extensions = new WebGLExtensions(_gl);
			capabilities = new WebGLCapabilities(_gl, extensions, parameters);
			extensions.init(capabilities);
			utils = new WebGLUtils(_gl, extensions, capabilities);
			state = new WebGLState(_gl, extensions, capabilities);
			_currentDrawBuffers[0] = _gl.BACK;
			info = new WebGLInfo(_gl);
			properties = new WebGLProperties();
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
			cubemaps = new WebGLCubeMaps(_this);
			cubeuvmaps = new WebGLCubeUVMaps(_this);
			attributes = new WebGLAttributes(_gl, capabilities);
			bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
			geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
			objects = new WebGLObjects(_gl, geometries, attributes, info);
			morphtargets = new WebGLMorphtargets(_gl);
			clipping = new WebGLClipping(properties);
			programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
			materials = new WebGLMaterials(properties);
			renderLists = new WebGLRenderLists(properties);
			renderStates = new WebGLRenderStates(extensions, capabilities);
			background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
			shadowMap = new WebGLShadowMap(_this, objects, capabilities);
			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
			info.programs = programCache.programs;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;
		}

		initGLContext(); // xr

		const xr = new WebXRManager(_this, _gl);
		this.xr = xr; // API

		this.getContext = function () {
			return _gl;
		};

		this.getContextAttributes = function () {
			return _gl.getContextAttributes();
		};

		this.forceContextLoss = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.loseContext();
		};

		this.forceContextRestore = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.restoreContext();
		};

		this.getPixelRatio = function () {
			return _pixelRatio;
		};

		this.setPixelRatio = function (value) {
			if (value === undefined) return;
			_pixelRatio = value;
			this.setSize(_width, _height, false);
		};

		this.getSize = function (target) {
			return target.set(_width, _height);
		};

		this.setSize = function (width, height, updateStyle) {
			if (xr.isPresenting) {
				console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
				return;
			}

			_width = width;
			_height = height;
			_canvas.width = Math.floor(width * _pixelRatio);
			_canvas.height = Math.floor(height * _pixelRatio);

			if (updateStyle !== false) {
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
			}

			this.setViewport(0, 0, width, height);
		};

		this.getDrawingBufferSize = function (target) {
			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
		};

		this.setDrawingBufferSize = function (width, height, pixelRatio) {
			_width = width;
			_height = height;
			_pixelRatio = pixelRatio;
			_canvas.width = Math.floor(width * pixelRatio);
			_canvas.height = Math.floor(height * pixelRatio);
			this.setViewport(0, 0, width, height);
		};

		this.getCurrentViewport = function (target) {
			return target.copy(_currentViewport);
		};

		this.getViewport = function (target) {
			return target.copy(_viewport);
		};

		this.setViewport = function (x, y, width, height) {
			if (x.isVector4) {
				_viewport.set(x.x, x.y, x.z, x.w);
			} else {
				_viewport.set(x, y, width, height);
			}

			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissor = function (target) {
			return target.copy(_scissor);
		};

		this.setScissor = function (x, y, width, height) {
			if (x.isVector4) {
				_scissor.set(x.x, x.y, x.z, x.w);
			} else {
				_scissor.set(x, y, width, height);
			}

			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissorTest = function () {
			return _scissorTest;
		};

		this.setScissorTest = function (boolean) {
			state.setScissorTest(_scissorTest = boolean);
		};

		this.setOpaqueSort = function (method) {
			_opaqueSort = method;
		};

		this.setTransparentSort = function (method) {
			_transparentSort = method;
		}; // Clearing


		this.getClearColor = function (target) {
			return target.copy(background.getClearColor());
		};

		this.setClearColor = function () {
			background.setClearColor.apply(background, arguments);
		};

		this.getClearAlpha = function () {
			return background.getClearAlpha();
		};

		this.setClearAlpha = function () {
			background.setClearAlpha.apply(background, arguments);
		};

		this.clear = function (color, depth, stencil) {
			let bits = 0;
			if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
			if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
			if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear(bits);
		};

		this.clearColor = function () {
			this.clear(true, false, false);
		};

		this.clearDepth = function () {
			this.clear(false, true, false);
		};

		this.clearStencil = function () {
			this.clear(false, false, true);
		}; //


		this.dispose = function () {
			_canvas.removeEventListener('webglcontextlost', onContextLost, false);

			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			xr.dispose();
			xr.removeEventListener('sessionstart', onXRSessionStart);
			xr.removeEventListener('sessionend', onXRSessionEnd);

			if (_transmissionRenderTarget) {
				_transmissionRenderTarget.dispose();

				_transmissionRenderTarget = null;
			}

			animation.stop();
		}; // Events


		function onContextLost(event) {
			event.preventDefault();
			console.log('THREE.WebGLRenderer: Context Lost.');
			_isContextLost = true;
		}

		function onContextRestore()
		/* event */
		{
			console.log('THREE.WebGLRenderer: Context Restored.');
			_isContextLost = false;
			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;
			initGLContext();
			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;
		}

		function onMaterialDispose(event) {
			const material = event.target;
			material.removeEventListener('dispose', onMaterialDispose);
			deallocateMaterial(material);
		} // Buffer deallocation


		function deallocateMaterial(material) {
			releaseMaterialProgramReferences(material);
			properties.remove(material);
		}

		function releaseMaterialProgramReferences(material) {
			const programs = properties.get(material).programs;

			if (programs !== undefined) {
				programs.forEach(function (program) {
					programCache.releaseProgram(program);
				});
			}
		} // Buffer rendering


		function renderObjectImmediate(object, program) {
			object.render(function (object) {
				_this.renderBufferImmediate(object, program);
			});
		}

		this.renderBufferImmediate = function (object, program) {
			bindingStates.initAttributes();
			const buffers = properties.get(object);
			if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
			if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
			if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
			if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
			const programAttributes = program.getAttributes();

			if (object.hasPositions) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.position);

				_gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasNormals) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.normal);

				_gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasUvs) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.uv);

				_gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasColors) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.color);

				_gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
			}

			bindingStates.disableUnusedAttributes();

			_gl.drawArrays(_gl.TRIANGLES, 0, object.count);

			object.count = 0;
		};

		this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
			if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
			const program = setProgram(camera, scene, material, object);
			state.setMaterial(material, frontFaceCW); //

			let index = geometry.index;
			const position = geometry.attributes.position; //

			if (index === null) {
				if (position === undefined || position.count === 0) return;
			} else if (index.count === 0) {
				return;
			} //


			let rangeFactor = 1;

			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry);
				rangeFactor = 2;
			}

			if (geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined) {
				morphtargets.update(object, geometry, material, program);
			}

			bindingStates.setup(object, material, program, geometry, index);
			let attribute;
			let renderer = bufferRenderer;

			if (index !== null) {
				attribute = attributes.get(index);
				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute);
			} //


			const dataCount = index !== null ? index.count : position.count;
			const rangeStart = geometry.drawRange.start * rangeFactor;
			const rangeCount = geometry.drawRange.count * rangeFactor;
			const groupStart = group !== null ? group.start * rangeFactor : 0;
			const groupCount = group !== null ? group.count * rangeFactor : Infinity;
			const drawStart = Math.max(rangeStart, groupStart);
			const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
			const drawCount = Math.max(0, drawEnd - drawStart + 1);
			if (drawCount === 0) return; //

			if (object.isMesh) {
				if (material.wireframe === true) {
					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(_gl.LINES);
				} else {
					renderer.setMode(_gl.TRIANGLES);
				}
			} else if (object.isLine) {
				let lineWidth = material.linewidth;
				if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio());

				if (object.isLineSegments) {
					renderer.setMode(_gl.LINES);
				} else if (object.isLineLoop) {
					renderer.setMode(_gl.LINE_LOOP);
				} else {
					renderer.setMode(_gl.LINE_STRIP);
				}
			} else if (object.isPoints) {
				renderer.setMode(_gl.POINTS);
			} else if (object.isSprite) {
				renderer.setMode(_gl.TRIANGLES);
			}

			if (object.isInstancedMesh) {
				renderer.renderInstances(drawStart, drawCount, object.count);
			} else if (geometry.isInstancedBufferGeometry) {
				const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
				renderer.renderInstances(drawStart, drawCount, instanceCount);
			} else {
				renderer.render(drawStart, drawCount);
			}
		}; // Compile


		this.compile = function (scene, camera) {
			currentRenderState = renderStates.get(scene);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);
			scene.traverseVisible(function (object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				}
			});
			currentRenderState.setupLights();
			scene.traverse(function (object) {
				const material = object.material;

				if (material) {
					if (Array.isArray(material)) {
						for (let i = 0; i < material.length; i++) {
							const material2 = material[i];
							getProgram(material2, scene, object);
						}
					} else {
						getProgram(material, scene, object);
					}
				}
			});
			renderStateStack.pop();
			currentRenderState = null;
		}; // Animation Loop


		let onAnimationFrameCallback = null;

		function onAnimationFrame(time) {
			if (onAnimationFrameCallback) onAnimationFrameCallback(time);
		}

		function onXRSessionStart() {
			animation.stop();
		}

		function onXRSessionEnd() {
			animation.start();
		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);
		if (typeof window !== 'undefined') animation.setContext(window);

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
			xr.setAnimationLoop(callback);
			callback === null ? animation.stop() : animation.start();
		};

		xr.addEventListener('sessionstart', onXRSessionStart);
		xr.addEventListener('sessionend', onXRSessionEnd); // Rendering

		this.render = function (scene, camera) {
			if (camera !== undefined && camera.isCamera !== true) {
				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
				return;
			}

			if (_isContextLost === true) return; // update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld();

			if (xr.enabled === true && xr.isPresenting === true) {
				if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
				camera = xr.getCamera(); // use XR camera for rendering
			} //


			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
			currentRenderState = renderStates.get(scene, renderStateStack.length);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			_frustum.setFromProjectionMatrix(_projScreenMatrix);

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
			currentRenderList = renderLists.get(scene, renderListStack.length);
			currentRenderList.init();
			renderListStack.push(currentRenderList);
			projectObject(scene, camera, 0, _this.sortObjects);
			currentRenderList.finish();

			if (_this.sortObjects === true) {
				currentRenderList.sort(_opaqueSort, _transparentSort);
			} //


			if (_clippingEnabled === true) clipping.beginShadows();
			const shadowsArray = currentRenderState.state.shadowsArray;
			shadowMap.render(shadowsArray, scene, camera);
			currentRenderState.setupLights();
			currentRenderState.setupLightsView(camera);
			if (_clippingEnabled === true) clipping.endShadows(); //

			if (this.info.autoReset === true) this.info.reset(); //

			background.render(currentRenderList, scene); // render scene

			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;
			const transparentObjects = currentRenderList.transparent;
			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
			if (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //

			if (_currentRenderTarget !== null) {
				// resolve multisample renderbuffers to a single-sample texture if necessary
				textures.updateMultisampleRenderTarget(_currentRenderTarget); // Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap(_currentRenderTarget);
			} //


			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);
			state.setPolygonOffset(false); // _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = -1;
			_currentCamera = null;
			renderStateStack.pop();

			if (renderStateStack.length > 0) {
				currentRenderState = renderStateStack[renderStateStack.length - 1];
			} else {
				currentRenderState = null;
			}

			renderListStack.pop();

			if (renderListStack.length > 0) {
				currentRenderList = renderListStack[renderListStack.length - 1];
			} else {
				currentRenderList = null;
			}
		};

		function projectObject(object, camera, groupOrder, sortObjects) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);

			if (visible) {
				if (object.isGroup) {
					groupOrder = object.renderOrder;
				} else if (object.isLOD) {
					if (object.autoUpdate === true) object.update(camera);
				} else if (object.isLight) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						const geometry = objects.update(object);
						const material = object.material;

						if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				} else if (object.isImmediateRenderObject) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}

					currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (object.isSkinnedMesh) {
						// update skeleton only once in a frame
						if (object.skeleton.frame !== info.render.frame) {
							object.skeleton.update();
							object.skeleton.frame = info.render.frame;
						}
					}

					if (!object.frustumCulled || _frustum.intersectsObject(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						const geometry = objects.update(object);
						const material = object.material;

						if (Array.isArray(material)) {
							const groups = geometry.groups;

							for (let i = 0, l = groups.length; i < l; i++) {
								const group = groups[i];
								const groupMaterial = material[group.materialIndex];

								if (groupMaterial && groupMaterial.visible) {
									currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
								}
							}
						} else if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				}
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				projectObject(children[i], camera, groupOrder, sortObjects);
			}
		}

		function renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {
			if (_transmissionRenderTarget === null) {
				const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
				const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
				_transmissionRenderTarget = new renderTargetType(1024, 1024, {
					generateMipmaps: true,
					type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					magFilter: NearestFilter,
					wrapS: ClampToEdgeWrapping,
					wrapT: ClampToEdgeWrapping
				});
			}

			const currentRenderTarget = _this.getRenderTarget();

			_this.setRenderTarget(_transmissionRenderTarget);

			_this.clear(); // Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.


			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;
			renderObjects(opaqueObjects, scene, camera);
			_this.toneMapping = currentToneMapping;
			textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
			textures.updateRenderTargetMipmap(_transmissionRenderTarget);

			_this.setRenderTarget(currentRenderTarget);

			renderObjects(transmissiveObjects, scene, camera);
		}

		function renderObjects(renderList, scene, camera) {
			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			if (camera.isArrayCamera) {
				const cameras = camera.cameras;

				for (let i = 0, l = cameras.length; i < l; i++) {
					const camera2 = cameras[i];
					state.viewport(_currentViewport.copy(camera2.viewport));
					currentRenderState.setupLightsView(camera2);

					for (let j = 0, jl = renderList.length; j < jl; j++) {
						const renderItem = renderList[j];
						const object = renderItem.object;
						const geometry = renderItem.geometry;
						const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
						const group = renderItem.group;

						if (object.layers.test(camera2.layers)) {
							renderObject(object, scene, camera2, geometry, material, group);
						}
					}
				}
			} else {
				for (let j = 0, jl = renderList.length; j < jl; j++) {
					const renderItem = renderList[j];
					const object = renderItem.object;
					const geometry = renderItem.geometry;
					const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
					const group = renderItem.group;
					renderObject(object, scene, camera, geometry, material, group);
				}
			}
		}

		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group);
			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

			if (object.isImmediateRenderObject) {
				const program = setProgram(camera, scene, material, object);
				state.setMaterial(material);
				bindingStates.reset();
				renderObjectImmediate(object, program);
			} else {
				if (material.transparent === true && material.side === DoubleSide) {
					material.side = BackSide;
					material.needsUpdate = true;

					_this.renderBufferDirect(camera, scene, geometry, material, object, group);

					material.side = FrontSide;
					material.needsUpdate = true;

					_this.renderBufferDirect(camera, scene, geometry, material, object, group);

					material.side = DoubleSide;
				} else {
					_this.renderBufferDirect(camera, scene, geometry, material, object, group);
				}
			}

			object.onAfterRender(_this, scene, camera, geometry, material, group);
		}

		function getProgram(material, scene, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;
			const lightsStateVersion = lights.state.version;
			const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
			const programCacheKey = programCache.getProgramCacheKey(parameters);
			let programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);

			if (programs === undefined) {
				// new material
				material.addEventListener('dispose', onMaterialDispose);
				programs = new Map();
				materialProperties.programs = programs;
			}

			let program = programs.get(programCacheKey);

			if (program !== undefined) {
				// early out if program and light state is identical
				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
					updateCommonMaterialProperties(material, parameters);
					return program;
				}
			} else {
				parameters.uniforms = programCache.getUniforms(material);
				material.onBuild(parameters, _this);
				material.onBeforeCompile(parameters, _this);
				program = programCache.acquireProgram(parameters, programCacheKey);
				programs.set(programCacheKey, program);
				materialProperties.uniforms = parameters.uniforms;
			}

			const uniforms = materialProperties.uniforms;

			if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
				uniforms.clippingPlanes = clipping.uniform;
			}

			updateCommonMaterialProperties(material, parameters); // store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights(material);
			materialProperties.lightsStateVersion = lightsStateVersion;

			if (materialProperties.needsLights) {
				// wire up the material to this renderer's lighting state
				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;
				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
			}

			const progUniforms = program.getUniforms();
			const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
			materialProperties.currentProgram = program;
			materialProperties.uniformsList = uniformsList;
			return program;
		}

		function updateCommonMaterialProperties(material, parameters) {
			const materialProperties = properties.get(material);
			materialProperties.outputEncoding = parameters.outputEncoding;
			materialProperties.instancing = parameters.instancing;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
		}

		function setProgram(camera, scene, material, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();
			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			const vertexAlphas = material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
			const vertexTangents = !!object.geometry && !!object.geometry.attributes.tangent;
			const morphTargets = !!object.geometry && !!object.geometry.morphAttributes.position;
			const morphNormals = !!object.geometry && !!object.geometry.morphAttributes.normal;
			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;

			if (_clippingEnabled === true) {
				if (_localClippingEnabled === true || camera !== _currentCamera) {
					const useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)

					clipping.setState(material, camera, useCache);
				}
			} //


			let needsProgramChange = false;

			if (material.version === materialProperties.__version) {
				if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
					needsProgramChange = true;
				} else if (materialProperties.outputEncoding !== encoding) {
					needsProgramChange = true;
				} else if (object.isInstancedMesh && materialProperties.instancing === false) {
					needsProgramChange = true;
				} else if (!object.isInstancedMesh && materialProperties.instancing === true) {
					needsProgramChange = true;
				} else if (object.isSkinnedMesh && materialProperties.skinning === false) {
					needsProgramChange = true;
				} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
					needsProgramChange = true;
				} else if (materialProperties.envMap !== envMap) {
					needsProgramChange = true;
				} else if (material.fog && materialProperties.fog !== fog) {
					needsProgramChange = true;
				} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
					needsProgramChange = true;
				} else if (materialProperties.vertexAlphas !== vertexAlphas) {
					needsProgramChange = true;
				} else if (materialProperties.vertexTangents !== vertexTangents) {
					needsProgramChange = true;
				} else if (materialProperties.morphTargets !== morphTargets) {
					needsProgramChange = true;
				} else if (materialProperties.morphNormals !== morphNormals) {
					needsProgramChange = true;
				}
			} else {
				needsProgramChange = true;
				materialProperties.__version = material.version;
			} //


			let program = materialProperties.currentProgram;

			if (needsProgramChange === true) {
				program = getProgram(material, scene, object);
			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;
			const p_uniforms = program.getUniforms(),
						m_uniforms = materialProperties.uniforms;

			if (state.useProgram(program.program)) {
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
			}

			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id;
				refreshMaterial = true;
			}

			if (refreshProgram || _currentCamera !== camera) {
				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

				if (capabilities.logarithmicDepthBuffer) {
					p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
				}

				if (_currentCamera !== camera) {
					_currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true; // set to true on material change

					refreshLights = true; // remains set until update done
				} // load material specific uniforms
				// (shader material also gets them for the sake of genericity)


				if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
					const uCamPos = p_uniforms.map.cameraPosition;

					if (uCamPos !== undefined) {
						uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
					}
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
					p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
				}
			} // skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures


			if (object.isSkinnedMesh) {
				p_uniforms.setOptional(_gl, object, 'bindMatrix');
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
				const skeleton = object.skeleton;

				if (skeleton) {
					if (capabilities.floatVertexTextures) {
						if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
					} else {
						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
					}
				}
			}

			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
			}

			if (refreshMaterial) {
				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

				if (materialProperties.needsLights) {
					// the current material requires lighting info
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
				} // refresh uniforms common to several materials


				if (fog && material.fog) {
					materials.refreshFogUniforms(m_uniforms, fog);
				}

				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			}

			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
				material.uniformsNeedUpdate = false;
			}

			if (material.isSpriteMaterial) {
				p_uniforms.setValue(_gl, 'center', object.center);
			} // common matrices


			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
			return program;
		} // If uniforms are marked as clean, they don't need to be loaded to the GPU.


		function markUniformsLightsNeedsUpdate(uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;
			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
		}

		function materialNeedsLights(material) {
			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
		}

		this.getActiveCubeFace = function () {
			return _currentActiveCubeFace;
		};

		this.getActiveMipmapLevel = function () {
			return _currentActiveMipmapLevel;
		};

		this.getRenderTarget = function () {
			return _currentRenderTarget;
		};

		this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
				textures.setupRenderTarget(renderTarget);
			}

			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;

			if (renderTarget) {
				const texture = renderTarget.texture;

				if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
					isRenderTarget3D = true;
				}

				const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

				if (renderTarget.isWebGLCubeRenderTarget) {
					framebuffer = __webglFramebuffer[activeCubeFace];
					isCube = true;
				} else if (renderTarget.isWebGLMultisampleRenderTarget) {
					framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
				} else {
					framebuffer = __webglFramebuffer;
				}

				_currentViewport.copy(renderTarget.viewport);

				_currentScissor.copy(renderTarget.scissor);

				_currentScissorTest = renderTarget.scissorTest;
			} else {
				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

				_currentScissorTest = _scissorTest;
			}

			const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (framebufferBound && capabilities.drawBuffers) {
				let needsUpdate = false;

				if (renderTarget) {
					if (renderTarget.isWebGLMultipleRenderTargets) {
						const textures = renderTarget.texture;

						if (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							for (let i = 0, il = textures.length; i < il; i++) {
								_currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i;
							}

							_currentDrawBuffers.length = textures.length;
							needsUpdate = true;
						}
					} else {
						if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							_currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;
							_currentDrawBuffers.length = 1;
							needsUpdate = true;
						}
					}
				} else {
					if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {
						_currentDrawBuffers[0] = _gl.BACK;
						_currentDrawBuffers.length = 1;
						needsUpdate = true;
					}
				}

				if (needsUpdate) {
					if (capabilities.isWebGL2) {
						_gl.drawBuffers(_currentDrawBuffers);
					} else {
						extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);
					}
				}
			}

			state.viewport(_currentViewport);
			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);

			if (isCube) {
				const textureProperties = properties.get(renderTarget.texture);

				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
			} else if (isRenderTarget3D) {
				const textureProperties = properties.get(renderTarget.texture);
				const layer = activeCubeFace || 0;

				_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
			}
		};

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
				return;
			}

			let framebuffer = properties.get(renderTarget).__webglFramebuffer;

			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
				framebuffer = framebuffer[activeCubeFaceIndex];
			}

			if (framebuffer) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

				try {
					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
						return;
					}

					const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));

					if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
					!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
					!halfFloatSupportedByExt) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
						return;
					}

					if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
						if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
							_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
						}
					} else {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
					}
				} finally {
					// restore framebuffer of current render target if necessary
					const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
					state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				}
			}
		};

		this.copyFramebufferToTexture = function (position, texture, level = 0) {
			const levelScale = Math.pow(2, -level);
			const width = Math.floor(texture.image.width * levelScale);
			const height = Math.floor(texture.image.height * levelScale);
			let glFormat = utils.convert(texture.format);

			if (capabilities.isWebGL2) {
				// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
				// Not needed in Chrome 93+
				if (glFormat === _gl.RGB) glFormat = _gl.RGB8;
				if (glFormat === _gl.RGBA) glFormat = _gl.RGBA8;
			}

			textures.setTexture2D(texture, 0);

			_gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);

			state.unbindTexture();
		};

		this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			if (srcTexture.isDataTexture) {
				_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
				} else {
					_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
				}
			} // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
			state.unbindTexture();
		};

		this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {
			if (_this.isWebGL1Renderer) {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
				return;
			}

			const width = sourceBox.max.x - sourceBox.min.x + 1;
			const height = sourceBox.max.y - sourceBox.min.y + 1;
			const depth = sourceBox.max.z - sourceBox.min.z + 1;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			let glTarget;

			if (dstTexture.isDataTexture3D) {
				textures.setTexture3D(dstTexture, 0);
				glTarget = _gl.TEXTURE_3D;
			} else if (dstTexture.isDataTexture2DArray) {
				textures.setTexture2DArray(dstTexture, 0);
				glTarget = _gl.TEXTURE_2D_ARRAY;
			} else {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
				return;
			}

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);

			const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);

			const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);

			const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);

			const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);

			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);

			if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
				_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');

					_gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
				} else {
					_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
				}
			}

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
			state.unbindTexture();
		};

		this.initTexture = function (texture) {
			textures.setTexture2D(texture, 0);
			state.unbindTexture();
		};

		this.resetState = function () {
			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;
			state.reset();
			bindingStates.reset();
		};

		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
				detail: this
			})); // eslint-disable-line no-undef

		}
	}

	class WebGL1Renderer extends WebGLRenderer {}

	WebGL1Renderer.prototype.isWebGL1Renderer = true;

	class FogExp2 {
		constructor(color, density = 0.00025) {
			this.name = '';
			this.color = new Color(color);
			this.density = density;
		}

		clone() {
			return new FogExp2(this.color, this.density);
		}

		toJSON()
		/* meta */
		{
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
		}

	}

	FogExp2.prototype.isFogExp2 = true;

	class Fog {
		constructor(color, near = 1, far = 1000) {
			this.name = '';
			this.color = new Color(color);
			this.near = near;
			this.far = far;
		}

		clone() {
			return new Fog(this.color, this.near, this.far);
		}

		toJSON()
		/* meta */
		{
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
		}

	}

	Fog.prototype.isFog = true;

	class Scene extends Object3D {
		constructor() {
			super();
			this.type = 'Scene';
			this.background = null;
			this.environment = null;
			this.fog = null;
			this.overrideMaterial = null;
			this.autoUpdate = true; // checked by the renderer

			if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
				__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
					detail: this
				})); // eslint-disable-line no-undef

			}
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			if (source.background !== null) this.background = source.background.clone();
			if (source.environment !== null) this.environment = source.environment.clone();
			if (source.fog !== null) this.fog = source.fog.clone();
			if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.fog !== null) data.object.fog = this.fog.toJSON();
			return data;
		}

	}

	Scene.prototype.isScene = true;

	class InterleavedBuffer {
		constructor(array, stride) {
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
			this.uuid = generateUUID();
		}

		onUploadCallback() {}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setUsage(value) {
			this.usage = value;
			return this;
		}

		copy(source) {
			this.array = new source.array.constructor(source.array);
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;
			return this;
		}

		copyAt(index1, attribute, index2) {
			index1 *= this.stride;
			index2 *= attribute.stride;

			for (let i = 0, l = this.stride; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		}

		set(value, offset = 0) {
			this.array.set(value, offset);
			return this;
		}

		clone(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			}

			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
			}

			const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
			const ib = new this.constructor(array, this.stride);
			ib.setUsage(this.usage);
			return ib;
		}

		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}

		toJSON(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			} // generate UUID for array buffer if necessary


			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
			} //


			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};
		}

	}

	InterleavedBuffer.prototype.isInterleavedBuffer = true;

	const _vector$6 = /*@__PURE__*/new Vector3();

	class InterleavedBufferAttribute {
		constructor(interleavedBuffer, itemSize, offset, normalized = false) {
			this.name = '';
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
			this.normalized = normalized === true;
		}

		get count() {
			return this.data.count;
		}

		get array() {
			return this.data.array;
		}

		set needsUpdate(value) {
			this.data.needsUpdate = value;
		}

		applyMatrix4(m) {
			for (let i = 0, l = this.data.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyMatrix4(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyNormalMatrix(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.transformDirection(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		setX(index, x) {
			this.data.array[index * this.data.stride + this.offset] = x;
			return this;
		}

		setY(index, y) {
			this.data.array[index * this.data.stride + this.offset + 1] = y;
			return this;
		}

		setZ(index, z) {
			this.data.array[index * this.data.stride + this.offset + 2] = z;
			return this;
		}

		setW(index, w) {
			this.data.array[index * this.data.stride + this.offset + 3] = w;
			return this;
		}

		getX(index) {
			return this.data.array[index * this.data.stride + this.offset];
		}

		getY(index) {
			return this.data.array[index * this.data.stride + this.offset + 1];
		}

		getZ(index) {
			return this.data.array[index * this.data.stride + this.offset + 2];
		}

		getW(index) {
			return this.data.array[index * this.data.stride + this.offset + 3];
		}

		setXY(index, x, y) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			return this;
		}

		setXYZ(index, x, y, z) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			return this;
		}

		setXYZW(index, x, y, z, w) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			this.data.array[index + 3] = w;
			return this;
		}

		clone(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
				const array = [];

				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;

					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				}

				return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
			} else {
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
				}

				return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
			}
		}

		toJSON(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
				const array = [];

				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;

					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				} // deinterleave data and save it as an ordinary buffer attribute for now


				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};
			} else {
				// save as true interlaved attribtue
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};
			}
		}

	}

	InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *	rotation: <float>,
	 *	sizeAttenuation: <bool>
	 * }
	 */

	class SpriteMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'SpriteMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.rotation = 0;
			this.sizeAttenuation = true;
			this.transparent = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.rotation = source.rotation;
			this.sizeAttenuation = source.sizeAttenuation;
			return this;
		}

	}

	SpriteMaterial.prototype.isSpriteMaterial = true;

	let _geometry;

	const _intersectPoint = /*@__PURE__*/new Vector3();

	const _worldScale = /*@__PURE__*/new Vector3();

	const _mvPosition = /*@__PURE__*/new Vector3();

	const _alignedPosition = /*@__PURE__*/new Vector2();

	const _rotatedPosition = /*@__PURE__*/new Vector2();

	const _viewWorldMatrix = /*@__PURE__*/new Matrix4();

	const _vA = /*@__PURE__*/new Vector3();

	const _vB = /*@__PURE__*/new Vector3();

	const _vC = /*@__PURE__*/new Vector3();

	const _uvA = /*@__PURE__*/new Vector2();

	const _uvB = /*@__PURE__*/new Vector2();

	const _uvC = /*@__PURE__*/new Vector2();

	class Sprite extends Object3D {
		constructor(material) {
			super();
			this.type = 'Sprite';

			if (_geometry === undefined) {
				_geometry = new BufferGeometry();
				const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
				const interleavedBuffer = new InterleavedBuffer(float32Array, 5);

				_geometry.setIndex([0, 1, 2, 0, 2, 3]);

				_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

				_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
			}

			this.geometry = _geometry;
			this.material = material !== undefined ? material : new SpriteMaterial();
			this.center = new Vector2(0.5, 0.5);
		}

		raycast(raycaster, intersects) {
			if (raycaster.camera === null) {
				console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
			}

			_worldScale.setFromMatrixScale(this.matrixWorld);

			_viewWorldMatrix.copy(raycaster.camera.matrixWorld);

			this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

			_mvPosition.setFromMatrixPosition(this.modelViewMatrix);

			if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
				_worldScale.multiplyScalar(-_mvPosition.z);
			}

			const rotation = this.material.rotation;
			let sin, cos;

			if (rotation !== 0) {
				cos = Math.cos(rotation);
				sin = Math.sin(rotation);
			}

			const center = this.center;
			transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

			_uvA.set(0, 0);

			_uvB.set(1, 0);

			_uvC.set(1, 1); // check first triangle


			let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);

			if (intersect === null) {
				// check second triangle
				transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

				_uvB.set(0, 1);

				intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);

				if (intersect === null) {
					return;
				}
			}

			const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
				face: null,
				object: this
			});
		}

		copy(source) {
			super.copy(source);
			if (source.center !== undefined) this.center.copy(source.center);
			this.material = source.material;
			return this;
		}

	}

	Sprite.prototype.isSprite = true;

	function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
		// compute position in camera space
		_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


		if (sin !== undefined) {
			_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
			_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
		} else {
			_rotatedPosition.copy(_alignedPosition);
		}

		vertexPosition.copy(mvPosition);
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y; // transform to world space

		vertexPosition.applyMatrix4(_viewWorldMatrix);
	}

	const _v1$2 = /*@__PURE__*/new Vector3();

	const _v2$1 = /*@__PURE__*/new Vector3();

	class LOD extends Object3D {
		constructor() {
			super();
			this._currentLevel = 0;
			this.type = 'LOD';
			Object.defineProperties(this, {
				levels: {
					enumerable: true,
					value: []
				},
				isLOD: {
					value: true
				}
			});
			this.autoUpdate = true;
		}

		copy(source) {
			super.copy(source, false);
			const levels = source.levels;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				this.addLevel(level.object.clone(), level.distance);
			}

			this.autoUpdate = source.autoUpdate;
			return this;
		}

		addLevel(object, distance = 0) {
			distance = Math.abs(distance);
			const levels = this.levels;
			let l;

			for (l = 0; l < levels.length; l++) {
				if (distance < levels[l].distance) {
					break;
				}
			}

			levels.splice(l, 0, {
				distance: distance,
				object: object
			});
			this.add(object);
			return this;
		}

		getCurrentLevel() {
			return this._currentLevel;
		}

		getObjectForDistance(distance) {
			const levels = this.levels;

			if (levels.length > 0) {
				let i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance < levels[i].distance) {
						break;
					}
				}

				return levels[i - 1].object;
			}

			return null;
		}

		raycast(raycaster, intersects) {
			const levels = this.levels;

			if (levels.length > 0) {
				_v1$2.setFromMatrixPosition(this.matrixWorld);

				const distance = raycaster.ray.origin.distanceTo(_v1$2);
				this.getObjectForDistance(distance).raycast(raycaster, intersects);
			}
		}

		update(camera) {
			const levels = this.levels;

			if (levels.length > 1) {
				_v1$2.setFromMatrixPosition(camera.matrixWorld);

				_v2$1.setFromMatrixPosition(this.matrixWorld);

				const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
				levels[0].object.visible = true;
				let i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance >= levels[i].distance) {
						levels[i - 1].object.visible = false;
						levels[i].object.visible = true;
					} else {
						break;
					}
				}

				this._currentLevel = i - 1;

				for (; i < l; i++) {
					levels[i].object.visible = false;
				}
			}
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.autoUpdate === false) data.object.autoUpdate = false;
			data.object.levels = [];
			const levels = this.levels;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance
				});
			}

			return data;
		}

	}

	const _basePosition = /*@__PURE__*/new Vector3();

	const _skinIndex = /*@__PURE__*/new Vector4();

	const _skinWeight = /*@__PURE__*/new Vector4();

	const _vector$5 = /*@__PURE__*/new Vector3();

	const _matrix = /*@__PURE__*/new Matrix4();

	class SkinnedMesh extends Mesh {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'SkinnedMesh';
			this.bindMode = 'attached';
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();
		}

		copy(source) {
			super.copy(source);
			this.bindMode = source.bindMode;
			this.bindMatrix.copy(source.bindMatrix);
			this.bindMatrixInverse.copy(source.bindMatrixInverse);
			this.skeleton = source.skeleton;
			return this;
		}

		bind(skeleton, bindMatrix) {
			this.skeleton = skeleton;

			if (bindMatrix === undefined) {
				this.updateMatrixWorld(true);
				this.skeleton.calculateInverses();
				bindMatrix = this.matrixWorld;
			}

			this.bindMatrix.copy(bindMatrix);
			this.bindMatrixInverse.copy(bindMatrix).invert();
		}

		pose() {
			this.skeleton.pose();
		}

		normalizeSkinWeights() {
			const vector = new Vector4();
			const skinWeight = this.geometry.attributes.skinWeight;

			for (let i = 0, l = skinWeight.count; i < l; i++) {
				vector.x = skinWeight.getX(i);
				vector.y = skinWeight.getY(i);
				vector.z = skinWeight.getZ(i);
				vector.w = skinWeight.getW(i);
				const scale = 1.0 / vector.manhattanLength();

				if (scale !== Infinity) {
					vector.multiplyScalar(scale);
				} else {
					vector.set(1, 0, 0, 0); // do something reasonable
				}

				skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
			}
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);

			if (this.bindMode === 'attached') {
				this.bindMatrixInverse.copy(this.matrixWorld).invert();
			} else if (this.bindMode === 'detached') {
				this.bindMatrixInverse.copy(this.bindMatrix).invert();
			} else {
				console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
			}
		}

		boneTransform(index, target) {
			const skeleton = this.skeleton;
			const geometry = this.geometry;

			_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);

			_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

			_basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);

			target.set(0, 0, 0);

			for (let i = 0; i < 4; i++) {
				const weight = _skinWeight.getComponent(i);

				if (weight !== 0) {
					const boneIndex = _skinIndex.getComponent(i);

					_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);

					target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
				}
			}

			return target.applyMatrix4(this.bindMatrixInverse);
		}

	}

	SkinnedMesh.prototype.isSkinnedMesh = true;

	class Bone extends Object3D {
		constructor() {
			super();
			this.type = 'Bone';
		}

	}

	Bone.prototype.isBone = true;

	class DataTexture extends Texture {
		constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.image = {
				data: data,
				width: width,
				height: height
			};
			this.magFilter = magFilter;
			this.minFilter = minFilter;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture.prototype.isDataTexture = true;

	const _offsetMatrix = /*@__PURE__*/new Matrix4();

	const _identityMatrix = /*@__PURE__*/new Matrix4();

	class Skeleton {
		constructor(bones = [], boneInverses = []) {
			this.uuid = generateUUID();
			this.bones = bones.slice(0);
			this.boneInverses = boneInverses;
			this.boneMatrices = null;
			this.boneTexture = null;
			this.boneTextureSize = 0;
			this.frame = -1;
			this.init();
		}

		init() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary

			if (boneInverses.length === 0) {
				this.calculateInverses();
			} else {
				// handle special case
				if (bones.length !== boneInverses.length) {
					console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
					this.boneInverses = [];

					for (let i = 0, il = this.bones.length; i < il; i++) {
						this.boneInverses.push(new Matrix4());
					}
				}
			}
		}

		calculateInverses() {
			this.boneInverses.length = 0;

			for (let i = 0, il = this.bones.length; i < il; i++) {
				const inverse = new Matrix4();

				if (this.bones[i]) {
					inverse.copy(this.bones[i].matrixWorld).invert();
				}

				this.boneInverses.push(inverse);
			}
		}

		pose() {
			// recover the bind-time world matrices
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone) {
					bone.matrixWorld.copy(this.boneInverses[i]).invert();
				}
			} // compute the local matrices, positions, rotations and scales


			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone) {
					if (bone.parent && bone.parent.isBone) {
						bone.matrix.copy(bone.parent.matrixWorld).invert();
						bone.matrix.multiply(bone.matrixWorld);
					} else {
						bone.matrix.copy(bone.matrixWorld);
					}

					bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
				}
			}
		}

		update() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			const boneMatrices = this.boneMatrices;
			const boneTexture = this.boneTexture; // flatten bone matrices to array

			for (let i = 0, il = bones.length; i < il; i++) {
				// compute the offset between the current and the original transform
				const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

				_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

				_offsetMatrix.toArray(boneMatrices, i * 16);
			}

			if (boneTexture !== null) {
				boneTexture.needsUpdate = true;
			}
		}

		clone() {
			return new Skeleton(this.bones, this.boneInverses);
		}

		computeBoneTexture() {
			// layout (1 matrix = 4 pixels)
			//			RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//	with	8x8	pixel texture max	 16 bones * 4 pixels =	(8 * 8)
			//			 16x16 pixel texture max	 64 bones * 4 pixels = (16 * 16)
			//			 32x32 pixel texture max	256 bones * 4 pixels = (32 * 32)
			//			 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
			let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix

			size = ceilPowerOfTwo(size);
			size = Math.max(size, 4);
			const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

			boneMatrices.set(this.boneMatrices); // copy current values

			const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
			this.boneMatrices = boneMatrices;
			this.boneTexture = boneTexture;
			this.boneTextureSize = size;
			return this;
		}

		getBoneByName(name) {
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone.name === name) {
					return bone;
				}
			}

			return undefined;
		}

		dispose() {
			if (this.boneTexture !== null) {
				this.boneTexture.dispose();
				this.boneTexture = null;
			}
		}

		fromJSON(json, bones) {
			this.uuid = json.uuid;

			for (let i = 0, l = json.bones.length; i < l; i++) {
				const uuid = json.bones[i];
				let bone = bones[uuid];

				if (bone === undefined) {
					console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
					bone = new Bone();
				}

				this.bones.push(bone);
				this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
			}

			this.init();
			return this;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};
			data.uuid = this.uuid;
			const bones = this.bones;
			const boneInverses = this.boneInverses;

			for (let i = 0, l = bones.length; i < l; i++) {
				const bone = bones[i];
				data.bones.push(bone.uuid);
				const boneInverse = boneInverses[i];
				data.boneInverses.push(boneInverse.toArray());
			}

			return data;
		}

	}

	const _instanceLocalMatrix = /*@__PURE__*/new Matrix4();

	const _instanceWorldMatrix = /*@__PURE__*/new Matrix4();

	const _instanceIntersects = [];

	const _mesh = /*@__PURE__*/new Mesh();

	class InstancedMesh extends Mesh {
		constructor(geometry, material, count) {
			super(geometry, material);
			this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
			this.instanceColor = null;
			this.count = count;
			this.frustumCulled = false;
		}

		copy(source) {
			super.copy(source);
			this.instanceMatrix.copy(source.instanceMatrix);
			if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
			this.count = source.count;
			return this;
		}

		getColorAt(index, color) {
			color.fromArray(this.instanceColor.array, index * 3);
		}

		getMatrixAt(index, matrix) {
			matrix.fromArray(this.instanceMatrix.array, index * 16);
		}

		raycast(raycaster, intersects) {
			const matrixWorld = this.matrixWorld;
			const raycastTimes = this.count;
			_mesh.geometry = this.geometry;
			_mesh.material = this.material;
			if (_mesh.material === undefined) return;

			for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
				// calculate the world matrix for each instance
				this.getMatrixAt(instanceId, _instanceLocalMatrix);

				_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


				for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
					const intersect = _instanceIntersects[i];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push(intersect);
				}

				_instanceIntersects.length = 0;
			}
		}

		setColorAt(index, color) {
			if (this.instanceColor === null) {
				this.instanceColor = new BufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
			}

			color.toArray(this.instanceColor.array, index * 3);
		}

		setMatrixAt(index, matrix) {
			matrix.toArray(this.instanceMatrix.array, index * 16);
		}

		updateMorphTargets() {}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	InstancedMesh.prototype.isInstancedMesh = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *	linecap: "round",
	 *	linejoin: "round"
	 * }
	 */

	class LineBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'LineBasicMaterial';
			this.color = new Color(0xffffff);
			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
			return this;
		}

	}

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	const _start$1 = /*@__PURE__*/new Vector3();

	const _end$1 = /*@__PURE__*/new Vector3();

	const _inverseMatrix$1 = /*@__PURE__*/new Matrix4();

	const _ray$1 = /*@__PURE__*/new Ray();

	const _sphere$1 = /*@__PURE__*/new Sphere();

	class Line extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
			super();
			this.type = 'Line';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		computeLineDistances() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					const positionAttribute = geometry.attributes.position;
					const lineDistances = [0];

					for (let i = 1, l = positionAttribute.count; i < l; i++) {
						_start$1.fromBufferAttribute(positionAttribute, i - 1);

						_end$1.fromBufferAttribute(positionAttribute, i);

						lineDistances[i] = lineDistances[i - 1];
						lineDistances[i] += _start$1.distanceTo(_end$1);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;
			const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$1.copy(geometry.boundingSphere);

			_sphere$1.applyMatrix4(matrixWorld);

			_sphere$1.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //

			_inverseMatrix$1.copy(matrixWorld).invert();

			_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;
			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if (index !== null) {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(index.count, drawRange.start + drawRange.count);

					for (let i = start, l = end - 1; i < l; i += step) {
						const a = index.getX(i);
						const b = index.getX(i + 1);
						vStart.fromBufferAttribute(positionAttribute, a);
						vEnd.fromBufferAttribute(positionAttribute, b);

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (let i = start, l = end - 1; i < l; i += step) {
						vStart.fromBufferAttribute(positionAttribute, i);
						vEnd.fromBufferAttribute(positionAttribute, i + 1);

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

	}

	Line.prototype.isLine = true;

	const _start = /*@__PURE__*/new Vector3();

	const _end = /*@__PURE__*/new Vector3();

	class LineSegments extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'LineSegments';
		}

		computeLineDistances() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					const positionAttribute = geometry.attributes.position;
					const lineDistances = [];

					for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
						_start.fromBufferAttribute(positionAttribute, i);

						_end.fromBufferAttribute(positionAttribute, i + 1);

						lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
						lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		}

	}

	LineSegments.prototype.isLineSegments = true;

	class LineLoop extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'LineLoop';
		}

	}

	LineLoop.prototype.isLineLoop = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	size: <float>,
	 *	sizeAttenuation: <bool>
	 *
	 * }
	 */

	class PointsMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'PointsMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.size = 1;
			this.sizeAttenuation = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
			return this;
		}

	}

	PointsMaterial.prototype.isPointsMaterial = true;

	const _inverseMatrix = /*@__PURE__*/new Matrix4();

	const _ray = /*@__PURE__*/new Ray();

	const _sphere = /*@__PURE__*/new Sphere();

	const _position$2 = /*@__PURE__*/new Vector3();

	class Points extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
			super();
			this.type = 'Points';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;
			const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere.copy(geometry.boundingSphere);

			_sphere.applyMatrix4(matrixWorld);

			_sphere.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

			_inverseMatrix.copy(matrixWorld).invert();

			_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if (index !== null) {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(index.count, drawRange.start + drawRange.count);

					for (let i = start, il = end; i < il; i++) {
						const a = index.getX(i);

						_position$2.fromBufferAttribute(positionAttribute, a);

						testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (let i = start, l = end; i < l; i++) {
						_position$2.fromBufferAttribute(positionAttribute, i);

						testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				}
			} else {
				console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

	}

	Points.prototype.isPoints = true;

	function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
		const rayPointDistanceSq = _ray.distanceSqToPoint(point);

		if (rayPointDistanceSq < localThresholdSq) {
			const intersectPoint = new Vector3();

			_ray.closestPointToPoint(point, intersectPoint);

			intersectPoint.applyMatrix4(matrixWorld);
			const distance = raycaster.ray.origin.distanceTo(intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				distanceToRay: Math.sqrt(rayPointDistanceSq),
				point: intersectPoint,
				index: index,
				face: null,
				object: object
			});
		}
	}

	class VideoTexture extends Texture {
		constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.format = format !== undefined ? format : RGBFormat;
			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.generateMipmaps = false;
			const scope = this;

			function updateVideo() {
				scope.needsUpdate = true;
				video.requestVideoFrameCallback(updateVideo);
			}

			if ('requestVideoFrameCallback' in video) {
				video.requestVideoFrameCallback(updateVideo);
			}
		}

		clone() {
			return new this.constructor(this.image).copy(this);
		}

		update() {
			const video = this.image;
			const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);

			if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
				this.needsUpdate = true;
			}
		}

	}

	VideoTexture.prototype.isVideoTexture = true;

	class CompressedTexture extends Texture {
		constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.image = {
				width: width,
				height: height
			};
			this.mipmaps = mipmaps; // no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false; // can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;
		}

	}

	CompressedTexture.prototype.isCompressedTexture = true;

	class CanvasTexture extends Texture {
		constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.needsUpdate = true;
		}

	}

	CanvasTexture.prototype.isCanvasTexture = true;

	class DepthTexture extends Texture {
		constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
			format = format !== undefined ? format : DepthFormat;

			if (format !== DepthFormat && format !== DepthStencilFormat) {
				throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
			}

			if (type === undefined && format === DepthFormat) type = UnsignedShortType;
			if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.image = {
				width: width,
				height: height
			};
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
			this.flipY = false;
			this.generateMipmaps = false;
		}

	}

	DepthTexture.prototype.isDepthTexture = true;

	class CircleGeometry extends BufferGeometry {
		constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CircleGeometry';
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			segments = Math.max(3, segments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const vertex = new Vector3();
			const uv = new Vector2(); // center point

			vertices.push(0, 0, 0);
			normals.push(0, 0, 1);
			uvs.push(0.5, 0.5);

			for (let s = 0, i = 3; s <= segments; s++, i += 3) {
				const segment = thetaStart + s / segments * thetaLength; // vertex

				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);
				vertices.push(vertex.x, vertex.y, vertex.z); // normal

				normals.push(0, 0, 1); // uvs

				uv.x = (vertices[i] / radius + 1) / 2;
				uv.y = (vertices[i + 1] / radius + 1) / 2;
				uvs.push(uv.x, uv.y);
			} // indices


			for (let i = 1; i <= segments; i++) {
				indices.push(i, i + 1, 0);
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
		}

	}

	class CylinderGeometry extends BufferGeometry {
		constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CylinderGeometry';
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			const scope = this;
			radialSegments = Math.floor(radialSegments);
			heightSegments = Math.floor(heightSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0; // generate geometry

			generateTorso();

			if (openEnded === false) {
				if (radiusTop > 0) generateCap(true);
				if (radiusBottom > 0) generateCap(false);
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function generateTorso() {
				const normal = new Vector3();
				const vertex = new Vector3();
				let groupCount = 0; // this will be used to calculate the normal

				const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

				for (let y = 0; y <= heightSegments; y++) {
					const indexRow = [];
					const v = y / heightSegments; // calculate the radius of the current row

					const radius = v * (radiusBottom - radiusTop) + radiusTop;

					for (let x = 0; x <= radialSegments; x++) {
						const u = x / radialSegments;
						const theta = u * thetaLength + thetaStart;
						const sinTheta = Math.sin(theta);
						const cosTheta = Math.cos(theta); // vertex

						vertex.x = radius * sinTheta;
						vertex.y = -v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push(vertex.x, vertex.y, vertex.z); // normal

						normal.set(sinTheta, slope, cosTheta).normalize();
						normals.push(normal.x, normal.y, normal.z); // uv

						uvs.push(u, 1 - v); // save index of vertex in respective row

						indexRow.push(index++);
					} // now save vertices of the row in our index array


					indexArray.push(indexRow);
				} // generate indices


				for (let x = 0; x < radialSegments; x++) {
					for (let y = 0; y < heightSegments; y++) {
						// we use the index array to access the correct indices
						const a = indexArray[y][x];
						const b = indexArray[y + 1][x];
						const c = indexArray[y + 1][x + 1];
						const d = indexArray[y][x + 1]; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // update group counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

				groupStart += groupCount;
			}

			function generateCap(top) {
				// save the index of the first center vertex
				const centerIndexStart = index;
				const uv = new Vector2();
				const vertex = new Vector3();
				let groupCount = 0;
				const radius = top === true ? radiusTop : radiusBottom;
				const sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for (let x = 1; x <= radialSegments; x++) {
					// vertex
					vertices.push(0, halfHeight * sign, 0); // normal

					normals.push(0, sign, 0); // uv

					uvs.push(0.5, 0.5); // increase index

					index++;
				} // save the index of the last center vertex


				const centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

				for (let x = 0; x <= radialSegments; x++) {
					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;
					const cosTheta = Math.cos(theta);
					const sinTheta = Math.sin(theta); // vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, sign, 0); // uv

					uv.x = cosTheta * 0.5 + 0.5;
					uv.y = sinTheta * 0.5 * sign + 0.5;
					uvs.push(uv.x, uv.y); // increase index

					index++;
				} // generate indices


				for (let x = 0; x < radialSegments; x++) {
					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if (top === true) {
						// face top
						indices.push(i, i + 1, c);
					} else {
						// face bottom
						indices.push(i + 1, i, c);
					}

					groupCount += 3;
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

				groupStart += groupCount;
			}
		}

		static fromJSON(data) {
			return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		}

	}

	class ConeGeometry extends CylinderGeometry {
		constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
			this.type = 'ConeGeometry';
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
		}

		static fromJSON(data) {
			return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		}

	}

	class PolyhedronGeometry extends BufferGeometry {
		constructor(vertices, indices, radius = 1, detail = 0) {
			super();
			this.type = 'PolyhedronGeometry';
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			}; // default buffer data

			const vertexBuffer = [];
			const uvBuffer = []; // the subdivision creates the vertex buffer data

			subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

			applyRadius(radius); // finally, create the uv data

			generateUVs(); // build non-indexed geometry

			this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
			this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

			if (detail === 0) {
				this.computeVertexNormals(); // flat normals
			} else {
				this.normalizeNormals(); // smooth normals
			} // helper functions


			function subdivide(detail) {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

				for (let i = 0; i < indices.length; i += 3) {
					// get the vertices of the face
					getVertexByIndex(indices[i + 0], a);
					getVertexByIndex(indices[i + 1], b);
					getVertexByIndex(indices[i + 2], c); // perform subdivision

					subdivideFace(a, b, c, detail);
				}
			}

			function subdivideFace(a, b, c, detail) {
				const cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

				const v = []; // construct all of the vertices for this subdivision

				for (let i = 0; i <= cols; i++) {
					v[i] = [];
					const aj = a.clone().lerp(c, i / cols);
					const bj = b.clone().lerp(c, i / cols);
					const rows = cols - i;

					for (let j = 0; j <= rows; j++) {
						if (j === 0 && i === cols) {
							v[i][j] = aj;
						} else {
							v[i][j] = aj.clone().lerp(bj, j / rows);
						}
					}
				} // construct all of the faces


				for (let i = 0; i < cols; i++) {
					for (let j = 0; j < 2 * (cols - i) - 1; j++) {
						const k = Math.floor(j / 2);

						if (j % 2 === 0) {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k]);
							pushVertex(v[i][k]);
						} else {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k + 1]);
							pushVertex(v[i + 1][k]);
						}
					}
				}
			}

			function applyRadius(radius) {
				const vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					vertex.normalize().multiplyScalar(radius);
					vertexBuffer[i + 0] = vertex.x;
					vertexBuffer[i + 1] = vertex.y;
					vertexBuffer[i + 2] = vertex.z;
				}
			}

			function generateUVs() {
				const vertex = new Vector3();

				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					const u = azimuth(vertex) / 2 / Math.PI + 0.5;
					const v = inclination(vertex) / Math.PI + 0.5;
					uvBuffer.push(u, 1 - v);
				}

				correctUVs();
				correctSeam();
			}

			function correctSeam() {
				// handle case when face straddles the seam, see #3269
				for (let i = 0; i < uvBuffer.length; i += 6) {
					// uv data of a single face
					const x0 = uvBuffer[i + 0];
					const x1 = uvBuffer[i + 2];
					const x2 = uvBuffer[i + 4];
					const max = Math.max(x0, x1, x2);
					const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

					if (max > 0.9 && min < 0.1) {
						if (x0 < 0.2) uvBuffer[i + 0] += 1;
						if (x1 < 0.2) uvBuffer[i + 2] += 1;
						if (x2 < 0.2) uvBuffer[i + 4] += 1;
					}
				}
			}

			function pushVertex(vertex) {
				vertexBuffer.push(vertex.x, vertex.y, vertex.z);
			}

			function getVertexByIndex(index, vertex) {
				const stride = index * 3;
				vertex.x = vertices[stride + 0];
				vertex.y = vertices[stride + 1];
				vertex.z = vertices[stride + 2];
			}

			function correctUVs() {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();
				const centroid = new Vector3();
				const uvA = new Vector2();
				const uvB = new Vector2();
				const uvC = new Vector2();

				for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
					a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
					b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
					c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
					uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
					uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
					uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
					centroid.copy(a).add(b).add(c).divideScalar(3);
					const azi = azimuth(centroid);
					correctUV(uvA, j + 0, a, azi);
					correctUV(uvB, j + 2, b, azi);
					correctUV(uvC, j + 4, c, azi);
				}
			}

			function correctUV(uv, stride, vector, azimuth) {
				if (azimuth < 0 && uv.x === 1) {
					uvBuffer[stride] = uv.x - 1;
				}

				if (vector.x === 0 && vector.z === 0) {
					uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
				}
			} // Angle around the Y axis, counter-clockwise when looking from above.


			function azimuth(vector) {
				return Math.atan2(vector.z, -vector.x);
			} // Angle above the XZ plane.


			function inclination(vector) {
				return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
			}
		}

		static fromJSON(data) {
			return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
		}

	}

	class DodecahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const r = 1 / t;
			const vertices = [// (Â±1, Â±1, Â±1)
			-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, Â±1/Ï†, Â±Ï†)
			0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (Â±1/Ï†, Â±Ï†, 0)
			-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (Â±Ï†, 0, Â±1/Ï†)
			-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
			const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
			super(vertices, indices, radius, detail);
			this.type = 'DodecahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new DodecahedronGeometry(data.radius, data.detail);
		}

	}

	const _v0 = new Vector3();

	const _v1$1 = new Vector3();

	const _normal = new Vector3();

	const _triangle = new Triangle();

	class EdgesGeometry extends BufferGeometry {
		constructor(geometry, thresholdAngle) {
			super();
			this.type = 'EdgesGeometry';
			this.parameters = {
				thresholdAngle: thresholdAngle
			};
			thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;

			if (geometry.isGeometry === true) {
				console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				return;
			}

			const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute('position');
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
			const indexArr = [0, 0, 0];
			const vertKeys = ['a', 'b', 'c'];
			const hashes = new Array(3);
			const edgeData = {};
			const vertices = [];

			for (let i = 0; i < indexCount; i += 3) {
				if (indexAttr) {
					indexArr[0] = indexAttr.getX(i);
					indexArr[1] = indexAttr.getX(i + 1);
					indexArr[2] = indexAttr.getX(i + 2);
				} else {
					indexArr[0] = i;
					indexArr[1] = i + 1;
					indexArr[2] = i + 2;
				}

				const {
					a,
					b,
					c
				} = _triangle;
				a.fromBufferAttribute(positionAttr, indexArr[0]);
				b.fromBufferAttribute(positionAttr, indexArr[1]);
				c.fromBufferAttribute(positionAttr, indexArr[2]);

				_triangle.getNormal(_normal); // create hashes for the edge from the vertices


				hashes[0] = `${a.x},${a.y},${a.z}`;
				hashes[1] = `${b.x},${b.y},${b.z}`;
				hashes[2] = `${c.x},${c.y},${c.z}`; // skip degenerate triangles

				if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
					continue;
				} // iterate over every edge


				for (let j = 0; j < 3; j++) {
					// get the first and next vertex making up the edge
					const jNext = (j + 1) % 3;
					const vecHash0 = hashes[j];
					const vecHash1 = hashes[jNext];
					const v0 = _triangle[vertKeys[j]];
					const v1 = _triangle[vertKeys[jNext]];
					const hash = `${vecHash0}_${vecHash1}`;
					const reverseHash = `${vecHash1}_${vecHash0}`;

					if (reverseHash in edgeData && edgeData[reverseHash]) {
						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
							vertices.push(v0.x, v0.y, v0.z);
							vertices.push(v1.x, v1.y, v1.z);
						}

						edgeData[reverseHash] = null;
					} else if (!(hash in edgeData)) {
						// if we've already got an edge here then skip adding a new one
						edgeData[hash] = {
							index0: indexArr[j],
							index1: indexArr[jNext],
							normal: _normal.clone()
						};
					}
				}
			} // iterate over all remaining, unmatched edges and add them to the vertex array


			for (const key in edgeData) {
				if (edgeData[key]) {
					const {
						index0,
						index1
					} = edgeData[key];

					_v0.fromBufferAttribute(positionAttr, index0);

					_v1$1.fromBufferAttribute(positionAttr, index1);

					vertices.push(_v0.x, _v0.y, _v0.z);
					vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
				}
			}

			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		}

	}

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	class Curve {
		constructor() {
			this.type = 'Curve';
			this.arcLengthDivisions = 200;
		} // Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]


		getPoint()
		/* t, optionalTarget */
		{
			console.warn('THREE.Curve: .getPoint() not implemented.');
			return null;
		} // Get point at relative position in curve according to arc length
		// - u [0 .. 1]


		getPointAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getPoint(t, optionalTarget);
		} // Get sequence of points using getPoint( t )


		getPoints(divisions = 5) {
			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPoint(d / divisions));
			}

			return points;
		} // Get sequence of points using getPointAt( u )


		getSpacedPoints(divisions = 5) {
			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPointAt(d / divisions));
			}

			return points;
		} // Get total curve arc length


		getLength() {
			const lengths = this.getLengths();
			return lengths[lengths.length - 1];
		} // Get list of cumulative segment lengths


		getLengths(divisions = this.arcLengthDivisions) {
			if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
				return this.cacheArcLengths;
			}

			this.needsUpdate = false;
			const cache = [];
			let current,
					last = this.getPoint(0);
			let sum = 0;
			cache.push(0);

			for (let p = 1; p <= divisions; p++) {
				current = this.getPoint(p / divisions);
				sum += current.distanceTo(last);
				cache.push(sum);
				last = current;
			}

			this.cacheArcLengths = cache;
			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
		}

		updateArcLengths() {
			this.needsUpdate = true;
			this.getLengths();
		} // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant


		getUtoTmapping(u, distance) {
			const arcLengths = this.getLengths();
			let i = 0;
			const il = arcLengths.length;
			let targetArcLength; // The targeted u distance value to get

			if (distance) {
				targetArcLength = distance;
			} else {
				targetArcLength = u * arcLengths[il - 1];
			} // binary search for the index with largest value smaller than target u distance


			let low = 0,
					high = il - 1,
					comparison;

			while (low <= high) {
				i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[i] - targetArcLength;

				if (comparison < 0) {
					low = i + 1;
				} else if (comparison > 0) {
					high = i - 1;
				} else {
					high = i;
					break; // DONE
				}
			}

			i = high;

			if (arcLengths[i] === targetArcLength) {
				return i / (il - 1);
			} // we could get finer grain at lengths, or use simple interpolation between two points


			const lengthBefore = arcLengths[i];
			const lengthAfter = arcLengths[i + 1];
			const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

			const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

			const t = (i + segmentFraction) / (il - 1);
			return t;
		} // Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation


		getTangent(t, optionalTarget) {
			const delta = 0.0001;
			let t1 = t - delta;
			let t2 = t + delta; // Capping in case of danger

			if (t1 < 0) t1 = 0;
			if (t2 > 1) t2 = 1;
			const pt1 = this.getPoint(t1);
			const pt2 = this.getPoint(t2);
			const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
			tangent.copy(pt2).sub(pt1).normalize();
			return tangent;
		}

		getTangentAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getTangent(t, optionalTarget);
		}

		computeFrenetFrames(segments, closed) {
			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
			const normal = new Vector3();
			const tangents = [];
			const normals = [];
			const binormals = [];
			const vec = new Vector3();
			const mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

			for (let i = 0; i <= segments; i++) {
				const u = i / segments;
				tangents[i] = this.getTangentAt(u, new Vector3());
				tangents[i].normalize();
			} // select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component


			normals[0] = new Vector3();
			binormals[0] = new Vector3();
			let min = Number.MAX_VALUE;
			const tx = Math.abs(tangents[0].x);
			const ty = Math.abs(tangents[0].y);
			const tz = Math.abs(tangents[0].z);

			if (tx <= min) {
				min = tx;
				normal.set(1, 0, 0);
			}

			if (ty <= min) {
				min = ty;
				normal.set(0, 1, 0);
			}

			if (tz <= min) {
				normal.set(0, 0, 1);
			}

			vec.crossVectors(tangents[0], normal).normalize();
			normals[0].crossVectors(tangents[0], vec);
			binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

			for (let i = 1; i <= segments; i++) {
				normals[i] = normals[i - 1].clone();
				binormals[i] = binormals[i - 1].clone();
				vec.crossVectors(tangents[i - 1], tangents[i]);

				if (vec.length() > Number.EPSILON) {
					vec.normalize();
					const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

					normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
				}

				binormals[i].crossVectors(tangents[i], normals[i]);
			} // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


			if (closed === true) {
				let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
				theta /= segments;

				if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
					theta = -theta;
				}

				for (let i = 1; i <= segments; i++) {
					// twist a little...
					normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
					binormals[i].crossVectors(tangents[i], normals[i]);
				}
			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.arcLengthDivisions = source.arcLengthDivisions;
			return this;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};
			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;
			return data;
		}

		fromJSON(json) {
			this.arcLengthDivisions = json.arcLengthDivisions;
			return this;
		}

	}

	class EllipseCurve extends Curve {
		constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
			super();
			this.type = 'EllipseCurve';
			this.aX = aX;
			this.aY = aY;
			this.xRadius = xRadius;
			this.yRadius = yRadius;
			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;
			this.aClockwise = aClockwise;
			this.aRotation = aRotation;
		}

		getPoint(t, optionalTarget) {
			const point = optionalTarget || new Vector2();
			const twoPi = Math.PI * 2;
			let deltaAngle = this.aEndAngle - this.aStartAngle;
			const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

			while (deltaAngle < 0) deltaAngle += twoPi;

			while (deltaAngle > twoPi) deltaAngle -= twoPi;

			if (deltaAngle < Number.EPSILON) {
				if (samePoints) {
					deltaAngle = 0;
				} else {
					deltaAngle = twoPi;
				}
			}

			if (this.aClockwise === true && !samePoints) {
				if (deltaAngle === twoPi) {
					deltaAngle = -twoPi;
				} else {
					deltaAngle = deltaAngle - twoPi;
				}
			}

			const angle = this.aStartAngle + t * deltaAngle;
			let x = this.aX + this.xRadius * Math.cos(angle);
			let y = this.aY + this.yRadius * Math.sin(angle);

			if (this.aRotation !== 0) {
				const cos = Math.cos(this.aRotation);
				const sin = Math.sin(this.aRotation);
				const tx = x - this.aX;
				const ty = y - this.aY; // Rotate the point about the center of the ellipse.

				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
			}

			return point.set(x, y);
		}

		copy(source) {
			super.copy(source);
			this.aX = source.aX;
			this.aY = source.aY;
			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;
			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;
			this.aClockwise = source.aClockwise;
			this.aRotation = source.aRotation;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.aX = this.aX;
			data.aY = this.aY;
			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;
			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;
			data.aClockwise = this.aClockwise;
			data.aRotation = this.aRotation;
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.aX = json.aX;
			this.aY = json.aY;
			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;
			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;
			this.aClockwise = json.aClockwise;
			this.aRotation = json.aRotation;
			return this;
		}

	}

	EllipseCurve.prototype.isEllipseCurve = true;

	class ArcCurve extends EllipseCurve {
		constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			this.type = 'ArcCurve';
		}

	}

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {
		let c0 = 0,
				c1 = 0,
				c2 = 0,
				c3 = 0;
		/*
		 * Compute coefficients for a cubic polynomial
		 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *	 p(0) = x0, p(1) = x1
		 *	and
		 *	 p'(0) = t0, p'(1) = t1.
		 */

		function init(x0, x1, t0, t1) {
			c0 = x0;
			c1 = t0;
			c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
		}

		return {
			initCatmullRom: function (x0, x1, x2, x3, tension) {
				init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
			},
			initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
				// compute tangents when parameterized in [t1,t2]
				let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
				let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

				t1 *= dt1;
				t2 *= dt1;
				init(x1, x2, t1, t2);
			},
			calc: function (t) {
				const t2 = t * t;
				const t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
			}
		};
	} //


	const tmp = new Vector3();
	const px = new CubicPoly(),
				py = new CubicPoly(),
				pz = new CubicPoly();

	class CatmullRomCurve3 extends Curve {
		constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
			super();
			this.type = 'CatmullRomCurve3';
			this.points = points;
			this.closed = closed;
			this.curveType = curveType;
			this.tension = tension;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const points = this.points;
			const l = points.length;
			const p = (l - (this.closed ? 0 : 1)) * t;
			let intPoint = Math.floor(p);
			let weight = p - intPoint;

			if (this.closed) {
				intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
			} else if (weight === 0 && intPoint === l - 1) {
				intPoint = l - 2;
				weight = 1;
			}

			let p0, p3; // 4 points (p1 & p2 defined below)

			if (this.closed || intPoint > 0) {
				p0 = points[(intPoint - 1) % l];
			} else {
				// extrapolate first point
				tmp.subVectors(points[0], points[1]).add(points[0]);
				p0 = tmp;
			}

			const p1 = points[intPoint % l];
			const p2 = points[(intPoint + 1) % l];

			if (this.closed || intPoint + 2 < l) {
				p3 = points[(intPoint + 2) % l];
			} else {
				// extrapolate last point
				tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
				p3 = tmp;
			}

			if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
				// init Centripetal / Chordal Catmull-Rom
				const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
				let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
				let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

				if (dt1 < 1e-4) dt1 = 1.0;
				if (dt0 < 1e-4) dt0 = dt1;
				if (dt2 < 1e-4) dt2 = dt1;
				px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
				py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
				pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
			} else if (this.curveType === 'catmullrom') {
				px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
				py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
				pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
			}

			point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.points = [];

			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.points = [];

			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];

			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector3().fromArray(point));
			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;
			return this;
		}

	}

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	/**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/BÃ©zier_curve
	 */
	function CatmullRom(t, p0, p1, p2, p3) {
		const v0 = (p2 - p0) * 0.5;
		const v1 = (p3 - p1) * 0.5;
		const t2 = t * t;
		const t3 = t * t2;
		return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	} //


	function QuadraticBezierP0(t, p) {
		const k = 1 - t;
		return k * k * p;
	}

	function QuadraticBezierP1(t, p) {
		return 2 * (1 - t) * t * p;
	}

	function QuadraticBezierP2(t, p) {
		return t * t * p;
	}

	function QuadraticBezier(t, p0, p1, p2) {
		return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
	} //


	function CubicBezierP0(t, p) {
		const k = 1 - t;
		return k * k * k * p;
	}

	function CubicBezierP1(t, p) {
		const k = 1 - t;
		return 3 * k * k * t * p;
	}

	function CubicBezierP2(t, p) {
		return 3 * (1 - t) * t * t * p;
	}

	function CubicBezierP3(t, p) {
		return t * t * t * p;
	}

	function CubicBezier(t, p0, p1, p2, p3) {
		return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
	}

	class CubicBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
			super();
			this.type = 'CubicBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2,
						v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}

	}

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	class CubicBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
			super();
			this.type = 'CubicBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2,
						v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}

	}

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	class LineCurve extends Curve {
		constructor(v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.type = 'LineCurve';
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt


		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}

		getTangent(t, optionalTarget) {
			const tangent = optionalTarget || new Vector2();
			tangent.copy(this.v2).sub(this.v1).normalize();
			return tangent;
		}

		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	LineCurve.prototype.isLineCurve = true;

	class LineCurve3 extends Curve {
		constructor(v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.type = 'LineCurve3';
			this.isLineCurve3 = true;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt


		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}

		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	class QuadraticBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.type = 'QuadraticBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	class QuadraticBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.type = 'QuadraticBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	class SplineCurve extends Curve {
		constructor(points = []) {
			super();
			this.type = 'SplineCurve';
			this.points = points;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const points = this.points;
			const p = (points.length - 1) * t;
			const intPoint = Math.floor(p);
			const weight = p - intPoint;
			const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
			const p1 = points[intPoint];
			const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
			const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
			point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.points = [];

			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}

			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.points = [];

			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];

			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector2().fromArray(point));
			}

			return this;
		}

	}

	SplineCurve.prototype.isSplineCurve = true;

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */
	const Earcut = {
		triangulate: function (data, holeIndices, dim = 2) {
			const hasHoles = holeIndices && holeIndices.length;
			const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
			let outerNode = linkedList(data, 0, outerLen, dim, true);
			const triangles = [];
			if (!outerNode || outerNode.next === outerNode.prev) return triangles;
			let minX, minY, maxX, maxY, x, y, invSize;
			if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if (data.length > 80 * dim) {
				minX = maxX = data[0];
				minY = maxY = data[1];

				for (let i = dim; i < outerLen; i += dim) {
					x = data[i];
					y = data[i + 1];
					if (x < minX) minX = x;
					if (y < minY) minY = y;
					if (x > maxX) maxX = x;
					if (y > maxY) maxY = y;
				} // minX, minY and invSize are later used to transform coords into integers for z-order calculation


				invSize = Math.max(maxX - minX, maxY - minY);
				invSize = invSize !== 0 ? 1 / invSize : 0;
			}

			earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
			return triangles;
		}
	}; // create a circular doubly linked list from polygon points in the specified winding order

	function linkedList(data, start, end, dim, clockwise) {
		let i, last;

		if (clockwise === signedArea(data, start, end, dim) > 0) {
			for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
		} else {
			for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
		}

		if (last && equals(last, last.next)) {
			removeNode(last);
			last = last.next;
		}

		return last;
	} // eliminate colinear or duplicate points


	function filterPoints(start, end) {
		if (!start) return start;
		if (!end) end = start;
		let p = start,
				again;

		do {
			again = false;

			if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
				removeNode(p);
				p = end = p.prev;
				if (p === p.next) break;
				again = true;
			} else {
				p = p.next;
			}
		} while (again || p !== end);

		return end;
	} // main ear slicing loop which triangulates a polygon (given as a linked list)


	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
		if (!ear) return; // interlink polygon nodes in z-order

		if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
		let stop = ear,
				prev,
				next; // iterate through ears, slicing them one by one

		while (ear.prev !== ear.next) {
			prev = ear.prev;
			next = ear.next;

			if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
				// cut off the triangle
				triangles.push(prev.i / dim);
				triangles.push(ear.i / dim);
				triangles.push(next.i / dim);
				removeNode(ear); // skipping the next vertex leads to less sliver triangles

				ear = next.next;
				stop = next.next;
				continue;
			}

			ear = next; // if we looped through the whole remaining polygon and can't find any more ears

			if (ear === stop) {
				// try filtering points and slicing again
				if (!pass) {
					earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
				} else if (pass === 1) {
					ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
					earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
				} else if (pass === 2) {
					splitEarcut(ear, triangles, dim, minX, minY, invSize);
				}

				break;
			}
		}
	} // check whether a polygon node forms a valid ear with adjacent nodes


	function isEar(ear) {
		const a = ear.prev,
					b = ear,
					c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// now make sure we don't have other points inside the potential ear

		let p = ear.next.next;

		while (p !== ear.prev) {
			if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.next;
		}

		return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
		const a = ear.prev,
					b = ear,
					c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// triangle bbox; min & max are calculated like this for speed

		const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
					minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
					maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
					maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

		const minZ = zOrder(minTX, minTY, minX, minY, invSize),
					maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
		let p = ear.prevZ,
				n = ear.nextZ; // look for points inside the triangle in both directions

		while (p && p.z >= minZ && n && n.z <= maxZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		} // look for remaining points in decreasing z-order


		while (p && p.z >= minZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
		} // look for remaining points in increasing z-order


		while (n && n.z <= maxZ) {
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		}

		return true;
	} // go through all polygon nodes and cure small local self-intersections


	function cureLocalIntersections(start, triangles, dim) {
		let p = start;

		do {
			const a = p.prev,
						b = p.next.next;

			if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
				triangles.push(a.i / dim);
				triangles.push(p.i / dim);
				triangles.push(b.i / dim); // remove two nodes involved

				removeNode(p);
				removeNode(p.next);
				p = start = b;
			}

			p = p.next;
		} while (p !== start);

		return filterPoints(p);
	} // try splitting polygon into two and triangulate them independently


	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
		// look for a valid diagonal that divides the polygon into two
		let a = start;

		do {
			let b = a.next.next;

			while (b !== a.prev) {
				if (a.i !== b.i && isValidDiagonal(a, b)) {
					// split the polygon in two by the diagonal
					let c = splitPolygon(a, b); // filter colinear points around the cuts

					a = filterPoints(a, a.next);
					c = filterPoints(c, c.next); // run earcut on each half

					earcutLinked(a, triangles, dim, minX, minY, invSize);
					earcutLinked(c, triangles, dim, minX, minY, invSize);
					return;
				}

				b = b.next;
			}

			a = a.next;
		} while (a !== start);
	} // link every hole into the outer loop, producing a single-ring polygon without holes


	function eliminateHoles(data, holeIndices, outerNode, dim) {
		const queue = [];
		let i, len, start, end, list;

		for (i = 0, len = holeIndices.length; i < len; i++) {
			start = holeIndices[i] * dim;
			end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
			list = linkedList(data, start, end, dim, false);
			if (list === list.next) list.steiner = true;
			queue.push(getLeftmost(list));
		}

		queue.sort(compareX); // process holes from left to right

		for (i = 0; i < queue.length; i++) {
			eliminateHole(queue[i], outerNode);
			outerNode = filterPoints(outerNode, outerNode.next);
		}

		return outerNode;
	}

	function compareX(a, b) {
		return a.x - b.x;
	} // find a bridge between vertices that connects hole with an outer ring and and link it


	function eliminateHole(hole, outerNode) {
		outerNode = findHoleBridge(hole, outerNode);

		if (outerNode) {
			const b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

			filterPoints(outerNode, outerNode.next);
			filterPoints(b, b.next);
		}
	} // David Eberly's algorithm for finding a bridge between hole and outer polygon


	function findHoleBridge(hole, outerNode) {
		let p = outerNode;
		const hx = hole.x;
		const hy = hole.y;
		let qx = -Infinity,
				m; // find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {
			if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
				const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

				if (x <= hx && x > qx) {
					qx = x;

					if (x === hx) {
						if (hy === p.y) return p;
						if (hy === p.next.y) return p.next;
					}

					m = p.x < p.next.x ? p : p.next;
				}
			}

			p = p.next;
		} while (p !== outerNode);

		if (!m) return null;
		if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		const stop = m,
					mx = m.x,
					my = m.y;
		let tanMin = Infinity,
				tan;
		p = m;

		do {
			if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
				tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

				if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
					m = p;
					tanMin = tan;
				}
			}

			p = p.next;
		} while (p !== stop);

		return m;
	} // whether sector in vertex m contains sector in vertex p in the same coordinates


	function sectorContainsSector(m, p) {
		return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	} // interlink polygon nodes in z-order


	function indexCurve(start, minX, minY, invSize) {
		let p = start;

		do {
			if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while (p !== start);

		p.prevZ.nextZ = null;
		p.prevZ = null;
		sortLinked(p);
	} // Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


	function sortLinked(list) {
		let i,
				p,
				q,
				e,
				tail,
				numMerges,
				pSize,
				qSize,
				inSize = 1;

		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while (p) {
				numMerges++;
				q = p;
				pSize = 0;

				for (i = 0; i < inSize; i++) {
					pSize++;
					q = q.nextZ;
					if (!q) break;
				}

				qSize = inSize;

				while (pSize > 0 || qSize > 0 && q) {
					if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
						e = p;
						p = p.nextZ;
						pSize--;
					} else {
						e = q;
						q = q.nextZ;
						qSize--;
					}

					if (tail) tail.nextZ = e;else list = e;
					e.prevZ = tail;
					tail = e;
				}

				p = q;
			}

			tail.nextZ = null;
			inSize *= 2;
		} while (numMerges > 1);

		return list;
	} // z-order of a point given coords and inverse of the longer side of data bbox


	function zOrder(x, y, minX, minY, invSize) {
		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * (x - minX) * invSize;
		y = 32767 * (y - minY) * invSize;
		x = (x | x << 8) & 0x00FF00FF;
		x = (x | x << 4) & 0x0F0F0F0F;
		x = (x | x << 2) & 0x33333333;
		x = (x | x << 1) & 0x55555555;
		y = (y | y << 8) & 0x00FF00FF;
		y = (y | y << 4) & 0x0F0F0F0F;
		y = (y | y << 2) & 0x33333333;
		y = (y | y << 1) & 0x55555555;
		return x | y << 1;
	} // find the leftmost node of a polygon ring


	function getLeftmost(start) {
		let p = start,
				leftmost = start;

		do {
			if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
			p = p.next;
		} while (p !== start);

		return leftmost;
	} // check if a point lies within a convex triangle


	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
		return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


	function isValidDiagonal(a, b) {
		return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
		locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
		area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
		equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
	} // signed area of a triangle


	function area(p, q, r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	} // check if two points are equal


	function equals(p1, p2) {
		return p1.x === p2.x && p1.y === p2.y;
	} // check if two segments intersect


	function intersects(p1, q1, p2, q2) {
		const o1 = sign(area(p1, q1, p2));
		const o2 = sign(area(p1, q1, q2));
		const o3 = sign(area(p2, q2, p1));
		const o4 = sign(area(p2, q2, q1));
		if (o1 !== o2 && o3 !== o4) return true; // general case

		if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

		if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

		if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

		if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;
	} // for collinear points p, q, r, check if point q lies on segment pr


	function onSegment(p, q, r) {
		return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}

	function sign(num) {
		return num > 0 ? 1 : num < 0 ? -1 : 0;
	} // check if a polygon diagonal intersects any polygon segments


	function intersectsPolygon(a, b) {
		let p = a;

		do {
			if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
			p = p.next;
		} while (p !== a);

		return false;
	} // check if a polygon diagonal is locally inside the polygon


	function locallyInside(a, b) {
		return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	} // check if the middle point of a polygon diagonal is inside the polygon


	function middleInside(a, b) {
		let p = a,
				inside = false;
		const px = (a.x + b.x) / 2,
					py = (a.y + b.y) / 2;

		do {
			if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
			p = p.next;
		} while (p !== a);

		return inside;
	} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring


	function splitPolygon(a, b) {
		const a2 = new Node(a.i, a.x, a.y),
					b2 = new Node(b.i, b.x, b.y),
					an = a.next,
					bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	} // create a node and optionally link it with previous one (in a circular doubly linked list)


	function insertNode(i, x, y, last) {
		const p = new Node(i, x, y);

		if (!last) {
			p.prev = p;
			p.next = p;
		} else {
			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
		}

		return p;
	}

	function removeNode(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;
		if (p.prevZ) p.prevZ.nextZ = p.nextZ;
		if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
		// vertex index in coordinates array
		this.i = i; // vertex coordinates

		this.x = x;
		this.y = y; // previous and next vertex nodes in a polygon ring

		this.prev = null;
		this.next = null; // z-order curve value

		this.z = null; // previous and next nodes in z-order

		this.prevZ = null;
		this.nextZ = null; // indicates whether this is a steiner point

		this.steiner = false;
	}

	function signedArea(data, start, end, dim) {
		let sum = 0;

		for (let i = start, j = end - dim; i < end; i += dim) {
			sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
			j = i;
		}

		return sum;
	}

	class ShapeUtils {
		// calculate area of the contour polygon
		static area(contour) {
			const n = contour.length;
			let a = 0.0;

			for (let p = n - 1, q = 0; q < n; p = q++) {
				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
			}

			return a * 0.5;
		}

		static isClockWise(pts) {
			return ShapeUtils.area(pts) < 0;
		}

		static triangulateShape(contour, holes) {
			const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

			const holeIndices = []; // array of hole indices

			const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts(contour);
			addContour(vertices, contour); //

			let holeIndex = contour.length;
			holes.forEach(removeDupEndPts);

			for (let i = 0; i < holes.length; i++) {
				holeIndices.push(holeIndex);
				holeIndex += holes[i].length;
				addContour(vertices, holes[i]);
			} //


			const triangles = Earcut.triangulate(vertices, holeIndices); //

			for (let i = 0; i < triangles.length; i += 3) {
				faces.push(triangles.slice(i, i + 3));
			}

			return faces;
		}

	}

	function removeDupEndPts(points) {
		const l = points.length;

		if (l > 2 && points[l - 1].equals(points[0])) {
			points.pop();
		}
	}

	function addContour(vertices, contour) {
		for (let i = 0; i < contour.length; i++) {
			vertices.push(contour[i].x);
			vertices.push(contour[i].y);
		}
	}

	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves
	 *	steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *	depth: <float>, // Depth to extrude the shape
	 *
	 *	bevelEnabled: <bool>, // turn on bevel
	 *	bevelThickness: <float>, // how deep into the original shape bevel goes
	 *	bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *	bevelOffset: <float>, // how far from shape outline does bevel start
	 *	bevelSegments: <int>, // number of bevel layers
	 *
	 *	extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *	UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	class ExtrudeGeometry extends BufferGeometry {
		constructor(shapes, options) {
			super();
			this.type = 'ExtrudeGeometry';
			this.parameters = {
				shapes: shapes,
				options: options
			};
			shapes = Array.isArray(shapes) ? shapes : [shapes];
			const scope = this;
			const verticesArray = [];
			const uvArray = [];

			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				addShape(shape);
			} // build geometry


			this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
			this.computeVertexNormals(); // functions

			function addShape(shape) {
				const placeholder = []; // options

				const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				const steps = options.steps !== undefined ? options.steps : 1;
				let depth = options.depth !== undefined ? options.depth : 100;
				let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
				let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
				let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
				const extrudePath = options.extrudePath;
				const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

				if (options.amount !== undefined) {
					console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
					depth = options.amount;
				} //


				let extrudePts,
						extrudeByPath = false;
				let splineTube, binormal, normal, position2;

				if (extrudePath) {
					extrudePts = extrudePath.getSpacedPoints(steps);
					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion
					// SETUP TNB variables
					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();
				} // Safeguards if bevels are not enabled


				if (!bevelEnabled) {
					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;
				} // Variables initialization


				const shapePoints = shape.extractPoints(curveSegments);
				let vertices = shapePoints.shape;
				const holes = shapePoints.holes;
				const reverse = !ShapeUtils.isClockWise(vertices);

				if (reverse) {
					vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];

						if (ShapeUtils.isClockWise(ahole)) {
							holes[h] = ahole.reverse();
						}
					}
				}

				const faces = ShapeUtils.triangulateShape(vertices, holes);
				/* Vertices */

				const contour = vertices; // vertices has all points but contour has only points of circumference

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					vertices = vertices.concat(ahole);
				}

				function scalePt2(pt, vec, size) {
					if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
					return vec.clone().multiplyScalar(size).add(pt);
				}

				const vlen = vertices.length,
							flen = faces.length; // Find directions for point movement

				function getBevelVec(inPt, inPrev, inNext) {
					// computes for inPt the corresponding point inPt' on a new contour
					//	 shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//	adjacent edges of inPt at a distance of 1 unit on the left side.
					let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					const v_prev_x = inPt.x - inPrev.x,
								v_prev_y = inPt.y - inPrev.y;
					const v_next_x = inNext.x - inPt.x,
								v_next_y = inNext.y - inPt.y;
					const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

					const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

					if (Math.abs(collinear0) > Number.EPSILON) {
						// not collinear
						// length of vectors for normalizing
						const v_prev_len = Math.sqrt(v_prev_lensq);
						const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

						const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
						const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
						const ptNextShift_x = inNext.x - v_next_y / v_next_len;
						const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

						const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

						v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
						v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
						//	but prevent crazy spikes

						const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

						if (v_trans_lensq <= 2) {
							return new Vector2(v_trans_x, v_trans_y);
						} else {
							shrink_by = Math.sqrt(v_trans_lensq / 2);
						}
					} else {
						// handle special case of collinear edges
						let direction_eq = false; // assumes: opposite

						if (v_prev_x > Number.EPSILON) {
							if (v_next_x > Number.EPSILON) {
								direction_eq = true;
							}
						} else {
							if (v_prev_x < -Number.EPSILON) {
								if (v_next_x < -Number.EPSILON) {
									direction_eq = true;
								}
							} else {
								if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
									direction_eq = true;
								}
							}
						}

						if (direction_eq) {
							// console.log("Warning: lines are a straight sequence");
							v_trans_x = -v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt(v_prev_lensq);
						} else {
							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt(v_prev_lensq / 2);
						}
					}

					return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
				}

				const contourMovements = [];

				for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0; //	(j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
				}

				const holesMovements = [];
				let oneHoleMovements,
						verticesMovements = contourMovements.concat();

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					oneHoleMovements = [];

					for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
						if (j === il) j = 0;
						if (k === il) k = 0; //	(j)---(i)---(k)

						oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
					}

					holesMovements.push(oneHoleMovements);
					verticesMovements = verticesMovements.concat(oneHoleMovements);
				} // Loop bevelSegments, 1 for the front, 1 for the back


				for (let b = 0; b < bevelSegments; b++) {
					//for ( b = bevelSegments; b > 0; b -- ) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, -z);
					} // expand holes


					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];

						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
							v(vert.x, vert.y, -z);
						}
					}
				}

				const bs = bevelSize + bevelOffset; // Back facing vertices

				for (let i = 0; i < vlen; i++) {
					const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

					if (!extrudeByPath) {
						v(vert.x, vert.y, 0);
					} else {
						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
						normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
						binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
						position2.copy(extrudePts[0]).add(normal).add(binormal);
						v(position2.x, position2.y, position2.z);
					}
				} // Add stepped vertices...
				// Including front facing vertices


				for (let s = 1; s <= steps; s++) {
					for (let i = 0; i < vlen; i++) {
						const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

						if (!extrudeByPath) {
							v(vert.x, vert.y, depth / steps * s);
						} else {
							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
							normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
							binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
							position2.copy(extrudePts[s]).add(normal).add(binormal);
							v(position2.x, position2.y, position2.z);
						}
					}
				} // Add bevel segments planes
				//for ( b = 1; b <= bevelSegments; b ++ ) {


				for (let b = bevelSegments - 1; b >= 0; b--) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, depth + z);
					} // expand holes


					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];

						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

							if (!extrudeByPath) {
								v(vert.x, vert.y, depth + z);
							} else {
								v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
							}
						}
					}
				}
				/* Faces */
				// Top and bottom faces


				buildLidFaces(); // Sides faces

				buildSideFaces(); /////	Internal functions

				function buildLidFaces() {
					const start = verticesArray.length / 3;

					if (bevelEnabled) {
						let layer = 0; // steps + 1

						let offset = vlen * layer; // Bottom faces

						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2] + offset, face[1] + offset, face[0] + offset);
						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer; // Top faces

						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + offset, face[1] + offset, face[2] + offset);
						}
					} else {
						// Bottom faces
						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2], face[1], face[0]);
						} // Top faces


						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
						}
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 0);
				} // Create faces for the z-sides of the shape


				function buildSideFaces() {
					const start = verticesArray.length / 3;
					let layeroffset = 0;
					sidewalls(contour, layeroffset);
					layeroffset += contour.length;

					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						sidewalls(ahole, layeroffset); //, true

						layeroffset += ahole.length;
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 1);
				}

				function sidewalls(contour, layeroffset) {
					let i = contour.length;

					while (--i >= 0) {
						const j = i;
						let k = i - 1;
						if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

						for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
							const slen1 = vlen * s;
							const slen2 = vlen * (s + 1);
							const a = layeroffset + j + slen1,
										b = layeroffset + k + slen1,
										c = layeroffset + k + slen2,
										d = layeroffset + j + slen2;
							f4(a, b, c, d);
						}
					}
				}

				function v(x, y, z) {
					placeholder.push(x);
					placeholder.push(y);
					placeholder.push(z);
				}

				function f3(a, b, c) {
					addVertex(a);
					addVertex(b);
					addVertex(c);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[2]);
				}

				function f4(a, b, c, d) {
					addVertex(a);
					addVertex(b);
					addVertex(d);
					addVertex(b);
					addVertex(c);
					addVertex(d);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[3]);
					addUV(uvs[1]);
					addUV(uvs[2]);
					addUV(uvs[3]);
				}

				function addVertex(index) {
					verticesArray.push(placeholder[index * 3 + 0]);
					verticesArray.push(placeholder[index * 3 + 1]);
					verticesArray.push(placeholder[index * 3 + 2]);
				}

				function addUV(vector2) {
					uvArray.push(vector2.x);
					uvArray.push(vector2.y);
				}
			}
		}

		toJSON() {
			const data = super.toJSON();
			const shapes = this.parameters.shapes;
			const options = this.parameters.options;
			return toJSON$1(shapes, options, data);
		}

		static fromJSON(data, shapes) {
			const geometryShapes = [];

			for (let j = 0, jl = data.shapes.length; j < jl; j++) {
				const shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}

			const extrudePath = data.options.extrudePath;

			if (extrudePath !== undefined) {
				data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
			}

			return new ExtrudeGeometry(geometryShapes, data.options);
		}

	}

	const WorldUVGenerator = {
		generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
		},
		generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const a_z = vertices[indexA * 3 + 2];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const b_z = vertices[indexB * 3 + 2];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			const c_z = vertices[indexC * 3 + 2];
			const d_x = vertices[indexD * 3];
			const d_y = vertices[indexD * 3 + 1];
			const d_z = vertices[indexD * 3 + 2];

			if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
				return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
			} else {
				return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
			}
		}
	};

	function toJSON$1(shapes, options, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
		return data;
	}

	class IcosahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
			const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
			super(vertices, indices, radius, detail);
			this.type = 'IcosahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new IcosahedronGeometry(data.radius, data.detail);
		}

	}

	class LatheGeometry extends BufferGeometry {
		constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
			super();
			this.type = 'LatheGeometry';
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
			segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = clamp(phiLength, 0, Math.PI * 2); // buffers

			const indices = [];
			const vertices = [];
			const uvs = []; // helper variables

			const inverseSegments = 1.0 / segments;
			const vertex = new Vector3();
			const uv = new Vector2(); // generate vertices and uvs

			for (let i = 0; i <= segments; i++) {
				const phi = phiStart + i * inverseSegments * phiLength;
				const sin = Math.sin(phi);
				const cos = Math.cos(phi);

				for (let j = 0; j <= points.length - 1; j++) {
					// vertex
					vertex.x = points[j].x * sin;
					vertex.y = points[j].y;
					vertex.z = points[j].x * cos;
					vertices.push(vertex.x, vertex.y, vertex.z); // uv

					uv.x = i / segments;
					uv.y = j / (points.length - 1);
					uvs.push(uv.x, uv.y);
				}
			} // indices


			for (let i = 0; i < segments; i++) {
				for (let j = 0; j < points.length - 1; j++) {
					const base = j + i * points.length;
					const a = base;
					const b = base + points.length;
					const c = base + points.length + 1;
					const d = base + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals

			this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if (phiLength === Math.PI * 2) {
				const normals = this.attributes.normal.array;
				const n1 = new Vector3();
				const n2 = new Vector3();
				const n = new Vector3(); // this is the buffer offset for the last line of vertices

				const base = segments * points.length * 3;

				for (let i = 0, j = 0; i < points.length; i++, j += 3) {
					// select the normal of the vertex in the first line
					n1.x = normals[j + 0];
					n1.y = normals[j + 1];
					n1.z = normals[j + 2]; // select the normal of the vertex in the last line

					n2.x = normals[base + j + 0];
					n2.y = normals[base + j + 1];
					n2.z = normals[base + j + 2]; // average normals

					n.addVectors(n1, n2).normalize(); // assign the new values to both normals

					normals[j + 0] = normals[base + j + 0] = n.x;
					normals[j + 1] = normals[base + j + 1] = n.y;
					normals[j + 2] = normals[base + j + 2] = n.z;
				}
			}
		}

		static fromJSON(data) {
			return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
		}

	}

	class OctahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
			const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
			super(vertices, indices, radius, detail);
			this.type = 'OctahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new OctahedronGeometry(data.radius, data.detail);
		}

	}

	/**
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
	 */

	class ParametricGeometry extends BufferGeometry {
		constructor(func, slices, stacks) {
			super();
			this.type = 'ParametricGeometry';
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			}; // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			const EPS = 0.00001;
			const normal = new Vector3();
			const p0 = new Vector3(),
						p1 = new Vector3();
			const pu = new Vector3(),
						pv = new Vector3();

			if (func.length < 3) {
				console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
			} // generate vertices, normals and uvs


			const sliceCount = slices + 1;

			for (let i = 0; i <= stacks; i++) {
				const v = i / stacks;

				for (let j = 0; j <= slices; j++) {
					const u = j / slices; // vertex

					func(u, v, p0);
					vertices.push(p0.x, p0.y, p0.z); // normal
					// approximate tangent vectors via finite differences

					if (u - EPS >= 0) {
						func(u - EPS, v, p1);
						pu.subVectors(p0, p1);
					} else {
						func(u + EPS, v, p1);
						pu.subVectors(p1, p0);
					}

					if (v - EPS >= 0) {
						func(u, v - EPS, p1);
						pv.subVectors(p0, p1);
					} else {
						func(u, v + EPS, p1);
						pv.subVectors(p1, p0);
					} // cross product of tangent vectors returns surface normal


					normal.crossVectors(pu, pv).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(u, v);
				}
			} // generate indices


			for (let i = 0; i < stacks; i++) {
				for (let j = 0; j < slices; j++) {
					const a = i * sliceCount + j;
					const b = i * sliceCount + j + 1;
					const c = (i + 1) * sliceCount + j + 1;
					const d = (i + 1) * sliceCount + j; // faces one and two

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

	}

	class RingGeometry extends BufferGeometry {
		constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'RingGeometry';
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			thetaSegments = Math.max(3, thetaSegments);
			phiSegments = Math.max(1, phiSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // some helper variables

			let radius = innerRadius;
			const radiusStep = (outerRadius - innerRadius) / phiSegments;
			const vertex = new Vector3();
			const uv = new Vector2(); // generate vertices, normals and uvs

			for (let j = 0; j <= phiSegments; j++) {
				for (let i = 0; i <= thetaSegments; i++) {
					// values are generate from the inside of the ring to the outside
					const segment = thetaStart + i / thetaSegments * thetaLength; // vertex

					vertex.x = radius * Math.cos(segment);
					vertex.y = radius * Math.sin(segment);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, 0, 1); // uv

					uv.x = (vertex.x / outerRadius + 1) / 2;
					uv.y = (vertex.y / outerRadius + 1) / 2;
					uvs.push(uv.x, uv.y);
				} // increase the radius for next row of vertices


				radius += radiusStep;
			} // indices


			for (let j = 0; j < phiSegments; j++) {
				const thetaSegmentLevel = j * (thetaSegments + 1);

				for (let i = 0; i < thetaSegments; i++) {
					const segment = i + thetaSegmentLevel;
					const a = segment;
					const b = segment + thetaSegments + 1;
					const c = segment + thetaSegments + 2;
					const d = segment + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
		}

	}

	class ShapeGeometry extends BufferGeometry {
		constructor(shapes, curveSegments = 12) {
			super();
			this.type = 'ShapeGeometry';
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			}; // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let groupStart = 0;
			let groupCount = 0; // allow single and array values for "shapes" parameter

			if (Array.isArray(shapes) === false) {
				addShape(shapes);
			} else {
				for (let i = 0; i < shapes.length; i++) {
					addShape(shapes[i]);
					this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

					groupStart += groupCount;
					groupCount = 0;
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions

			function addShape(shape) {
				const indexOffset = vertices.length / 3;
				const points = shape.extractPoints(curveSegments);
				let shapeVertices = points.shape;
				const shapeHoles = points.holes; // check direction of vertices

				if (ShapeUtils.isClockWise(shapeVertices) === false) {
					shapeVertices = shapeVertices.reverse();
				}

				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];

					if (ShapeUtils.isClockWise(shapeHole) === true) {
						shapeHoles[i] = shapeHole.reverse();
					}
				}

				const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];
					shapeVertices = shapeVertices.concat(shapeHole);
				} // vertices, normals, uvs


				for (let i = 0, l = shapeVertices.length; i < l; i++) {
					const vertex = shapeVertices[i];
					vertices.push(vertex.x, vertex.y, 0);
					normals.push(0, 0, 1);
					uvs.push(vertex.x, vertex.y); // world uvs
				} // incides


				for (let i = 0, l = faces.length; i < l; i++) {
					const face = faces[i];
					const a = face[0] + indexOffset;
					const b = face[1] + indexOffset;
					const c = face[2] + indexOffset;
					indices.push(a, b, c);
					groupCount += 3;
				}
			}
		}

		toJSON() {
			const data = super.toJSON();
			const shapes = this.parameters.shapes;
			return toJSON(shapes, data);
		}

		static fromJSON(data, shapes) {
			const geometryShapes = [];

			for (let j = 0, jl = data.shapes.length; j < jl; j++) {
				const shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}

			return new ShapeGeometry(geometryShapes, data.curveSegments);
		}

	}

	function toJSON(shapes, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		return data;
	}

	class SphereGeometry extends BufferGeometry {
		constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
			super();
			this.type = 'SphereGeometry';
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			widthSegments = Math.max(3, Math.floor(widthSegments));
			heightSegments = Math.max(2, Math.floor(heightSegments));
			const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
			let index = 0;
			const grid = [];
			const vertex = new Vector3();
			const normal = new Vector3(); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // generate vertices, normals and uvs

			for (let iy = 0; iy <= heightSegments; iy++) {
				const verticesRow = [];
				const v = iy / heightSegments; // special case for the poles

				let uOffset = 0;

				if (iy == 0 && thetaStart == 0) {
					uOffset = 0.5 / widthSegments;
				} else if (iy == heightSegments && thetaEnd == Math.PI) {
					uOffset = -0.5 / widthSegments;
				}

				for (let ix = 0; ix <= widthSegments; ix++) {
					const u = ix / widthSegments; // vertex

					vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
					vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normal.copy(vertex).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(u + uOffset, 1 - v);
					verticesRow.push(index++);
				}

				grid.push(verticesRow);
			} // indices


			for (let iy = 0; iy < heightSegments; iy++) {
				for (let ix = 0; ix < widthSegments; ix++) {
					const a = grid[iy][ix + 1];
					const b = grid[iy][ix];
					const c = grid[iy + 1][ix];
					const d = grid[iy + 1][ix + 1];
					if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
					if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
		}

	}

	class TetrahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
			const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
			super(vertices, indices, radius, detail);
			this.type = 'TetrahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new TetrahedronGeometry(data.radius, data.detail);
		}

	}

	/**
	 * Text = 3D Text
	 *
	 * parameters = {
	 *	font: <THREE.Font>, // font
	 *
	 *	size: <float>, // size of the text
	 *	height: <float>, // thickness to extrude text
	 *	curveSegments: <int>, // number of points on the curves
	 *
	 *	bevelEnabled: <bool>, // turn on bevel
	 *	bevelThickness: <float>, // how deep into text bevel goes
	 *	bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
	 *	bevelOffset: <float> // how far from text outline does bevel start
	 * }
	 */

	class TextGeometry extends ExtrudeGeometry {
		constructor(text, parameters = {}) {
			const font = parameters.font;

			if (!(font && font.isFont)) {
				console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
				return new BufferGeometry();
			}

			const shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API

			parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults

			if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
			if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
			if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
			super(shapes, parameters);
			this.type = 'TextGeometry';
		}

	}

	class TorusGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
			super();
			this.type = 'TorusGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
			radialSegments = Math.floor(radialSegments);
			tubularSegments = Math.floor(tubularSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const center = new Vector3();
			const vertex = new Vector3();
			const normal = new Vector3(); // generate vertices, normals and uvs

			for (let j = 0; j <= radialSegments; j++) {
				for (let i = 0; i <= tubularSegments; i++) {
					const u = i / tubularSegments * arc;
					const v = j / radialSegments * Math.PI * 2; // vertex

					vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
					vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
					vertex.z = tube * Math.sin(v);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					center.x = radius * Math.cos(u);
					center.y = radius * Math.sin(u);
					normal.subVectors(vertex, center).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (let j = 1; j <= radialSegments; j++) {
				for (let i = 1; i <= tubularSegments; i++) {
					// indices
					const a = (tubularSegments + 1) * j + i - 1;
					const b = (tubularSegments + 1) * (j - 1) + i - 1;
					const c = (tubularSegments + 1) * (j - 1) + i;
					const d = (tubularSegments + 1) * j + i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
		}

	}

	class TorusKnotGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
			super();
			this.type = 'TorusKnotGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
			tubularSegments = Math.floor(tubularSegments);
			radialSegments = Math.floor(radialSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const P1 = new Vector3();
			const P2 = new Vector3();
			const B = new Vector3();
			const T = new Vector3();
			const N = new Vector3(); // generate vertices, normals and uvs

			for (let i = 0; i <= tubularSegments; ++i) {
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
				const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve(u, p, q, radius, P1);
				calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

				T.subVectors(P2, P1);
				N.addVectors(P2, P1);
				B.crossVectors(T, N);
				N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for (let j = 0; j <= radialSegments; ++j) {
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
					const v = j / radialSegments * Math.PI * 2;
					const cx = -tube * Math.cos(v);
					const cy = tube * Math.sin(v); // now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + (cx * N.x + cy * B.x);
					vertex.y = P1.y + (cx * N.y + cy * B.y);
					vertex.z = P1.z + (cx * N.z + cy * B.z);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors(vertex, P1).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (let j = 1; j <= tubularSegments; j++) {
				for (let i = 1; i <= radialSegments; i++) {
					// indices
					const a = (radialSegments + 1) * (j - 1) + (i - 1);
					const b = (radialSegments + 1) * j + (i - 1);
					const c = (radialSegments + 1) * j + i;
					const d = (radialSegments + 1) * (j - 1) + i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

			function calculatePositionOnCurve(u, p, q, radius, position) {
				const cu = Math.cos(u);
				const su = Math.sin(u);
				const quOverP = q / p * u;
				const cs = Math.cos(quOverP);
				position.x = radius * (2 + cs) * 0.5 * cu;
				position.y = radius * (2 + cs) * su * 0.5;
				position.z = radius * Math.sin(quOverP) * 0.5;
			}
		}

		static fromJSON(data) {
			return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
		}

	}

	class TubeGeometry extends BufferGeometry {
		constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
			super();
			this.type = 'TubeGeometry';
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
			const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals; // helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const uv = new Vector2();
			let P = new Vector3(); // buffer

			const vertices = [];
			const normals = [];
			const uvs = [];
			const indices = []; // create buffer data

			generateBufferData(); // build geometry

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions

			function generateBufferData() {
				for (let i = 0; i < tubularSegments; i++) {
					generateSegment(i);
				} // if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


				generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs(); // finally create faces

				generateIndices();
			}

			function generateSegment(i) {
				// we use getPointAt to sample evenly distributed points from the given path
				P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

				const N = frames.normals[i];
				const B = frames.binormals[i]; // generate normals and vertices for the current segment

				for (let j = 0; j <= radialSegments; j++) {
					const v = j / radialSegments * Math.PI * 2;
					const sin = Math.sin(v);
					const cos = -Math.cos(v); // normal

					normal.x = cos * N.x + sin * B.x;
					normal.y = cos * N.y + sin * B.y;
					normal.z = cos * N.z + sin * B.z;
					normal.normalize();
					normals.push(normal.x, normal.y, normal.z); // vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			}

			function generateIndices() {
				for (let j = 1; j <= tubularSegments; j++) {
					for (let i = 1; i <= radialSegments; i++) {
						const a = (radialSegments + 1) * (j - 1) + (i - 1);
						const b = (radialSegments + 1) * j + (i - 1);
						const c = (radialSegments + 1) * j + i;
						const d = (radialSegments + 1) * (j - 1) + i; // faces

						indices.push(a, b, d);
						indices.push(b, c, d);
					}
				}
			}

			function generateUVs() {
				for (let i = 0; i <= tubularSegments; i++) {
					for (let j = 0; j <= radialSegments; j++) {
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
						uvs.push(uv.x, uv.y);
					}
				}
			}
		}

		toJSON() {
			const data = super.toJSON();
			data.path = this.parameters.path.toJSON();
			return data;
		}

		static fromJSON(data) {
			// This only works for built-in curves (e.g. CatmullRomCurve3).
			// User defined curves or instances of CurvePath will not be deserialized.
			return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
		}

	}

	class WireframeGeometry extends BufferGeometry {
		constructor(geometry) {
			super();
			this.type = 'WireframeGeometry';

			if (geometry.isGeometry === true) {
				console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				return;
			} // buffer


			const vertices = [];
			const edges = new Set(); // helper variables

			const start = new Vector3();
			const end = new Vector3();

			if (geometry.index !== null) {
				// indexed BufferGeometry
				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if (groups.length === 0) {
					groups = [{
						start: 0,
						count: indices.count,
						materialIndex: 0
					}];
				} // create a data structure that contains all eges without duplicates


				for (let o = 0, ol = groups.length; o < ol; ++o) {
					const group = groups[o];
					const groupStart = group.start;
					const groupCount = group.count;

					for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
						for (let j = 0; j < 3; j++) {
							const index1 = indices.getX(i + j);
							const index2 = indices.getX(i + (j + 1) % 3);
							start.fromBufferAttribute(position, index1);
							end.fromBufferAttribute(position, index2);

							if (isUniqueEdge(start, end, edges) === true) {
								vertices.push(start.x, start.y, start.z);
								vertices.push(end.x, end.y, end.z);
							}
						}
					}
				}
			} else {
				// non-indexed BufferGeometry
				const position = geometry.attributes.position;

				for (let i = 0, l = position.count / 3; i < l; i++) {
					for (let j = 0; j < 3; j++) {
						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
						const index1 = 3 * i + j;
						const index2 = 3 * i + (j + 1) % 3;
						start.fromBufferAttribute(position, index1);
						end.fromBufferAttribute(position, index2);

						if (isUniqueEdge(start, end, edges) === true) {
							vertices.push(start.x, start.y, start.z);
							vertices.push(end.x, end.y, end.z);
						}
					}
				}
			} // build geometry


			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		}

	}

	function isUniqueEdge(start, end, edges) {
		const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
		const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

		if (edges.has(hash1) === true || edges.has(hash2) === true) {
			return false;
		} else {
			edges.add(hash1, hash2);
			return true;
		}
	}

	var Geometries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	});

	/**
	 * parameters = {
	 *	color: <THREE.Color>
	 * }
	 */

	class ShadowMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'ShadowMaterial';
			this.color = new Color(0x000000);
			this.transparent = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			return this;
		}

	}

	ShadowMaterial.prototype.isShadowMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	roughness: <float>,
	 *	metalness: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *	metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	envMapIntensity: <float>
	 *
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshStandardMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'STANDARD': ''
			};
			this.type = 'MeshStandardMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.roughness = 1.0;
			this.metalness = 0.0;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.roughnessMap = null;
			this.metalnessMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.envMapIntensity = 1.0;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': ''
			};
			this.color.copy(source.color);
			this.roughness = source.roughness;
			this.metalness = source.metalness;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.roughnessMap = source.roughnessMap;
			this.metalnessMap = source.metalnessMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	/**
	 * parameters = {
	 *	clearcoat: <float>,
	 *	clearcoatMap: new THREE.Texture( <Image> ),
	 *	clearcoatRoughness: <float>,
	 *	clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *	clearcoatNormalScale: <Vector2>,
	 *	clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *	reflectivity: <float>,
	 *	ior: <float>,
	 *
	 *	sheen: <Color>,
	 *
	 *	transmission: <float>,
	 *	transmissionMap: new THREE.Texture( <Image> ),
	 *
	 *	thickness: <float>,
	 *	thicknessMap: new THREE.Texture( <Image> ),
	 *	attenuationDistance: <float>,
	 *	attenuationTint: <Color>,
	 *
	 *	specularIntensity: <float>,
	 *	specularIntensityhMap: new THREE.Texture( <Image> ),
	 *	specularTint: <Color>,
	 *	specularTintMap: new THREE.Texture( <Image> )
	 * }
	 */

	class MeshPhysicalMaterial extends MeshStandardMaterial {
		constructor(parameters) {
			super();
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.type = 'MeshPhysicalMaterial';
			this.clearcoat = 0.0;
			this.clearcoatMap = null;
			this.clearcoatRoughness = 0.0;
			this.clearcoatRoughnessMap = null;
			this.clearcoatNormalScale = new Vector2(1, 1);
			this.clearcoatNormalMap = null;
			this.reflectivity = 0.5; // maps to F0 = 0.04

			Object.defineProperty(this, 'ior', {
				get: function () {
					return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
				},
				set: function (ior) {
					this.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
				}
			});
			this.sheen = null; // null will disable sheen bsdf

			this.transmission = 0.0;
			this.transmissionMap = null;
			this.thickness = 0.01;
			this.thicknessMap = null;
			this.attenuationDistance = 0.0;
			this.attenuationTint = new Color(1, 1, 1);
			this.specularIntensity = 1.0;
			this.specularIntensityMap = null;
			this.specularTint = new Color(1, 1, 1);
			this.specularTintMap = null;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
			this.reflectivity = source.reflectivity;

			if (source.sheen) {
				this.sheen = (this.sheen || new Color()).copy(source.sheen);
			} else {
				this.sheen = null;
			}

			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;
			this.thickness = source.thickness;
			this.thicknessMap = source.thicknessMap;
			this.attenuationDistance = source.attenuationDistance;
			this.attenuationTint.copy(source.attenuationTint);
			this.specularIntensity = source.specularIntensity;
			this.specularIntensityMap = source.specularIntensityMap;
			this.specularTint.copy(source.specularTint);
			this.specularTintMap = source.specularTintMap;
			return this;
		}

	}

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	specular: <hex>,
	 *	shininess: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.MultiplyOperation,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshPhongMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshPhongMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.specular = new Color(0x111111);
			this.shininess = 30;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.specular.copy(source.specular);
			this.shininess = source.shininess;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *	gradientMap: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 * }
	 */

	class MeshToonMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'TOON': ''
			};
			this.type = 'MeshToonMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.gradientMap = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.gradientMap = source.gradientMap;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		}

	}

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	/**
	 * parameters = {
	 *	opacity: <float>,
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshNormalMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshNormalMaterial';
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false;
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 * }
	 */

	class MeshLambertMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshLambertMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		}

	}

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	matcap: new THREE.Texture( <Image> ),
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshMatcapMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'MATCAP': ''
			};
			this.type = 'MeshMatcapMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.matcap = null;
			this.map = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'MATCAP': ''
			};
			this.color.copy(source.color);
			this.matcap = source.matcap;
			this.map = source.map;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *
	 *	scale: <float>,
	 *	dashSize: <float>,
	 *	gapSize: <float>
	 * }
	 */

	class LineDashedMaterial extends LineBasicMaterial {
		constructor(parameters) {
			super();
			this.type = 'LineDashedMaterial';
			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
			return this;
		}

	}

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	var Materials = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	const AnimationUtils = {
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function (array, from, to) {
			if (AnimationUtils.isTypedArray(array)) {
				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
			}

			return array.slice(from, to);
		},
		// converts an array to a specific type
		convertArray: function (array, type, forceClone) {
			if (!array || // let 'undefined' and 'null' pass
			!forceClone && array.constructor === type) return array;

			if (typeof type.BYTES_PER_ELEMENT === 'number') {
				return new type(array); // create typed array
			}

			return Array.prototype.slice.call(array); // create Array
		},
		isTypedArray: function (object) {
			return ArrayBuffer.isView(object) && !(object instanceof DataView);
		},
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function (times) {
			function compareTime(i, j) {
				return times[i] - times[j];
			}

			const n = times.length;
			const result = new Array(n);

			for (let i = 0; i !== n; ++i) result[i] = i;

			result.sort(compareTime);
			return result;
		},
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function (values, stride, order) {
			const nValues = values.length;
			const result = new values.constructor(nValues);

			for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
				const srcOffset = order[i] * stride;

				for (let j = 0; j !== stride; ++j) {
					result[dstOffset++] = values[srcOffset + j];
				}
			}

			return result;
		},
		// function for parsing AOS keyframe formats
		flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
			let i = 1,
					key = jsonKeys[0];

			while (key !== undefined && key[valuePropertyName] === undefined) {
				key = jsonKeys[i++];
			}

			if (key === undefined) return; // no data

			let value = key[valuePropertyName];
			if (value === undefined) return; // no data

			if (Array.isArray(value)) {
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push.apply(values, value); // push all elements
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else if (value.toArray !== undefined) {
				// ...assume THREE.Math-ish
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						value.toArray(values, values.length);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else {
				// otherwise push as-is
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push(value);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			}
		},
		subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {
			const clip = sourceClip.clone();
			clip.name = name;
			const tracks = [];

			for (let i = 0; i < clip.tracks.length; ++i) {
				const track = clip.tracks[i];
				const valueSize = track.getValueSize();
				const times = [];
				const values = [];

				for (let j = 0; j < track.times.length; ++j) {
					const frame = track.times[j] * fps;
					if (frame < startFrame || frame >= endFrame) continue;
					times.push(track.times[j]);

					for (let k = 0; k < valueSize; ++k) {
						values.push(track.values[j * valueSize + k]);
					}
				}

				if (times.length === 0) continue;
				track.times = AnimationUtils.convertArray(times, track.times.constructor);
				track.values = AnimationUtils.convertArray(values, track.values.constructor);
				tracks.push(track);
			}

			clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

			let minStartTime = Infinity;

			for (let i = 0; i < clip.tracks.length; ++i) {
				if (minStartTime > clip.tracks[i].times[0]) {
					minStartTime = clip.tracks[i].times[0];
				}
			} // shift all tracks such that clip begins at t=0


			for (let i = 0; i < clip.tracks.length; ++i) {
				clip.tracks[i].shift(-1 * minStartTime);
			}

			clip.resetDuration();
			return clip;
		},
		makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
			if (fps <= 0) fps = 30;
			const numTracks = referenceClip.tracks.length;
			const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

			for (let i = 0; i < numTracks; ++i) {
				const referenceTrack = referenceClip.tracks[i];
				const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

				if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track

				const targetTrack = targetClip.tracks.find(function (track) {
					return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
				});
				if (targetTrack === undefined) continue;
				let referenceOffset = 0;
				const referenceValueSize = referenceTrack.getValueSize();

				if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					referenceOffset = referenceValueSize / 3;
				}

				let targetOffset = 0;
				const targetValueSize = targetTrack.getValueSize();

				if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					targetOffset = targetValueSize / 3;
				}

				const lastIndex = referenceTrack.times.length - 1;
				let referenceValue; // Find the value to subtract out of the track

				if (referenceTime <= referenceTrack.times[0]) {
					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else if (referenceTime >= referenceTrack.times[lastIndex]) {
					// Reference frame is after the last keyframe, so just use the last keyframe
					const startIndex = lastIndex * referenceValueSize + referenceOffset;
					const endIndex = startIndex + referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else {
					// Interpolate to the reference value
					const interpolant = referenceTrack.createInterpolant();
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					interpolant.evaluate(referenceTime);
					referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
				} // Conjugate the quaternion


				if (referenceTrackType === 'quaternion') {
					const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
					referenceQuat.toArray(referenceValue);
				} // Subtract the reference value from all of the track values


				const numTimes = targetTrack.times.length;

				for (let j = 0; j < numTimes; ++j) {
					const valueStart = j * targetValueSize + targetOffset;

					if (referenceTrackType === 'quaternion') {
						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
					} else {
						const valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types

						for (let k = 0; k < valueEnd; ++k) {
							targetTrack.values[valueStart + k] -= referenceValue[k];
						}
					}
				}
			}

			targetClip.blendMode = AdditiveAnimationBlendMode;
			return targetClip;
		}
	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */
	class Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
			this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
			this.settings = null;
			this.DefaultSettings_ = {};
		}

		evaluate(t) {
			const pp = this.parameterPositions;
			let i1 = this._cachedIndex,
					t1 = pp[i1],
					t0 = pp[i1 - 1];

			validate_interval: {
				seek: {
					let right;

					linear_scan: {
						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {
							for (let giveUpAt = i1 + 2;;) {
								if (t1 === undefined) {
									if (t < t0) break forward_scan; // after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_(i1 - 1, t, t0);
								}

								if (i1 === giveUpAt) break; // this loop

								t0 = t1;
								t1 = pp[++i1];

								if (t < t1) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the right side of the index


							right = pp.length;
							break linear_scan;
						} //- slower code:
						//-					if ( t < t0 || t0 === undefined ) {


						if (!(t >= t0)) {
							// looping?
							const t1global = pp[1];

							if (t < t1global) {
								i1 = 2; // + 1, using the scan for the details

								t0 = t1global;
							} // linear reverse scan


							for (let giveUpAt = i1 - 2;;) {
								if (t0 === undefined) {
									// before start
									this._cachedIndex = 0;
									return this.beforeStart_(0, t, t1);
								}

								if (i1 === giveUpAt) break; // this loop

								t1 = t0;
								t0 = pp[--i1 - 1];

								if (t >= t0) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the left side of the index


							right = i1;
							i1 = 0;
							break linear_scan;
						} // the interval is valid


						break validate_interval;
					} // linear scan
					// binary search


					while (i1 < right) {
						const mid = i1 + right >>> 1;

						if (t < pp[mid]) {
							right = mid;
						} else {
							i1 = mid + 1;
						}
					}

					t1 = pp[i1];
					t0 = pp[i1 - 1]; // check boundary cases, again

					if (t0 === undefined) {
						this._cachedIndex = 0;
						return this.beforeStart_(0, t, t1);
					}

					if (t1 === undefined) {
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_(i1 - 1, t0, t);
					}
				} // seek


				this._cachedIndex = i1;
				this.intervalChanged_(i1, t0, t1);
			} // validate_interval


			return this.interpolate_(i1, t0, t, t1);
		}

		getSettings_() {
			return this.settings || this.DefaultSettings_;
		}

		copySampleValue_(index) {
			// copies a sample value to the result buffer
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						offset = index * stride;

			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset + i];
			}

			return result;
		} // Template methods for derived classes:


		interpolate_()
		/* i1, t0, t, t1 */
		{
			throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
		}

		intervalChanged_()
		/* i1, t0, t1 */
		{// empty
		}

	} // ALIAS DEFINITIONS


	Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
	Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	class CubicInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;
			this.DefaultSettings_ = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};
		}

		intervalChanged_(i1, t0, t1) {
			const pp = this.parameterPositions;
			let iPrev = i1 - 2,
					iNext = i1 + 1,
					tPrev = pp[iPrev],
					tNext = pp[iNext];

			if (tPrev === undefined) {
				switch (this.getSettings_().endingStart) {
					case ZeroSlopeEnding:
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
				}
			}

			if (tNext === undefined) {
				switch (this.getSettings_().endingEnd) {
					case ZeroSlopeEnding:
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[1] - pp[0];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
				}
			}

			const halfDt = (t1 - t0) * 0.5,
						stride = this.valueSize;
			this._weightPrev = halfDt / (t0 - tPrev);
			this._weightNext = halfDt / (tNext - t1);
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						o1 = i1 * stride,
						o0 = o1 - stride,
						oP = this._offsetPrev,
						oN = this._offsetNext,
						wP = this._weightPrev,
						wN = this._weightNext,
						p = (t - t0) / (t1 - t0),
						pp = p * p,
						ppp = pp * p; // evaluate polynomials

			const sP = -wP * ppp + 2 * wP * pp - wP * p;
			const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
			const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
			const sN = wN * ppp - wN * pp; // combine data linearly

			for (let i = 0; i !== stride; ++i) {
				result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
			}

			return result;
		}

	}

	class LinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						offset1 = i1 * stride,
						offset0 = offset1 - stride,
						weight1 = (t - t0) / (t1 - t0),
						weight0 = 1 - weight1;

			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
			}

			return result;
		}

	}

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */

	class DiscreteInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1
		/*, t0, t, t1 */
		) {
			return this.copySampleValue_(i1 - 1);
		}

	}

	class KeyframeTrack {
		constructor(name, times, values, interpolation) {
			if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
			if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
			this.name = name;
			this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
			this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
			this.setInterpolation(interpolation || this.DefaultInterpolation);
		} // Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):


		static toJSON(track) {
			const trackType = track.constructor;
			let json; // derived classes can define a static toJSON method

			if (trackType.toJSON !== this.toJSON) {
				json = trackType.toJSON(track);
			} else {
				// by default, we assume the data can be serialized as-is
				json = {
					'name': track.name,
					'times': AnimationUtils.convertArray(track.times, Array),
					'values': AnimationUtils.convertArray(track.values, Array)
				};
				const interpolation = track.getInterpolation();

				if (interpolation !== track.DefaultInterpolation) {
					json.interpolation = interpolation;
				}
			}

			json.type = track.ValueTypeName; // mandatory

			return json;
		}

		InterpolantFactoryMethodDiscrete(result) {
			return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		InterpolantFactoryMethodLinear(result) {
			return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		InterpolantFactoryMethodSmooth(result) {
			return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		setInterpolation(interpolation) {
			let factoryMethod;

			switch (interpolation) {
				case InterpolateDiscrete:
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
					break;

				case InterpolateLinear:
					factoryMethod = this.InterpolantFactoryMethodLinear;
					break;

				case InterpolateSmooth:
					factoryMethod = this.InterpolantFactoryMethodSmooth;
					break;
			}

			if (factoryMethod === undefined) {
				const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;

				if (this.createInterpolant === undefined) {
					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {
						this.setInterpolation(this.DefaultInterpolation);
					} else {
						throw new Error(message); // fatal, in this case
					}
				}

				console.warn('THREE.KeyframeTrack:', message);
				return this;
			}

			this.createInterpolant = factoryMethod;
			return this;
		}

		getInterpolation() {
			switch (this.createInterpolant) {
				case this.InterpolantFactoryMethodDiscrete:
					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:
					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:
					return InterpolateSmooth;
			}
		}

		getValueSize() {
			return this.values.length / this.times.length;
		} // move all keyframes either forwards or backwards in time


		shift(timeOffset) {
			if (timeOffset !== 0.0) {
				const times = this.times;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] += timeOffset;
				}
			}

			return this;
		} // scale all keyframe times by a factor (useful for frame <-> seconds conversions)


		scale(timeScale) {
			if (timeScale !== 1.0) {
				const times = this.times;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] *= timeScale;
				}
			}

			return this;
		} // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values


		trim(startTime, endTime) {
			const times = this.times,
						nKeys = times.length;
			let from = 0,
					to = nKeys - 1;

			while (from !== nKeys && times[from] < startTime) {
				++from;
			}

			while (to !== -1 && times[to] > endTime) {
				--to;
			}

			++to; // inclusive -> exclusive bound

			if (from !== 0 || to !== nKeys) {
				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) {
					to = Math.max(to, 1);
					from = to - 1;
				}

				const stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice(times, from, to);
				this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
			}

			return this;
		} // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable


		validate() {
			let valid = true;
			const valueSize = this.getValueSize();

			if (valueSize - Math.floor(valueSize) !== 0) {
				console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
				valid = false;
			}

			const times = this.times,
						values = this.values,
						nKeys = times.length;

			if (nKeys === 0) {
				console.error('THREE.KeyframeTrack: Track is empty.', this);
				valid = false;
			}

			let prevTime = null;

			for (let i = 0; i !== nKeys; i++) {
				const currTime = times[i];

				if (typeof currTime === 'number' && isNaN(currTime)) {
					console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
					valid = false;
					break;
				}

				if (prevTime !== null && prevTime > currTime) {
					console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
					valid = false;
					break;
				}

				prevTime = currTime;
			}

			if (values !== undefined) {
				if (AnimationUtils.isTypedArray(values)) {
					for (let i = 0, n = values.length; i !== n; ++i) {
						const value = values[i];

						if (isNaN(value)) {
							console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
							valid = false;
							break;
						}
					}
				}
			}

			return valid;
		} // removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)


		optimize() {
			// times or values may be shared with other tracks, so overwriting is unsafe
			const times = AnimationUtils.arraySlice(this.times),
						values = AnimationUtils.arraySlice(this.values),
						stride = this.getValueSize(),
						smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
						lastIndex = times.length - 1;
			let writeIndex = 1;

			for (let i = 1; i < lastIndex; ++i) {
				let keep = false;
				const time = times[i];
				const timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

				if (time !== timeNext && (i !== 1 || time !== times[0])) {
					if (!smoothInterpolation) {
						// remove unnecessary keyframes same as their neighbors
						const offset = i * stride,
									offsetP = offset - stride,
									offsetN = offset + stride;

						for (let j = 0; j !== stride; ++j) {
							const value = values[offset + j];

							if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
								keep = true;
								break;
							}
						}
					} else {
						keep = true;
					}
				} // in-place compaction


				if (keep) {
					if (i !== writeIndex) {
						times[writeIndex] = times[i];
						const readOffset = i * stride,
									writeOffset = writeIndex * stride;

						for (let j = 0; j !== stride; ++j) {
							values[writeOffset + j] = values[readOffset + j];
						}
					}

					++writeIndex;
				}
			} // flush last keyframe (compaction looks ahead)


			if (lastIndex > 0) {
				times[writeIndex] = times[lastIndex];

				for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
					values[writeOffset + j] = values[readOffset + j];
				}

				++writeIndex;
			}

			if (writeIndex !== times.length) {
				this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
				this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
			} else {
				this.times = times;
				this.values = values;
			}

			return this;
		}

		clone() {
			const times = AnimationUtils.arraySlice(this.times, 0);
			const values = AnimationUtils.arraySlice(this.values, 0);
			const TypedKeyframeTrack = this.constructor;
			const track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

			track.createInterpolant = this.createInterpolant;
			return track;
		}

	}

	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

	/**
	 * A Track of Boolean keyframe values.
	 */

	class BooleanKeyframeTrack extends KeyframeTrack {}

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined; // Note: Actually this track could have a optimized / compressed

	/**
	 * A Track of keyframe values that represent color.
	 */

	class ColorKeyframeTrack extends KeyframeTrack {}

	ColorKeyframeTrack.prototype.ValueTypeName = 'color'; // ValueBufferType is inherited

	/**
	 * A Track of numeric keyframe values.
	 */

	class NumberKeyframeTrack extends KeyframeTrack {}

	NumberKeyframeTrack.prototype.ValueTypeName = 'number'; // ValueBufferType is inherited

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	class QuaternionLinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						alpha = (t - t0) / (t1 - t0);
			let offset = i1 * stride;

			for (let end = offset + stride; offset !== end; offset += 4) {
				Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
			}

			return result;
		}

	}

	/**
	 * A Track of quaternion keyframe values.
	 */

	class QuaternionKeyframeTrack extends KeyframeTrack {
		InterpolantFactoryMethodLinear(result) {
			return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}

	}

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited

	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track that interpolates Strings
	 */

	class StringKeyframeTrack extends KeyframeTrack {}

	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of vectored keyframe values.
	 */

	class VectorKeyframeTrack extends KeyframeTrack {}

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector'; // ValueBufferType is inherited

	class AnimationClip {
		constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
			this.name = name;
			this.tracks = tracks;
			this.duration = duration;
			this.blendMode = blendMode;
			this.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks

			if (this.duration < 0) {
				this.resetDuration();
			}
		}

		static parse(json) {
			const tracks = [],
						jsonTracks = json.tracks,
						frameTime = 1.0 / (json.fps || 1.0);

			for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
				tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
			}

			const clip = new this(json.name, json.duration, tracks, json.blendMode);
			clip.uuid = json.uuid;
			return clip;
		}

		static toJSON(clip) {
			const tracks = [],
						clipTracks = clip.tracks;
			const json = {
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode
			};

			for (let i = 0, n = clipTracks.length; i !== n; ++i) {
				tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
			}

			return json;
		}

		static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
			const numMorphTargets = morphTargetSequence.length;
			const tracks = [];

			for (let i = 0; i < numMorphTargets; i++) {
				let times = [];
				let values = [];
				times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
				values.push(0, 1, 0);
				const order = AnimationUtils.getKeyframeOrder(times);
				times = AnimationUtils.sortedArray(times, 1, order);
				values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.

				if (!noLoop && times[0] === 0) {
					times.push(numMorphTargets);
					values.push(values[0]);
				}

				tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
			}

			return new this(name, -1, tracks);
		}

		static findByName(objectOrClipArray, name) {
			let clipArray = objectOrClipArray;

			if (!Array.isArray(objectOrClipArray)) {
				const o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
			}

			for (let i = 0; i < clipArray.length; i++) {
				if (clipArray[i].name === name) {
					return clipArray[i];
				}
			}

			return null;
		}

		static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
			const animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059

			const pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002

			for (let i = 0, il = morphTargets.length; i < il; i++) {
				const morphTarget = morphTargets[i];
				const parts = morphTarget.name.match(pattern);

				if (parts && parts.length > 1) {
					const name = parts[1];
					let animationMorphTargets = animationToMorphTargets[name];

					if (!animationMorphTargets) {
						animationToMorphTargets[name] = animationMorphTargets = [];
					}

					animationMorphTargets.push(morphTarget);
				}
			}

			const clips = [];

			for (const name in animationToMorphTargets) {
				clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
			}

			return clips;
		} // parse the animation.hierarchy format


		static parseAnimation(animation, bones) {
			if (!animation) {
				console.error('THREE.AnimationClip: No animation in JSONLoader data.');
				return null;
			}

			const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {
					const times = [];
					const values = [];
					AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

					if (times.length !== 0) {
						destTracks.push(new trackType(trackName, times, values));
					}
				}
			};

			const tracks = [];
			const clipName = animation.name || 'default';
			const fps = animation.fps || 30;
			const blendMode = animation.blendMode; // automatic length determination in AnimationClip.

			let duration = animation.length || -1;
			const hierarchyTracks = animation.hierarchy || [];

			for (let h = 0; h < hierarchyTracks.length; h++) {
				const animationKeys = hierarchyTracks[h].keys; // skip empty tracks

				if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

				if (animationKeys[0].morphTargets) {
					// figure out all morph targets used in this track
					const morphTargetNames = {};
					let k;

					for (k = 0; k < animationKeys.length; k++) {
						if (animationKeys[k].morphTargets) {
							for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
								morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
							}
						}
					} // create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.


					for (const morphTargetName in morphTargetNames) {
						const times = [];
						const values = [];

						for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
							const animationKey = animationKeys[k];
							times.push(animationKey.time);
							values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
						}

						tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
					}

					duration = morphTargetNames.length * (fps || 1.0);
				} else {
					// ...assume skeletal animation
					const boneName = '.bones[' + bones[h].name + ']';
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
					addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
				}
			}

			if (tracks.length === 0) {
				return null;
			}

			const clip = new this(clipName, duration, tracks, blendMode);
			return clip;
		}

		resetDuration() {
			const tracks = this.tracks;
			let duration = 0;

			for (let i = 0, n = tracks.length; i !== n; ++i) {
				const track = this.tracks[i];
				duration = Math.max(duration, track.times[track.times.length - 1]);
			}

			this.duration = duration;
			return this;
		}

		trim() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].trim(0, this.duration);
			}

			return this;
		}

		validate() {
			let valid = true;

			for (let i = 0; i < this.tracks.length; i++) {
				valid = valid && this.tracks[i].validate();
			}

			return valid;
		}

		optimize() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].optimize();
			}

			return this;
		}

		clone() {
			const tracks = [];

			for (let i = 0; i < this.tracks.length; i++) {
				tracks.push(this.tracks[i].clone());
			}

			return new this.constructor(this.name, this.duration, tracks, this.blendMode);
		}

		toJSON() {
			return this.constructor.toJSON(this);
		}

	}

	function getTrackTypeForValueTypeName(typeName) {
		switch (typeName.toLowerCase()) {
			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
				return VectorKeyframeTrack;

			case 'color':
				return ColorKeyframeTrack;

			case 'quaternion':
				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':
				return BooleanKeyframeTrack;

			case 'string':
				return StringKeyframeTrack;
		}

		throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
	}

	function parseKeyframeTrack(json) {
		if (json.type === undefined) {
			throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
		}

		const trackType = getTrackTypeForValueTypeName(json.type);

		if (json.times === undefined) {
			const times = [],
						values = [];
			AnimationUtils.flattenJSON(json.keys, times, values, 'value');
			json.times = times;
			json.values = values;
		} // derived classes can define a static parse method


		if (trackType.parse !== undefined) {
			return trackType.parse(json);
		} else {
			// by default, we assume a constructor compatible with the base
			return new trackType(json.name, json.times, json.values, json.interpolation);
		}
	}

	const Cache = {
		enabled: false,
		files: {},
		add: function (key, file) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[key] = file;
		},
		get: function (key) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[key];
		},
		remove: function (key) {
			delete this.files[key];
		},
		clear: function () {
			this.files = {};
		}
	};

	class LoadingManager {
		constructor(onLoad, onProgress, onError) {
			const scope = this;
			let isLoading = false;
			let itemsLoaded = 0;
			let itemsTotal = 0;
			let urlModifier = undefined;
			const handlers = []; // Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function (url) {
				itemsTotal++;

				if (isLoading === false) {
					if (scope.onStart !== undefined) {
						scope.onStart(url, itemsLoaded, itemsTotal);
					}
				}

				isLoading = true;
			};

			this.itemEnd = function (url) {
				itemsLoaded++;

				if (scope.onProgress !== undefined) {
					scope.onProgress(url, itemsLoaded, itemsTotal);
				}

				if (itemsLoaded === itemsTotal) {
					isLoading = false;

					if (scope.onLoad !== undefined) {
						scope.onLoad();
					}
				}
			};

			this.itemError = function (url) {
				if (scope.onError !== undefined) {
					scope.onError(url);
				}
			};

			this.resolveURL = function (url) {
				if (urlModifier) {
					return urlModifier(url);
				}

				return url;
			};

			this.setURLModifier = function (transform) {
				urlModifier = transform;
				return this;
			};

			this.addHandler = function (regex, loader) {
				handlers.push(regex, loader);
				return this;
			};

			this.removeHandler = function (regex) {
				const index = handlers.indexOf(regex);

				if (index !== -1) {
					handlers.splice(index, 2);
				}

				return this;
			};

			this.getHandler = function (file) {
				for (let i = 0, l = handlers.length; i < l; i += 2) {
					const regex = handlers[i];
					const loader = handlers[i + 1];
					if (regex.global) regex.lastIndex = 0; // see #17920

					if (regex.test(file)) {
						return loader;
					}
				}

				return null;
			};
		}

	}

	const DefaultLoadingManager = new LoadingManager();

	class Loader {
		constructor(manager) {
			this.manager = manager !== undefined ? manager : DefaultLoadingManager;
			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};
		}

		load()
		/* url, onLoad, onProgress, onError */
		{}

		loadAsync(url, onProgress) {
			const scope = this;
			return new Promise(function (resolve, reject) {
				scope.load(url, resolve, onProgress, reject);
			});
		}

		parse()
		/* data */
		{}

		setCrossOrigin(crossOrigin) {
			this.crossOrigin = crossOrigin;
			return this;
		}

		setWithCredentials(value) {
			this.withCredentials = value;
			return this;
		}

		setPath(path) {
			this.path = path;
			return this;
		}

		setResourcePath(resourcePath) {
			this.resourcePath = resourcePath;
			return this;
		}

		setRequestHeader(requestHeader) {
			this.requestHeader = requestHeader;
			return this;
		}

	}

	const loading = {};

	class FileLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			} // Check if request is duplicate


			if (loading[url] !== undefined) {
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				return;
			} // Check for data: URI


			const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			const dataUriRegexResult = url.match(dataUriRegex);
			let request; // Safari can not handle Data URIs through XMLHttpRequest so process manually

			if (dataUriRegexResult) {
				const mimeType = dataUriRegexResult[1];
				const isBase64 = !!dataUriRegexResult[2];
				let data = dataUriRegexResult[3];
				data = decodeURIComponent(data);
				if (isBase64) data = atob(data);

				try {
					let response;
					const responseType = (this.responseType || '').toLowerCase();

					switch (responseType) {
						case 'arraybuffer':
						case 'blob':
							const view = new Uint8Array(data.length);

							for (let i = 0; i < data.length; i++) {
								view[i] = data.charCodeAt(i);
							}

							if (responseType === 'blob') {
								response = new Blob([view.buffer], {
									type: mimeType
								});
							} else {
								response = view.buffer;
							}

							break;

						case 'document':
							const parser = new DOMParser();
							response = parser.parseFromString(data, mimeType);
							break;

						case 'json':
							response = JSON.parse(data);
							break;

						default:
							// 'text' or other
							response = data;
							break;
					} // Wait for next browser tick like standard XMLHttpRequest event dispatching does


					setTimeout(function () {
						if (onLoad) onLoad(response);
						scope.manager.itemEnd(url);
					}, 0);
				} catch (error) {
					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout(function () {
						if (onError) onError(error);
						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}, 0);
				}
			} else {
				// Initialise array for duplicate requests
				loading[url] = [];
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				request = new XMLHttpRequest();
				request.open('GET', url, true);
				request.addEventListener('load', function (event) {
					const response = this.response;
					const callbacks = loading[url];
					delete loading[url];

					if (this.status === 200 || this.status === 0) {
						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.
						if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.

						Cache.add(url, response);

						for (let i = 0, il = callbacks.length; i < il; i++) {
							const callback = callbacks[i];
							if (callback.onLoad) callback.onLoad(response);
						}

						scope.manager.itemEnd(url);
					} else {
						for (let i = 0, il = callbacks.length; i < il; i++) {
							const callback = callbacks[i];
							if (callback.onError) callback.onError(event);
						}

						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}
				}, false);
				request.addEventListener('progress', function (event) {
					const callbacks = loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onProgress) callback.onProgress(event);
					}
				}, false);
				request.addEventListener('error', function (event) {
					const callbacks = loading[url];
					delete loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				request.addEventListener('abort', function (event) {
					const callbacks = loading[url];
					delete loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				if (this.responseType !== undefined) request.responseType = this.responseType;
				if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
				if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

				for (const header in this.requestHeader) {
					request.setRequestHeader(header, this.requestHeader[header]);
				}

				request.send(null);
			}

			scope.manager.itemStart(url);
			return request;
		}

		setResponseType(value) {
			this.responseType = value;
			return this;
		}

		setMimeType(value) {
			this.mimeType = value;
			return this;
		}

	}

	class AnimationLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const animations = [];

			for (let i = 0; i < json.length; i++) {
				const clip = AnimationClip.parse(json[i]);
				animations.push(clip);
			}

			return animations;
		}

	}

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class CompressedTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const images = [];
			const texture = new CompressedTexture();
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(url[i], function (buffer) {
					const texDatas = scope.parse(buffer, true);
					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
					loaded += 1;

					if (loaded === 6) {
						if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, onProgress, onError);
			}

			if (Array.isArray(url)) {
				for (let i = 0, il = url.length; i < il; ++i) {
					loadTexture(i);
				}
			} else {
				// compressed cubemap texture stored in a single DDS file
				loader.load(url, function (buffer) {
					const texDatas = scope.parse(buffer, true);

					if (texDatas.isCubemap) {
						const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for (let f = 0; f < faces; f++) {
							images[f] = {
								mipmaps: []
							};

							for (let i = 0; i < texDatas.mipmapCount; i++) {
								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
								images[f].format = texDatas.format;
								images[f].width = texDatas.width;
								images[f].height = texDatas.height;
							}
						}

						texture.image = images;
					} else {
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
					}

					if (texDatas.mipmapCount === 1) {
						texture.minFilter = LinearFilter;
					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;
					if (onLoad) onLoad(texture);
				}, onProgress, onError);
			}

			return texture;
		}

	}

	class ImageLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

			function onImageLoad() {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				Cache.add(url, this);
				if (onLoad) onLoad(this);
				scope.manager.itemEnd(url);
			}

			function onImageError(event) {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				if (onError) onError(event);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			}

			image.addEventListener('load', onImageLoad, false);
			image.addEventListener('error', onImageError, false);

			if (url.substr(0, 5) !== 'data:') {
				if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
			}

			scope.manager.itemStart(url);
			image.src = url;
			return image;
		}

	}

	class CubeTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(urls, onLoad, onProgress, onError) {
			const texture = new CubeTexture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(urls[i], function (image) {
					texture.images[i] = image;
					loaded++;

					if (loaded === 6) {
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, undefined, onError);
			}

			for (let i = 0; i < urls.length; ++i) {
				loadTexture(i);
			}

			return texture;
		}

	}

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class DataTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const texture = new DataTexture();
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setPath(this.path);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (buffer) {
				const texData = scope.parse(buffer);
				if (!texData) return;

				if (texData.image !== undefined) {
					texture.image = texData.image;
				} else if (texData.data !== undefined) {
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if (texData.encoding !== undefined) {
					texture.encoding = texData.encoding;
				}

				if (texData.flipY !== undefined) {
					texture.flipY = texData.flipY;
				}

				if (texData.format !== undefined) {
					texture.format = texData.format;
				}

				if (texData.type !== undefined) {
					texture.type = texData.type;
				}

				if (texData.mipmaps !== undefined) {
					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...
				}

				if (texData.mipmapCount === 1) {
					texture.minFilter = LinearFilter;
				}

				if (texData.generateMipmaps !== undefined) {
					texture.generateMipmaps = texData.generateMipmaps;
				}

				texture.needsUpdate = true;
				if (onLoad) onLoad(texture, texData);
			}, onProgress, onError);
			return texture;
		}

	}

	class TextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const texture = new Texture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			loader.load(url, function (image) {
				texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

				const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if (onLoad !== undefined) {
					onLoad(texture);
				}
			}, onProgress, onError);
			return texture;
		}

	}

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *	curves, but retains the api of a curve
	 **************************************************************/

	class CurvePath extends Curve {
		constructor() {
			super();
			this.type = 'CurvePath';
			this.curves = [];
			this.autoClose = false; // Automatically closes the path
		}

		add(curve) {
			this.curves.push(curve);
		}

		closePath() {
			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[0].getPoint(0);
			const endPoint = this.curves[this.curves.length - 1].getPoint(1);

			if (!startPoint.equals(endPoint)) {
				this.curves.push(new LineCurve(endPoint, startPoint));
			}
		} // To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')


		getPoint(t) {
			const d = t * this.getLength();
			const curveLengths = this.getCurveLengths();
			let i = 0; // To think about boundaries points.

			while (i < curveLengths.length) {
				if (curveLengths[i] >= d) {
					const diff = curveLengths[i] - d;
					const curve = this.curves[i];
					const segmentLength = curve.getLength();
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
					return curve.getPointAt(u);
				}

				i++;
			}

			return null; // loop where sum != 0, sum > d , sum+1 <d
		} // We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength


		getLength() {
			const lens = this.getCurveLengths();
			return lens[lens.length - 1];
		} // cacheLengths must be recalculated.


		updateArcLengths() {
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
		} // Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.


		getCurveLengths() {
			// We use cache values if curves and cache array are same length
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
				return this.cacheLengths;
			} // Get length of sub-curve
			// Push sums into cached array


			const lengths = [];
			let sums = 0;

			for (let i = 0, l = this.curves.length; i < l; i++) {
				sums += this.curves[i].getLength();
				lengths.push(sums);
			}

			this.cacheLengths = lengths;
			return lengths;
		}

		getSpacedPoints(divisions = 40) {
			const points = [];

			for (let i = 0; i <= divisions; i++) {
				points.push(this.getPoint(i / divisions));
			}

			if (this.autoClose) {
				points.push(points[0]);
			}

			return points;
		}

		getPoints(divisions = 12) {
			const points = [];
			let last;

			for (let i = 0, curves = this.curves; i < curves.length; i++) {
				const curve = curves[i];
				const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
				const pts = curve.getPoints(resolution);

				for (let j = 0; j < pts.length; j++) {
					const point = pts[j];
					if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

					points.push(point);
					last = point;
				}
			}

			if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
				points.push(points[0]);
			}

			return points;
		}

		copy(source) {
			super.copy(source);
			this.curves = [];

			for (let i = 0, l = source.curves.length; i < l; i++) {
				const curve = source.curves[i];
				this.curves.push(curve.clone());
			}

			this.autoClose = source.autoClose;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.autoClose = this.autoClose;
			data.curves = [];

			for (let i = 0, l = this.curves.length; i < l; i++) {
				const curve = this.curves[i];
				data.curves.push(curve.toJSON());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.autoClose = json.autoClose;
			this.curves = [];

			for (let i = 0, l = json.curves.length; i < l; i++) {
				const curve = json.curves[i];
				this.curves.push(new Curves[curve.type]().fromJSON(curve));
			}

			return this;
		}

	}

	class Path extends CurvePath {
		constructor(points) {
			super();
			this.type = 'Path';
			this.currentPoint = new Vector2();

			if (points) {
				this.setFromPoints(points);
			}
		}

		setFromPoints(points) {
			this.moveTo(points[0].x, points[0].y);

			for (let i = 1, l = points.length; i < l; i++) {
				this.lineTo(points[i].x, points[i].y);
			}

			return this;
		}

		moveTo(x, y) {
			this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

			return this;
		}

		lineTo(x, y) {
			const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
			this.curves.push(curve);
			this.currentPoint.set(x, y);
			return this;
		}

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}

		splineThru(pts
		/*Array of Vector*/
		) {
			const npts = [this.currentPoint.clone()].concat(pts);
			const curve = new SplineCurve(npts);
			this.curves.push(curve);
			this.currentPoint.copy(pts[pts.length - 1]);
			return this;
		}

		arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		}

		absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		}

		ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
			return this;
		}

		absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

			if (this.curves.length > 0) {
				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint(0);

				if (!firstPoint.equals(this.currentPoint)) {
					this.lineTo(firstPoint.x, firstPoint.y);
				}
			}

			this.curves.push(curve);
			const lastPoint = curve.getPoint(1);
			this.currentPoint.copy(lastPoint);
			return this;
		}

		copy(source) {
			super.copy(source);
			this.currentPoint.copy(source.currentPoint);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.currentPoint = this.currentPoint.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.currentPoint.fromArray(json.currentPoint);
			return this;
		}

	}

	class Shape extends Path {
		constructor(points) {
			super(points);
			this.uuid = generateUUID();
			this.type = 'Shape';
			this.holes = [];
		}

		getPointsHoles(divisions) {
			const holesPts = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				holesPts[i] = this.holes[i].getPoints(divisions);
			}

			return holesPts;
		} // get points of shape and holes (keypoints based on segments parameter)


		extractPoints(divisions) {
			return {
				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions)
			};
		}

		copy(source) {
			super.copy(source);
			this.holes = [];

			for (let i = 0, l = source.holes.length; i < l; i++) {
				const hole = source.holes[i];
				this.holes.push(hole.clone());
			}

			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.uuid = this.uuid;
			data.holes = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				const hole = this.holes[i];
				data.holes.push(hole.toJSON());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.uuid = json.uuid;
			this.holes = [];

			for (let i = 0, l = json.holes.length; i < l; i++) {
				const hole = json.holes[i];
				this.holes.push(new Path().fromJSON(hole));
			}

			return this;
		}

	}

	class Light extends Object3D {
		constructor(color, intensity = 1) {
			super();
			this.type = 'Light';
			this.color = new Color(color);
			this.intensity = intensity;
		}

		dispose() {// Empty here in base class; some subclasses override.
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.intensity = source.intensity;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
			if (this.distance !== undefined) data.object.distance = this.distance;
			if (this.angle !== undefined) data.object.angle = this.angle;
			if (this.decay !== undefined) data.object.decay = this.decay;
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
			if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
			return data;
		}

	}

	Light.prototype.isLight = true;

	class HemisphereLight extends Light {
		constructor(skyColor, groundColor, intensity) {
			super(skyColor, intensity);
			this.type = 'HemisphereLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.groundColor = new Color(groundColor);
		}

		copy(source) {
			Light.prototype.copy.call(this, source);
			this.groundColor.copy(source.groundColor);
			return this;
		}

	}

	HemisphereLight.prototype.isHemisphereLight = true;

	const _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();

	const _lightPositionWorld$1 = /*@__PURE__*/new Vector3();

	const _lookTarget$1 = /*@__PURE__*/new Vector3();

	class LightShadow {
		constructor(camera) {
			this.camera = camera;
			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.mapSize = new Vector2(512, 512);
			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();
			this.autoUpdate = true;
			this.needsUpdate = false;
			this._frustum = new Frustum();
			this._frameExtents = new Vector2(1, 1);
			this._viewportCount = 1;
			this._viewports = [new Vector4(0, 0, 1, 1)];
		}

		getViewportCount() {
			return this._viewportCount;
		}

		getFrustum() {
			return this._frustum;
		}

		updateMatrices(light) {
			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);

			shadowCamera.position.copy(_lightPositionWorld$1);

			_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);

			shadowCamera.lookAt(_lookTarget$1);
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);

			shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
			shadowMatrix.multiply(shadowCamera.projectionMatrix);
			shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
		}

		getViewport(viewportIndex) {
			return this._viewports[viewportIndex];
		}

		getFrameExtents() {
			return this._frameExtents;
		}

		dispose() {
			if (this.map) {
				this.map.dispose();
			}

			if (this.mapPass) {
				this.mapPass.dispose();
			}
		}

		copy(source) {
			this.camera = source.camera.clone();
			this.bias = source.bias;
			this.radius = source.radius;
			this.mapSize.copy(source.mapSize);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		toJSON() {
			const object = {};
			if (this.bias !== 0) object.bias = this.bias;
			if (this.normalBias !== 0) object.normalBias = this.normalBias;
			if (this.radius !== 1) object.radius = this.radius;
			if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
			object.camera = this.camera.toJSON(false).object;
			delete object.camera.matrix;
			return object;
		}

	}

	class SpotLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(50, 1, 0.5, 500));
			this.focus = 1;
		}

		updateMatrices(light) {
			const camera = this.camera;
			const fov = RAD2DEG * 2 * light.angle * this.focus;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;

			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			super.updateMatrices(light);
		}

		copy(source) {
			super.copy(source);
			this.focus = source.focus;
			return this;
		}

	}

	SpotLightShadow.prototype.isSpotLightShadow = true;

	class SpotLight extends Light {
		constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
			super(color, intensity);
			this.type = 'SpotLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.target = new Object3D();
			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();
		}

		get power() {
			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * Math.PI;
		}

		set power(power) {
			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / Math.PI;
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	SpotLight.prototype.isSpotLight = true;

	const _projScreenMatrix = /*@__PURE__*/new Matrix4();

	const _lightPositionWorld = /*@__PURE__*/new Vector3();

	const _lookTarget = /*@__PURE__*/new Vector3();

	class PointLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(90, 1, 0.5, 500));
			this._frameExtents = new Vector2(4, 2);
			this._viewportCount = 6;
			this._viewports = [// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//	xzXZ
			//	 y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction
			// positive X
			new Vector4(2, 1, 1, 1), // negative X
			new Vector4(0, 1, 1, 1), // positive Z
			new Vector4(3, 1, 1, 1), // negative Z
			new Vector4(1, 1, 1, 1), // positive Y
			new Vector4(3, 0, 1, 1), // negative Y
			new Vector4(1, 0, 1, 1)];
			this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
			this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
		}

		updateMatrices(light, viewportIndex = 0) {
			const camera = this.camera;
			const shadowMatrix = this.matrix;
			const far = light.distance || camera.far;

			if (far !== camera.far) {
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);

			camera.position.copy(_lightPositionWorld);

			_lookTarget.copy(camera.position);

			_lookTarget.add(this._cubeDirections[viewportIndex]);

			camera.up.copy(this._cubeUps[viewportIndex]);
			camera.lookAt(_lookTarget);
			camera.updateMatrixWorld();
			shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix);
		}

	}

	PointLightShadow.prototype.isPointLightShadow = true;

	class PointLight extends Light {
		constructor(color, intensity, distance = 0, decay = 1) {
			super(color, intensity);
			this.type = 'PointLight';
			this.distance = distance;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new PointLightShadow();
		}

		get power() {
			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * 4 * Math.PI;
		}

		set power(power) {
			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / (4 * Math.PI);
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.distance = source.distance;
			this.decay = source.decay;
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	PointLight.prototype.isPointLight = true;

	class DirectionalLightShadow extends LightShadow {
		constructor() {
			super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
		}

	}

	DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

	class DirectionalLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.type = 'DirectionalLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.target = new Object3D();
			this.shadow = new DirectionalLightShadow();
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	DirectionalLight.prototype.isDirectionalLight = true;

	class AmbientLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.type = 'AmbientLight';
		}

	}

	AmbientLight.prototype.isAmbientLight = true;

	class RectAreaLight extends Light {
		constructor(color, intensity, width = 10, height = 10) {
			super(color, intensity);
			this.type = 'RectAreaLight';
			this.width = width;
			this.height = height;
		}

		copy(source) {
			super.copy(source);
			this.width = source.width;
			this.height = source.height;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.width = this.width;
			data.object.height = this.height;
			return data;
		}

	}

	RectAreaLight.prototype.isRectAreaLight = true;

	/**
	 * Primary reference:
	 *	 https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *	 https://www.ppsloan.org/publications/StupidSH36.pdf
	 */
	// 3-band SH defined by 9 coefficients

	class SphericalHarmonics3 {
		constructor() {
			this.coefficients = [];

			for (let i = 0; i < 9; i++) {
				this.coefficients.push(new Vector3());
			}
		}

		set(coefficients) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].copy(coefficients[i]);
			}

			return this;
		}

		zero() {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].set(0, 0, 0);
			}

			return this;
		} // get the radiance in the direction of the normal
		// target is a Vector3


		getAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z;
			const coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

			target.addScaledVector(coeff[1], 0.488603 * y);
			target.addScaledVector(coeff[2], 0.488603 * z);
			target.addScaledVector(coeff[3], 0.488603 * x); // band 2

			target.addScaledVector(coeff[4], 1.092548 * (x * y));
			target.addScaledVector(coeff[5], 1.092548 * (y * z));
			target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
			target.addScaledVector(coeff[7], 1.092548 * (x * z));
			target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
			return target;
		} // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf


		getIrradianceAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z;
			const coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.886227); // Ï€ * 0.282095
			// band 1

			target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * Ï€ / 3 ) * 0.488603

			target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
			target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

			target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( Ï€ / 4 ) * 1.092548

			target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
			target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( Ï€ / 4 ) * 0.315392 * 3

			target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
			target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( Ï€ / 4 ) * 0.546274

			return target;
		}

		add(sh) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].add(sh.coefficients[i]);
			}

			return this;
		}

		addScaledSH(sh, s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].addScaledVector(sh.coefficients[i], s);
			}

			return this;
		}

		scale(s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].multiplyScalar(s);
			}

			return this;
		}

		lerp(sh, alpha) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].lerp(sh.coefficients[i], alpha);
			}

			return this;
		}

		equals(sh) {
			for (let i = 0; i < 9; i++) {
				if (!this.coefficients[i].equals(sh.coefficients[i])) {
					return false;
				}
			}

			return true;
		}

		copy(sh) {
			return this.set(sh.coefficients);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		fromArray(array, offset = 0) {
			const coefficients = this.coefficients;

			for (let i = 0; i < 9; i++) {
				coefficients[i].fromArray(array, offset + i * 3);
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const coefficients = this.coefficients;

			for (let i = 0; i < 9; i++) {
				coefficients[i].toArray(array, offset + i * 3);
			}

			return array;
		} // evaluate the basis functions
		// shBasis is an Array[ 9 ]


		static getBasisAt(normal, shBasis) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z; // band 0

			shBasis[0] = 0.282095; // band 1

			shBasis[1] = 0.488603 * y;
			shBasis[2] = 0.488603 * z;
			shBasis[3] = 0.488603 * x; // band 2

			shBasis[4] = 1.092548 * x * y;
			shBasis[5] = 1.092548 * y * z;
			shBasis[6] = 0.315392 * (3 * z * z - 1);
			shBasis[7] = 1.092548 * x * z;
			shBasis[8] = 0.546274 * (x * x - y * y);
		}

	}

	SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

	class LightProbe extends Light {
		constructor(sh = new SphericalHarmonics3(), intensity = 1) {
			super(undefined, intensity);
			this.sh = sh;
		}

		copy(source) {
			super.copy(source);
			this.sh.copy(source.sh);
			return this;
		}

		fromJSON(json) {
			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

			this.sh.fromArray(json.sh);
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.sh = this.sh.toArray();
			return data;
		}

	}

	LightProbe.prototype.isLightProbe = true;

	class MaterialLoader extends Loader {
		constructor(manager) {
			super(manager);
			this.textures = {};
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const textures = this.textures;

			function getTexture(name) {
				if (textures[name] === undefined) {
					console.warn('THREE.MaterialLoader: Undefined texture', name);
				}

				return textures[name];
			}

			const material = new Materials[json.type]();
			if (json.uuid !== undefined) material.uuid = json.uuid;
			if (json.name !== undefined) material.name = json.name;
			if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
			if (json.roughness !== undefined) material.roughness = json.roughness;
			if (json.metalness !== undefined) material.metalness = json.metalness;
			if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
			if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
			if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
			if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
			if (json.specularTint !== undefined && material.specularTint !== undefined) material.specularTint.setHex(json.specularTint);
			if (json.shininess !== undefined) material.shininess = json.shininess;
			if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
			if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
			if (json.transmission !== undefined) material.transmission = json.transmission;
			if (json.thickness !== undefined) material.thickness = json.thickness;
			if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
			if (json.attenuationTint !== undefined && material.attenuationTint !== undefined) material.attenuationTint.setHex(json.attenuationTint);
			if (json.fog !== undefined) material.fog = json.fog;
			if (json.flatShading !== undefined) material.flatShading = json.flatShading;
			if (json.blending !== undefined) material.blending = json.blending;
			if (json.combine !== undefined) material.combine = json.combine;
			if (json.side !== undefined) material.side = json.side;
			if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
			if (json.opacity !== undefined) material.opacity = json.opacity;
			if (json.transparent !== undefined) material.transparent = json.transparent;
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
			if (json.depthTest !== undefined) material.depthTest = json.depthTest;
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
			if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
			if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
			if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
			if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
			if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
			if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
			if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
			if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
			if (json.wireframe !== undefined) material.wireframe = json.wireframe;
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
			if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
			if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
			if (json.rotation !== undefined) material.rotation = json.rotation;
			if (json.linewidth !== 1) material.linewidth = json.linewidth;
			if (json.dashSize !== undefined) material.dashSize = json.dashSize;
			if (json.gapSize !== undefined) material.gapSize = json.gapSize;
			if (json.scale !== undefined) material.scale = json.scale;
			if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
			if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
			if (json.dithering !== undefined) material.dithering = json.dithering;
			if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
			if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
			if (json.visible !== undefined) material.visible = json.visible;
			if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
			if (json.userData !== undefined) material.userData = json.userData;

			if (json.vertexColors !== undefined) {
				if (typeof json.vertexColors === 'number') {
					material.vertexColors = json.vertexColors > 0 ? true : false;
				} else {
					material.vertexColors = json.vertexColors;
				}
			} // Shader Material


			if (json.uniforms !== undefined) {
				for (const name in json.uniforms) {
					const uniform = json.uniforms[name];
					material.uniforms[name] = {};

					switch (uniform.type) {
						case 't':
							material.uniforms[name].value = getTexture(uniform.value);
							break;

						case 'c':
							material.uniforms[name].value = new Color().setHex(uniform.value);
							break;

						case 'v2':
							material.uniforms[name].value = new Vector2().fromArray(uniform.value);
							break;

						case 'v3':
							material.uniforms[name].value = new Vector3().fromArray(uniform.value);
							break;

						case 'v4':
							material.uniforms[name].value = new Vector4().fromArray(uniform.value);
							break;

						case 'm3':
							material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
							break;

						case 'm4':
							material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
							break;

						default:
							material.uniforms[name].value = uniform.value;
					}
				}
			}

			if (json.defines !== undefined) material.defines = json.defines;
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

			if (json.extensions !== undefined) {
				for (const key in json.extensions) {
					material.extensions[key] = json.extensions[key];
				}
			} // Deprecated


			if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
			// for PointsMaterial

			if (json.size !== undefined) material.size = json.size;
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

			if (json.map !== undefined) material.map = getTexture(json.map);
			if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
			if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
			if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
			if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
			if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

			if (json.normalScale !== undefined) {
				let normalScale = json.normalScale;

				if (Array.isArray(normalScale) === false) {
					// Blender exporter used to export a scalar. See #7459
					normalScale = [normalScale, normalScale];
				}

				material.normalScale = new Vector2().fromArray(normalScale);
			}

			if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
			if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
			if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
			if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
			if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
			if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
			if (json.specularTintMap !== undefined) material.specularTintMap = getTexture(json.specularTintMap);
			if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
			if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
			if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
			if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
			if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
			if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
			if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
			if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
			if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
			if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
			if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
			if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
			return material;
		}

		setTextures(value) {
			this.textures = value;
			return this;
		}

	}

	class LoaderUtils {
		static decodeText(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			} // Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.


			let s = '';

			for (let i = 0, il = array.length; i < il; i++) {
				// Implicitly assumes little-endian.
				s += String.fromCharCode(array[i]);
			}

			try {
				// merges multi-byte utf-8 characters.
				return decodeURIComponent(escape(s));
			} catch (e) {
				// see #16358
				return s;
			}
		}

		static extractUrlBase(url) {
			const index = url.lastIndexOf('/');
			if (index === -1) return './';
			return url.substr(0, index + 1);
		}

	}

	class InstancedBufferGeometry extends BufferGeometry {
		constructor() {
			super();
			this.type = 'InstancedBufferGeometry';
			this.instanceCount = Infinity;
		}

		copy(source) {
			super.copy(source);
			this.instanceCount = source.instanceCount;
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		toJSON() {
			const data = super.toJSON(this);
			data.instanceCount = this.instanceCount;
			data.isInstancedBufferGeometry = true;
			return data;
		}

	}

	InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

	class InstancedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized, meshPerAttribute = 1) {
			if (typeof normalized === 'number') {
				meshPerAttribute = normalized;
				normalized = false;
				console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
			}

			super(array, itemSize, normalized);
			this.meshPerAttribute = meshPerAttribute;
		}

		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.meshPerAttribute = this.meshPerAttribute;
			data.isInstancedBufferAttribute = true;
			return data;
		}

	}

	InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

	class BufferGeometryLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const interleavedBufferMap = {};
			const arrayBufferMap = {};

			function getInterleavedBuffer(json, uuid) {
				if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
				const interleavedBuffers = json.interleavedBuffers;
				const interleavedBuffer = interleavedBuffers[uuid];
				const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
				const array = getTypedArray(interleavedBuffer.type, buffer);
				const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
				ib.uuid = interleavedBuffer.uuid;
				interleavedBufferMap[uuid] = ib;
				return ib;
			}

			function getArrayBuffer(json, uuid) {
				if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
				const arrayBuffers = json.arrayBuffers;
				const arrayBuffer = arrayBuffers[uuid];
				const ab = new Uint32Array(arrayBuffer).buffer;
				arrayBufferMap[uuid] = ab;
				return ab;
			}

			const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
			const index = json.data.index;

			if (index !== undefined) {
				const typedArray = getTypedArray(index.type, index.array);
				geometry.setIndex(new BufferAttribute(typedArray, 1));
			}

			const attributes = json.data.attributes;

			for (const key in attributes) {
				const attribute = attributes[key];
				let bufferAttribute;

				if (attribute.isInterleavedBufferAttribute) {
					const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
					bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
				} else {
					const typedArray = getTypedArray(attribute.type, attribute.array);
					const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
				}

				if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
				if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);

				if (attribute.updateRange !== undefined) {
					bufferAttribute.updateRange.offset = attribute.updateRange.offset;
					bufferAttribute.updateRange.count = attribute.updateRange.count;
				}

				geometry.setAttribute(key, bufferAttribute);
			}

			const morphAttributes = json.data.morphAttributes;

			if (morphAttributes) {
				for (const key in morphAttributes) {
					const attributeArray = morphAttributes[key];
					const array = [];

					for (let i = 0, il = attributeArray.length; i < il; i++) {
						const attribute = attributeArray[i];
						let bufferAttribute;

						if (attribute.isInterleavedBufferAttribute) {
							const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
							bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
						} else {
							const typedArray = getTypedArray(attribute.type, attribute.array);
							bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
						}

						if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
						array.push(bufferAttribute);
					}

					geometry.morphAttributes[key] = array;
				}
			}

			const morphTargetsRelative = json.data.morphTargetsRelative;

			if (morphTargetsRelative) {
				geometry.morphTargetsRelative = true;
			}

			const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if (groups !== undefined) {
				for (let i = 0, n = groups.length; i !== n; ++i) {
					const group = groups[i];
					geometry.addGroup(group.start, group.count, group.materialIndex);
				}
			}

			const boundingSphere = json.data.boundingSphere;

			if (boundingSphere !== undefined) {
				const center = new Vector3();

				if (boundingSphere.center !== undefined) {
					center.fromArray(boundingSphere.center);
				}

				geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
			}

			if (json.name) geometry.name = json.name;
			if (json.userData) geometry.userData = json.userData;
			return geometry;
		}

	}

	class ObjectLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				let json = null;

				try {
					json = JSON.parse(text);
				} catch (error) {
					if (onError !== undefined) onError(error);
					console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
					return;
				}

				const metadata = json.metadata;

				if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
					console.error('THREE.ObjectLoader: Can\'t load ' + url);
					return;
				}

				scope.parse(json, onLoad);
			}, onProgress, onError);
		}

		async loadAsync(url, onProgress) {
			const scope = this;
			const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			const text = await loader.loadAsync(url, onProgress);
			const json = JSON.parse(text);
			const metadata = json.metadata;

			if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
				throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
			}

			return await scope.parseAsync(json);
		}

		parse(json, onLoad) {
			const animations = this.parseAnimations(json.animations);
			const shapes = this.parseShapes(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);
			const images = this.parseImages(json.images, function () {
				if (onLoad !== undefined) onLoad(object);
			});
			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);
			const object = this.parseObject(json.object, geometries, materials, textures, animations);
			const skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons); //

			if (onLoad !== undefined) {
				let hasImages = false;

				for (const uuid in images) {
					if (images[uuid] instanceof HTMLImageElement) {
						hasImages = true;
						break;
					}
				}

				if (hasImages === false) onLoad(object);
			}

			return object;
		}

		async parseAsync(json) {
			const animations = this.parseAnimations(json.animations);
			const shapes = this.parseShapes(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);
			const images = await this.parseImagesAsync(json.images);
			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);
			const object = this.parseObject(json.object, geometries, materials, textures, animations);
			const skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons);
			return object;
		}

		parseShapes(json) {
			const shapes = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const shape = new Shape().fromJSON(json[i]);
					shapes[shape.uuid] = shape;
				}
			}

			return shapes;
		}

		parseSkeletons(json, object) {
			const skeletons = {};
			const bones = {}; // generate bone lookup table

			object.traverse(function (child) {
				if (child.isBone) bones[child.uuid] = child;
			}); // create skeletons

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const skeleton = new Skeleton().fromJSON(json[i], bones);
					skeletons[skeleton.uuid] = skeleton;
				}
			}

			return skeletons;
		}

		parseGeometries(json, shapes) {
			const geometries = {};

			if (json !== undefined) {
				const bufferGeometryLoader = new BufferGeometryLoader();

				for (let i = 0, l = json.length; i < l; i++) {
					let geometry;
					const data = json[i];

					switch (data.type) {
						case 'BufferGeometry':
						case 'InstancedBufferGeometry':
							geometry = bufferGeometryLoader.parse(data);
							break;

						case 'Geometry':
							console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');
							break;

						default:
							if (data.type in Geometries) {
								geometry = Geometries[data.type].fromJSON(data, shapes);
							} else {
								console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
							}

					}

					geometry.uuid = data.uuid;
					if (data.name !== undefined) geometry.name = data.name;
					if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
					geometries[data.uuid] = geometry;
				}
			}

			return geometries;
		}

		parseMaterials(json, textures) {
			const cache = {}; // MultiMaterial

			const materials = {};

			if (json !== undefined) {
				const loader = new MaterialLoader();
				loader.setTextures(textures);

				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.type === 'MultiMaterial') {
						// Deprecated
						const array = [];

						for (let j = 0; j < data.materials.length; j++) {
							const material = data.materials[j];

							if (cache[material.uuid] === undefined) {
								cache[material.uuid] = loader.parse(material);
							}

							array.push(cache[material.uuid]);
						}

						materials[data.uuid] = array;
					} else {
						if (cache[data.uuid] === undefined) {
							cache[data.uuid] = loader.parse(data);
						}

						materials[data.uuid] = cache[data.uuid];
					}
				}
			}

			return materials;
		}

		parseAnimations(json) {
			const animations = {};

			if (json !== undefined) {
				for (let i = 0; i < json.length; i++) {
					const data = json[i];
					const clip = AnimationClip.parse(data);
					animations[clip.uuid] = clip;
				}
			}

			return animations;
		}

		parseImages(json, onLoad) {
			const scope = this;
			const images = {};
			let loader;

			function loadImage(url) {
				scope.manager.itemStart(url);
				return loader.load(url, function () {
					scope.manager.itemEnd(url);
				}, undefined, function () {
					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				});
			}

			function deserializeImage(image) {
				if (typeof image === 'string') {
					const url = image;
					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return loadImage(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}

			if (json !== undefined && json.length > 0) {
				const manager = new LoadingManager(onLoad);
				loader = new ImageLoader(manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const url = image.url;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						images[image.uuid] = [];

						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];
							const deserializedImage = deserializeImage(currentUrl);

							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									images[image.uuid].push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
					} else {
						// load single image
						const deserializedImage = deserializeImage(image.url);

						if (deserializedImage !== null) {
							images[image.uuid] = deserializedImage;
						}
					}
				}
			}

			return images;
		}

		async parseImagesAsync(json) {
			const scope = this;
			const images = {};
			let loader;

			async function deserializeImage(image) {
				if (typeof image === 'string') {
					const url = image;
					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return await loader.loadAsync(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}

			if (json !== undefined && json.length > 0) {
				loader = new ImageLoader(this.manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const url = image.url;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						images[image.uuid] = [];

						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];
							const deserializedImage = await deserializeImage(currentUrl);

							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									images[image.uuid].push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
					} else {
						// load single image
						const deserializedImage = await deserializeImage(image.url);

						if (deserializedImage !== null) {
							images[image.uuid] = deserializedImage;
						}
					}
				}
			}

			return images;
		}

		parseTextures(json, images) {
			function parseConstant(value, type) {
				if (typeof value === 'number') return value;
				console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
				return type[value];
			}

			const textures = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.image === undefined) {
						console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
					}

					if (images[data.image] === undefined) {
						console.warn('THREE.ObjectLoader: Undefined image', data.image);
					}

					let texture;
					const image = images[data.image];

					if (Array.isArray(image)) {
						texture = new CubeTexture(image);
						if (image.length === 6) texture.needsUpdate = true;
					} else {
						if (image && image.data) {
							texture = new DataTexture(image.data, image.width, image.height);
						} else {
							texture = new Texture(image);
						}

						if (image) texture.needsUpdate = true; // textures can have undefined image data
					}

					texture.uuid = data.uuid;
					if (data.name !== undefined) texture.name = data.name;
					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
					if (data.offset !== undefined) texture.offset.fromArray(data.offset);
					if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
					if (data.center !== undefined) texture.center.fromArray(data.center);
					if (data.rotation !== undefined) texture.rotation = data.rotation;

					if (data.wrap !== undefined) {
						texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
						texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
					}

					if (data.format !== undefined) texture.format = data.format;
					if (data.type !== undefined) texture.type = data.type;
					if (data.encoding !== undefined) texture.encoding = data.encoding;
					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
					if (data.flipY !== undefined) texture.flipY = data.flipY;
					if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
					if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
					textures[data.uuid] = texture;
				}
			}

			return textures;
		}

		parseObject(data, geometries, materials, textures, animations) {
			let object;

			function getGeometry(name) {
				if (geometries[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined geometry', name);
				}

				return geometries[name];
			}

			function getMaterial(name) {
				if (name === undefined) return undefined;

				if (Array.isArray(name)) {
					const array = [];

					for (let i = 0, l = name.length; i < l; i++) {
						const uuid = name[i];

						if (materials[uuid] === undefined) {
							console.warn('THREE.ObjectLoader: Undefined material', uuid);
						}

						array.push(materials[uuid]);
					}

					return array;
				}

				if (materials[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined material', name);
				}

				return materials[name];
			}

			function getTexture(uuid) {
				if (textures[uuid] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined texture', uuid);
				}

				return textures[uuid];
			}

			let geometry, material;

			switch (data.type) {
				case 'Scene':
					object = new Scene();

					if (data.background !== undefined) {
						if (Number.isInteger(data.background)) {
							object.background = new Color(data.background);
						} else {
							object.background = getTexture(data.background);
						}
					}

					if (data.environment !== undefined) {
						object.environment = getTexture(data.environment);
					}

					if (data.fog !== undefined) {
						if (data.fog.type === 'Fog') {
							object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
						} else if (data.fog.type === 'FogExp2') {
							object.fog = new FogExp2(data.fog.color, data.fog.density);
						}
					}

					break;

				case 'PerspectiveCamera':
					object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
					if (data.focus !== undefined) object.focus = data.focus;
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
					if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'OrthographicCamera':
					object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'AmbientLight':
					object = new AmbientLight(data.color, data.intensity);
					break;

				case 'DirectionalLight':
					object = new DirectionalLight(data.color, data.intensity);
					break;

				case 'PointLight':
					object = new PointLight(data.color, data.intensity, data.distance, data.decay);
					break;

				case 'RectAreaLight':
					object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
					break;

				case 'SpotLight':
					object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
					break;

				case 'HemisphereLight':
					object = new HemisphereLight(data.color, data.groundColor, data.intensity);
					break;

				case 'LightProbe':
					object = new LightProbe().fromJSON(data);
					break;

				case 'SkinnedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new SkinnedMesh(geometry, material);
					if (data.bindMode !== undefined) object.bindMode = data.bindMode;
					if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
					if (data.skeleton !== undefined) object.skeleton = data.skeleton;
					break;

				case 'Mesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new Mesh(geometry, material);
					break;

				case 'InstancedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					const count = data.count;
					const instanceMatrix = data.instanceMatrix;
					const instanceColor = data.instanceColor;
					object = new InstancedMesh(geometry, material, count);
					object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
					if (instanceColor !== undefined) object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
					break;

				case 'LOD':
					object = new LOD();
					break;

				case 'Line':
					object = new Line(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineLoop':
					object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineSegments':
					object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'PointCloud':
				case 'Points':
					object = new Points(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'Sprite':
					object = new Sprite(getMaterial(data.material));
					break;

				case 'Group':
					object = new Group();
					break;

				case 'Bone':
					object = new Bone();
					break;

				default:
					object = new Object3D();
			}

			object.uuid = data.uuid;
			if (data.name !== undefined) object.name = data.name;

			if (data.matrix !== undefined) {
				object.matrix.fromArray(data.matrix);
				if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
			} else {
				if (data.position !== undefined) object.position.fromArray(data.position);
				if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
				if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
				if (data.scale !== undefined) object.scale.fromArray(data.scale);
			}

			if (data.castShadow !== undefined) object.castShadow = data.castShadow;
			if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

			if (data.shadow) {
				if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
				if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
				if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
				if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
				if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
			}

			if (data.visible !== undefined) object.visible = data.visible;
			if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
			if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
			if (data.userData !== undefined) object.userData = data.userData;
			if (data.layers !== undefined) object.layers.mask = data.layers;

			if (data.children !== undefined) {
				const children = data.children;

				for (let i = 0; i < children.length; i++) {
					object.add(this.parseObject(children[i], geometries, materials, textures, animations));
				}
			}

			if (data.animations !== undefined) {
				const objectAnimations = data.animations;

				for (let i = 0; i < objectAnimations.length; i++) {
					const uuid = objectAnimations[i];
					object.animations.push(animations[uuid]);
				}
			}

			if (data.type === 'LOD') {
				if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
				const levels = data.levels;

				for (let l = 0; l < levels.length; l++) {
					const level = levels[l];
					const child = object.getObjectByProperty('uuid', level.object);

					if (child !== undefined) {
						object.addLevel(child, level.distance);
					}
				}
			}

			return object;
		}

		bindSkeletons(object, skeletons) {
			if (Object.keys(skeletons).length === 0) return;
			object.traverse(function (child) {
				if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
					const skeleton = skeletons[child.skeleton];

					if (skeleton === undefined) {
						console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
					} else {
						child.bind(skeleton, child.bindMatrix);
					}
				}
			});
		}
		/* DEPRECATED */


		setTexturePath(value) {
			console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
			return this.setResourcePath(value);
		}

	}

	const TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};
	const TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};
	const TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};

	class ImageBitmapLoader extends Loader {
		constructor(manager) {
			super(manager);

			if (typeof createImageBitmap === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
			}

			if (typeof fetch === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
			}

			this.options = {
				premultiplyAlpha: 'none'
			};
		}

		setOptions(options) {
			this.options = options;
			return this;
		}

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			const fetchOptions = {};
			fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
			fetchOptions.headers = this.requestHeader;
			fetch(url, fetchOptions).then(function (res) {
				return res.blob();
			}).then(function (blob) {
				return createImageBitmap(blob, Object.assign(scope.options, {
					colorSpaceConversion: 'none'
				}));
			}).then(function (imageBitmap) {
				Cache.add(url, imageBitmap);
				if (onLoad) onLoad(imageBitmap);
				scope.manager.itemEnd(url);
			}).catch(function (e) {
				if (onError) onError(e);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			});
			scope.manager.itemStart(url);
		}

	}

	ImageBitmapLoader.prototype.isImageBitmapLoader = true;

	class ShapePath {
		constructor() {
			this.type = 'ShapePath';
			this.color = new Color();
			this.subPaths = [];
			this.currentPath = null;
		}

		moveTo(x, y) {
			this.currentPath = new Path();
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo(x, y);
			return this;
		}

		lineTo(x, y) {
			this.currentPath.lineTo(x, y);
			return this;
		}

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
			return this;
		}

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
			return this;
		}

		splineThru(pts) {
			this.currentPath.splineThru(pts);
			return this;
		}

		toShapes(isCCW, noHoles) {
			function toShapesNoHoles(inSubpaths) {
				const shapes = [];

				for (let i = 0, l = inSubpaths.length; i < l; i++) {
					const tmpPath = inSubpaths[i];
					const tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push(tmpShape);
				}

				return shapes;
			}

			function isPointInsidePolygon(inPt, inPolygon) {
				const polyLen = inPolygon.length; // inPt on polygon contour => immediate success		or
				// toggling of inside/outside at every single! intersection point of an edge
				//	with the horizontal line through inPt, left of inPt
				//	not counting lowerY endpoints of edges and whole edges on that line

				let inside = false;

				for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
					let edgeLowPt = inPolygon[p];
					let edgeHighPt = inPolygon[q];
					let edgeDx = edgeHighPt.x - edgeLowPt.x;
					let edgeDy = edgeHighPt.y - edgeLowPt.y;

					if (Math.abs(edgeDy) > Number.EPSILON) {
						// not parallel
						if (edgeDy < 0) {
							edgeLowPt = inPolygon[q];
							edgeDx = -edgeDx;
							edgeHighPt = inPolygon[p];
							edgeDy = -edgeDy;
						}

						if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

						if (inPt.y === edgeLowPt.y) {
							if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
						} else {
							const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
							if (perpEdge === 0) return true; // inPt is on contour ?

							if (perpEdge < 0) continue;
							inside = !inside; // true intersection left of inPt
						}
					} else {
						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) continue; // parallel
						// edge lies on the same horizontal line as inPt

						if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
						// continue;
					}
				}

				return inside;
			}

			const isClockWise = ShapeUtils.isClockWise;
			const subPaths = this.subPaths;
			if (subPaths.length === 0) return [];
			if (noHoles === true) return toShapesNoHoles(subPaths);
			let solid, tmpPath, tmpShape;
			const shapes = [];

			if (subPaths.length === 1) {
				tmpPath = subPaths[0];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
				return shapes;
			}

			let holesFirst = !isClockWise(subPaths[0].getPoints());
			holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

			const betterShapeHoles = [];
			const newShapes = [];
			let newShapeHoles = [];
			let mainIdx = 0;
			let tmpPoints;
			newShapes[mainIdx] = undefined;
			newShapeHoles[mainIdx] = [];

			for (let i = 0, l = subPaths.length; i < l; i++) {
				tmpPath = subPaths[i];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise(tmpPoints);
				solid = isCCW ? !solid : solid;

				if (solid) {
					if (!holesFirst && newShapes[mainIdx]) mainIdx++;
					newShapes[mainIdx] = {
						s: new Shape(),
						p: tmpPoints
					};
					newShapes[mainIdx].s.curves = tmpPath.curves;
					if (holesFirst) mainIdx++;
					newShapeHoles[mainIdx] = []; //console.log('cw', i);
				} else {
					newShapeHoles[mainIdx].push({
						h: tmpPath,
						p: tmpPoints[0]
					}); //console.log('ccw', i);
				}
			} // only Holes? -> probably all Shapes with wrong orientation


			if (!newShapes[0]) return toShapesNoHoles(subPaths);

			if (newShapes.length > 1) {
				let ambiguous = false;
				const toChange = [];

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					betterShapeHoles[sIdx] = [];
				}

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					const sho = newShapeHoles[sIdx];

					for (let hIdx = 0; hIdx < sho.length; hIdx++) {
						const ho = sho[hIdx];
						let hole_unassigned = true;

						for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
								if (sIdx !== s2Idx) toChange.push({
									froms: sIdx,
									tos: s2Idx,
									hole: hIdx
								});

								if (hole_unassigned) {
									hole_unassigned = false;
									betterShapeHoles[s2Idx].push(ho);
								} else {
									ambiguous = true;
								}
							}
						}

						if (hole_unassigned) {
							betterShapeHoles[sIdx].push(ho);
						}
					}
				} // console.log("ambiguous: ", ambiguous);


				if (toChange.length > 0) {
					// console.log("to change: ", toChange);
					if (!ambiguous) newShapeHoles = betterShapeHoles;
				}
			}

			let tmpHoles;

			for (let i = 0, il = newShapes.length; i < il; i++) {
				tmpShape = newShapes[i].s;
				shapes.push(tmpShape);
				tmpHoles = newShapeHoles[i];

				for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
					tmpShape.holes.push(tmpHoles[j].h);
				}
			} //console.log("shape", shapes);


			return shapes;
		}

	}

	class Font {
		constructor(data) {
			this.type = 'Font';
			this.data = data;
		}

		generateShapes(text, size = 100) {
			const shapes = [];
			const paths = createPaths(text, size, this.data);

			for (let p = 0, pl = paths.length; p < pl; p++) {
				Array.prototype.push.apply(shapes, paths[p].toShapes());
			}

			return shapes;
		}

	}

	function createPaths(text, size, data) {
		const chars = Array.from(text);
		const scale = size / data.resolution;
		const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
		const paths = [];
		let offsetX = 0,
				offsetY = 0;

		for (let i = 0; i < chars.length; i++) {
			const char = chars[i];

			if (char === '\n') {
				offsetX = 0;
				offsetY -= line_height;
			} else {
				const ret = createPath(char, scale, offsetX, offsetY, data);
				offsetX += ret.offsetX;
				paths.push(ret.path);
			}
		}

		return paths;
	}

	function createPath(char, scale, offsetX, offsetY, data) {
		const glyph = data.glyphs[char] || data.glyphs['?'];

		if (!glyph) {
			console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
			return;
		}

		const path = new ShapePath();
		let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if (glyph.o) {
			const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

			for (let i = 0, l = outline.length; i < l;) {
				const action = outline[i++];

				switch (action) {
					case 'm':
						// moveTo
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.moveTo(x, y);
						break;

					case 'l':
						// lineTo
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.lineTo(x, y);
						break;

					case 'q':
						// quadraticCurveTo
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;
						path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
						break;

					case 'b':
						// bezierCurveTo
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;
						cpx2 = outline[i++] * scale + offsetX;
						cpy2 = outline[i++] * scale + offsetY;
						path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
						break;
				}
			}
		}

		return {
			offsetX: glyph.ha * scale,
			path: path
		};
	}

	Font.prototype.isFont = true;

	class FontLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				let json;

				try {
					json = JSON.parse(text);
				} catch (e) {
					console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
					json = JSON.parse(text.substring(65, text.length - 2));
				}

				const font = scope.parse(json);
				if (onLoad) onLoad(font);
			}, onProgress, onError);
		}

		parse(json) {
			return new Font(json);
		}

	}

	let _context;

	const AudioContext = {
		getContext: function () {
			if (_context === undefined) {
				_context = new (window.AudioContext || window.webkitAudioContext)();
			}

			return _context;
		},
		setContext: function (value) {
			_context = value;
		}
	};

	class AudioLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (buffer) {
				try {
					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					const bufferCopy = buffer.slice(0);
					const context = AudioContext.getContext();
					context.decodeAudioData(bufferCopy, function (audioBuffer) {
						onLoad(audioBuffer);
					});
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

	}

	class HemisphereLightProbe extends LightProbe {
		constructor(skyColor, groundColor, intensity = 1) {
			super(undefined, intensity);
			const color1 = new Color().set(skyColor);
			const color2 = new Color().set(groundColor);
			const sky = new Vector3(color1.r, color1.g, color1.b);
			const ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

			const c0 = Math.sqrt(Math.PI);
			const c1 = c0 * Math.sqrt(0.75);
			this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
			this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
		}

	}

	HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

	class AmbientLightProbe extends LightProbe {
		constructor(color, intensity = 1) {
			super(undefined, intensity);
			const color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

			this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
		}

	}

	AmbientLightProbe.prototype.isAmbientLightProbe = true;

	const _eyeRight = /*@__PURE__*/new Matrix4();

	const _eyeLeft = /*@__PURE__*/new Matrix4();

	class StereoCamera {
		constructor() {
			this.type = 'StereoCamera';
			this.aspect = 1;
			this.eyeSep = 0.064;
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable(1);
			this.cameraL.matrixAutoUpdate = false;
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable(2);
			this.cameraR.matrixAutoUpdate = false;
			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			};
		}

		update(camera) {
			const cache = this._cache;
			const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if (needsUpdate) {
				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				const projectionMatrix = camera.projectionMatrix.clone();
				const eyeSepHalf = cache.eyeSep / 2;
				const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
				let xmin, xmax; // translate xOffset

				_eyeLeft.elements[12] = -eyeSepHalf;
				_eyeRight.elements[12] = eyeSepHalf; // for left eye

				xmin = -ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

				xmin = -ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraR.projectionMatrix.copy(projectionMatrix);
			}

			this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
			this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
		}

	}

	class Clock {
		constructor(autoStart = true) {
			this.autoStart = autoStart;
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
			this.running = false;
		}

		start() {
			this.startTime = now();
			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
		}

		stop() {
			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
		}

		getElapsedTime() {
			this.getDelta();
			return this.elapsedTime;
		}

		getDelta() {
			let diff = 0;

			if (this.autoStart && !this.running) {
				this.start();
				return 0;
			}

			if (this.running) {
				const newTime = now();
				diff = (newTime - this.oldTime) / 1000;
				this.oldTime = newTime;
				this.elapsedTime += diff;
			}

			return diff;
		}

	}

	function now() {
		return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
	}

	const _position$1 = /*@__PURE__*/new Vector3();

	const _quaternion$1 = /*@__PURE__*/new Quaternion();

	const _scale$1 = /*@__PURE__*/new Vector3();

	const _orientation$1 = /*@__PURE__*/new Vector3();

	class AudioListener extends Object3D {
		constructor() {
			super();
			this.type = 'AudioListener';
			this.context = AudioContext.getContext();
			this.gain = this.context.createGain();
			this.gain.connect(this.context.destination);
			this.filter = null;
			this.timeDelta = 0; // private

			this._clock = new Clock();
		}

		getInput() {
			return this.gain;
		}

		removeFilter() {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
				this.gain.connect(this.context.destination);
				this.filter = null;
			}

			return this;
		}

		getFilter() {
			return this.filter;
		}

		setFilter(value) {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
			} else {
				this.gain.disconnect(this.context.destination);
			}

			this.filter = value;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);
			return this;
		}

		getMasterVolume() {
			return this.gain.gain.value;
		}

		setMasterVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			const listener = this.context.listener;
			const up = this.up;
			this.timeDelta = this._clock.getDelta();
			this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);

			_orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);

			if (listener.positionX) {
				// code path for Chrome (see #14393)
				const endTime = this.context.currentTime + this.timeDelta;
				listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
				listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
				listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
				listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
				listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
				listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
				listener.upX.linearRampToValueAtTime(up.x, endTime);
				listener.upY.linearRampToValueAtTime(up.y, endTime);
				listener.upZ.linearRampToValueAtTime(up.z, endTime);
			} else {
				listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
				listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
			}
		}

	}

	class Audio extends Object3D {
		constructor(listener) {
			super();
			this.type = 'Audio';
			this.listener = listener;
			this.context = listener.context;
			this.gain = this.context.createGain();
			this.gain.connect(listener.getInput());
			this.autoplay = false;
			this.buffer = null;
			this.detune = 0;
			this.loop = false;
			this.loopStart = 0;
			this.loopEnd = 0;
			this.offset = 0;
			this.duration = undefined;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.source = null;
			this.sourceType = 'empty';
			this._startedAt = 0;
			this._progress = 0;
			this._connected = false;
			this.filters = [];
		}

		getOutput() {
			return this.gain;
		}

		setNodeSource(audioNode) {
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
			return this;
		}

		setMediaElementSource(mediaElement) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource(mediaElement);
			this.connect();
			return this;
		}

		setMediaStreamSource(mediaStream) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource(mediaStream);
			this.connect();
			return this;
		}

		setBuffer(audioBuffer) {
			this.buffer = audioBuffer;
			this.sourceType = 'buffer';
			if (this.autoplay) this.play();
			return this;
		}

		play(delay = 0) {
			if (this.isPlaying === true) {
				console.warn('THREE.Audio: Audio is already playing.');
				return;
			}

			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._startedAt = this.context.currentTime + delay;
			const source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind(this);
			source.start(this._startedAt, this._progress + this.offset, this.duration);
			this.isPlaying = true;
			this.source = source;
			this.setDetune(this.detune);
			this.setPlaybackRate(this.playbackRate);
			return this.connect();
		}

		pause() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			if (this.isPlaying === true) {
				// update current progress
				this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

				if (this.loop === true) {
					// ensure _progress does not exceed duration with looped audios
					this._progress = this._progress % (this.duration || this.buffer.duration);
				}

				this.source.stop();
				this.source.onended = null;
				this.isPlaying = false;
			}

			return this;
		}

		stop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._progress = 0;
			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;
			return this;
		}

		connect() {
			if (this.filters.length > 0) {
				this.source.connect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].connect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].connect(this.getOutput());
			} else {
				this.source.connect(this.getOutput());
			}

			this._connected = true;
			return this;
		}

		disconnect() {
			if (this.filters.length > 0) {
				this.source.disconnect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].disconnect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].disconnect(this.getOutput());
			} else {
				this.source.disconnect(this.getOutput());
			}

			this._connected = false;
			return this;
		}

		getFilters() {
			return this.filters;
		}

		setFilters(value) {
			if (!value) value = [];

			if (this._connected === true) {
				this.disconnect();
				this.filters = value.slice();
				this.connect();
			} else {
				this.filters = value.slice();
			}

			return this;
		}

		setDetune(value) {
			this.detune = value;
			if (this.source.detune === undefined) return; // only set detune when available

			if (this.isPlaying === true) {
				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
			}

			return this;
		}

		getDetune() {
			return this.detune;
		}

		getFilter() {
			return this.getFilters()[0];
		}

		setFilter(filter) {
			return this.setFilters(filter ? [filter] : []);
		}

		setPlaybackRate(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.playbackRate = value;

			if (this.isPlaying === true) {
				this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
			}

			return this;
		}

		getPlaybackRate() {
			return this.playbackRate;
		}

		onEnded() {
			this.isPlaying = false;
		}

		getLoop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return false;
			}

			return this.loop;
		}

		setLoop(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.loop = value;

			if (this.isPlaying === true) {
				this.source.loop = this.loop;
			}

			return this;
		}

		setLoopStart(value) {
			this.loopStart = value;
			return this;
		}

		setLoopEnd(value) {
			this.loopEnd = value;
			return this;
		}

		getVolume() {
			return this.gain.gain.value;
		}

		setVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}

	}

	const _position = /*@__PURE__*/new Vector3();

	const _quaternion = /*@__PURE__*/new Quaternion();

	const _scale = /*@__PURE__*/new Vector3();

	const _orientation = /*@__PURE__*/new Vector3();

	class PositionalAudio extends Audio {
		constructor(listener) {
			super(listener);
			this.panner = this.context.createPanner();
			this.panner.panningModel = 'HRTF';
			this.panner.connect(this.gain);
		}

		getOutput() {
			return this.panner;
		}

		getRefDistance() {
			return this.panner.refDistance;
		}

		setRefDistance(value) {
			this.panner.refDistance = value;
			return this;
		}

		getRolloffFactor() {
			return this.panner.rolloffFactor;
		}

		setRolloffFactor(value) {
			this.panner.rolloffFactor = value;
			return this;
		}

		getDistanceModel() {
			return this.panner.distanceModel;
		}

		setDistanceModel(value) {
			this.panner.distanceModel = value;
			return this;
		}

		getMaxDistance() {
			return this.panner.maxDistance;
		}

		setMaxDistance(value) {
			this.panner.maxDistance = value;
			return this;
		}

		setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;
			return this;
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			if (this.hasPlaybackControl === true && this.isPlaying === false) return;
			this.matrixWorld.decompose(_position, _quaternion, _scale);

			_orientation.set(0, 0, 1).applyQuaternion(_quaternion);

			const panner = this.panner;

			if (panner.positionX) {
				// code path for Chrome and Firefox (see #14393)
				const endTime = this.context.currentTime + this.listener.timeDelta;
				panner.positionX.linearRampToValueAtTime(_position.x, endTime);
				panner.positionY.linearRampToValueAtTime(_position.y, endTime);
				panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
				panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
				panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
				panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
			} else {
				panner.setPosition(_position.x, _position.y, _position.z);
				panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
			}
		}

	}

	class AudioAnalyser {
		constructor(audio, fftSize = 2048) {
			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize;
			this.data = new Uint8Array(this.analyser.frequencyBinCount);
			audio.getOutput().connect(this.analyser);
		}

		getFrequencyData() {
			this.analyser.getByteFrequencyData(this.data);
			return this.data;
		}

		getAverageFrequency() {
			let value = 0;
			const data = this.getFrequencyData();

			for (let i = 0; i < data.length; i++) {
				value += data[i];
			}

			return value / data.length;
		}

	}

	class PropertyMixer {
		constructor(binding, typeName, valueSize) {
			this.binding = binding;
			this.valueSize = valueSize;
			let mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results

			switch (typeName) {
				case 'quaternion':
					mixFunction = this._slerp;
					mixFunctionAdditive = this._slerpAdditive;
					setIdentity = this._setAdditiveIdentityQuaternion;
					this.buffer = new Float64Array(valueSize * 6);
					this._workIndex = 5;
					break;

				case 'string':
				case 'bool':
					mixFunction = this._select; // Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types

					mixFunctionAdditive = this._select;
					setIdentity = this._setAdditiveIdentityOther;
					this.buffer = new Array(valueSize * 5);
					break;

				default:
					mixFunction = this._lerp;
					mixFunctionAdditive = this._lerpAdditive;
					setIdentity = this._setAdditiveIdentityNumeric;
					this.buffer = new Float64Array(valueSize * 5);
			}

			this._mixBufferRegion = mixFunction;
			this._mixBufferRegionAdditive = mixFunctionAdditive;
			this._setIdentity = setIdentity;
			this._origIndex = 3;
			this._addIndex = 4;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
			this.useCount = 0;
			this.referenceCount = 0;
		} // accumulate data in the 'incoming' region into 'accu<i>'


		accumulate(accuIndex, weight) {
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
			const buffer = this.buffer,
						stride = this.valueSize,
						offset = accuIndex * stride + stride;
			let currentWeight = this.cumulativeWeight;

			if (currentWeight === 0) {
				// accuN := incoming * weight
				for (let i = 0; i !== stride; ++i) {
					buffer[offset + i] = buffer[i];
				}

				currentWeight = weight;
			} else {
				// accuN := accuN + incoming * weight
				currentWeight += weight;
				const mix = weight / currentWeight;

				this._mixBufferRegion(buffer, offset, 0, mix, stride);
			}

			this.cumulativeWeight = currentWeight;
		} // accumulate data in the 'incoming' region into 'add'


		accumulateAdditive(weight) {
			const buffer = this.buffer,
						stride = this.valueSize,
						offset = stride * this._addIndex;

			if (this.cumulativeWeightAdditive === 0) {
				// add = identity
				this._setIdentity();
			} // add := add + incoming * weight


			this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

			this.cumulativeWeightAdditive += weight;
		} // apply the state of 'accu<i>' to the binding when accus differ


		apply(accuIndex) {
			const stride = this.valueSize,
						buffer = this.buffer,
						offset = accuIndex * stride + stride,
						weight = this.cumulativeWeight,
						weightAdditive = this.cumulativeWeightAdditive,
						binding = this.binding;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			if (weight < 1) {
				// accuN := accuN + original * ( 1 - cumulativeWeight )
				const originalValueOffset = stride * this._origIndex;

				this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
			}

			if (weightAdditive > 0) {
				// accuN := accuN + additive accuN
				this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
			}

			for (let i = stride, e = stride + stride; i !== e; ++i) {
				if (buffer[i] !== buffer[i + stride]) {
					// value has changed -> update scene graph
					binding.setValue(buffer, offset);
					break;
				}
			}
		} // remember the state of the bound property and copy it to both accus


		saveOriginalState() {
			const binding = this.binding;
			const buffer = this.buffer,
						stride = this.valueSize,
						originalValueOffset = stride * this._origIndex;
			binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

			for (let i = stride, e = originalValueOffset; i !== e; ++i) {
				buffer[i] = buffer[originalValueOffset + i % stride];
			} // Add to identity for additive


			this._setIdentity();

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
		} // apply the state previously taken via 'saveOriginalState' to the binding


		restoreOriginalState() {
			const originalValueOffset = this.valueSize * 3;
			this.binding.setValue(this.buffer, originalValueOffset);
		}

		_setAdditiveIdentityNumeric() {
			const startIndex = this._addIndex * this.valueSize;
			const endIndex = startIndex + this.valueSize;

			for (let i = startIndex; i < endIndex; i++) {
				this.buffer[i] = 0;
			}
		}

		_setAdditiveIdentityQuaternion() {
			this._setAdditiveIdentityNumeric();

			this.buffer[this._addIndex * this.valueSize + 3] = 1;
		}

		_setAdditiveIdentityOther() {
			const startIndex = this._origIndex * this.valueSize;
			const targetIndex = this._addIndex * this.valueSize;

			for (let i = 0; i < this.valueSize; i++) {
				this.buffer[targetIndex + i] = this.buffer[startIndex + i];
			}
		} // mix functions


		_select(buffer, dstOffset, srcOffset, t, stride) {
			if (t >= 0.5) {
				for (let i = 0; i !== stride; ++i) {
					buffer[dstOffset + i] = buffer[srcOffset + i];
				}
			}
		}

		_slerp(buffer, dstOffset, srcOffset, t) {
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
		}

		_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			const workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

			Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
		}

		_lerp(buffer, dstOffset, srcOffset, t, stride) {
			const s = 1 - t;

			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
			}
		}

		_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
			}
		}

	}

	// Characters [].:/ are reserved for track binding syntax.
	const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.


	const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

	const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.


	const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


	const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.


	const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.


	const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

	const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

	const _supportedObjectNames = ['material', 'materials', 'bones'];

	class Composite {
		constructor(targetGroup, path, optionalParsedPath) {
			const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_(path, parsedPath);
		}

		getValue(array, offset) {
			this.bind(); // bind all binding

			const firstValidIndex = this._targetGroup.nCachedObjects_,
						binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

			if (binding !== undefined) binding.getValue(array, offset);
		}

		setValue(array, offset) {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].setValue(array, offset);
			}
		}

		bind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].bind();
			}
		}

		unbind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].unbind();
			}
		}

	} // Note: This class uses a State pattern on a per-method basis:
	// 'bind' sets 'this.getValue' / 'setValue' and shadows the
	// prototype version of these methods with one that represents
	// the bound state. When the property is not found, the methods
	// become no-ops.


	class PropertyBinding {
		constructor(rootNode, path, parsedPath) {
			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
			this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
			this.rootNode = rootNode; // initial state of these methods that calls 'bind'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}

		static create(root, path, parsedPath) {
			if (!(root && root.isAnimationObjectGroup)) {
				return new PropertyBinding(root, path, parsedPath);
			} else {
				return new PropertyBinding.Composite(root, path, parsedPath);
			}
		}
		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */


		static sanitizeNodeName(name) {
			return name.replace(/\s/g, '_').replace(_reservedRe, '');
		}

		static parseTrackName(trackName) {
			const matches = _trackRe.exec(trackName);

			if (!matches) {
				throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
			}

			const results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[2],
				objectName: matches[3],
				objectIndex: matches[4],
				propertyName: matches[5],
				// required
				propertyIndex: matches[6]
			};
			const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

			if (lastDot !== undefined && lastDot !== -1) {
				const objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).

				if (_supportedObjectNames.indexOf(objectName) !== -1) {
					results.nodeName = results.nodeName.substring(0, lastDot);
					results.objectName = objectName;
				}
			}

			if (results.propertyName === null || results.propertyName.length === 0) {
				throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
			}

			return results;
		}

		static findNode(root, nodeName) {
			if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
				return root;
			} // search into skeleton bones.


			if (root.skeleton) {
				const bone = root.skeleton.getBoneByName(nodeName);

				if (bone !== undefined) {
					return bone;
				}
			} // search into node subtree.


			if (root.children) {
				const searchNodeSubtree = function (children) {
					for (let i = 0; i < children.length; i++) {
						const childNode = children[i];

						if (childNode.name === nodeName || childNode.uuid === nodeName) {
							return childNode;
						}

						const result = searchNodeSubtree(childNode.children);
						if (result) return result;
					}

					return null;
				};

				const subTreeNode = searchNodeSubtree(root.children);

				if (subTreeNode) {
					return subTreeNode;
				}
			}

			return null;
		} // these are used to "bind" a nonexistent property


		_getValue_unavailable() {}

		_setValue_unavailable() {} // Getters


		_getValue_direct(buffer, offset) {
			buffer[offset] = this.node[this.propertyName];
		}

		_getValue_array(buffer, offset) {
			const source = this.resolvedProperty;

			for (let i = 0, n = source.length; i !== n; ++i) {
				buffer[offset++] = source[i];
			}
		}

		_getValue_arrayElement(buffer, offset) {
			buffer[offset] = this.resolvedProperty[this.propertyIndex];
		}

		_getValue_toArray(buffer, offset) {
			this.resolvedProperty.toArray(buffer, offset);
		} // Direct


		_setValue_direct(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
		}

		_setValue_direct_setNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}

		_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // EntireArray


		_setValue_array(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}
		}

		_setValue_array_setNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.needsUpdate = true;
		}

		_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.matrixWorldNeedsUpdate = true;
		} // ArrayElement


		_setValue_arrayElement(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
		}

		_setValue_arrayElement_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}

		_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // HasToFromArray


		_setValue_fromArray(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
		}

		_setValue_fromArray_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.needsUpdate = true;
		}

		_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.matrixWorldNeedsUpdate = true;
		}

		_getValue_unbound(targetArray, offset) {
			this.bind();
			this.getValue(targetArray, offset);
		}

		_setValue_unbound(sourceArray, offset) {
			this.bind();
			this.setValue(sourceArray, offset);
		} // create getter / setter pair for a property in the scene graph


		bind() {
			let targetObject = this.node;
			const parsedPath = this.parsedPath;
			const objectName = parsedPath.objectName;
			const propertyName = parsedPath.propertyName;
			let propertyIndex = parsedPath.propertyIndex;

			if (!targetObject) {
				targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
				this.node = targetObject;
			} // set fail state so we can just 'return' on error


			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable; // ensure there is a value node

			if (!targetObject) {
				console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
				return;
			}

			if (objectName) {
				let objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

				switch (objectName) {
					case 'materials':
						if (!targetObject.material) {
							console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
							return;
						}

						if (!targetObject.material.materials) {
							console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
							return;
						}

						targetObject = targetObject.material.materials;
						break;

					case 'bones':
						if (!targetObject.skeleton) {
							console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
							return;
						} // potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.


						targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

						for (let i = 0; i < targetObject.length; i++) {
							if (targetObject[i].name === objectIndex) {
								objectIndex = i;
								break;
							}
						}

						break;

					default:
						if (targetObject[objectName] === undefined) {
							console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
							return;
						}

						targetObject = targetObject[objectName];
				}

				if (objectIndex !== undefined) {
					if (targetObject[objectIndex] === undefined) {
						console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
						return;
					}

					targetObject = targetObject[objectIndex];
				}
			} // resolve property


			const nodeProperty = targetObject[propertyName];

			if (nodeProperty === undefined) {
				const nodeName = parsedPath.nodeName;
				console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
				return;
			} // determine versioning scheme


			let versioning = this.Versioning.None;
			this.targetObject = targetObject;

			if (targetObject.needsUpdate !== undefined) {
				// material
				versioning = this.Versioning.NeedsUpdate;
			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
				// node transform
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
			} // determine how the property gets bound


			let bindingType = this.BindingType.Direct;

			if (propertyIndex !== undefined) {
				// access a sub element of the property array (only primitives are supported right now)
				if (propertyName === 'morphTargetInfluences') {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
						return;
					}

					if (targetObject.geometry.isBufferGeometry) {
						if (!targetObject.geometry.morphAttributes) {
							console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
							return;
						}

						if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
							propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
						}
					} else {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
						return;
					}
				}

				bindingType = this.BindingType.ArrayElement;
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
				// must use copy for Object3D.Euler/Quaternion
				bindingType = this.BindingType.HasFromToArray;
				this.resolvedProperty = nodeProperty;
			} else if (Array.isArray(nodeProperty)) {
				bindingType = this.BindingType.EntireArray;
				this.resolvedProperty = nodeProperty;
			} else {
				this.propertyName = propertyName;
			} // select getter / setter


			this.getValue = this.GetterByBindingType[bindingType];
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
		}

		unbind() {
			this.node = null; // back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}

	}

	PropertyBinding.Composite = Composite;
	PropertyBinding.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};
	PropertyBinding.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};
	PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
	PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct
	PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray
	PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement
	PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray
	PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *	- Add objects you would otherwise pass as 'root' to the
	 *		constructor or the .clipAction method of AnimationMixer.
	 *
	 *	- Instead pass this object as 'root'.
	 *
	 *	- You can also add and remove objects later when the mixer
	 *		is running.
	 *
	 * Note:
	 *
	 *		Objects of this class appear as one object to the mixer,
	 *		so cache control of the individual objects must be done
	 *		on the group.
	 *
	 * Limitation:
	 *
	 *	- The animated properties must be compatible among the
	 *		all objects in the group.
	 *
	 *	- A single property can either be controlled through a
	 *		target group or directly, but not both.
	 */

	class AnimationObjectGroup {
		constructor() {
			this.uuid = generateUUID(); // cached objects followed by the active ones

			this._objects = Array.prototype.slice.call(arguments);
			this.nCachedObjects_ = 0; // threshold
			// note: read by PropertyBinding.Composite

			const indices = {};
			this._indicesByUUID = indices; // for bookkeeping

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				indices[arguments[i].uuid] = i;
			}

			this._paths = []; // inside: string

			this._parsedPaths = []; // inside: { we don't care, here }

			this._bindings = []; // inside: Array< PropertyBinding >

			this._bindingsIndicesByPath = {}; // inside: indices in these arrays

			const scope = this;
			this.stats = {
				objects: {
					get total() {
						return scope._objects.length;
					},

					get inUse() {
						return this.total - scope.nCachedObjects_;
					}

				},

				get bindingsPerObject() {
					return scope._bindings.length;
				}

			};
		}

		add() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						nBindings = bindings.length;
			let knownObject = undefined,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid;
				let index = indicesByUUID[uuid];

				if (index === undefined) {
					// unknown object -> add it to the ACTIVE region
					index = nObjects++;
					indicesByUUID[uuid] = index;
					objects.push(object); // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
					}
				} else if (index < nCachedObjects) {
					knownObject = objects[index]; // move existing object to the ACTIVE region

					const firstActiveIndex = --nCachedObjects,
								lastCachedObject = objects[firstActiveIndex];
					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;
					indicesByUUID[uuid] = firstActiveIndex;
					objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
									lastCached = bindingsForPath[firstActiveIndex];
						let binding = bindingsForPath[index];
						bindingsForPath[index] = lastCached;

						if (binding === undefined) {
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
							binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
						}

						bindingsForPath[firstActiveIndex] = binding;
					}
				} else if (objects[index] !== knownObject) {
					console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
				} // else the object is already where we want it to be

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		}

		remove() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						bindings = this._bindings,
						nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid,
							index = indicesByUUID[uuid];

				if (index !== undefined && index >= nCachedObjects) {
					// move existing object into the CACHED region
					const lastCachedIndex = nCachedObjects++,
								firstActiveObject = objects[lastCachedIndex];
					indicesByUUID[firstActiveObject.uuid] = index;
					objects[index] = firstActiveObject;
					indicesByUUID[uuid] = lastCachedIndex;
					objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
									firstActive = bindingsForPath[lastCachedIndex],
									binding = bindingsForPath[index];
						bindingsForPath[index] = firstActive;
						bindingsForPath[lastCachedIndex] = binding;
					}
				}
			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // remove & forget


		uncache() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						bindings = this._bindings,
						nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_,
					nObjects = objects.length;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid,
							index = indicesByUUID[uuid];

				if (index !== undefined) {
					delete indicesByUUID[uuid];

					if (index < nCachedObjects) {
						// object is cached, shrink the CACHED region
						const firstActiveIndex = --nCachedObjects,
									lastCachedObject = objects[firstActiveIndex],
									lastIndex = --nObjects,
									lastObject = objects[lastIndex]; // last cached object takes this object's place

						indicesByUUID[lastCachedObject.uuid] = index;
						objects[index] = lastCachedObject; // last object goes to the activated slot and pop

						indicesByUUID[lastObject.uuid] = firstActiveIndex;
						objects[firstActiveIndex] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j],
										lastCached = bindingsForPath[firstActiveIndex],
										last = bindingsForPath[lastIndex];
							bindingsForPath[index] = lastCached;
							bindingsForPath[firstActiveIndex] = last;
							bindingsForPath.pop();
						}
					} else {
						// object is active, just swap with the last and pop
						const lastIndex = --nObjects,
									lastObject = objects[lastIndex];

						if (lastIndex > 0) {
							indicesByUUID[lastObject.uuid] = index;
						}

						objects[index] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j];
							bindingsForPath[index] = bindingsForPath[lastIndex];
							bindingsForPath.pop();
						}
					} // cached or active

				} // if object is known

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // Internal interface used by befriended PropertyBinding.Composite:


		subscribe_(path, parsedPath) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
			const indicesByPath = this._bindingsIndicesByPath;
			let index = indicesByPath[path];
			const bindings = this._bindings;
			if (index !== undefined) return bindings[index];
			const paths = this._paths,
						parsedPaths = this._parsedPaths,
						objects = this._objects,
						nObjects = objects.length,
						nCachedObjects = this.nCachedObjects_,
						bindingsForPath = new Array(nObjects);
			index = bindings.length;
			indicesByPath[path] = index;
			paths.push(path);
			parsedPaths.push(parsedPath);
			bindings.push(bindingsForPath);

			for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
				const object = objects[i];
				bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
			}

			return bindingsForPath;
		}

		unsubscribe_(path) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
			const indicesByPath = this._bindingsIndicesByPath,
						index = indicesByPath[path];

			if (index !== undefined) {
				const paths = this._paths,
							parsedPaths = this._parsedPaths,
							bindings = this._bindings,
							lastBindingsIndex = bindings.length - 1,
							lastBindings = bindings[lastBindingsIndex],
							lastBindingsPath = path[lastBindingsIndex];
				indicesByPath[lastBindingsPath] = index;
				bindings[index] = lastBindings;
				bindings.pop();
				parsedPaths[index] = parsedPaths[lastBindingsIndex];
				parsedPaths.pop();
				paths[index] = paths[lastBindingsIndex];
				paths.pop();
			}
		}

	}

	AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

	class AnimationAction {
		constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;
			const tracks = clip.tracks,
						nTracks = tracks.length,
						interpolants = new Array(nTracks);
			const interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for (let i = 0; i !== nTracks; ++i) {
				const interpolant = tracks[i].createInterpolant(null);
				interpolants[i] = interpolant;
				interpolant.settings = interpolantSettings;
			}

			this._interpolantSettings = interpolantSettings;
			this._interpolants = interpolants; // bound by the mixer
			// inside: PropertyMixer (managed by the mixer)

			this._propertyBindings = new Array(nTracks);
			this._cacheIndex = null; // for the memory manager

			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
			this.loop = LoopRepeat;
			this._loopCount = -1; // global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action

			this._startTime = null; // scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop

			this.time = 0;
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
			this.weight = 1;
			this._effectiveWeight = 1;
			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale

			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false; // keep feeding the last frame?

			this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

			this.zeroSlopeAtEnd = true; // clips for start, loop and end
		} // State & Scheduling


		play() {
			this._mixer._activateAction(this);

			return this;
		}

		stop() {
			this._mixer._deactivateAction(this);

			return this.reset();
		}

		reset() {
			this.paused = false;
			this.enabled = true;
			this.time = 0; // restart clip

			this._loopCount = -1; // forget previous loops

			this._startTime = null; // forget scheduling

			return this.stopFading().stopWarping();
		}

		isRunning() {
			return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
		} // return true when play has been called


		isScheduled() {
			return this._mixer._isActiveAction(this);
		}

		startAt(time) {
			this._startTime = time;
			return this;
		}

		setLoop(mode, repetitions) {
			this.loop = mode;
			this.repetitions = repetitions;
			return this;
		} // Weight
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing


		setEffectiveWeight(weight) {
			this.weight = weight; // note: same logic as when updated at runtime

			this._effectiveWeight = this.enabled ? weight : 0;
			return this.stopFading();
		} // return the weight considering fading and .enabled


		getEffectiveWeight() {
			return this._effectiveWeight;
		}

		fadeIn(duration) {
			return this._scheduleFading(duration, 0, 1);
		}

		fadeOut(duration) {
			return this._scheduleFading(duration, 1, 0);
		}

		crossFadeFrom(fadeOutAction, duration, warp) {
			fadeOutAction.fadeOut(duration);
			this.fadeIn(duration);

			if (warp) {
				const fadeInDuration = this._clip.duration,
							fadeOutDuration = fadeOutAction._clip.duration,
							startEndRatio = fadeOutDuration / fadeInDuration,
							endStartRatio = fadeInDuration / fadeOutDuration;
				fadeOutAction.warp(1.0, startEndRatio, duration);
				this.warp(endStartRatio, 1.0, duration);
			}

			return this;
		}

		crossFadeTo(fadeInAction, duration, warp) {
			return fadeInAction.crossFadeFrom(this, duration, warp);
		}

		stopFading() {
			const weightInterpolant = this._weightInterpolant;

			if (weightInterpolant !== null) {
				this._weightInterpolant = null;

				this._mixer._takeBackControlInterpolant(weightInterpolant);
			}

			return this;
		} // Time Scale Control
		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing


		setEffectiveTimeScale(timeScale) {
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;
			return this.stopWarping();
		} // return the time scale considering warping and .paused


		getEffectiveTimeScale() {
			return this._effectiveTimeScale;
		}

		setDuration(duration) {
			this.timeScale = this._clip.duration / duration;
			return this.stopWarping();
		}

		syncWith(action) {
			this.time = action.time;
			this.timeScale = action.timeScale;
			return this.stopWarping();
		}

		halt(duration) {
			return this.warp(this._effectiveTimeScale, 0, duration);
		}

		warp(startTimeScale, endTimeScale, duration) {
			const mixer = this._mixer,
						now = mixer.time,
						timeScale = this.timeScale;
			let interpolant = this._timeScaleInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions,
						values = interpolant.sampleValues;
			times[0] = now;
			times[1] = now + duration;
			values[0] = startTimeScale / timeScale;
			values[1] = endTimeScale / timeScale;
			return this;
		}

		stopWarping() {
			const timeScaleInterpolant = this._timeScaleInterpolant;

			if (timeScaleInterpolant !== null) {
				this._timeScaleInterpolant = null;

				this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
			}

			return this;
		} // Object Accessors


		getMixer() {
			return this._mixer;
		}

		getClip() {
			return this._clip;
		}

		getRoot() {
			return this._localRoot || this._mixer._root;
		} // Interna


		_update(time, deltaTime, timeDirection, accuIndex) {
			// called by the mixer
			if (!this.enabled) {
				// call ._updateWeight() to update ._effectiveWeight
				this._updateWeight(time);

				return;
			}

			const startTime = this._startTime;

			if (startTime !== null) {
				// check for scheduled start of action
				const timeRunning = (time - startTime) * timeDirection;

				if (timeRunning < 0 || timeDirection === 0) {
					return; // yet to come / don't decide when delta = 0
				} // start


				this._startTime = null; // unschedule

				deltaTime = timeDirection * timeRunning;
			} // apply time scale and advance time


			deltaTime *= this._updateTimeScale(time);

			const clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
			// an effective weight of 0


			const weight = this._updateWeight(time);

			if (weight > 0) {
				const interpolants = this._interpolants;
				const propertyMixers = this._propertyBindings;

				switch (this.blendMode) {
					case AdditiveAnimationBlendMode:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulateAdditive(weight);
						}

						break;

					case NormalAnimationBlendMode:
					default:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulate(accuIndex, weight);
						}

				}
			}
		}

		_updateWeight(time) {
			let weight = 0;

			if (this.enabled) {
				weight = this.weight;
				const interpolant = this._weightInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					weight *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopFading();

						if (interpolantValue === 0) {
							// faded out, disable
							this.enabled = false;
						}
					}
				}
			}

			this._effectiveWeight = weight;
			return weight;
		}

		_updateTimeScale(time) {
			let timeScale = 0;

			if (!this.paused) {
				timeScale = this.timeScale;
				const interpolant = this._timeScaleInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					timeScale *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopWarping();

						if (timeScale === 0) {
							// motion has halted, pause
							this.paused = true;
						} else {
							// warp done - apply final time scale
							this.timeScale = timeScale;
						}
					}
				}
			}

			this._effectiveTimeScale = timeScale;
			return timeScale;
		}

		_updateTime(deltaTime) {
			const duration = this._clip.duration;
			const loop = this.loop;
			let time = this.time + deltaTime;
			let loopCount = this._loopCount;
			const pingPong = loop === LoopPingPong;

			if (deltaTime === 0) {
				if (loopCount === -1) return time;
				return pingPong && (loopCount & 1) === 1 ? duration - time : time;
			}

			if (loop === LoopOnce) {
				if (loopCount === -1) {
					// just started
					this._loopCount = 0;

					this._setEndings(true, true, false);
				}

				handle_stop: {
					if (time >= duration) {
						time = duration;
					} else if (time < 0) {
						time = 0;
					} else {
						this.time = time;
						break handle_stop;
					}

					if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
					this.time = time;

					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: deltaTime < 0 ? -1 : 1
					});
				}
			} else {
				// repetitive Repeat or PingPong
				if (loopCount === -1) {
					// just started
					if (deltaTime >= 0) {
						loopCount = 0;

						this._setEndings(true, this.repetitions === 0, pingPong);
					} else {
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
						this._setEndings(this.repetitions === 0, true, pingPong);
					}
				}

				if (time >= duration || time < 0) {
					// wrap around
					const loopDelta = Math.floor(time / duration); // signed

					time -= duration * loopDelta;
					loopCount += Math.abs(loopDelta);
					const pending = this.repetitions - loopCount;

					if (pending <= 0) {
						// have to stop (switch state, clamp time, fire event)
						if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
						time = deltaTime > 0 ? duration : 0;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'finished',
							action: this,
							direction: deltaTime > 0 ? 1 : -1
						});
					} else {
						// keep running
						if (pending === 1) {
							// entering the last round
							const atStart = deltaTime < 0;

							this._setEndings(atStart, !atStart, pingPong);
						} else {
							this._setEndings(false, false, pingPong);
						}

						this._loopCount = loopCount;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'loop',
							action: this,
							loopDelta: loopDelta
						});
					}
				} else {
					this.time = time;
				}

				if (pingPong && (loopCount & 1) === 1) {
					// invert time for the "pong round"
					return duration - time;
				}
			}

			return time;
		}

		_setEndings(atStart, atEnd, pingPong) {
			const settings = this._interpolantSettings;

			if (pingPong) {
				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;
			} else {
				// assuming for LoopOnce atStart == atEnd == true
				if (atStart) {
					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingStart = WrapAroundEnding;
				}

				if (atEnd) {
					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingEnd = WrapAroundEnding;
				}
			}
		}

		_scheduleFading(duration, weightNow, weightThen) {
			const mixer = this._mixer,
						now = mixer.time;
			let interpolant = this._weightInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions,
						values = interpolant.sampleValues;
			times[0] = now;
			values[0] = weightNow;
			times[1] = now + duration;
			values[1] = weightThen;
			return this;
		}

	}

	class AnimationMixer extends EventDispatcher {
		constructor(root) {
			super();
			this._root = root;

			this._initMemoryManager();

			this._accuIndex = 0;
			this.time = 0;
			this.timeScale = 1.0;
		}

		_bindAction(action, prototypeAction) {
			const root = action._localRoot || this._root,
						tracks = action._clip.tracks,
						nTracks = tracks.length,
						bindings = action._propertyBindings,
						interpolants = action._interpolants,
						rootUuid = root.uuid,
						bindingsByRoot = this._bindingsByRootAndName;
			let bindingsByName = bindingsByRoot[rootUuid];

			if (bindingsByName === undefined) {
				bindingsByName = {};
				bindingsByRoot[rootUuid] = bindingsByName;
			}

			for (let i = 0; i !== nTracks; ++i) {
				const track = tracks[i],
							trackName = track.name;
				let binding = bindingsByName[trackName];

				if (binding !== undefined) {
					bindings[i] = binding;
				} else {
					binding = bindings[i];

					if (binding !== undefined) {
						// existing binding, make sure the cache knows
						if (binding._cacheIndex === null) {
							++binding.referenceCount;

							this._addInactiveBinding(binding, rootUuid, trackName);
						}

						continue;
					}

					const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
					binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
					++binding.referenceCount;

					this._addInactiveBinding(binding, rootUuid, trackName);

					bindings[i] = binding;
				}

				interpolants[i].resultBuffer = binding.buffer;
			}
		}

		_activateAction(action) {
			if (!this._isActiveAction(action)) {
				if (action._cacheIndex === null) {
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
					const rootUuid = (action._localRoot || this._root).uuid,
								clipUuid = action._clip.uuid,
								actionsForClip = this._actionsByClip[clipUuid];

					this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

					this._addInactiveAction(action, clipUuid, rootUuid);
				}

				const bindings = action._propertyBindings; // increment reference counts / sort out state

				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (binding.useCount++ === 0) {
						this._lendBinding(binding);

						binding.saveOriginalState();
					}
				}

				this._lendAction(action);
			}
		}

		_deactivateAction(action) {
			if (this._isActiveAction(action)) {
				const bindings = action._propertyBindings; // decrement reference counts / sort out state

				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (--binding.useCount === 0) {
						binding.restoreOriginalState();

						this._takeBackBinding(binding);
					}
				}

				this._takeBackAction(action);
			}
		} // Memory manager


		_initMemoryManager() {
			this._actions = []; // 'nActiveActions' followed by inactive ones

			this._nActiveActions = 0;
			this._actionsByClip = {}; // inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }

			this._bindings = []; // 'nActiveBindings' followed by inactive ones

			this._nActiveBindings = 0;
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

			this._controlInterpolants = []; // same game as above

			this._nActiveControlInterpolants = 0;
			const scope = this;
			this.stats = {
				actions: {
					get total() {
						return scope._actions.length;
					},

					get inUse() {
						return scope._nActiveActions;
					}

				},
				bindings: {
					get total() {
						return scope._bindings.length;
					},

					get inUse() {
						return scope._nActiveBindings;
					}

				},
				controlInterpolants: {
					get total() {
						return scope._controlInterpolants.length;
					},

					get inUse() {
						return scope._nActiveControlInterpolants;
					}

				}
			};
		} // Memory management for AnimationAction objects


		_isActiveAction(action) {
			const index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
		}

		_addInactiveAction(action, clipUuid, rootUuid) {
			const actions = this._actions,
						actionsByClip = this._actionsByClip;
			let actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip === undefined) {
				actionsForClip = {
					knownActions: [action],
					actionByRoot: {}
				};
				action._byClipCacheIndex = 0;
				actionsByClip[clipUuid] = actionsForClip;
			} else {
				const knownActions = actionsForClip.knownActions;
				action._byClipCacheIndex = knownActions.length;
				knownActions.push(action);
			}

			action._cacheIndex = actions.length;
			actions.push(action);
			actionsForClip.actionByRoot[rootUuid] = action;
		}

		_removeInactiveAction(action) {
			const actions = this._actions,
						lastInactiveAction = actions[actions.length - 1],
						cacheIndex = action._cacheIndex;
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[cacheIndex] = lastInactiveAction;
			actions.pop();
			action._cacheIndex = null;
			const clipUuid = action._clip.uuid,
						actionsByClip = this._actionsByClip,
						actionsForClip = actionsByClip[clipUuid],
						knownActionsForClip = actionsForClip.knownActions,
						lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
						byClipCacheIndex = action._byClipCacheIndex;
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[byClipCacheIndex] = lastKnownAction;
			knownActionsForClip.pop();
			action._byClipCacheIndex = null;
			const actionByRoot = actionsForClip.actionByRoot,
						rootUuid = (action._localRoot || this._root).uuid;
			delete actionByRoot[rootUuid];

			if (knownActionsForClip.length === 0) {
				delete actionsByClip[clipUuid];
			}

			this._removeInactiveBindingsForAction(action);
		}

		_removeInactiveBindingsForAction(action) {
			const bindings = action._propertyBindings;

			for (let i = 0, n = bindings.length; i !== n; ++i) {
				const binding = bindings[i];

				if (--binding.referenceCount === 0) {
					this._removeInactiveBinding(binding);
				}
			}
		}

		_lendAction(action) {
			// [ active actions |	inactive actions	]
			// [	active actions >| inactive actions ]
			//								 s				a
			//									<-swap->
			//								 a				s
			const actions = this._actions,
						prevIndex = action._cacheIndex,
						lastActiveIndex = this._nActiveActions++,
						firstInactiveAction = actions[lastActiveIndex];
			action._cacheIndex = lastActiveIndex;
			actions[lastActiveIndex] = action;
			firstInactiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = firstInactiveAction;
		}

		_takeBackAction(action) {
			// [	active actions	| inactive actions ]
			// [ active actions |< inactive actions	]
			//				a				s
			//				 <-swap->
			//				s				a
			const actions = this._actions,
						prevIndex = action._cacheIndex,
						firstInactiveIndex = --this._nActiveActions,
						lastActiveAction = actions[firstInactiveIndex];
			action._cacheIndex = firstInactiveIndex;
			actions[firstInactiveIndex] = action;
			lastActiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = lastActiveAction;
		} // Memory management for PropertyMixer objects


		_addInactiveBinding(binding, rootUuid, trackName) {
			const bindingsByRoot = this._bindingsByRootAndName,
						bindings = this._bindings;
			let bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName === undefined) {
				bindingByName = {};
				bindingsByRoot[rootUuid] = bindingByName;
			}

			bindingByName[trackName] = binding;
			binding._cacheIndex = bindings.length;
			bindings.push(binding);
		}

		_removeInactiveBinding(binding) {
			const bindings = this._bindings,
						propBinding = binding.binding,
						rootUuid = propBinding.rootNode.uuid,
						trackName = propBinding.path,
						bindingsByRoot = this._bindingsByRootAndName,
						bindingByName = bindingsByRoot[rootUuid],
						lastInactiveBinding = bindings[bindings.length - 1],
						cacheIndex = binding._cacheIndex;
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[cacheIndex] = lastInactiveBinding;
			bindings.pop();
			delete bindingByName[trackName];

			if (Object.keys(bindingByName).length === 0) {
				delete bindingsByRoot[rootUuid];
			}
		}

		_lendBinding(binding) {
			const bindings = this._bindings,
						prevIndex = binding._cacheIndex,
						lastActiveIndex = this._nActiveBindings++,
						firstInactiveBinding = bindings[lastActiveIndex];
			binding._cacheIndex = lastActiveIndex;
			bindings[lastActiveIndex] = binding;
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = firstInactiveBinding;
		}

		_takeBackBinding(binding) {
			const bindings = this._bindings,
						prevIndex = binding._cacheIndex,
						firstInactiveIndex = --this._nActiveBindings,
						lastActiveBinding = bindings[firstInactiveIndex];
			binding._cacheIndex = firstInactiveIndex;
			bindings[firstInactiveIndex] = binding;
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = lastActiveBinding;
		} // Memory management of Interpolants for weight and time scale


		_lendControlInterpolant() {
			const interpolants = this._controlInterpolants,
						lastActiveIndex = this._nActiveControlInterpolants++;
			let interpolant = interpolants[lastActiveIndex];

			if (interpolant === undefined) {
				interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[lastActiveIndex] = interpolant;
			}

			return interpolant;
		}

		_takeBackControlInterpolant(interpolant) {
			const interpolants = this._controlInterpolants,
						prevIndex = interpolant.__cacheIndex,
						firstInactiveIndex = --this._nActiveControlInterpolants,
						lastActiveInterpolant = interpolants[firstInactiveIndex];
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[firstInactiveIndex] = interpolant;
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[prevIndex] = lastActiveInterpolant;
		} // return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)


		clipAction(clip, optionalRoot, blendMode) {
			const root = optionalRoot || this._root,
						rootUuid = root.uuid;
			let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
			const clipUuid = clipObject !== null ? clipObject.uuid : clip;
			const actionsForClip = this._actionsByClip[clipUuid];
			let prototypeAction = null;

			if (blendMode === undefined) {
				if (clipObject !== null) {
					blendMode = clipObject.blendMode;
				} else {
					blendMode = NormalAnimationBlendMode;
				}
			}

			if (actionsForClip !== undefined) {
				const existingAction = actionsForClip.actionByRoot[rootUuid];

				if (existingAction !== undefined && existingAction.blendMode === blendMode) {
					return existingAction;
				} // we know the clip, so we don't have to parse all
				// the bindings again but can just copy


				prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

				if (clipObject === null) clipObject = prototypeAction._clip;
			} // clip must be known when specified via string


			if (clipObject === null) return null; // allocate all resources required to run it

			const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

			this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


			this._addInactiveAction(newAction, clipUuid, rootUuid);

			return newAction;
		} // get an existing action


		existingAction(clip, optionalRoot) {
			const root = optionalRoot || this._root,
						rootUuid = root.uuid,
						clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
						clipUuid = clipObject ? clipObject.uuid : clip,
						actionsForClip = this._actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				return actionsForClip.actionByRoot[rootUuid] || null;
			}

			return null;
		} // deactivates all previously scheduled actions


		stopAllAction() {
			const actions = this._actions,
						nActions = this._nActiveActions;

			for (let i = nActions - 1; i >= 0; --i) {
				actions[i].stop();
			}

			return this;
		} // advance the time and update apply the animation


		update(deltaTime) {
			deltaTime *= this.timeScale;
			const actions = this._actions,
						nActions = this._nActiveActions,
						time = this.time += deltaTime,
						timeDirection = Math.sign(deltaTime),
						accuIndex = this._accuIndex ^= 1; // run active actions

			for (let i = 0; i !== nActions; ++i) {
				const action = actions[i];

				action._update(time, deltaTime, timeDirection, accuIndex);
			} // update scene graph


			const bindings = this._bindings,
						nBindings = this._nActiveBindings;

			for (let i = 0; i !== nBindings; ++i) {
				bindings[i].apply(accuIndex);
			}

			return this;
		} // Allows you to seek to a specific time in an animation.


		setTime(timeInSeconds) {
			this.time = 0; // Zero out time attribute for AnimationMixer object;

			for (let i = 0; i < this._actions.length; i++) {
				this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
			}

			return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
		} // return this mixer's root target object


		getRoot() {
			return this._root;
		} // free all resources specific to a particular clip


		uncacheClip(clip) {
			const actions = this._actions,
						clipUuid = clip.uuid,
						actionsByClip = this._actionsByClip,
						actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
				const actionsToRemove = actionsForClip.knownActions;

				for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
					const action = actionsToRemove[i];

					this._deactivateAction(action);

					const cacheIndex = action._cacheIndex,
								lastInactiveAction = actions[actions.length - 1];
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[cacheIndex] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction(action);
				}

				delete actionsByClip[clipUuid];
			}
		} // free all resources specific to a particular root target object


		uncacheRoot(root) {
			const rootUuid = root.uuid,
						actionsByClip = this._actionsByClip;

			for (const clipUuid in actionsByClip) {
				const actionByRoot = actionsByClip[clipUuid].actionByRoot,
							action = actionByRoot[rootUuid];

				if (action !== undefined) {
					this._deactivateAction(action);

					this._removeInactiveAction(action);
				}
			}

			const bindingsByRoot = this._bindingsByRootAndName,
						bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName !== undefined) {
				for (const trackName in bindingByName) {
					const binding = bindingByName[trackName];
					binding.restoreOriginalState();

					this._removeInactiveBinding(binding);
				}
			}
		} // remove a targeted clip from the cache


		uncacheAction(clip, optionalRoot) {
			const action = this.existingAction(clip, optionalRoot);

			if (action !== null) {
				this._deactivateAction(action);

				this._removeInactiveAction(action);
			}
		}

	}

	AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);

	class Uniform {
		constructor(value) {
			if (typeof value === 'string') {
				console.warn('THREE.Uniform: Type parameter is no longer needed.');
				value = arguments[1];
			}

			this.value = value;
		}

		clone() {
			return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
		}

	}

	class InstancedInterleavedBuffer extends InterleavedBuffer {
		constructor(array, stride, meshPerAttribute = 1) {
			super(array, stride);
			this.meshPerAttribute = meshPerAttribute;
		}

		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}

		clone(data) {
			const ib = super.clone(data);
			ib.meshPerAttribute = this.meshPerAttribute;
			return ib;
		}

		toJSON(data) {
			const json = super.toJSON(data);
			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;
			return json;
		}

	}

	InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

	class GLBufferAttribute {
		constructor(buffer, type, itemSize, elementSize, count) {
			this.buffer = buffer;
			this.type = type;
			this.itemSize = itemSize;
			this.elementSize = elementSize;
			this.count = count;
			this.version = 0;
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setBuffer(buffer) {
			this.buffer = buffer;
			return this;
		}

		setType(type, elementSize) {
			this.type = type;
			this.elementSize = elementSize;
			return this;
		}

		setItemSize(itemSize) {
			this.itemSize = itemSize;
			return this;
		}

		setCount(count) {
			this.count = count;
			return this;
		}

	}

	GLBufferAttribute.prototype.isGLBufferAttribute = true;

	class Raycaster {
		constructor(origin, direction, near = 0, far = Infinity) {
			this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();
			this.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			};
		}

		set(origin, direction) {
			// direction is assumed to be normalized (for accurate distance calculations)
			this.ray.set(origin, direction);
		}

		setFromCamera(coords, camera) {
			if (camera && camera.isPerspectiveCamera) {
				this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
				this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
				this.camera = camera;
			} else if (camera && camera.isOrthographicCamera) {
				this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

				this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
				this.camera = camera;
			} else {
				console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
			}
		}

		intersectObject(object, recursive = false, intersects = []) {
			intersectObject(object, this, intersects, recursive);
			intersects.sort(ascSort);
			return intersects;
		}

		intersectObjects(objects, recursive = false, intersects = []) {
			for (let i = 0, l = objects.length; i < l; i++) {
				intersectObject(objects[i], this, intersects, recursive);
			}

			intersects.sort(ascSort);
			return intersects;
		}

	}

	function ascSort(a, b) {
		return a.distance - b.distance;
	}

	function intersectObject(object, raycaster, intersects, recursive) {
		if (object.layers.test(raycaster.layers)) {
			object.raycast(raycaster, intersects);
		}

		if (recursive === true) {
			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				intersectObject(children[i], raycaster, intersects, true);
			}
		}
	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	class Spherical {
		constructor(radius = 1, phi = 0, theta = 0) {
			this.radius = radius;
			this.phi = phi; // polar angle

			this.theta = theta; // azimuthal angle

			return this;
		}

		set(radius, phi, theta) {
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
			return this;
		}

		copy(other) {
			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;
			return this;
		} // restrict phi to be betwee EPS and PI-EPS


		makeSafe() {
			const EPS = 0.000001;
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
			return this;
		}

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + y * y + z * z);

			if (this.radius === 0) {
				this.theta = 0;
				this.phi = 0;
			} else {
				this.theta = Math.atan2(x, z);
				this.phi = Math.acos(clamp(y / this.radius, -1, 1));
			}

			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */
	class Cylindrical {
		constructor(radius = 1, theta = 0, y = 0) {
			this.radius = radius; // distance from the origin to a point in the x-z plane

			this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

			this.y = y; // height above the x-z plane

			return this;
		}

		set(radius, theta, y) {
			this.radius = radius;
			this.theta = theta;
			this.y = y;
			return this;
		}

		copy(other) {
			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;
			return this;
		}

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + z * z);
			this.theta = Math.atan2(x, z);
			this.y = y;
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	const _vector$4 = /*@__PURE__*/new Vector2();

	class Box2 {
		constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
			this.min = min;
			this.max = max;
		}

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		}

		setFromCenterAndSize(center, size) {
			const halfSize = _vector$4.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}

		makeEmpty() {
			this.min.x = this.min.y = +Infinity;
			this.max.x = this.max.y = -Infinity;
			return this;
		}

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y;
		}

		getCenter(target) {
			return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}

		getSize(target) {
			return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
		}

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}

		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
		}

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
		}

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
		}

		intersectsBox(box) {
			// using 4 splitting planes to rule out intersections
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
		}

		clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		}

		distanceToPoint(point) {
			const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		}

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);
			return this;
		}

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}

	}

	Box2.prototype.isBox2 = true;

	const _startP = /*@__PURE__*/new Vector3();

	const _startEnd = /*@__PURE__*/new Vector3();

	class Line3 {
		constructor(start = new Vector3(), end = new Vector3()) {
			this.start = start;
			this.end = end;
		}

		set(start, end) {
			this.start.copy(start);
			this.end.copy(end);
			return this;
		}

		copy(line) {
			this.start.copy(line.start);
			this.end.copy(line.end);
			return this;
		}

		getCenter(target) {
			return target.addVectors(this.start, this.end).multiplyScalar(0.5);
		}

		delta(target) {
			return target.subVectors(this.end, this.start);
		}

		distanceSq() {
			return this.start.distanceToSquared(this.end);
		}

		distance() {
			return this.start.distanceTo(this.end);
		}

		at(t, target) {
			return this.delta(target).multiplyScalar(t).add(this.start);
		}

		closestPointToPointParameter(point, clampToLine) {
			_startP.subVectors(point, this.start);

			_startEnd.subVectors(this.end, this.start);

			const startEnd2 = _startEnd.dot(_startEnd);

			const startEnd_startP = _startEnd.dot(_startP);

			let t = startEnd_startP / startEnd2;

			if (clampToLine) {
				t = clamp(t, 0, 1);
			}

			return t;
		}

		closestPointToPoint(point, clampToLine, target) {
			const t = this.closestPointToPointParameter(point, clampToLine);
			return this.delta(target).multiplyScalar(t).add(this.start);
		}

		applyMatrix4(matrix) {
			this.start.applyMatrix4(matrix);
			this.end.applyMatrix4(matrix);
			return this;
		}

		equals(line) {
			return line.start.equals(this.start) && line.end.equals(this.end);
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	class ImmediateRenderObject extends Object3D {
		constructor(material) {
			super();
			this.material = material;

			this.render = function ()
			/* renderCallback */
			{};

			this.hasPositions = false;
			this.hasNormals = false;
			this.hasColors = false;
			this.hasUvs = false;
			this.positionArray = null;
			this.normalArray = null;
			this.colorArray = null;
			this.uvArray = null;
			this.count = 0;
		}

	}

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	const _vector$3 = /*@__PURE__*/new Vector3();

	class SpotLightHelper extends Object3D {
		constructor(light, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			const geometry = new BufferGeometry();
			const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

			for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
				const p1 = i / l * Math.PI * 2;
				const p2 = j / l * Math.PI * 2;
				positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.cone = new LineSegments(geometry, material);
			this.add(this.cone);
			this.update();
		}

		dispose() {
			this.cone.geometry.dispose();
			this.cone.material.dispose();
		}

		update() {
			this.light.updateMatrixWorld();
			const coneLength = this.light.distance ? this.light.distance : 1000;
			const coneWidth = coneLength * Math.tan(this.light.angle);
			this.cone.scale.set(coneWidth, coneWidth, coneLength);

			_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);

			this.cone.lookAt(_vector$3);

			if (this.color !== undefined) {
				this.cone.material.color.set(this.color);
			} else {
				this.cone.material.color.copy(this.light.color);
			}
		}

	}

	const _vector$2 = /*@__PURE__*/new Vector3();

	const _boneMatrix = /*@__PURE__*/new Matrix4();

	const _matrixWorldInv = /*@__PURE__*/new Matrix4();

	class SkeletonHelper extends LineSegments {
		constructor(object) {
			const bones = getBoneList(object);
			const geometry = new BufferGeometry();
			const vertices = [];
			const colors = [];
			const color1 = new Color(0, 0, 1);
			const color2 = new Color(0, 1, 0);

			for (let i = 0; i < bones.length; i++) {
				const bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					vertices.push(0, 0, 0);
					vertices.push(0, 0, 0);
					colors.push(color1.r, color1.g, color1.b);
					colors.push(color2.r, color2.g, color2.b);
				}
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				depthTest: false,
				depthWrite: false,
				toneMapped: false,
				transparent: true
			});
			super(geometry, material);
			this.type = 'SkeletonHelper';
			this.isSkeletonHelper = true;
			this.root = object;
			this.bones = bones;
			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;
		}

		updateMatrixWorld(force) {
			const bones = this.bones;
			const geometry = this.geometry;
			const position = geometry.getAttribute('position');

			_matrixWorldInv.copy(this.root.matrixWorld).invert();

			for (let i = 0, j = 0; i < bones.length; i++) {
				const bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

					_vector$2.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);

					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

					_vector$2.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
					j += 2;
				}
			}

			geometry.getAttribute('position').needsUpdate = true;
			super.updateMatrixWorld(force);
		}

	}

	function getBoneList(object) {
		const boneList = [];

		if (object && object.isBone) {
			boneList.push(object);
		}

		for (let i = 0; i < object.children.length; i++) {
			boneList.push.apply(boneList, getBoneList(object.children[i]));
		}

		return boneList;
	}

	class PointLightHelper extends Mesh {
		constructor(light, sphereSize, color) {
			const geometry = new SphereGeometry(sphereSize, 4, 2);
			const material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			super(geometry, material);
			this.light = light;
			this.light.updateMatrixWorld();
			this.color = color;
			this.type = 'PointLightHelper';
			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.update();
			/*
			// TODO: delete this comment?
			const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
			const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
			const d = light.distance;
			if ( d === 0.0 ) {
				this.lightDistance.visible = false;
			} else {
				this.lightDistance.scale.set( d, d, d );
			}
			this.add( this.lightDistance );
			*/
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

		update() {
			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				this.material.color.copy(this.light.color);
			}
			/*
			const d = this.light.distance;
				if ( d === 0.0 ) {
					this.lightDistance.visible = false;
				} else {
					this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
				}
			*/

		}

	}

	const _vector$1 = /*@__PURE__*/new Vector3();

	const _color1 = /*@__PURE__*/new Color();

	const _color2 = /*@__PURE__*/new Color();

	class HemisphereLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			const geometry = new OctahedronGeometry(size);
			geometry.rotateY(Math.PI * 0.5);
			this.material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			if (this.color === undefined) this.material.vertexColors = true;
			const position = geometry.getAttribute('position');
			const colors = new Float32Array(position.count * 3);
			geometry.setAttribute('color', new BufferAttribute(colors, 3));
			this.add(new Mesh(geometry, this.material));
			this.update();
		}

		dispose() {
			this.children[0].geometry.dispose();
			this.children[0].material.dispose();
		}

		update() {
			const mesh = this.children[0];

			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				const colors = mesh.geometry.getAttribute('color');

				_color1.copy(this.light.color);

				_color2.copy(this.light.groundColor);

				for (let i = 0, l = colors.count; i < l; i++) {
					const color = i < l / 2 ? _color1 : _color2;
					colors.setXYZ(i, color.r, color.g, color.b);
				}

				colors.needsUpdate = true;
			}

			mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
		}

	}

	class GridHelper extends LineSegments {
		constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const center = divisions / 2;
			const step = size / divisions;
			const halfSize = size / 2;
			const vertices = [],
						colors = [];

			for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
				vertices.push(-halfSize, 0, k, halfSize, 0, k);
				vertices.push(k, 0, -halfSize, k, 0, halfSize);
				const color = i === center ? color1 : color2;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
			}

			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'GridHelper';
		}

	}

	class PolarGridHelper extends LineSegments {
		constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const vertices = [];
			const colors = []; // create the radials

			for (let i = 0; i <= radials; i++) {
				const v = i / radials * (Math.PI * 2);
				const x = Math.sin(v) * radius;
				const z = Math.cos(v) * radius;
				vertices.push(0, 0, 0);
				vertices.push(x, 0, z);
				const color = i & 1 ? color1 : color2;
				colors.push(color.r, color.g, color.b);
				colors.push(color.r, color.g, color.b);
			} // create the circles


			for (let i = 0; i <= circles; i++) {
				const color = i & 1 ? color1 : color2;
				const r = radius - radius / circles * i;

				for (let j = 0; j < divisions; j++) {
					// first vertex
					let v = j / divisions * (Math.PI * 2);
					let x = Math.sin(v) * r;
					let z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b); // second vertex

					v = (j + 1) / divisions * (Math.PI * 2);
					x = Math.sin(v) * r;
					z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b);
				}
			}

			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'PolarGridHelper';
		}

	}

	const _v1 = /*@__PURE__*/new Vector3();

	const _v2 = /*@__PURE__*/new Vector3();

	const _v3 = /*@__PURE__*/new Vector3();

	class DirectionalLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			if (size === undefined) size = 1;
			let geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.lightPlane = new Line(geometry, material);
			this.add(this.lightPlane);
			geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
			this.targetLine = new Line(geometry, material);
			this.add(this.targetLine);
			this.update();
		}

		dispose() {
			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();
		}

		update() {
			_v1.setFromMatrixPosition(this.light.matrixWorld);

			_v2.setFromMatrixPosition(this.light.target.matrixWorld);

			_v3.subVectors(_v2, _v1);

			this.lightPlane.lookAt(_v2);

			if (this.color !== undefined) {
				this.lightPlane.material.color.set(this.color);
				this.targetLine.material.color.set(this.color);
			} else {
				this.lightPlane.material.color.copy(this.light.color);
				this.targetLine.material.color.copy(this.light.color);
			}

			this.targetLine.lookAt(_v2);
			this.targetLine.scale.z = _v3.length();
		}

	}

	const _vector = /*@__PURE__*/new Vector3();

	const _camera = /*@__PURE__*/new Camera();
	/**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */


	class CameraHelper extends LineSegments {
		constructor(camera) {
			const geometry = new BufferGeometry();
			const material = new LineBasicMaterial({
				color: 0xffffff,
				vertexColors: true,
				toneMapped: false
			});
			const vertices = [];
			const colors = [];
			const pointMap = {}; // colors

			const colorFrustum = new Color(0xffaa00);
			const colorCone = new Color(0xff0000);
			const colorUp = new Color(0x00aaff);
			const colorTarget = new Color(0xffffff);
			const colorCross = new Color(0x333333); // near

			addLine('n1', 'n2', colorFrustum);
			addLine('n2', 'n4', colorFrustum);
			addLine('n4', 'n3', colorFrustum);
			addLine('n3', 'n1', colorFrustum); // far

			addLine('f1', 'f2', colorFrustum);
			addLine('f2', 'f4', colorFrustum);
			addLine('f4', 'f3', colorFrustum);
			addLine('f3', 'f1', colorFrustum); // sides

			addLine('n1', 'f1', colorFrustum);
			addLine('n2', 'f2', colorFrustum);
			addLine('n3', 'f3', colorFrustum);
			addLine('n4', 'f4', colorFrustum); // cone

			addLine('p', 'n1', colorCone);
			addLine('p', 'n2', colorCone);
			addLine('p', 'n3', colorCone);
			addLine('p', 'n4', colorCone); // up

			addLine('u1', 'u2', colorUp);
			addLine('u2', 'u3', colorUp);
			addLine('u3', 'u1', colorUp); // target

			addLine('c', 't', colorTarget);
			addLine('p', 'c', colorCross); // cross

			addLine('cn1', 'cn2', colorCross);
			addLine('cn3', 'cn4', colorCross);
			addLine('cf1', 'cf2', colorCross);
			addLine('cf3', 'cf4', colorCross);

			function addLine(a, b, color) {
				addPoint(a, color);
				addPoint(b, color);
			}

			function addPoint(id, color) {
				vertices.push(0, 0, 0);
				colors.push(color.r, color.g, color.b);

				if (pointMap[id] === undefined) {
					pointMap[id] = [];
				}

				pointMap[id].push(vertices.length / 3 - 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			super(geometry, material);
			this.type = 'CameraHelper';
			this.camera = camera;
			if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;
			this.pointMap = pointMap;
			this.update();
		}

		update() {
			const geometry = this.geometry;
			const pointMap = this.pointMap;
			const w = 1,
						h = 1; // we need just camera projection matrix inverse
			// world matrix must be identity

			_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


			setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
			setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

			setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
			setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
			setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
			setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

			setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
			setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
			setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
			setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

			setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
			setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
			setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

			setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
			setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
			setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
			setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
			setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
			setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
			setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
			setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
			geometry.getAttribute('position').needsUpdate = true;
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

	}

	function setPoint(point, pointMap, geometry, camera, x, y, z) {
		_vector.set(x, y, z).unproject(camera);

		const points = pointMap[point];

		if (points !== undefined) {
			const position = geometry.getAttribute('position');

			for (let i = 0, l = points.length; i < l; i++) {
				position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
			}
		}
	}

	const _box = /*@__PURE__*/new Box3();

	class BoxHelper extends LineSegments {
		constructor(object, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = new Float32Array(8 * 3);
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.object = object;
			this.type = 'BoxHelper';
			this.matrixAutoUpdate = false;
			this.update();
		}

		update(object) {
			if (object !== undefined) {
				console.warn('THREE.BoxHelper: .update() has no longer arguments.');
			}

			if (this.object !== undefined) {
				_box.setFromObject(this.object);
			}

			if (_box.isEmpty()) return;
			const min = _box.min;
			const max = _box.max;
			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/
				0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			const position = this.geometry.attributes.position;
			const array = position.array;
			array[0] = max.x;
			array[1] = max.y;
			array[2] = max.z;
			array[3] = min.x;
			array[4] = max.y;
			array[5] = max.z;
			array[6] = min.x;
			array[7] = min.y;
			array[8] = max.z;
			array[9] = max.x;
			array[10] = min.y;
			array[11] = max.z;
			array[12] = max.x;
			array[13] = max.y;
			array[14] = min.z;
			array[15] = min.x;
			array[16] = max.y;
			array[17] = min.z;
			array[18] = min.x;
			array[19] = min.y;
			array[20] = min.z;
			array[21] = max.x;
			array[22] = min.y;
			array[23] = min.z;
			position.needsUpdate = true;
			this.geometry.computeBoundingSphere();
		}

		setFromObject(object) {
			this.object = object;
			this.update();
			return this;
		}

		copy(source) {
			LineSegments.prototype.copy.call(this, source);
			this.object = source.object;
			return this;
		}

	}

	class Box3Helper extends LineSegments {
		constructor(box, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.box = box;
			this.type = 'Box3Helper';
			this.geometry.computeBoundingSphere();
		}

		updateMatrixWorld(force) {
			const box = this.box;
			if (box.isEmpty()) return;
			box.getCenter(this.position);
			box.getSize(this.scale);
			this.scale.multiplyScalar(0.5);
			super.updateMatrixWorld(force);
		}

	}

	class PlaneHelper extends Line {
		constructor(plane, size = 1, hex = 0xffff00) {
			const color = hex;
			const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			geometry.computeBoundingSphere();
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.type = 'PlaneHelper';
			this.plane = plane;
			this.size = size;
			const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
			const geometry2 = new BufferGeometry();
			geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
			geometry2.computeBoundingSphere();
			this.add(new Mesh(geometry2, new MeshBasicMaterial({
				color: color,
				opacity: 0.2,
				transparent: true,
				depthWrite: false,
				toneMapped: false
			})));
		}

		updateMatrixWorld(force) {
			let scale = -this.plane.constant;
			if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

			this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
			this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

			this.lookAt(this.plane.normal);
			super.updateMatrixWorld(force);
		}

	}

	const _axis = /*@__PURE__*/new Vector3();

	let _lineGeometry, _coneGeometry;

	class ArrowHelper extends Object3D {
		// dir is assumed to be normalized
		constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
			super();
			this.type = 'ArrowHelper';

			if (_lineGeometry === undefined) {
				_lineGeometry = new BufferGeometry();

				_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

				_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);

				_coneGeometry.translate(0, -0.5, 0);
			}

			this.position.copy(origin);
			this.line = new Line(_lineGeometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.line.matrixAutoUpdate = false;
			this.add(this.line);
			this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.cone.matrixAutoUpdate = false;
			this.add(this.cone);
			this.setDirection(dir);
			this.setLength(length, headLength, headWidth);
		}

		setDirection(dir) {
			// dir is assumed to be normalized
			if (dir.y > 0.99999) {
				this.quaternion.set(0, 0, 0, 1);
			} else if (dir.y < -0.99999) {
				this.quaternion.set(1, 0, 0, 0);
			} else {
				_axis.set(dir.z, 0, -dir.x).normalize();

				const radians = Math.acos(dir.y);
				this.quaternion.setFromAxisAngle(_axis, radians);
			}
		}

		setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
			this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

			this.line.updateMatrix();
			this.cone.scale.set(headWidth, headLength, headWidth);
			this.cone.position.y = length;
			this.cone.updateMatrix();
		}

		setColor(color) {
			this.line.material.color.set(color);
			this.cone.material.color.set(color);
		}

		copy(source) {
			super.copy(source, false);
			this.line.copy(source.line);
			this.cone.copy(source.cone);
			return this;
		}

	}

	class AxesHelper extends LineSegments {
		constructor(size = 1) {
			const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
			const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'AxesHelper';
		}

		setColors(xAxisColor, yAxisColor, zAxisColor) {
			const color = new Color();
			const array = this.geometry.attributes.color.array;
			color.set(xAxisColor);
			color.toArray(array, 0);
			color.toArray(array, 3);
			color.set(yAxisColor);
			color.toArray(array, 6);
			color.toArray(array, 9);
			color.set(zAxisColor);
			color.toArray(array, 12);
			color.toArray(array, 15);
			this.geometry.attributes.color.needsUpdate = true;
			return this;
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

	}

	const _floatView = new Float32Array(1);

	const _int32View = new Int32Array(_floatView.buffer);

	class DataUtils {
		// Converts float32 to float16 (stored as uint16 value).
		static toHalfFloat(val) {
			// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

			/* This method is faster than the OpenEXR implementation (very often
			* used, eg. in Ogre), with the additional benefit of rounding, inspired
			* by James Tursa?s half-precision code. */
			_floatView[0] = val;
			const x = _int32View[0];
			let bits = x >> 16 & 0x8000;
			/* Get the sign */

			let m = x >> 12 & 0x07ff;
			/* Keep one extra bit for rounding */

			const e = x >> 23 & 0xff;
			/* Using int is faster here */

			/* If zero, or denormal, or exponent underflows too much for a denormal
				* half, return signed zero. */

			if (e < 103) return bits;
			/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */

			if (e > 142) {
				bits |= 0x7c00;
				/* If exponent was 0xff and one mantissa bit was set, it means NaN,
							* not Inf, so make sure we set one mantissa bit too. */

				bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}
			/* If exponent underflows but not too much, return a denormal */


			if (e < 113) {
				m |= 0x0800;
				/* Extra rounding may overflow and set mantissa to 0 and exponent
					* to 1, which is OK. */

				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}

			bits |= e - 112 << 10 | m >> 1;
			/* Extra rounding. An overflow will set mantissa to 0 and increment
				* the exponent, which is OK. */

			bits += m & 1;
			return bits;
		}

	}

	const LineStrip = 0;
	const LinePieces = 1;
	const NoColors = 0;
	const FaceColors = 1;
	const VertexColors = 2;
	function MeshFaceMaterial(materials) {
		console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
		return materials;
	}
	function MultiMaterial(materials = []) {
		console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
		materials.isMultiMaterial = true;
		materials.materials = materials;

		materials.clone = function () {
			return materials.slice();
		};

		return materials;
	}
	function PointCloud(geometry, material) {
		console.warn('THREE.PointCloud has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function Particle(material) {
		console.warn('THREE.Particle has been renamed to THREE.Sprite.');
		return new Sprite(material);
	}
	function ParticleSystem(geometry, material) {
		console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function PointCloudMaterial(parameters) {
		console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleBasicMaterial(parameters) {
		console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleSystemMaterial(parameters) {
		console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function Vertex(x, y, z) {
		console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
		return new Vector3(x, y, z);
	} //

	function DynamicBufferAttribute(array, itemSize) {
		console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
		return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
	}
	function Int8Attribute(array, itemSize) {
		console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
		return new Int8BufferAttribute(array, itemSize);
	}
	function Uint8Attribute(array, itemSize) {
		console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
		return new Uint8BufferAttribute(array, itemSize);
	}
	function Uint8ClampedAttribute(array, itemSize) {
		console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
		return new Uint8ClampedBufferAttribute(array, itemSize);
	}
	function Int16Attribute(array, itemSize) {
		console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
		return new Int16BufferAttribute(array, itemSize);
	}
	function Uint16Attribute(array, itemSize) {
		console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
		return new Uint16BufferAttribute(array, itemSize);
	}
	function Int32Attribute(array, itemSize) {
		console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
		return new Int32BufferAttribute(array, itemSize);
	}
	function Uint32Attribute(array, itemSize) {
		console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
		return new Uint32BufferAttribute(array, itemSize);
	}
	function Float32Attribute(array, itemSize) {
		console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
		return new Float32BufferAttribute(array, itemSize);
	}
	function Float64Attribute(array, itemSize) {
		console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
		return new Float64BufferAttribute(array, itemSize);
	} //

	Curve.create = function (construct, getPoint) {
		console.log('THREE.Curve.create() has been deprecated');
		construct.prototype = Object.create(Curve.prototype);
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;
		return construct;
	}; //


	Path.prototype.fromPoints = function (points) {
		console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
		return this.setFromPoints(points);
	}; //


	function AxisHelper(size) {
		console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
		return new AxesHelper(size);
	}
	function BoundingBoxHelper(object, color) {
		console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
		return new BoxHelper(object, color);
	}
	function EdgesHelper(object, hex) {
		console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
		return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	}

	GridHelper.prototype.setColors = function () {
		console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
	};

	SkeletonHelper.prototype.update = function () {
		console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
	};

	function WireframeHelper(object, hex) {
		console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
		return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	} //

	Loader.prototype.extractUrlBase = function (url) {
		console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
		return LoaderUtils.extractUrlBase(url);
	};

	Loader.Handlers = {
		add: function ()
		/* regex, loader */
		{
			console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
		},
		get: function ()
		/* file */
		{
			console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
		}
	};
	function XHRLoader(manager) {
		console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
		return new FileLoader(manager);
	}
	function BinaryTextureLoader(manager) {
		console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
		return new DataTextureLoader(manager);
	} //

	Box2.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box2.prototype.empty = function () {
		console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box2.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box2.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box2: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Box3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box3.prototype.empty = function () {
		console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box3.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box3.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	};

	Box3.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box3: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Sphere.prototype.empty = function () {
		console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	}; //


	Frustum.prototype.setFromMatrix = function (m) {
		console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
		return this.setFromProjectionMatrix(m);
	}; //


	Line3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	}; //


	Matrix3.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix3.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
		return vector.applyMatrix3(this);
	};

	Matrix3.prototype.multiplyVector3Array = function ()
	/* a */
	{
		console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
	};

	Matrix3.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
		return attribute.applyMatrix3(this);
	};

	Matrix3.prototype.applyToVector3Array = function ()
	/* array, offset, length */
	{
		console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
	};

	Matrix3.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Matrix4.prototype.extractPosition = function (m) {
		console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
		return this.copyPosition(m);
	};

	Matrix4.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix4.prototype.getPosition = function () {
		console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
		return new Vector3().setFromMatrixColumn(this, 3);
	};

	Matrix4.prototype.setRotationFromQuaternion = function (q) {
		console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
		return this.makeRotationFromQuaternion(q);
	};

	Matrix4.prototype.multiplyToArray = function () {
		console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
	};

	Matrix4.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector4 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector3Array = function ()
	/* a */
	{
		console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
	};

	Matrix4.prototype.rotateAxis = function (v) {
		console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
		v.transformDirection(this);
	};

	Matrix4.prototype.crossVector = function (vector) {
		console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.translate = function () {
		console.error('THREE.Matrix4: .translate() has been removed.');
	};

	Matrix4.prototype.rotateX = function () {
		console.error('THREE.Matrix4: .rotateX() has been removed.');
	};

	Matrix4.prototype.rotateY = function () {
		console.error('THREE.Matrix4: .rotateY() has been removed.');
	};

	Matrix4.prototype.rotateZ = function () {
		console.error('THREE.Matrix4: .rotateZ() has been removed.');
	};

	Matrix4.prototype.rotateByAxis = function () {
		console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
	};

	Matrix4.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
		return attribute.applyMatrix4(this);
	};

	Matrix4.prototype.applyToVector3Array = function ()
	/* array, offset, length */
	{
		console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
	};

	Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
		console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
		return this.makePerspective(left, right, top, bottom, near, far);
	};

	Matrix4.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Plane.prototype.isIntersectionLine = function (line) {
		console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
		return this.intersectsLine(line);
	}; //


	Quaternion.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
		return vector.applyQuaternion(this);
	};

	Quaternion.prototype.inverse = function () {
		console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
		return this.invert();
	}; //


	Ray.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Ray.prototype.isIntersectionPlane = function (plane) {
		console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
		return this.intersectsPlane(plane);
	};

	Ray.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	}; //


	Triangle.prototype.area = function () {
		console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
		return this.getArea();
	};

	Triangle.prototype.barycoordFromPoint = function (point, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return this.getBarycoord(point, target);
	};

	Triangle.prototype.midpoint = function (target) {
		console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
		return this.getMidpoint(target);
	};

	Triangle.prototypenormal = function (target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return this.getNormal(target);
	};

	Triangle.prototype.plane = function (target) {
		console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
		return this.getPlane(target);
	};

	Triangle.barycoordFromPoint = function (point, a, b, c, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return Triangle.getBarycoord(point, a, b, c, target);
	};

	Triangle.normal = function (a, b, c, target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return Triangle.getNormal(a, b, c, target);
	}; //


	Shape.prototype.extractAllPoints = function (divisions) {
		console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
		return this.extractPoints(divisions);
	};

	Shape.prototype.extrude = function (options) {
		console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
		return new ExtrudeGeometry(this, options);
	};

	Shape.prototype.makeGeometry = function (options) {
		console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
		return new ShapeGeometry(this, options);
	}; //


	Vector2.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector2.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector2.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector3.prototype.setEulerFromRotationMatrix = function () {
		console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
	};

	Vector3.prototype.setEulerFromQuaternion = function () {
		console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
	};

	Vector3.prototype.getPositionFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
		return this.setFromMatrixPosition(m);
	};

	Vector3.prototype.getScaleFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
		return this.setFromMatrixScale(m);
	};

	Vector3.prototype.getColumnFromMatrix = function (index, matrix) {
		console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
		return this.setFromMatrixColumn(matrix, index);
	};

	Vector3.prototype.applyProjection = function (m) {
		console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
		return this.applyMatrix4(m);
	};

	Vector3.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector3.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector3.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector4.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector4.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Object3D.prototype.getChildByName = function (name) {
		console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
		return this.getObjectByName(name);
	};

	Object3D.prototype.renderDepth = function () {
		console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
	};

	Object3D.prototype.translate = function (distance, axis) {
		console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
		return this.translateOnAxis(axis, distance);
	};

	Object3D.prototype.getWorldRotation = function () {
		console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
	};

	Object3D.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(Object3D.prototype, {
		eulerOrder: {
			get: function () {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				return this.rotation.order;
			},
			set: function (value) {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				this.rotation.order = value;
			}
		},
		useQuaternion: {
			get: function () {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			},
			set: function () {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			}
		}
	});

	Mesh.prototype.setDrawMode = function () {
		console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
	};

	Object.defineProperties(Mesh.prototype, {
		drawMode: {
			get: function () {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
				return TrianglesDrawMode;
			},
			set: function () {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
			}
		}
	});

	SkinnedMesh.prototype.initBones = function () {
		console.error('THREE.SkinnedMesh: initBones() has been removed.');
	}; //


	PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
		console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
		if (filmGauge !== undefined) this.filmGauge = filmGauge;
		this.setFocalLength(focalLength);
	}; //


	Object.defineProperties(Light.prototype, {
		onlyShadow: {
			set: function () {
				console.warn('THREE.Light: .onlyShadow has been removed.');
			}
		},
		shadowCameraFov: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function () {
				console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
			}
		},
		shadowBias: {
			set: function (value) {
				console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function () {
				console.warn('THREE.Light: .shadowDarkness has been removed.');
			}
		},
		shadowMapWidth: {
			set: function (value) {
				console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function (value) {
				console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
				this.shadow.mapSize.height = value;
			}
		}
	}); //

	Object.defineProperties(BufferAttribute.prototype, {
		length: {
			get: function () {
				console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
				return this.array.length;
			}
		},
		dynamic: {
			get: function () {
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				return this.usage === DynamicDrawUsage;
			},
			set: function ()
			/* value */
			{
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				this.setUsage(DynamicDrawUsage);
			}
		}
	});

	BufferAttribute.prototype.setDynamic = function (value) {
		console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	BufferAttribute.prototype.copyIndicesArray = function ()
	/* indices */
	{
		console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
	}, BufferAttribute.prototype.setArray = function ()
	/* array */
	{
		console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //

	BufferGeometry.prototype.addIndex = function (index) {
		console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
		this.setIndex(index);
	};

	BufferGeometry.prototype.addAttribute = function (name, attribute) {
		console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

		if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
			console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
			return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
		}

		if (name === 'index') {
			console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
			this.setIndex(attribute);
			return this;
		}

		return this.setAttribute(name, attribute);
	};

	BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {
		if (indexOffset !== undefined) {
			console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
		}

		console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
		this.addGroup(start, count);
	};

	BufferGeometry.prototype.clearDrawCalls = function () {
		console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
		this.clearGroups();
	};

	BufferGeometry.prototype.computeOffsets = function () {
		console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
	};

	BufferGeometry.prototype.removeAttribute = function (name) {
		console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
		return this.deleteAttribute(name);
	};

	BufferGeometry.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(BufferGeometry.prototype, {
		drawcalls: {
			get: function () {
				console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
				return this.groups;
			}
		},
		offsets: {
			get: function () {
				console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
				return this.groups;
			}
		}
	});

	InterleavedBuffer.prototype.setDynamic = function (value) {
		console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	InterleavedBuffer.prototype.setArray = function ()
	/* array */
	{
		console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //


	ExtrudeGeometry.prototype.getArrays = function () {
		console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
	};

	ExtrudeGeometry.prototype.addShapeList = function () {
		console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
	};

	ExtrudeGeometry.prototype.addShape = function () {
		console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
	}; //


	Scene.prototype.dispose = function () {
		console.error('THREE.Scene: .dispose() has been removed.');
	}; //


	Uniform.prototype.onUpdate = function () {
		console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
		return this;
	}; //


	Object.defineProperties(Material.prototype, {
		wrapAround: {
			get: function () {
				console.warn('THREE.Material: .wrapAround has been removed.');
			},
			set: function () {
				console.warn('THREE.Material: .wrapAround has been removed.');
			}
		},
		overdraw: {
			get: function () {
				console.warn('THREE.Material: .overdraw has been removed.');
			},
			set: function () {
				console.warn('THREE.Material: .overdraw has been removed.');
			}
		},
		wrapRGB: {
			get: function () {
				console.warn('THREE.Material: .wrapRGB has been removed.');
				return new Color();
			}
		},
		shading: {
			get: function () {
				console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
			},
			set: function (value) {
				console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
				this.flatShading = value === FlatShading;
			}
		},
		stencilMask: {
			get: function () {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				return this.stencilFuncMask;
			},
			set: function (value) {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				this.stencilFuncMask = value;
			}
		},
		vertexTangents: {
			get: function () {
				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
			},
			set: function () {
				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
			}
		}
	});
	Object.defineProperties(ShaderMaterial.prototype, {
		derivatives: {
			get: function () {
				console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				return this.extensions.derivatives;
			},
			set: function (value) {
				console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				this.extensions.derivatives = value;
			}
		}
	}); //

	WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
		console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
		this.setRenderTarget(renderTarget);
		this.clear(color, depth, stencil);
	};

	WebGLRenderer.prototype.animate = function (callback) {
		console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
		this.setAnimationLoop(callback);
	};

	WebGLRenderer.prototype.getCurrentRenderTarget = function () {
		console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
		return this.getRenderTarget();
	};

	WebGLRenderer.prototype.getMaxAnisotropy = function () {
		console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
		return this.capabilities.getMaxAnisotropy();
	};

	WebGLRenderer.prototype.getPrecision = function () {
		console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
		return this.capabilities.precision;
	};

	WebGLRenderer.prototype.resetGLState = function () {
		console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
		return this.state.reset();
	};

	WebGLRenderer.prototype.supportsFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
		return this.extensions.get('OES_texture_float');
	};

	WebGLRenderer.prototype.supportsHalfFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
		return this.extensions.get('OES_texture_half_float');
	};

	WebGLRenderer.prototype.supportsStandardDerivatives = function () {
		console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
		return this.extensions.get('OES_standard_derivatives');
	};

	WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_s3tc');
	};

	WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_pvrtc');
	};

	WebGLRenderer.prototype.supportsBlendMinMax = function () {
		console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
		return this.extensions.get('EXT_blend_minmax');
	};

	WebGLRenderer.prototype.supportsVertexTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
		return this.capabilities.vertexTextures;
	};

	WebGLRenderer.prototype.supportsInstancedArrays = function () {
		console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
		return this.extensions.get('ANGLE_instanced_arrays');
	};

	WebGLRenderer.prototype.enableScissorTest = function (boolean) {
		console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
		this.setScissorTest(boolean);
	};

	WebGLRenderer.prototype.initMaterial = function () {
		console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
	};

	WebGLRenderer.prototype.addPrePlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
	};

	WebGLRenderer.prototype.addPostPlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
	};

	WebGLRenderer.prototype.updateShadowMap = function () {
		console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
	};

	WebGLRenderer.prototype.setFaceCulling = function () {
		console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
	};

	WebGLRenderer.prototype.allocTextureUnit = function () {
		console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
	};

	WebGLRenderer.prototype.setTexture = function () {
		console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
	};

	WebGLRenderer.prototype.setTexture2D = function () {
		console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
	};

	WebGLRenderer.prototype.setTextureCube = function () {
		console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
	};

	WebGLRenderer.prototype.getActiveMipMapLevel = function () {
		console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
		return this.getActiveMipmapLevel();
	};

	Object.defineProperties(WebGLRenderer.prototype, {
		shadowMapEnabled: {
			get: function () {
				return this.shadowMap.enabled;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function () {
				return this.shadowMap.type;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function ()
			/* value */
			{
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		context: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
				return this.getContext();
			}
		},
		vr: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
				return this.xr;
			}
		},
		gammaInput: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
				return false;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
			}
		},
		gammaOutput: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				return false;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
			}
		},
		toneMappingWhitePoint: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
				return 1.0;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
			}
		}
	});
	Object.defineProperties(WebGLShadowMap.prototype, {
		cullFace: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function ()
			/* cullFace */
			{
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		renderReverseSided: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
			}
		},
		renderSingleSided: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
			}
		}
	});
	function WebGLRenderTargetCube(width, height, options) {
		console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
		return new WebGLCubeRenderTarget(width, options);
	} //

	Object.defineProperties(WebGLRenderTarget.prototype, {
		wrapS: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				return this.texture.wrapS;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				return this.texture.wrapT;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				return this.texture.magFilter;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				return this.texture.minFilter;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				return this.texture.anisotropy;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				return this.texture.offset;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				return this.texture.repeat;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				this.texture.repeat = value;
			}
		},
		format: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				return this.texture.format;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				this.texture.format = value;
			}
		},
		type: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				return this.texture.type;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				return this.texture.generateMipmaps;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				this.texture.generateMipmaps = value;
			}
		}
	}); //

	Audio.prototype.load = function (file) {
		console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
		const scope = this;
		const audioLoader = new AudioLoader();
		audioLoader.load(file, function (buffer) {
			scope.setBuffer(buffer);
		});
		return this;
	};

	AudioAnalyser.prototype.getData = function () {
		console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
		return this.getFrequencyData();
	}; //


	CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
		console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
		return this.update(renderer, scene);
	};

	CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {
		console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
		return this.renderTarget.clear(renderer, color, depth, stencil);
	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
		const loader = new TextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		const texture = loader.load(url, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
		const loader = new CubeTextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		const texture = loader.load(urls, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadCompressedTexture = function () {
		console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
	};

	ImageUtils.loadCompressedTextureCube = function () {
		console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
	}; //


	function CanvasRenderer() {
		console.error('THREE.CanvasRenderer has been removed');
	} //

	function JSONLoader() {
		console.error('THREE.JSONLoader has been removed.');
	} //

	const SceneUtils = {
		createMultiMaterialObject: function ()
		/* geometry, materials */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		detach: function ()
		/* child, parent, scene */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		attach: function ()
		/* child, scene, parent */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		}
	}; //

	function LensFlare() {
		console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
	}

	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
		/* eslint-disable no-undef */
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
			detail: {
				revision: REVISION
			}
		}));
		/* eslint-enable no-undef */

	}

	if (typeof window !== 'undefined') {
		if (window.__THREE__) {
			console.warn('WARNING: Multiple instances of Three.js being imported.');
		} else {
			window.__THREE__ = REVISION;
		}
	}

	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.AddEquation = AddEquation;
	exports.AddOperation = AddOperation;
	exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
	exports.AdditiveBlending = AdditiveBlending;
	exports.AlphaFormat = AlphaFormat;
	exports.AlwaysDepth = AlwaysDepth;
	exports.AlwaysStencilFunc = AlwaysStencilFunc;
	exports.AmbientLight = AmbientLight;
	exports.AmbientLightProbe = AmbientLightProbe;
	exports.AnimationClip = AnimationClip;
	exports.AnimationLoader = AnimationLoader;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationUtils = AnimationUtils;
	exports.ArcCurve = ArcCurve;
	exports.ArrayCamera = ArrayCamera;
	exports.ArrowHelper = ArrowHelper;
	exports.Audio = Audio;
	exports.AudioAnalyser = AudioAnalyser;
	exports.AudioContext = AudioContext;
	exports.AudioListener = AudioListener;
	exports.AudioLoader = AudioLoader;
	exports.AxesHelper = AxesHelper;
	exports.AxisHelper = AxisHelper;
	exports.BackSide = BackSide;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.BasicShadowMap = BasicShadowMap;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.Bone = Bone;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.Box2 = Box2;
	exports.Box3 = Box3;
	exports.Box3Helper = Box3Helper;
	exports.BoxBufferGeometry = BoxGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxHelper = BoxHelper;
	exports.BufferAttribute = BufferAttribute;
	exports.BufferGeometry = BufferGeometry;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.ByteType = ByteType;
	exports.Cache = Cache;
	exports.Camera = Camera;
	exports.CameraHelper = CameraHelper;
	exports.CanvasRenderer = CanvasRenderer;
	exports.CanvasTexture = CanvasTexture;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CineonToneMapping = CineonToneMapping;
	exports.CircleBufferGeometry = CircleGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.Clock = Clock;
	exports.Color = Color;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.CompressedTexture = CompressedTexture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.ConeBufferGeometry = ConeGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.CubeCamera = CubeCamera;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.CubeTexture = CubeTexture;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.CubicInterpolant = CubicInterpolant;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.CullFaceNone = CullFaceNone;
	exports.Curve = Curve;
	exports.CurvePath = CurvePath;
	exports.CustomBlending = CustomBlending;
	exports.CustomToneMapping = CustomToneMapping;
	exports.CylinderBufferGeometry = CylinderGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.Cylindrical = Cylindrical;
	exports.DataTexture = DataTexture;
	exports.DataTexture2DArray = DataTexture2DArray;
	exports.DataTexture3D = DataTexture3D;
	exports.DataTextureLoader = DataTextureLoader;
	exports.DataUtils = DataUtils;
	exports.DecrementStencilOp = DecrementStencilOp;
	exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.DepthTexture = DepthTexture;
	exports.DirectionalLight = DirectionalLight;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.DodecahedronBufferGeometry = DodecahedronGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DoubleSide = DoubleSide;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.DynamicCopyUsage = DynamicCopyUsage;
	exports.DynamicDrawUsage = DynamicDrawUsage;
	exports.DynamicReadUsage = DynamicReadUsage;
	exports.EdgesGeometry = EdgesGeometry;
	exports.EdgesHelper = EdgesHelper;
	exports.EllipseCurve = EllipseCurve;
	exports.EqualDepth = EqualDepth;
	exports.EqualStencilFunc = EqualStencilFunc;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.Euler = Euler;
	exports.EventDispatcher = EventDispatcher;
	exports.ExtrudeBufferGeometry = ExtrudeGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.FaceColors = FaceColors;
	exports.FileLoader = FileLoader;
	exports.FlatShading = FlatShading;
	exports.Float16BufferAttribute = Float16BufferAttribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Float64Attribute = Float64Attribute;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.FloatType = FloatType;
	exports.Fog = Fog;
	exports.FogExp2 = FogExp2;
	exports.Font = Font;
	exports.FontLoader = FontLoader;
	exports.FrontSide = FrontSide;
	exports.Frustum = Frustum;
	exports.GLBufferAttribute = GLBufferAttribute;
	exports.GLSL1 = GLSL1;
	exports.GLSL3 = GLSL3;
	exports.GammaEncoding = GammaEncoding;
	exports.GreaterDepth = GreaterDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
	exports.GreaterStencilFunc = GreaterStencilFunc;
	exports.GridHelper = GridHelper;
	exports.Group = Group;
	exports.HalfFloatType = HalfFloatType;
	exports.HemisphereLight = HemisphereLight;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.HemisphereLightProbe = HemisphereLightProbe;
	exports.IcosahedronBufferGeometry = IcosahedronGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageUtils = ImageUtils;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.IncrementStencilOp = IncrementStencilOp;
	exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InstancedMesh = InstancedMesh;
	exports.Int16Attribute = Int16Attribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.IntType = IntType;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.Interpolant = Interpolant;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.InvertStencilOp = InvertStencilOp;
	exports.JSONLoader = JSONLoader;
	exports.KeepStencilOp = KeepStencilOp;
	exports.KeyframeTrack = KeyframeTrack;
	exports.LOD = LOD;
	exports.LatheBufferGeometry = LatheGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.Layers = Layers;
	exports.LensFlare = LensFlare;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.LessEqualStencilFunc = LessEqualStencilFunc;
	exports.LessStencilFunc = LessStencilFunc;
	exports.Light = Light;
	exports.LightProbe = LightProbe;
	exports.Line = Line;
	exports.Line3 = Line3;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineLoop = LineLoop;
	exports.LinePieces = LinePieces;
	exports.LineSegments = LineSegments;
	exports.LineStrip = LineStrip;
	exports.LinearEncoding = LinearEncoding;
	exports.LinearFilter = LinearFilter;
	exports.LinearInterpolant = LinearInterpolant;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
	exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
	exports.LinearToneMapping = LinearToneMapping;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.LoadingManager = LoadingManager;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.LoopOnce = LoopOnce;
	exports.LoopPingPong = LoopPingPong;
	exports.LoopRepeat = LoopRepeat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.MOUSE = MOUSE;
	exports.Material = Material;
	exports.MaterialLoader = MaterialLoader;
	exports.Math = MathUtils;
	exports.MathUtils = MathUtils;
	exports.Matrix3 = Matrix3;
	exports.Matrix4 = Matrix4;
	exports.MaxEquation = MaxEquation;
	exports.Mesh = Mesh;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MinEquation = MinEquation;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.MixOperation = MixOperation;
	exports.MultiMaterial = MultiMaterial;
	exports.MultiplyBlending = MultiplyBlending;
	exports.MultiplyOperation = MultiplyOperation;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
	exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
	exports.NeverDepth = NeverDepth;
	exports.NeverStencilFunc = NeverStencilFunc;
	exports.NoBlending = NoBlending;
	exports.NoColors = NoColors;
	exports.NoToneMapping = NoToneMapping;
	exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
	exports.NormalBlending = NormalBlending;
	exports.NotEqualDepth = NotEqualDepth;
	exports.NotEqualStencilFunc = NotEqualStencilFunc;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.Object3D = Object3D;
	exports.ObjectLoader = ObjectLoader;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.OctahedronBufferGeometry = OctahedronGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OneFactor = OneFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.OrthographicCamera = OrthographicCamera;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.PMREMGenerator = PMREMGenerator;
	exports.ParametricBufferGeometry = ParametricGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.Particle = Particle;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystem = ParticleSystem;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Path = Path;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.Plane = Plane;
	exports.PlaneBufferGeometry = PlaneGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneHelper = PlaneHelper;
	exports.PointCloud = PointCloud;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.PointLight = PointLight;
	exports.PointLightHelper = PointLightHelper;
	exports.Points = Points;
	exports.PointsMaterial = PointsMaterial;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PolyhedronBufferGeometry = PolyhedronGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PositionalAudio = PositionalAudio;
	exports.PropertyBinding = PropertyBinding;
	exports.PropertyMixer = PropertyMixer;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.Quaternion = Quaternion;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.REVISION = REVISION;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.RGBAFormat = RGBAFormat;
	exports.RGBAIntegerFormat = RGBAIntegerFormat;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
	exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGBDEncoding = RGBDEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.RGBEFormat = RGBEFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBIntegerFormat = RGBIntegerFormat;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGB_ETC2_Format = RGB_ETC2_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGFormat = RGFormat;
	exports.RGIntegerFormat = RGIntegerFormat;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.Ray = Ray;
	exports.Raycaster = Raycaster;
	exports.RectAreaLight = RectAreaLight;
	exports.RedFormat = RedFormat;
	exports.RedIntegerFormat = RedIntegerFormat;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ReplaceStencilOp = ReplaceStencilOp;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.RingBufferGeometry = RingGeometry;
	exports.RingGeometry = RingGeometry;
	exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
	exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
	exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
	exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
	exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
	exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
	exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
	exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
	exports.Scene = Scene;
	exports.SceneUtils = SceneUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.ShaderLib = ShaderLib;
	exports.ShaderMaterial = ShaderMaterial;
	exports.ShadowMaterial = ShadowMaterial;
	exports.Shape = Shape;
	exports.ShapeBufferGeometry = ShapeGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapePath = ShapePath;
	exports.ShapeUtils = ShapeUtils;
	exports.ShortType = ShortType;
	exports.Skeleton = Skeleton;
	exports.SkeletonHelper = SkeletonHelper;
	exports.SkinnedMesh = SkinnedMesh;
	exports.SmoothShading = SmoothShading;
	exports.Sphere = Sphere;
	exports.SphereBufferGeometry = SphereGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.Spherical = Spherical;
	exports.SphericalHarmonics3 = SphericalHarmonics3;
	exports.SplineCurve = SplineCurve;
	exports.SpotLight = SpotLight;
	exports.SpotLightHelper = SpotLightHelper;
	exports.Sprite = Sprite;
	exports.SpriteMaterial = SpriteMaterial;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.StaticCopyUsage = StaticCopyUsage;
	exports.StaticDrawUsage = StaticDrawUsage;
	exports.StaticReadUsage = StaticReadUsage;
	exports.StereoCamera = StereoCamera;
	exports.StreamCopyUsage = StreamCopyUsage;
	exports.StreamDrawUsage = StreamDrawUsage;
	exports.StreamReadUsage = StreamReadUsage;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.SubtractEquation = SubtractEquation;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.TOUCH = TOUCH;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.TetrahedronBufferGeometry = TetrahedronGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TextBufferGeometry = TextGeometry;
	exports.TextGeometry = TextGeometry;
	exports.Texture = Texture;
	exports.TextureLoader = TextureLoader;
	exports.TorusBufferGeometry = TorusGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.Triangle = Triangle;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TubeBufferGeometry = TubeGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.UVMapping = UVMapping;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uniform = Uniform;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.UnsignedByteType = UnsignedByteType;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.UnsignedIntType = UnsignedIntType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedShortType = UnsignedShortType;
	exports.VSMShadowMap = VSMShadowMap;
	exports.Vector2 = Vector2;
	exports.Vector3 = Vector3;
	exports.Vector4 = Vector4;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.Vertex = Vertex;
	exports.VertexColors = VertexColors;
	exports.VideoTexture = VideoTexture;
	exports.WebGL1Renderer = WebGL1Renderer;
	exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
	exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderer = WebGLRenderer;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.WireframeHelper = WireframeHelper;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.XHRLoader = XHRLoader;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroFactor = ZeroFactor;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.ZeroStencilOp = ZeroStencilOp;
	exports.sRGBEncoding = sRGBEncoding;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],6:[function(require,module,exports){
( function () {

	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	//
	//    Orbit - left mouse / touch: one-finger move
	//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
	//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

	const _changeEvent = {
		type: 'change'
	};
	const _startEvent = {
		type: 'start'
	};
	const _endEvent = {
		type: 'end'
	};

	class OrbitControls extends THREE.EventDispatcher {

		constructor( object, domElement ) {

			super();
			if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
			if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );
			this.object = object;
			this.domElement = domElement;
			this.domElement.style.touchAction = 'none'; // disable touch scroll
			// Set to false to disable this control

			this.enabled = true; // "target" sets the location of focus, where the object orbits around

			this.target = new THREE.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )

			this.minDistance = 0;
			this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

			this.minZoom = 0;
			this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
			// Range is 0 to Math.PI radians.

			this.minPolarAngle = 0; // radians

			this.maxPolarAngle = Math.PI; // radians
			// How far you can orbit horizontally, upper and lower limits.
			// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )

			this.minAzimuthAngle = - Infinity; // radians

			this.maxAzimuthAngle = Infinity; // radians
			// Set to true to enable damping (inertia)
			// If damping is enabled, you must call controls.update() in your animation loop

			this.enableDamping = false;
			this.dampingFactor = 0.05; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
			// Set to false to disable zooming

			this.enableZoom = true;
			this.zoomSpeed = 1.0; // Set to false to disable rotating

			this.enableRotate = true;
			this.rotateSpeed = 1.0; // Set to false to disable panning

			this.enablePan = true;
			this.panSpeed = 1.0;
			this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up

			this.keyPanSpeed = 7.0; // pixels moved per arrow key push
			// Set to true to automatically rotate around the target
			// If auto-rotate is enabled, you must call controls.update() in your animation loop

			this.autoRotate = false;
			this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60
			// The four arrow keys

			this.keys = {
				LEFT: 'ArrowLeft',
				UP: 'ArrowUp',
				RIGHT: 'ArrowRight',
				BOTTOM: 'ArrowDown'
			}; // Mouse buttons

			this.mouseButtons = {
				LEFT: THREE.MOUSE.ROTATE,
				MIDDLE: THREE.MOUSE.DOLLY,
				RIGHT: THREE.MOUSE.PAN
			}; // Touch fingers

			this.touches = {
				ONE: THREE.TOUCH.ROTATE,
				TWO: THREE.TOUCH.DOLLY_PAN
			}; // for reset

			this.target0 = this.target.clone();
			this.position0 = this.object.position.clone();
			this.zoom0 = this.object.zoom; // the target DOM element for key events

			this._domElementKeyEvents = null; //
			// public methods
			//

			this.getPolarAngle = function () {

				return spherical.phi;

			};

			this.getAzimuthalAngle = function () {

				return spherical.theta;

			};

			this.getDistance = function () {

				return this.object.position.distanceTo( this.target );

			};

			this.listenToKeyEvents = function ( domElement ) {

				domElement.addEventListener( 'keydown', onKeyDown );
				this._domElementKeyEvents = domElement;

			};

			this.saveState = function () {

				scope.target0.copy( scope.target );
				scope.position0.copy( scope.object.position );
				scope.zoom0 = scope.object.zoom;

			};

			this.reset = function () {

				scope.target.copy( scope.target0 );
				scope.object.position.copy( scope.position0 );
				scope.object.zoom = scope.zoom0;
				scope.object.updateProjectionMatrix();
				scope.dispatchEvent( _changeEvent );
				scope.update();
				state = STATE.NONE;

			}; // this method is exposed, but perhaps it would be better if we can make it private...


			this.update = function () {

				const offset = new THREE.Vector3(); // so camera.up is the orbit axis

				const quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
				const quatInverse = quat.clone().invert();
				const lastPosition = new THREE.Vector3();
				const lastQuaternion = new THREE.Quaternion();
				const twoPI = 2 * Math.PI;
				return function update() {

					const position = scope.object.position;
					offset.copy( position ).sub( scope.target ); // rotate offset to "y-axis-is-up" space

					offset.applyQuaternion( quat ); // angle from z-axis around y-axis

					spherical.setFromVector3( offset );

					if ( scope.autoRotate && state === STATE.NONE ) {

						rotateLeft( getAutoRotationAngle() );

					}

					if ( scope.enableDamping ) {

						spherical.theta += sphericalDelta.theta * scope.dampingFactor;
						spherical.phi += sphericalDelta.phi * scope.dampingFactor;

					} else {

						spherical.theta += sphericalDelta.theta;
						spherical.phi += sphericalDelta.phi;

					} // restrict theta to be between desired limits


					let min = scope.minAzimuthAngle;
					let max = scope.maxAzimuthAngle;

					if ( isFinite( min ) && isFinite( max ) ) {

						if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;
						if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

						if ( min <= max ) {

							spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

						} else {

							spherical.theta = spherical.theta > ( min + max ) / 2 ? Math.max( min, spherical.theta ) : Math.min( max, spherical.theta );

						}

					} // restrict phi to be between desired limits


					spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );
					spherical.makeSafe();
					spherical.radius *= scale; // restrict radius to be between desired limits

					spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) ); // move target to panned location

					if ( scope.enableDamping === true ) {

						scope.target.addScaledVector( panOffset, scope.dampingFactor );

					} else {

						scope.target.add( panOffset );

					}

					offset.setFromSpherical( spherical ); // rotate offset back to "camera-up-vector-is-up" space

					offset.applyQuaternion( quatInverse );
					position.copy( scope.target ).add( offset );
					scope.object.lookAt( scope.target );

					if ( scope.enableDamping === true ) {

						sphericalDelta.theta *= 1 - scope.dampingFactor;
						sphericalDelta.phi *= 1 - scope.dampingFactor;
						panOffset.multiplyScalar( 1 - scope.dampingFactor );

					} else {

						sphericalDelta.set( 0, 0, 0 );
						panOffset.set( 0, 0, 0 );

					}

					scale = 1; // update condition is:
					// min(camera displacement, camera rotation in radians)^2 > EPS
					// using small-angle approximation cos(x/2) = 1 - x^2 / 8

					if ( zoomChanged || lastPosition.distanceToSquared( scope.object.position ) > EPS || 8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

						scope.dispatchEvent( _changeEvent );
						lastPosition.copy( scope.object.position );
						lastQuaternion.copy( scope.object.quaternion );
						zoomChanged = false;
						return true;

					}

					return false;

				};

			}();

			this.dispose = function () {

				scope.domElement.removeEventListener( 'contextmenu', onContextMenu );
				scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
				scope.domElement.removeEventListener( 'pointercancel', onPointerCancel );
				scope.domElement.removeEventListener( 'wheel', onMouseWheel );
				scope.domElement.removeEventListener( 'pointermove', onPointerMove );
				scope.domElement.removeEventListener( 'pointerup', onPointerUp );

				if ( scope._domElementKeyEvents !== null ) {

					scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );

				} //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

			}; //
			// internals
			//


			const scope = this;
			const STATE = {
				NONE: - 1,
				ROTATE: 0,
				DOLLY: 1,
				PAN: 2,
				TOUCH_ROTATE: 3,
				TOUCH_PAN: 4,
				TOUCH_DOLLY_PAN: 5,
				TOUCH_DOLLY_ROTATE: 6
			};
			let state = STATE.NONE;
			const EPS = 0.000001; // current position in spherical coordinates

			const spherical = new THREE.Spherical();
			const sphericalDelta = new THREE.Spherical();
			let scale = 1;
			const panOffset = new THREE.Vector3();
			let zoomChanged = false;
			const rotateStart = new THREE.Vector2();
			const rotateEnd = new THREE.Vector2();
			const rotateDelta = new THREE.Vector2();
			const panStart = new THREE.Vector2();
			const panEnd = new THREE.Vector2();
			const panDelta = new THREE.Vector2();
			const dollyStart = new THREE.Vector2();
			const dollyEnd = new THREE.Vector2();
			const dollyDelta = new THREE.Vector2();
			const pointers = [];
			const pointerPositions = {};

			function getAutoRotationAngle() {

				return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

			}

			function getZoomScale() {

				return Math.pow( 0.95, scope.zoomSpeed );

			}

			function rotateLeft( angle ) {

				sphericalDelta.theta -= angle;

			}

			function rotateUp( angle ) {

				sphericalDelta.phi -= angle;

			}

			const panLeft = function () {

				const v = new THREE.Vector3();
				return function panLeft( distance, objectMatrix ) {

					v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix

					v.multiplyScalar( - distance );
					panOffset.add( v );

				};

			}();

			const panUp = function () {

				const v = new THREE.Vector3();
				return function panUp( distance, objectMatrix ) {

					if ( scope.screenSpacePanning === true ) {

						v.setFromMatrixColumn( objectMatrix, 1 );

					} else {

						v.setFromMatrixColumn( objectMatrix, 0 );
						v.crossVectors( scope.object.up, v );

					}

					v.multiplyScalar( distance );
					panOffset.add( v );

				};

			}(); // deltaX and deltaY are in pixels; right and down are positive


			const pan = function () {

				const offset = new THREE.Vector3();
				return function pan( deltaX, deltaY ) {

					const element = scope.domElement;

					if ( scope.object.isPerspectiveCamera ) {

						// perspective
						const position = scope.object.position;
						offset.copy( position ).sub( scope.target );
						let targetDistance = offset.length(); // half of the fov is center to top of screen

						targetDistance *= Math.tan( scope.object.fov / 2 * Math.PI / 180.0 ); // we use only clientHeight here so aspect ratio does not distort speed

						panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
						panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

					} else if ( scope.object.isOrthographicCamera ) {

						// orthographic
						panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
						panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

					} else {

						// camera neither orthographic nor perspective
						console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
						scope.enablePan = false;

					}

				};

			}();

			function dollyOut( dollyScale ) {

				if ( scope.object.isPerspectiveCamera ) {

					scale /= dollyScale;

				} else if ( scope.object.isOrthographicCamera ) {

					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
					scope.object.updateProjectionMatrix();
					zoomChanged = true;

				} else {

					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
					scope.enableZoom = false;

				}

			}

			function dollyIn( dollyScale ) {

				if ( scope.object.isPerspectiveCamera ) {

					scale *= dollyScale;

				} else if ( scope.object.isOrthographicCamera ) {

					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
					scope.object.updateProjectionMatrix();
					zoomChanged = true;

				} else {

					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
					scope.enableZoom = false;

				}

			} //
			// event callbacks - update the object state
			//


			function handleMouseDownRotate( event ) {

				rotateStart.set( event.clientX, event.clientY );

			}

			function handleMouseDownDolly( event ) {

				dollyStart.set( event.clientX, event.clientY );

			}

			function handleMouseDownPan( event ) {

				panStart.set( event.clientX, event.clientY );

			}

			function handleMouseMoveRotate( event ) {

				rotateEnd.set( event.clientX, event.clientY );
				rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );
				const element = scope.domElement;
				rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

				rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );
				rotateStart.copy( rotateEnd );
				scope.update();

			}

			function handleMouseMoveDolly( event ) {

				dollyEnd.set( event.clientX, event.clientY );
				dollyDelta.subVectors( dollyEnd, dollyStart );

				if ( dollyDelta.y > 0 ) {

					dollyOut( getZoomScale() );

				} else if ( dollyDelta.y < 0 ) {

					dollyIn( getZoomScale() );

				}

				dollyStart.copy( dollyEnd );
				scope.update();

			}

			function handleMouseMovePan( event ) {

				panEnd.set( event.clientX, event.clientY );
				panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );
				pan( panDelta.x, panDelta.y );
				panStart.copy( panEnd );
				scope.update();

			}

			function handleMouseUp( ) { // no-op
			}

			function handleMouseWheel( event ) {

				if ( event.deltaY < 0 ) {

					dollyIn( getZoomScale() );

				} else if ( event.deltaY > 0 ) {

					dollyOut( getZoomScale() );

				}

				scope.update();

			}

			function handleKeyDown( event ) {

				let needsUpdate = false;

				switch ( event.code ) {

					case scope.keys.UP:
						pan( 0, scope.keyPanSpeed );
						needsUpdate = true;
						break;

					case scope.keys.BOTTOM:
						pan( 0, - scope.keyPanSpeed );
						needsUpdate = true;
						break;

					case scope.keys.LEFT:
						pan( scope.keyPanSpeed, 0 );
						needsUpdate = true;
						break;

					case scope.keys.RIGHT:
						pan( - scope.keyPanSpeed, 0 );
						needsUpdate = true;
						break;

				}

				if ( needsUpdate ) {

					// prevent the browser from scrolling on cursor keys
					event.preventDefault();
					scope.update();

				}

			}

			function handleTouchStartRotate() {

				if ( pointers.length === 1 ) {

					rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

				} else {

					const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
					const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );
					rotateStart.set( x, y );

				}

			}

			function handleTouchStartPan() {

				if ( pointers.length === 1 ) {

					panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

				} else {

					const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
					const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );
					panStart.set( x, y );

				}

			}

			function handleTouchStartDolly() {

				const dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;
				const dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;
				const distance = Math.sqrt( dx * dx + dy * dy );
				dollyStart.set( 0, distance );

			}

			function handleTouchStartDollyPan() {

				if ( scope.enableZoom ) handleTouchStartDolly();
				if ( scope.enablePan ) handleTouchStartPan();

			}

			function handleTouchStartDollyRotate() {

				if ( scope.enableZoom ) handleTouchStartDolly();
				if ( scope.enableRotate ) handleTouchStartRotate();

			}

			function handleTouchMoveRotate( event ) {

				if ( pointers.length == 1 ) {

					rotateEnd.set( event.pageX, event.pageY );

				} else {

					const position = getSecondPointerPosition( event );
					const x = 0.5 * ( event.pageX + position.x );
					const y = 0.5 * ( event.pageY + position.y );
					rotateEnd.set( x, y );

				}

				rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );
				const element = scope.domElement;
				rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

				rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );
				rotateStart.copy( rotateEnd );

			}

			function handleTouchMovePan( event ) {

				if ( pointers.length === 1 ) {

					panEnd.set( event.pageX, event.pageY );

				} else {

					const position = getSecondPointerPosition( event );
					const x = 0.5 * ( event.pageX + position.x );
					const y = 0.5 * ( event.pageY + position.y );
					panEnd.set( x, y );

				}

				panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );
				pan( panDelta.x, panDelta.y );
				panStart.copy( panEnd );

			}

			function handleTouchMoveDolly( event ) {

				const position = getSecondPointerPosition( event );
				const dx = event.pageX - position.x;
				const dy = event.pageY - position.y;
				const distance = Math.sqrt( dx * dx + dy * dy );
				dollyEnd.set( 0, distance );
				dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );
				dollyOut( dollyDelta.y );
				dollyStart.copy( dollyEnd );

			}

			function handleTouchMoveDollyPan( event ) {

				if ( scope.enableZoom ) handleTouchMoveDolly( event );
				if ( scope.enablePan ) handleTouchMovePan( event );

			}

			function handleTouchMoveDollyRotate( event ) {

				if ( scope.enableZoom ) handleTouchMoveDolly( event );
				if ( scope.enableRotate ) handleTouchMoveRotate( event );

			}

			function handleTouchEnd( ) { // no-op
			} //
			// event handlers - FSM: listen for events and reset state
			//


			function onPointerDown( event ) {

				if ( scope.enabled === false ) return;

				if ( pointers.length === 0 ) {

					scope.domElement.setPointerCapture( event.pointerId );
					scope.domElement.addEventListener( 'pointermove', onPointerMove );
					scope.domElement.addEventListener( 'pointerup', onPointerUp );

				} //


				addPointer( event );

				if ( event.pointerType === 'touch' ) {

					onTouchStart( event );

				} else {

					onMouseDown( event );

				}

			}

			function onPointerMove( event ) {

				if ( scope.enabled === false ) return;

				if ( event.pointerType === 'touch' ) {

					onTouchMove( event );

				} else {

					onMouseMove( event );

				}

			}

			function onPointerUp( event ) {

				if ( scope.enabled === false ) return;

				if ( event.pointerType === 'touch' ) {

					onTouchEnd();

				} else {

					onMouseUp( event );

				}

				removePointer( event ); //

				if ( pointers.length === 0 ) {

					scope.domElement.releasePointerCapture( event.pointerId );
					scope.domElement.removeEventListener( 'pointermove', onPointerMove );
					scope.domElement.removeEventListener( 'pointerup', onPointerUp );

				}

			}

			function onPointerCancel( event ) {

				removePointer( event );

			}

			function onMouseDown( event ) {

				let mouseAction;

				switch ( event.button ) {

					case 0:
						mouseAction = scope.mouseButtons.LEFT;
						break;

					case 1:
						mouseAction = scope.mouseButtons.MIDDLE;
						break;

					case 2:
						mouseAction = scope.mouseButtons.RIGHT;
						break;

					default:
						mouseAction = - 1;

				}

				switch ( mouseAction ) {

					case THREE.MOUSE.DOLLY:
						if ( scope.enableZoom === false ) return;
						handleMouseDownDolly( event );
						state = STATE.DOLLY;
						break;

					case THREE.MOUSE.ROTATE:
						if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

							if ( scope.enablePan === false ) return;
							handleMouseDownPan( event );
							state = STATE.PAN;

						} else {

							if ( scope.enableRotate === false ) return;
							handleMouseDownRotate( event );
							state = STATE.ROTATE;

						}

						break;

					case THREE.MOUSE.PAN:
						if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

							if ( scope.enableRotate === false ) return;
							handleMouseDownRotate( event );
							state = STATE.ROTATE;

						} else {

							if ( scope.enablePan === false ) return;
							handleMouseDownPan( event );
							state = STATE.PAN;

						}

						break;

					default:
						state = STATE.NONE;

				}

				if ( state !== STATE.NONE ) {

					scope.dispatchEvent( _startEvent );

				}

			}

			function onMouseMove( event ) {

				if ( scope.enabled === false ) return;

				switch ( state ) {

					case STATE.ROTATE:
						if ( scope.enableRotate === false ) return;
						handleMouseMoveRotate( event );
						break;

					case STATE.DOLLY:
						if ( scope.enableZoom === false ) return;
						handleMouseMoveDolly( event );
						break;

					case STATE.PAN:
						if ( scope.enablePan === false ) return;
						handleMouseMovePan( event );
						break;

				}

			}

			function onMouseUp( event ) {

				handleMouseUp( event );
				scope.dispatchEvent( _endEvent );
				state = STATE.NONE;

			}

			function onMouseWheel( event ) {

				if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE ) return;
				event.preventDefault();
				scope.dispatchEvent( _startEvent );
				handleMouseWheel( event );
				scope.dispatchEvent( _endEvent );

			}

			function onKeyDown( event ) {

				if ( scope.enabled === false || scope.enablePan === false ) return;
				handleKeyDown( event );

			}

			function onTouchStart( event ) {

				trackPointer( event );

				switch ( pointers.length ) {

					case 1:
						switch ( scope.touches.ONE ) {

							case THREE.TOUCH.ROTATE:
								if ( scope.enableRotate === false ) return;
								handleTouchStartRotate();
								state = STATE.TOUCH_ROTATE;
								break;

							case THREE.TOUCH.PAN:
								if ( scope.enablePan === false ) return;
								handleTouchStartPan();
								state = STATE.TOUCH_PAN;
								break;

							default:
								state = STATE.NONE;

						}

						break;

					case 2:
						switch ( scope.touches.TWO ) {

							case THREE.TOUCH.DOLLY_PAN:
								if ( scope.enableZoom === false && scope.enablePan === false ) return;
								handleTouchStartDollyPan();
								state = STATE.TOUCH_DOLLY_PAN;
								break;

							case THREE.TOUCH.DOLLY_ROTATE:
								if ( scope.enableZoom === false && scope.enableRotate === false ) return;
								handleTouchStartDollyRotate();
								state = STATE.TOUCH_DOLLY_ROTATE;
								break;

							default:
								state = STATE.NONE;

						}

						break;

					default:
						state = STATE.NONE;

				}

				if ( state !== STATE.NONE ) {

					scope.dispatchEvent( _startEvent );

				}

			}

			function onTouchMove( event ) {

				trackPointer( event );

				switch ( state ) {

					case STATE.TOUCH_ROTATE:
						if ( scope.enableRotate === false ) return;
						handleTouchMoveRotate( event );
						scope.update();
						break;

					case STATE.TOUCH_PAN:
						if ( scope.enablePan === false ) return;
						handleTouchMovePan( event );
						scope.update();
						break;

					case STATE.TOUCH_DOLLY_PAN:
						if ( scope.enableZoom === false && scope.enablePan === false ) return;
						handleTouchMoveDollyPan( event );
						scope.update();
						break;

					case STATE.TOUCH_DOLLY_ROTATE:
						if ( scope.enableZoom === false && scope.enableRotate === false ) return;
						handleTouchMoveDollyRotate( event );
						scope.update();
						break;

					default:
						state = STATE.NONE;

				}

			}

			function onTouchEnd( event ) {

				handleTouchEnd( event );
				scope.dispatchEvent( _endEvent );
				state = STATE.NONE;

			}

			function onContextMenu( event ) {

				if ( scope.enabled === false ) return;
				event.preventDefault();

			}

			function addPointer( event ) {

				pointers.push( event );

			}

			function removePointer( event ) {

				delete pointerPositions[ event.pointerId ];

				for ( let i = 0; i < pointers.length; i ++ ) {

					if ( pointers[ i ].pointerId == event.pointerId ) {

						pointers.splice( i, 1 );
						return;

					}

				}

			}

			function trackPointer( event ) {

				let position = pointerPositions[ event.pointerId ];

				if ( position === undefined ) {

					position = new THREE.Vector2();
					pointerPositions[ event.pointerId ] = position;

				}

				position.set( event.pageX, event.pageY );

			}

			function getSecondPointerPosition( event ) {

				const pointer = event.pointerId === pointers[ 0 ].pointerId ? pointers[ 1 ] : pointers[ 0 ];
				return pointerPositions[ pointer.pointerId ];

			} //


			scope.domElement.addEventListener( 'contextmenu', onContextMenu );
			scope.domElement.addEventListener( 'pointerdown', onPointerDown );
			scope.domElement.addEventListener( 'pointercancel', onPointerCancel );
			scope.domElement.addEventListener( 'wheel', onMouseWheel, {
				passive: false
			} ); // force an update at start

			this.update();

		}

	} // This set of controls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	// This is very similar to OrbitControls, another set of touch behavior
	//
	//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
	//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
	//    Pan - left mouse, or arrow keys / touch: one-finger move


	class MapControls extends OrbitControls {

		constructor( object, domElement ) {

			super( object, domElement );
			this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

			this.mouseButtons.LEFT = THREE.MOUSE.PAN;
			this.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
			this.touches.ONE = THREE.TOUCH.PAN;
			this.touches.TWO = THREE.TOUCH.DOLLY_ROTATE;

		}

	}

	THREE.MapControls = MapControls;
	THREE.OrbitControls = OrbitControls;

} )();

},{}],7:[function(require,module,exports){
(function (global){(function (){

global.CANVAS_SKETCH_DEFAULT_STORAGE_KEY = "D:\\Manuel\\canvas-sketch\\examples\\animated-three-basic-cube.js";

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[7,1,2,3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1VzZXJzL0pvdmUvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC1jbGkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIkM6L1VzZXJzL0pvdmUvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC1jbGkvc3JjL2luc3RydW1lbnRhdGlvbi9jbGllbnQtZW5hYmxlLW91dHB1dC5qcyIsIkM6L1VzZXJzL0pvdmUvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC1jbGkvc3JjL2luc3RydW1lbnRhdGlvbi9jbGllbnQuanMiLCJhbmltYXRlZC10aHJlZS1iYXNpYy1jdWJlLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL3JpZ2h0LW5vdy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvaXMtcHJvbWlzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL2lzLWRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL2RhdGVmb3JtYXQvbGliL2RhdGVmb3JtYXQuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9yZXBlYXQtc3RyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvcGFkLWxlZnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi9zYXZlLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvYWNjZXNzaWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL2NvcmUva2V5Ym9hcmRTaG9ydGN1dHMuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi9wYXBlci1zaXplcy5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL2RlZmluZWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9jb252ZXJ0LWxlbmd0aC9jb252ZXJ0LWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL2Rpc3RhbmNlcy5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL2NvcmUvcmVzaXplQ2FudmFzLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvZ2V0LWNhbnZhcy1jb250ZXh0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvY29yZS9jcmVhdGVDYW52YXMuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi9jb3JlL1NrZXRjaE1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi9jYW52YXMtc2tldGNoLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL2J1aWxkL3RocmVlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzL2NvbnRyb2xzL09yYml0Q29udHJvbHMuanMiLCJjYW52YXMtc2tldGNoLWNsaS9pbmplY3RlZC9zdG9yYWdlLWtleS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUE7QUFDQSxNQUFNLENBQUMsbUJBQUQsQ0FBTixHQUE4QixNQUFNLENBQUMsbUJBQUQsQ0FBTixJQUErQixFQUE3RDtBQUNBLE1BQU0sQ0FBQyxtQkFBRCxDQUFOLENBQTRCLE1BQTVCLEdBQXFDLElBQXJDOzs7OztBQ0ZBLE1BQU0sU0FBUyxHQUFHLG1CQUFsQixDLENBRUE7O0FBQ0EsTUFBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQixNQUFNLENBQUMsU0FBRCxDQUFOLElBQXFCLEVBQXpDOztBQUVBLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBRCxDQUFOLENBQWtCLFdBQXZCLEVBQW9DO0FBQ2xDLEVBQUEsVUFBVTtBQUNYOztBQUVELFNBQVMsVUFBVCxHQUF1QjtBQUNyQjtBQUNBLEVBQUEsTUFBTSxDQUFDLFNBQUQsQ0FBTixDQUFrQixpQkFBbEIsR0FBc0MsU0FBdEM7QUFDQSxFQUFBLE1BQU0sQ0FBQyxTQUFELENBQU4sQ0FBa0IsV0FBbEIsR0FBZ0MsSUFBaEM7QUFFQSxRQUFNLGtCQUFrQixHQUFHO0FBQ3pCLElBQUEsTUFBTSxFQUFFLE1BRGlCO0FBRXpCLElBQUEsS0FBSyxFQUFFLFVBRmtCO0FBR3pCLElBQUEsV0FBVyxFQUFFO0FBSFksR0FBM0IsQ0FMcUIsQ0FXckI7O0FBQ0EsRUFBQSxNQUFNLENBQUMsU0FBRCxDQUFOLENBQWtCLFFBQWxCLEdBQTZCLENBQUMsSUFBRCxFQUFPLElBQVAsS0FBZ0I7QUFDM0MsSUFBQSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQWY7QUFFQSxVQUFNLElBQUksR0FBRyxJQUFJLE1BQU0sQ0FBQyxRQUFYLEVBQWI7QUFDQSxJQUFBLElBQUksQ0FBQyxNQUFMLENBQVksTUFBWixFQUFvQixJQUFwQixFQUEwQixJQUFJLENBQUMsUUFBL0I7QUFDQSxXQUFPLE1BQU0sQ0FBQyxLQUFQLENBQWEsNkJBQWIsRUFBNEMsTUFBTSxDQUFDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLGtCQUFsQixFQUFzQztBQUN2RixNQUFBLElBQUksRUFBRTtBQURpRixLQUF0QyxDQUE1QyxFQUVILElBRkcsQ0FFRSxHQUFHLElBQUk7QUFDZCxVQUFJLEdBQUcsQ0FBQyxNQUFKLEtBQWUsR0FBbkIsRUFBd0I7QUFDdEIsZUFBTyxHQUFHLENBQUMsSUFBSixFQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBTyxHQUFHLENBQUMsSUFBSixHQUFXLElBQVgsQ0FBZ0IsSUFBSSxJQUFJO0FBQzdCLGdCQUFNLElBQUksS0FBSixDQUFVLElBQVYsQ0FBTjtBQUNELFNBRk0sQ0FBUDtBQUdEO0FBQ0YsS0FWTSxFQVVKLEtBVkksQ0FVRSxHQUFHLElBQUk7QUFDZDtBQUNBLE1BQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxpQ0FBZ0MsSUFBSSxDQUFDLFFBQVMsRUFBNUQ7QUFDQSxNQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsR0FBZDtBQUNBLGFBQU8sU0FBUDtBQUNELEtBZk0sQ0FBUDtBQWdCRCxHQXJCRDs7QUF1QkEsUUFBTSxNQUFNLEdBQUcsQ0FBQyxHQUFELEVBQU0sSUFBTixLQUFlO0FBQzVCLElBQUEsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFmO0FBRUEsV0FBTyxNQUFNLENBQUMsS0FBUCxDQUFhLEdBQWIsRUFBa0IsTUFBTSxDQUFDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLGtCQUFsQixFQUFzQztBQUM3RCxNQUFBLE9BQU8sRUFBRTtBQUNQLHdCQUFnQjtBQURULE9BRG9EO0FBSTdELE1BQUEsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFMLENBQWU7QUFDbkIsUUFBQSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBRFE7QUFFbkIsUUFBQSxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBRkk7QUFHbkIsUUFBQSxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBSEc7QUFJbkIsUUFBQSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBSlM7QUFLbkIsUUFBQSxRQUFRLEVBQUUsSUFBSSxDQUFDO0FBTEksT0FBZjtBQUp1RCxLQUF0QyxDQUFsQixFQVlKLElBWkksQ0FZQyxHQUFHLElBQUk7QUFDWCxVQUFJLEdBQUcsQ0FBQyxNQUFKLEtBQWUsR0FBbkIsRUFBd0I7QUFDdEIsZUFBTyxHQUFHLENBQUMsSUFBSixFQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBTyxHQUFHLENBQUMsSUFBSixHQUFXLElBQVgsQ0FBZ0IsSUFBSSxJQUFJO0FBQzdCLGdCQUFNLElBQUksS0FBSixDQUFVLElBQVYsQ0FBTjtBQUNELFNBRk0sQ0FBUDtBQUdEO0FBQ0YsS0FwQkksRUFvQkYsS0FwQkUsQ0FvQkksR0FBRyxJQUFJO0FBQ2Q7QUFDQSxNQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsZ0RBQWQ7QUFDQSxNQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsR0FBZDtBQUNBLGFBQU8sU0FBUDtBQUNELEtBekJJLENBQVA7QUEwQkQsR0E3QkQsQ0FuQ3FCLENBa0VyQjs7O0FBQ0EsRUFBQSxNQUFNLENBQUMsU0FBRCxDQUFOLENBQWtCLFdBQWxCLEdBQWlDLElBQUQsSUFBVTtBQUN4QyxXQUFPLE1BQU0sQ0FBQyxpQ0FBRCxFQUFvQyxJQUFwQyxDQUFiO0FBQ0QsR0FGRDs7QUFJQSxFQUFBLE1BQU0sQ0FBQyxTQUFELENBQU4sQ0FBa0IsU0FBbEIsR0FBK0IsSUFBRCxJQUFVO0FBQ3RDLFdBQU8sTUFBTSxDQUFDLCtCQUFELEVBQWtDLElBQWxDLENBQWI7QUFDRCxHQUZELENBdkVxQixDQTJFckI7OztBQUNBLEVBQUEsTUFBTSxDQUFDLFNBQUQsQ0FBTixDQUFrQixNQUFsQixHQUEyQixNQUFNO0FBQy9CLFdBQU8sTUFBTSxDQUFDLEtBQVAsQ0FBYSwyQkFBYixFQUEwQyxrQkFBMUMsRUFDSixJQURJLENBQ0MsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFMLEVBRFQsRUFFSixJQUZJLENBRUMsTUFBTSxJQUFJO0FBQ2QsVUFBSSxNQUFNLENBQUMsS0FBWCxFQUFrQjtBQUNoQixZQUFJLE1BQU0sQ0FBQyxLQUFQLENBQWEsV0FBYixHQUEyQixRQUEzQixDQUFvQyxzQkFBcEMsQ0FBSixFQUFpRTtBQUMvRCxVQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsWUFBVyxNQUFNLENBQUMsS0FBTSxFQUF0QztBQUNBLGlCQUFPLElBQVA7QUFDRCxTQUhELE1BR087QUFDTCxnQkFBTSxJQUFJLEtBQUosQ0FBVSxNQUFNLENBQUMsS0FBakIsQ0FBTjtBQUNEO0FBQ0YsT0FSYSxDQVNkOzs7QUFDQSxNQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksTUFBTSxDQUFDLE9BQVAsR0FDUCxTQUFRLE1BQU0sQ0FBQyxJQUFLLG9CQURiLEdBRVAsU0FBUSxNQUFNLENBQUMsSUFBSyxrQkFGekI7QUFHQSxhQUFPLE1BQU0sQ0FBQyxJQUFkO0FBQ0QsS0FoQkksRUFpQkosS0FqQkksQ0FpQkUsR0FBRyxJQUFJO0FBQ1o7QUFDQSxNQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWEseUNBQWI7QUFDQSxNQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsR0FBZDtBQUNBLGFBQU8sU0FBUDtBQUNELEtBdEJJLENBQVA7QUF1QkQsR0F4QkQ7O0FBMEJBLE1BQUkscUJBQXFCLE1BQXpCLEVBQWlDO0FBQy9CLFVBQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxpQkFBRCxDQUFyQjtBQUNBLElBQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFJLElBQUk7QUFDcEIsVUFBSSxJQUFJLENBQUMsS0FBTCxLQUFlLFlBQW5CLEVBQWlDO0FBQy9CLFFBQUEsZUFBZSxDQUFDLElBQUksQ0FBQyxPQUFOLENBQWY7QUFDRDtBQUNGLEtBSkQsRUFGK0IsQ0FRL0I7O0FBQ0EsUUFBSSxNQUFNLENBQUMsU0FBRCxDQUFOLENBQWtCLEdBQXRCLEVBQTJCO0FBQ3pCLE1BQUEsZUFBZSxDQUFDLElBQUQsQ0FBZjtBQUNELEtBRkQsTUFFTztBQUNMLE1BQUEsZUFBZSxDQUFDLEtBQUQsQ0FBZjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTLGVBQVQsQ0FBMEIsU0FBMUIsRUFBcUM7QUFDbkMsUUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLFNBQUQsQ0FBTixDQUFrQixpQkFBeEM7O0FBQ0EsTUFBSSxPQUFPLGFBQVAsS0FBeUIsV0FBekIsSUFBd0MsU0FBUyxLQUFLLGFBQTFELEVBQXlFO0FBQ3ZFO0FBQ0E7QUFDQSxJQUFBLE1BQU0sQ0FBQyxRQUFQLENBQWdCLE1BQWhCLENBQXVCLElBQXZCO0FBQ0E7QUFDRDs7QUFFRCxNQUFJLFNBQVMsS0FBSyxNQUFNLENBQUMsU0FBRCxDQUFOLENBQWtCLGlCQUFwQyxFQUF1RDtBQUNyRDtBQUNBO0FBQ0QsR0Faa0MsQ0FjbkM7OztBQUNBLEVBQUEsTUFBTSxDQUFDLFNBQUQsQ0FBTixDQUFrQixpQkFBbEIsR0FBc0MsU0FBdEM7O0FBRUEsTUFBSSxTQUFKLEVBQWU7QUFDYixRQUFJLHFCQUFxQixNQUF6QixFQUFpQztBQUMvQixNQUFBLE9BQU8sQ0FBQyxHQUFSLENBQWEsOENBQWIsRUFBNEQsaUJBQTVELEVBQStFLGlCQUEvRTtBQUNBLFlBQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxpQkFBRCxDQUFyQjtBQUNBLE1BQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxZQUFkO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVMsWUFBVCxDQUF1QixJQUF2QixFQUE2QjtBQUMzQixRQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsaUJBQUQsQ0FBckI7QUFDQSxNQUFJLENBQUMsTUFBTCxFQUFhOztBQUViLE1BQUksSUFBSSxDQUFDLEtBQUwsS0FBZSxNQUFuQixFQUEyQjtBQUN6QixRQUFJLENBQUMsSUFBSSxDQUFDLEtBQVYsRUFBaUI7QUFDZixNQUFBLE1BQU0sQ0FBQyxVQUFQO0FBQ0Q7O0FBQ0QsUUFBSTtBQUNGLE1BQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFOLENBQUo7QUFDQSxVQUFJLENBQUMsSUFBSSxDQUFDLEtBQVYsRUFBaUIsT0FBTyxDQUFDLEdBQVIsQ0FBYSx3Q0FBYixFQUFzRCxpQkFBdEQsRUFBeUUsaUJBQXpFO0FBQ2xCLEtBSEQsQ0FHRSxPQUFPLEdBQVAsRUFBWTtBQUNaLE1BQUEsT0FBTyxDQUFDLEtBQVIsQ0FBZSw2Q0FBZixFQUE2RCxpQkFBN0QsRUFBZ0YsaUJBQWhGO0FBQ0EsTUFBQSxNQUFNLENBQUMsU0FBUCxDQUFpQixHQUFHLENBQUMsUUFBSixFQUFqQixFQUZZLENBSVo7QUFDQTs7QUFDQSxZQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixRQUF2QixDQUF0Qjs7QUFDQSxNQUFBLGFBQWEsQ0FBQyxNQUFkLEdBQXVCLE1BQU07QUFDM0IsUUFBQSxRQUFRLENBQUMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsYUFBMUI7QUFDRCxPQUZEOztBQUdBLE1BQUEsYUFBYSxDQUFDLEdBQWQsR0FBb0IsSUFBSSxDQUFDLEdBQXpCO0FBQ0EsTUFBQSxRQUFRLENBQUMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsYUFBMUI7QUFDRDtBQUNGO0FBQ0Y7Ozs7QUNuTEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztDQ25GQTs7Ozs7O0NBUUEsSUFBSSxxQkFBcUIsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUM7Q0FDekQsSUFBSSxjQUFjLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUM7Q0FDckQsSUFBSSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDOztDQUU3RCxTQUFTLFFBQVEsQ0FBQyxHQUFHLEVBQUU7RUFDdEIsSUFBSSxHQUFHLEtBQUssSUFBSSxJQUFJLEdBQUcsS0FBSyxTQUFTLEVBQUU7R0FDdEMsTUFBTSxJQUFJLFNBQVMsQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO0dBQzdFOztFQUVELE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQ25COztDQUVELFNBQVMsZUFBZSxHQUFHO0VBQzFCLElBQUk7R0FDSCxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtJQUNuQixPQUFPLEtBQUssQ0FBQztJQUNiOzs7OztHQUtELElBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0dBQzlCLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7R0FDaEIsSUFBSSxNQUFNLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFO0lBQ2pELE9BQU8sS0FBSyxDQUFDO0lBQ2I7OztHQUdELElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztHQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDNUIsS0FBSyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDO0dBQ0QsSUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRTtJQUMvRCxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoQixDQUFDLENBQUM7R0FDSCxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssWUFBWSxFQUFFO0lBQ3JDLE9BQU8sS0FBSyxDQUFDO0lBQ2I7OztHQUdELElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztHQUNmLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxNQUFNLEVBQUU7SUFDMUQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQztJQUN2QixDQUFDLENBQUM7R0FDSCxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO0tBQ2hELHNCQUFzQixFQUFFO0lBQ3pCLE9BQU8sS0FBSyxDQUFDO0lBQ2I7O0dBRUQsT0FBTyxJQUFJLENBQUM7R0FDWixDQUFDLE9BQU8sR0FBRyxFQUFFOztHQUViLE9BQU8sS0FBSyxDQUFDO0dBQ2I7RUFDRDs7Q0FFRCxnQkFBYyxHQUFHLGVBQWUsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsVUFBVSxNQUFNLEVBQUUsTUFBTSxFQUFFO0VBQzlFLElBQUksSUFBSSxDQUFDO0VBQ1QsSUFBSSxFQUFFLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0VBQzFCLElBQUksT0FBTyxDQUFDOztFQUVaLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0dBQzFDLElBQUksR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7O0dBRTVCLEtBQUssSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO0lBQ3JCLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUU7S0FDbkMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNwQjtJQUNEOztHQUVELElBQUkscUJBQXFCLEVBQUU7SUFDMUIsT0FBTyxHQUFHLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0tBQ3hDLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtNQUM1QyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ2xDO0tBQ0Q7SUFDRDtHQUNEOztFQUVELE9BQU8sRUFBRSxDQUFDO0VBQ1YsQ0FBQzs7Ozs7Ozs7Q0N6RkYsV0FBYztHQUNaLGNBQU0sQ0FBQyxXQUFXO0dBQ2xCLGNBQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHO0tBQ3RDLE9BQU8sV0FBVyxDQUFDLEdBQUcsRUFBRTtJQUN6QixHQUFHLElBQUksQ0FBQyxHQUFHLElBQUksU0FBUyxHQUFHLEdBQUc7S0FDN0IsT0FBTyxDQUFDLElBQUksSUFBSTtJQUNqQjs7Q0NOSCxlQUFjLEdBQUcsU0FBUyxDQUFDOztDQUUzQixTQUFTLFNBQVMsQ0FBQyxHQUFHLEVBQUU7R0FDdEIsT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLE9BQU8sR0FBRyxLQUFLLFFBQVEsSUFBSSxPQUFPLEdBQUcsS0FBSyxVQUFVLENBQUMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDO0VBQzFHOztDQ0pELFNBQWMsR0FBRyxPQUFNOztDQUV2QixTQUFTLE1BQU0sRUFBRSxHQUFHLEVBQUU7R0FDcEIsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVE7T0FDbkMsS0FBSztPQUNMLENBQUMsT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE9BQU8sTUFBTSxDQUFDLElBQUksS0FBSyxRQUFRO1VBQzNELEdBQUcsWUFBWSxNQUFNLENBQUMsSUFBSTtTQUMzQixDQUFDLE9BQU8sR0FBRyxDQUFDLFFBQVEsS0FBSyxRQUFRO1VBQ2hDLE9BQU8sR0FBRyxDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUM7RUFDekM7O0NDTE0sU0FBUyxlQUFnQjtLQUM5QixPQUFPLE9BQU8sTUFBUCxLQUFrQixXQUFsQixJQUFpQyxNQUFBLENBQU87OztBQUdqRCxDQUFPLFNBQVMsVUFBVzs7O0tBQ3pCLEtBQUssSUFBSSxJQUFJLEVBQUcsQ0FBQSxHQUFJLFNBQUEsQ0FBVSxRQUFRLENBQUEsSUFBSztTQUN6QyxJQUFJLFdBQUEsQ0FBVSxFQUFWLElBQWdCLE1BQU07YUFDeEIsT0FBTyxXQUFBLENBQVU7OztLQUdyQixPQUFPOzs7QUFHVCxDQUFPLFNBQVMsWUFBYTtLQUMzQixPQUFPLE9BQU8sUUFBUCxLQUFvQjs7O0FBRzdCLENBQU8sU0FBUyxlQUFnQixLQUFLO0tBQ25DLE9BQU8sT0FBTyxHQUFBLENBQUksS0FBWCxLQUFxQixVQUFyQixJQUFtQyxPQUFPLEdBQUEsQ0FBSSxVQUFYLEtBQTBCLFVBQTdELElBQTJFLE9BQU8sR0FBQSxDQUFJLFVBQVgsS0FBMEI7OztBQUc5RyxDQUFPLFNBQVMsU0FBVSxTQUFTO0tBQ2pDLE9BQU8sS0FBQSxDQUFNLFFBQU4sSUFBa0IsU0FBQSxDQUFVLElBQVYsQ0FBZSxPQUFBLENBQVEsU0FBekMsSUFBc0QsT0FBTyxPQUFBLENBQVEsVUFBZixLQUE4Qjs7OztDQzFCN0YsT0FBTyxHQUFHLGNBQWMsR0FBRyxPQUFPLE1BQU0sQ0FBQyxJQUFJLEtBQUssVUFBVTtLQUN4RCxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs7Q0FFdkIsWUFBWSxHQUFHLElBQUksQ0FBQztDQUNwQixTQUFTLElBQUksRUFBRSxHQUFHLEVBQUU7R0FDbEIsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQ2QsS0FBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztHQUNwQyxPQUFPLElBQUksQ0FBQztFQUNiOzs7OztDQ1JELElBQUksc0JBQXNCLEdBQUcsQ0FBQyxVQUFVO0dBQ3RDLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztFQUNqRCxHQUFHLElBQUksb0JBQW9CLENBQUM7O0NBRTdCLE9BQU8sR0FBRyxjQUFjLEdBQUcsc0JBQXNCLEdBQUcsU0FBUyxHQUFHLFdBQVcsQ0FBQzs7Q0FFNUUsaUJBQWlCLEdBQUcsU0FBUyxDQUFDO0NBQzlCLFNBQVMsU0FBUyxDQUFDLE1BQU0sRUFBRTtHQUN6QixPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxvQkFBb0IsQ0FBQztFQUN2RTtDQUVELG1CQUFtQixHQUFHLFdBQVcsQ0FBQztDQUNsQyxTQUFTLFdBQVcsQ0FBQyxNQUFNLENBQUM7R0FDMUIsT0FBTyxNQUFNO0tBQ1gsT0FBTyxNQUFNLElBQUksUUFBUTtLQUN6QixPQUFPLE1BQU0sQ0FBQyxNQUFNLElBQUksUUFBUTtLQUNoQyxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQztLQUN0RCxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUM7S0FDN0QsS0FBSyxDQUFDO0VBQ1Q7Ozs7O0NDbkJELElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDOzs7O0NBSW5DLElBQUksU0FBUyxHQUFHLGNBQWMsR0FBRyxVQUFVLE1BQU0sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFO0dBQ2pFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7R0FFckIsSUFBSSxNQUFNLEtBQUssUUFBUSxFQUFFO0tBQ3ZCLE9BQU8sSUFBSSxDQUFDOztJQUViLE1BQU0sSUFBSSxNQUFNLFlBQVksSUFBSSxJQUFJLFFBQVEsWUFBWSxJQUFJLEVBQUU7S0FDN0QsT0FBTyxNQUFNLENBQUMsT0FBTyxFQUFFLEtBQUssUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDOzs7O0lBSWhELE1BQU0sSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLFFBQVEsSUFBSSxPQUFPLE1BQU0sSUFBSSxRQUFRLElBQUksT0FBTyxRQUFRLElBQUksUUFBUSxFQUFFO0tBQzNGLE9BQU8sSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLEtBQUssUUFBUSxHQUFHLE1BQU0sSUFBSSxRQUFRLENBQUM7Ozs7Ozs7O0lBUS9ELE1BQU07S0FDTCxPQUFPLFFBQVEsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3pDO0dBQ0Y7O0NBRUQsU0FBUyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUU7R0FDaEMsT0FBTyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLENBQUM7RUFDOUM7O0NBRUQsU0FBUyxRQUFRLEVBQUUsQ0FBQyxFQUFFO0dBQ3BCLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssUUFBUSxJQUFJLE9BQU8sQ0FBQyxDQUFDLE1BQU0sS0FBSyxRQUFRLEVBQUUsT0FBTyxLQUFLLENBQUM7R0FDOUUsSUFBSSxPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssVUFBVSxJQUFJLE9BQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxVQUFVLEVBQUU7S0FDakUsT0FBTyxLQUFLLENBQUM7SUFDZDtHQUNELElBQUksQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxFQUFFLE9BQU8sS0FBSyxDQUFDO0dBQzNELE9BQU8sSUFBSSxDQUFDO0VBQ2I7O0NBRUQsU0FBUyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUU7R0FDNUIsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDO0dBQ1gsSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7S0FDOUMsT0FBTyxLQUFLLENBQUM7O0dBRWYsSUFBSSxDQUFDLENBQUMsU0FBUyxLQUFLLENBQUMsQ0FBQyxTQUFTLEVBQUUsT0FBTyxLQUFLLENBQUM7OztHQUc5QyxJQUFJLFlBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRTtLQUNsQixJQUFJLENBQUMsWUFBVyxDQUFDLENBQUMsQ0FBQyxFQUFFO09BQ25CLE9BQU8sS0FBSyxDQUFDO01BQ2Q7S0FDRCxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNuQixDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNuQixPQUFPLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzlCO0dBQ0QsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7S0FDZixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFO09BQ2hCLE9BQU8sS0FBSyxDQUFDO01BQ2Q7S0FDRCxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxPQUFPLEtBQUssQ0FBQztLQUN4QyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7T0FDN0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sS0FBSyxDQUFDO01BQ2pDO0tBQ0QsT0FBTyxJQUFJLENBQUM7SUFDYjtHQUNELElBQUk7S0FDRixJQUFJLEVBQUUsR0FBRyxJQUFVLENBQUMsQ0FBQyxDQUFDO1NBQ2xCLEVBQUUsR0FBRyxJQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEIsQ0FBQyxPQUFPLENBQUMsRUFBRTtLQUNWLE9BQU8sS0FBSyxDQUFDO0lBQ2Q7OztHQUdELElBQUksRUFBRSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsTUFBTTtLQUN4QixPQUFPLEtBQUssQ0FBQzs7R0FFZixFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7R0FDVixFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7O0dBRVYsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtLQUNuQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO09BQ2hCLE9BQU8sS0FBSyxDQUFDO0lBQ2hCOzs7R0FHRCxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0tBQ25DLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDWixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsT0FBTyxLQUFLLENBQUM7SUFDcEQ7R0FDRCxPQUFPLE9BQU8sQ0FBQyxLQUFLLE9BQU8sQ0FBQyxDQUFDO0VBQzlCOzs7O0NDN0ZEOzs7Ozs7Ozs7Ozs7OztDQWNBLENBQUMsU0FBUyxNQUFNLEVBQUU7O0dBR2hCLElBQUksVUFBVSxHQUFHLENBQUMsV0FBVztPQUN6QixJQUFJLEtBQUssR0FBRyxrRUFBa0UsQ0FBQztPQUMvRSxJQUFJLFFBQVEsR0FBRyxzSUFBc0ksQ0FBQztPQUN0SixJQUFJLFlBQVksR0FBRyxhQUFhLENBQUM7OztPQUdqQyxPQUFPLFVBQVUsSUFBSSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFOzs7U0FHckMsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtXQUMzRSxJQUFJLEdBQUcsSUFBSSxDQUFDO1dBQ1osSUFBSSxHQUFHLFNBQVMsQ0FBQztVQUNsQjs7U0FFRCxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDOztTQUV4QixHQUFHLEVBQUUsSUFBSSxZQUFZLElBQUksQ0FBQyxFQUFFO1dBQzFCLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztVQUN2Qjs7U0FFRCxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtXQUNmLE1BQU0sU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1VBQ2pDOztTQUVELElBQUksR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDOzs7U0FHN0UsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDakMsSUFBSSxTQUFTLEtBQUssTUFBTSxJQUFJLFNBQVMsS0FBSyxNQUFNLEVBQUU7V0FDaEQsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7V0FDckIsR0FBRyxHQUFHLElBQUksQ0FBQztXQUNYLElBQUksU0FBUyxLQUFLLE1BQU0sRUFBRTthQUN4QixHQUFHLEdBQUcsSUFBSSxDQUFDO1lBQ1o7VUFDRjs7U0FFRCxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsUUFBUSxHQUFHLEtBQUssQ0FBQztTQUMvQixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUM7U0FDM0IsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDO1NBQzFCLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQztTQUM1QixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUM7U0FDL0IsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDO1NBQzVCLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEVBQUUsQ0FBQztTQUM5QixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUM7U0FDOUIsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxjQUFjLENBQUMsRUFBRSxDQUFDO1NBQ25DLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7U0FDM0MsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3RCLElBQUksQ0FBQyxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzQixJQUFJLEtBQUssR0FBRztXQUNWLENBQUMsS0FBSyxDQUFDO1dBQ1AsRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7V0FDWixHQUFHLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1dBQ2pDLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1dBQ3JDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztXQUNYLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztXQUNoQixHQUFHLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1dBQ25DLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1dBQ3hDLEVBQUUsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztXQUN4QixJQUFJLEVBQUUsQ0FBQztXQUNQLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUU7V0FDbEIsRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztXQUN2QixDQUFDLEtBQUssQ0FBQztXQUNQLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQ1osQ0FBQyxLQUFLLENBQUM7V0FDUCxFQUFFLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztXQUNaLENBQUMsS0FBSyxDQUFDO1dBQ1AsRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7V0FDWixDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7V0FDZixDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1dBQzdCLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztXQUMxRSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7V0FDMUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1dBQzFFLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztXQUMxRSxDQUFDLEtBQUssR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDO1dBQ3hHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7V0FDekYsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1dBQ2xGLENBQUMsS0FBSyxDQUFDO1dBQ1AsQ0FBQyxLQUFLLENBQUM7VUFDUixDQUFDOztTQUVGLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsVUFBVSxLQUFLLEVBQUU7V0FDMUMsSUFBSSxLQUFLLElBQUksS0FBSyxFQUFFO2FBQ2xCLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JCO1dBQ0QsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1VBQ3pDLENBQUMsQ0FBQztRQUNKLENBQUM7TUFDSCxHQUFHLENBQUM7O0dBRVAsVUFBVSxDQUFDLEtBQUssR0FBRztLQUNqQixTQUFTLGdCQUFnQiwwQkFBMEI7S0FDbkQsV0FBVyxjQUFjLFFBQVE7S0FDakMsWUFBWSxhQUFhLGFBQWE7S0FDdEMsVUFBVSxlQUFlLGNBQWM7S0FDdkMsVUFBVSxlQUFlLG9CQUFvQjtLQUM3QyxXQUFXLGNBQWMsU0FBUztLQUNsQyxZQUFZLGFBQWEsWUFBWTtLQUNyQyxVQUFVLGVBQWUsY0FBYztLQUN2QyxTQUFTLGdCQUFnQixZQUFZO0tBQ3JDLFNBQVMsZ0JBQWdCLFVBQVU7S0FDbkMsYUFBYSxZQUFZLDBCQUEwQjtLQUNuRCxnQkFBZ0IsU0FBUyxrQ0FBa0M7S0FDM0QscUJBQXFCLElBQUksNkJBQTZCO0lBQ3ZELENBQUM7OztHQUdGLFVBQVUsQ0FBQyxJQUFJLEdBQUc7S0FDaEIsUUFBUSxFQUFFO09BQ1IsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSztPQUMvQyxRQUFRLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxVQUFVO01BQzdFO0tBQ0QsVUFBVSxFQUFFO09BQ1YsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLO09BQ2xGLFNBQVMsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsVUFBVTtNQUN6SDtLQUNELFNBQVMsRUFBRTtPQUNULEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJO01BQzNDO0lBQ0YsQ0FBQzs7Q0FFSixTQUFTLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFO0dBQ3JCLEdBQUcsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDbEIsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7R0FDZixPQUFPLEdBQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFO0tBQ3ZCLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0lBQ2pCO0dBQ0QsT0FBTyxHQUFHLENBQUM7RUFDWjs7Ozs7Ozs7OztDQVVELFNBQVMsT0FBTyxDQUFDLElBQUksRUFBRTs7R0FFckIsSUFBSSxjQUFjLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQzs7O0dBR25GLGNBQWMsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzs7O0dBRzNGLElBQUksYUFBYSxHQUFHLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7OztHQUdqRSxhQUFhLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7OztHQUd4RixJQUFJLEVBQUUsR0FBRyxjQUFjLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxhQUFhLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztHQUNoRixjQUFjLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQzs7O0dBR3hELElBQUksUUFBUSxHQUFHLENBQUMsY0FBYyxHQUFHLGFBQWEsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDL0QsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztFQUNqQzs7Ozs7Ozs7O0NBU0QsU0FBUyxZQUFZLENBQUMsSUFBSSxFQUFFO0dBQzFCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztHQUN4QixHQUFHLEdBQUcsS0FBSyxDQUFDLEVBQUU7S0FDWixHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ1Q7R0FDRCxPQUFPLEdBQUcsQ0FBQztFQUNaOzs7Ozs7O0NBT0QsU0FBUyxNQUFNLENBQUMsR0FBRyxFQUFFO0dBQ25CLElBQUksR0FBRyxLQUFLLElBQUksRUFBRTtLQUNoQixPQUFPLE1BQU0sQ0FBQztJQUNmOztHQUVELElBQUksR0FBRyxLQUFLLFNBQVMsRUFBRTtLQUNyQixPQUFPLFdBQVcsQ0FBQztJQUNwQjs7R0FFRCxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtLQUMzQixPQUFPLE9BQU8sR0FBRyxDQUFDO0lBQ25COztHQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtLQUN0QixPQUFPLE9BQU8sQ0FBQztJQUNoQjs7R0FFRCxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztNQUN6QixLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7RUFDL0I7OztHQUlDLElBQUksT0FBTyxTQUFNLEtBQUssVUFBVSxJQUFJLFNBQU0sQ0FBQyxHQUFHLEVBQUU7S0FDOUMsU0FBTSxDQUFDLFlBQVk7T0FDakIsT0FBTyxVQUFVLENBQUM7TUFDbkIsQ0FBQyxDQUFDO0lBQ0osTUFBTSxBQUFpQztLQUN0QyxjQUFjLEdBQUcsVUFBVSxDQUFDO0lBQzdCLEFBRUE7RUFDRixFQUFFLGNBQUksQ0FBQyxDQUFDOzs7Q0NwT1Q7Ozs7Ozs7Ozs7O0NBYUEsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0NBQ2IsSUFBSSxLQUFLLENBQUM7Ozs7OztDQU1WLGdCQUFjLEdBQUcsTUFBTSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CeEIsU0FBUyxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRTtHQUN4QixJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtLQUMzQixNQUFNLElBQUksU0FBUyxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDMUM7OztHQUdELElBQUksR0FBRyxLQUFLLENBQUMsRUFBRSxPQUFPLEdBQUcsQ0FBQztHQUMxQixJQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUUsT0FBTyxHQUFHLEdBQUcsR0FBRyxDQUFDOztHQUVoQyxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztHQUMzQixJQUFJLEtBQUssS0FBSyxHQUFHLElBQUksT0FBTyxLQUFLLEtBQUssV0FBVyxFQUFFO0tBQ2pELEtBQUssR0FBRyxHQUFHLENBQUM7S0FDWixHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ1YsTUFBTSxJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksR0FBRyxFQUFFO0tBQzVCLE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDM0I7O0dBRUQsT0FBTyxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO0tBQ2xDLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtPQUNYLEdBQUcsSUFBSSxHQUFHLENBQUM7TUFDWjs7S0FFRCxHQUFHLEtBQUssQ0FBQyxDQUFDO0tBQ1YsR0FBRyxJQUFJLEdBQUcsQ0FBQztJQUNaOztHQUVELEdBQUcsSUFBSSxHQUFHLENBQUM7R0FDWCxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7R0FDekIsT0FBTyxHQUFHLENBQUM7RUFDWjs7Q0MxREQsV0FBYyxHQUFHLFNBQVMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFO0dBQzlDLEdBQUcsR0FBRyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7O0dBRXJCLElBQUksT0FBTyxHQUFHLEtBQUssV0FBVyxFQUFFO0tBQzlCLE9BQU8sR0FBRyxDQUFDO0lBQ1o7O0dBRUQsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFO0tBQ1osRUFBRSxHQUFHLEdBQUcsQ0FBQztJQUNWLE1BQU0sSUFBSSxFQUFFLEVBQUU7S0FDYixFQUFFLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3BCLE1BQU07S0FDTCxFQUFFLEdBQUcsR0FBRyxDQUFDO0lBQ1Y7O0dBRUQsT0FBTyxZQUFNLENBQUMsRUFBRSxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDO0VBQzNDLENBQUM7O0NDdEJGLElBQU0sbUJBQU87Q0FDYixJQUFJO0NBQ0osSUFBSSxjQUFjO0tBQUUsV0FBVyxFQUFiO0tBQWlCLFFBQVEsRUFBekI7S0FBNkIsUUFBUTs7Q0FRdkQsSUFBTSxxQkFBcUIsQ0FDekIsWUFDQSxhQUNBO0NBR0YsU0FBUyxPQUFRLE9BQVMsRUFBQSxNQUFXO2dDQUFYLEdBQU87O0tBQy9CLE9BQU8sSUFBSSxPQUFKLFdBQWEsT0FBUyxFQUFBLFFBQVY7U0FDakIsSUFBQSxHQUFPLFlBQUEsQ0FBTyxJQUFJLGFBQWE7U0FDL0IsSUFBTSxXQUFXLGVBQUEsQ0FBZ0IsTUFBQSxDQUFPLE1BQVAsQ0FBYyxJQUFJLE1BQU07YUFDdkQsV0FBVyxFQUQ0QzthQUV2RCxPQUFPOztTQUVULElBQU0sT0FBTyxPQUFBLEdBQVUsZ0JBQWdCO1NBQ3ZDLElBQU0sU0FBUyxZQUFBO1NBQ2YsSUFBSSxNQUFBLElBQVUsTUFBQSxDQUFPLE1BQWpCLElBQTJCLE9BQU8sTUFBQSxDQUFPLEtBQWQsS0FBd0IsWUFBWTthQUNqRSxPQUFPLE1BQUEsQ0FBTyxLQUFQLENBQWEsWUFBQSxDQUFPLElBQUksTUFBTTsyQkFBRTtnQkFBaEMsQ0FDSixJQURJLFdBQ0MsYUFBTSxPQUFBLENBQVE7Z0JBQ2pCO2FBQ0wsT0FBTyxPQUFBLENBQVE7MkJBQUUsUUFBRjtpQkFBWSxRQUFROzs7Ozs7QUFLekMsQ0FBTyxTQUFTLFlBQWEsTUFBVztnQ0FBWCxHQUFPOztLQUNsQyxPQUFPLE1BQUEsQ0FBTyxNQUFNOzs7QUFHdEIsQ0FBTyxTQUFTLFVBQVcsTUFBVztnQ0FBWCxHQUFPOztLQUNoQyxPQUFPLE1BQUEsQ0FBTyxPQUFPOzs7QUFHdkIsQ0FBTyxTQUFTLGFBQWMsTUFBUSxFQUFBLEtBQVU7OEJBQVYsR0FBTTs7S0FDMUMsSUFBTSxXQUFXLEdBQUEsQ0FBSSxRQUFKLElBQWdCO0tBQ2pDLElBQUksQ0FBQyxrQkFBQSxDQUFtQixRQUFuQixDQUE0QjtXQUFXLE1BQU0sSUFBSSxLQUFKLCtCQUFxQztLQUN2RixJQUFJLGFBQWEsUUFBQSxDQUFTLEtBQVQsQ0FBZSxJQUFmLENBQW9CLEVBQXBCLElBQTBCLElBQUksT0FBL0IsQ0FBdUMsU0FBUztLQUNoRSxJQUFJO1dBQVcsU0FBQSxHQUFZLE9BQUksV0FBWSxXQUFoQjtLQUMzQixPQUFPO29CQUNMLFNBREs7U0FFTCxNQUFNLFFBRkQ7U0FHTCxTQUFTLE1BQUEsQ0FBTyxTQUFQLENBQWlCLFVBQVUsR0FBQSxDQUFJOzs7O0NBSTVDLFNBQVMsc0JBQXVCLFNBQVM7S0FDdkMsT0FBTyxJQUFJLE9BQUosV0FBYTtTQUNsQixJQUFNLGFBQWEsT0FBQSxDQUFRLE9BQVIsQ0FBZ0I7U0FDbkMsSUFBSSxVQUFBLEtBQWUsQ0FBQyxHQUFHO2FBQ3JCLE9BQUEsQ0FBUSxJQUFJLE1BQUEsQ0FBTyxJQUFYO2FBQ1I7O1NBRUYsSUFBTSxTQUFTLE9BQUEsQ0FBUSxLQUFSLENBQWMsVUFBQSxHQUFhO1NBQzFDLElBQU0sYUFBYSxNQUFBLENBQU8sSUFBUCxDQUFZO1NBQy9CLElBQU0sT0FBTyxPQUFBLENBQVEsS0FBUixDQUFjLEdBQUc7U0FDOUIsSUFBTSxZQUFZLGNBQUEsQ0FBZSxJQUFmLENBQW9CO1NBQ3RDLElBQU0sUUFBUSxTQUFBLEdBQVksU0FBQSxDQUFVLEtBQUssT0FBTztTQUNoRCxJQUFNLEtBQUssSUFBSSxXQUFKLENBQWdCLFVBQUEsQ0FBVztTQUN0QyxJQUFNLEtBQUssSUFBSSxVQUFKLENBQWU7U0FDMUIsS0FBSyxJQUFJLElBQUksRUFBRyxDQUFBLEdBQUksVUFBQSxDQUFXLFFBQVEsQ0FBQSxJQUFLO2FBQzFDLEVBQUEsQ0FBRyxFQUFILEdBQVEsVUFBQSxDQUFXLFVBQVgsQ0FBc0I7O1NBRWhDLE9BQUEsQ0FBUSxJQUFJLE1BQUEsQ0FBTyxJQUFYLENBQWdCLENBQUUsS0FBTTthQUFFLE1BQU07Ozs7O0FBSTVDLENBQU8sU0FBUyxZQUFhLE9BQVMsRUFBQSxNQUFXO2dDQUFYLEdBQU87O0tBQzNDLE9BQU8scUJBQUEsQ0FBc0IsUUFBdEIsQ0FDSixJQURJLFdBQ0MsZUFBUSxRQUFBLENBQVMsTUFBTTs7O0FBR2pDLENBQU8sU0FBUyxTQUFVLElBQU0sRUFBQSxNQUFXO2dDQUFYLEdBQU87O0tBQ3JDLE9BQU8sSUFBSSxPQUFKLFdBQVk7U0FDakIsSUFBQSxHQUFPLFlBQUEsQ0FBTyxJQUFJLGFBQWE7U0FDL0IsSUFBTSxXQUFXLElBQUEsQ0FBSztTQUV0QixJQUFNLFNBQVMsWUFBQTtTQUNmLElBQUksTUFBQSxJQUFVLE9BQU8sTUFBQSxDQUFPLFFBQWQsS0FBMkIsVUFBckMsSUFBbUQsTUFBQSxDQUFPLFFBQVE7YUFFcEUsT0FBTyxNQUFBLENBQU8sUUFBUCxDQUFnQixNQUFNLFlBQUEsQ0FBTyxJQUFJLE1BQU07MkJBQUU7Z0JBQXpDLENBQ0osSUFESSxXQUNDLGFBQU0sT0FBQSxDQUFRO2dCQUNqQjthQUVMLElBQUksQ0FBQyxNQUFNO2lCQUNULElBQUEsR0FBTyxRQUFBLENBQVMsYUFBVCxDQUF1QjtpQkFDOUIsSUFBQSxDQUFLLEtBQUwsQ0FBVyxVQUFYLEdBQXdCO2lCQUN4QixJQUFBLENBQUssTUFBTCxHQUFjOzthQUVoQixJQUFBLENBQUssUUFBTCxHQUFnQjthQUNoQixJQUFBLENBQUssSUFBTCxHQUFZLE1BQUEsQ0FBTyxHQUFQLENBQVcsZUFBWCxDQUEyQjthQUN2QyxRQUFBLENBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEI7YUFDMUIsSUFBQSxDQUFLLE9BQUwsZ0JBQWU7aUJBQ2IsSUFBQSxDQUFLLE9BQUwsR0FBZTtpQkFDZixVQUFBLGFBQVc7cUJBQ1QsTUFBQSxDQUFPLEdBQVAsQ0FBVyxlQUFYLENBQTJCO3FCQUMzQixJQUFJLElBQUEsQ0FBSzsyQkFBZSxJQUFBLENBQUssYUFBTCxDQUFtQixXQUFuQixDQUErQjtxQkFDdkQsSUFBQSxDQUFLLGVBQUwsQ0FBcUI7cUJBQ3JCLE9BQUEsQ0FBUTttQ0FBRSxRQUFGO3lCQUFZLFFBQVE7Ozs7YUFHaEMsSUFBQSxDQUFLLEtBQUw7Ozs7O0FBS04sQ0FBTyxTQUFTLFNBQVUsSUFBTSxFQUFBLE1BQVc7Z0NBQVgsR0FBTzs7S0FDckMsSUFBTSxRQUFRLEtBQUEsQ0FBTSxPQUFOLENBQWMsS0FBZCxHQUFzQixPQUFPLENBQUU7S0FDN0MsSUFBTSxPQUFPLElBQUksTUFBQSxDQUFPLElBQVgsQ0FBZ0IsT0FBTztTQUFFLE1BQU0sSUFBQSxDQUFLLElBQUwsSUFBYTs7S0FDekQsT0FBTyxRQUFBLENBQVMsTUFBTTs7O0FBR3hCLENBQU8sU0FBUyxlQUFnQjtLQUM5QixJQUFNLGdCQUFnQjtLQUN0QixPQUFPLFVBQUEsQ0FBVyxJQUFJLElBQUosSUFBWTs7O0FBU2hDLENBQU8sU0FBUyxnQkFBaUIsS0FBVTs4QkFBVixHQUFNOztLQUNyQyxHQUFBLEdBQU0sWUFBQSxDQUFPLElBQUk7S0FHakIsSUFBSSxPQUFPLEdBQUEsQ0FBSSxJQUFYLEtBQW9CLFlBQVk7U0FDbEMsT0FBTyxHQUFBLENBQUksSUFBSixDQUFTO1lBQ1gsSUFBSSxHQUFBLENBQUksTUFBTTtTQUNuQixPQUFPLEdBQUEsQ0FBSTs7S0FHYixJQUFJLFFBQVE7S0FDWixJQUFJLFlBQVk7S0FDaEIsSUFBSSxPQUFPLEdBQUEsQ0FBSSxTQUFYLEtBQXlCO1dBQVUsU0FBQSxHQUFZLEdBQUEsQ0FBSTtLQUV2RCxJQUFJLE9BQU8sR0FBQSxDQUFJLEtBQVgsS0FBcUIsVUFBVTtTQUNqQyxJQUFJO1NBQ0osSUFBSSxPQUFPLEdBQUEsQ0FBSSxXQUFYLEtBQTJCLFVBQVU7YUFDdkMsV0FBQSxHQUFjLEdBQUEsQ0FBSTtnQkFDYjthQUNMLFdBQUEsR0FBYyxJQUFBLENBQUssR0FBTCxDQUFTLE9BQU8sR0FBQSxDQUFJOztTQUVwQyxLQUFBLEdBQVEsT0FBQSxDQUFRLE1BQUEsQ0FBTyxHQUFBLENBQUksUUFBUSxNQUFBLENBQU8sWUFBUCxDQUFvQixRQUFROztLQUdqRSxJQUFNLFdBQVcsUUFBQSxDQUFTLEdBQUEsQ0FBSSxZQUFiLElBQTZCLFFBQUEsQ0FBUyxHQUFBLENBQUksTUFBMUMsSUFBb0QsR0FBQSxDQUFJLFdBQUosR0FBa0IsQ0FBdEUsVUFBNkUsR0FBQSxDQUFJLFVBQVU7S0FDNUcsSUFBSSxLQUFBLElBQVMsTUFBTTtTQUNqQixPQUFPLENBQUUsU0FBVSxNQUFaLENBQW9CLE1BQXBCLENBQTJCLFFBQTNCLENBQW9DLElBQXBDLENBQXlDLElBQXpDLEdBQWdEO1lBQ2xEO1NBQ0wsSUFBTSxrQkFBa0IsR0FBQSxDQUFJO1NBQzVCLE9BQU8sQ0FBRSxHQUFBLENBQUksT0FBUSxHQUFBLENBQUksSUFBSixJQUFZLGdCQUFpQixTQUFVLEdBQUEsQ0FBSSxLQUFNLEdBQUEsQ0FBSSxPQUFuRSxDQUE0RSxNQUE1RSxDQUFtRixRQUFuRixDQUE0RixJQUE1RixDQUFpRyxJQUFqRyxHQUF3Rzs7OztDQ3BLbkgsSUFBTSxjQUFjO0tBQ2xCLFdBQVcsWUFETztLQUVsQixVQUFVLFNBRlE7S0FHbEIsV0FBVyxTQUhPO0tBSWxCLE1BQU0sT0FKWTtLQUtsQixJQUFJLElBTGM7S0FNbEIsWUFBWSxXQU5NO0tBT2xCLFNBQVMsTUFQUztLQVFsQixjQUFjOztDQUloQixJQUFNLFVBQVUsQ0FDZCxhQUFjLFFBQVMsZ0JBQWlCLGNBQ3hDO0tBQWMsY0FBZSxRQUFTLGFBQ3RDLG1CQUFvQixnQkFBaUI7S0FDckMsZUFBZ0IsY0FBZSxTQUFVLFVBQVcsYUFDcEQsU0FBVTtLQUFRLE9BQVEsU0FBVSxTQUFVLFVBQVcsVUFDekQsT0FBUSxXQUFZO0tBQWUsTUFBTyxlQUFnQixZQUMxRCxRQUFTLE9BQVEsUUFBUyxZQUFhO0tBQVcsS0FBTSxLQUN4RCxvQkFBcUIsT0FBUSxTQUFVLFdBQVk7QUFLckQsQ0FBTyxJQUFNLDBCQUFpQjtLQUM1QixJQUFNLE9BQU8sTUFBQSxDQUFPLElBQVAsQ0FBWTtLQUN6QixJQUFBLENBQUssT0FBTCxXQUFhO1NBQ1gsSUFBSSxHQUFBLElBQU8sYUFBYTthQUN0QixJQUFNLFNBQVMsV0FBQSxDQUFZO2FBQzNCLE9BQUEsQ0FBUSxJQUFSLHlEQUFpRSw4QkFBdUI7Z0JBQ25GLElBQUksQ0FBQyxPQUFBLENBQVEsUUFBUixDQUFpQixNQUFNO2FBQ2pDLE9BQUEsQ0FBUSxJQUFSLHlEQUFpRTs7Ozs7Q0MvQnhELDRCQUFVLEtBQVU7OEJBQVYsR0FBTTs7S0FDN0IsSUFBTSxvQkFBVTtTQUNkLElBQUksQ0FBQyxHQUFBLENBQUksT0FBSjtlQUFlO1NBRXBCLElBQU0sU0FBUyxZQUFBO1NBQ2YsSUFBSSxFQUFBLENBQUcsT0FBSCxLQUFlLEVBQWYsSUFBcUIsQ0FBQyxFQUFBLENBQUcsTUFBekIsS0FBb0MsRUFBQSxDQUFHLE9BQUgsSUFBYyxFQUFBLENBQUcsVUFBVTthQUVqRSxFQUFBLENBQUcsY0FBSDthQUNBLEdBQUEsQ0FBSSxJQUFKLENBQVM7Z0JBQ0osSUFBSSxFQUFBLENBQUcsT0FBSCxLQUFlLElBQUk7YUFHNUIsR0FBQSxDQUFJLFVBQUosQ0FBZTtnQkFDVixJQUFJLE1BQUEsSUFBVSxDQUFDLEVBQUEsQ0FBRyxNQUFkLElBQXdCLEVBQUEsQ0FBRyxPQUFILEtBQWUsRUFBdkMsS0FBOEMsRUFBQSxDQUFHLE9BQUgsSUFBYyxFQUFBLENBQUcsVUFBVTthQUVsRixFQUFBLENBQUcsY0FBSDthQUNBLEdBQUEsQ0FBSSxNQUFKLENBQVc7OztLQUlmLElBQU0scUJBQVM7U0FDYixNQUFBLENBQU8sZ0JBQVAsQ0FBd0IsV0FBVzs7S0FHckMsSUFBTSxxQkFBUztTQUNiLE1BQUEsQ0FBTyxtQkFBUCxDQUEyQixXQUFXOztLQUd4QyxPQUFPO2lCQUNMLE1BREs7aUJBRUw7Ozs7Q0NoQ0osSUFBTSxlQUFlO0NBRXJCLElBQU0sT0FBTyxDQUdYLENBQUUsV0FBWSxNQUFPLE9BQ3JCLENBQUUsZUFBZ0IsSUFBSyxLQUN2QixDQUFFLFNBQVUsSUFBSztLQUNqQixDQUFFLGVBQWdCLElBQUssS0FDdkIsQ0FBRSxnQkFBaUIsS0FBTSxNQUd6QixDQUFFLEtBQU0sR0FBSSxJQUNaLENBQUUsS0FBTSxHQUFJO0tBQ1osQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLE1BQU8sSUFBSyxLQUNkLENBQUU7S0FBTyxJQUFLLEtBQ2QsQ0FBRSxNQUFPLElBQUssS0FHZCxDQUFFLEtBQU0sSUFBSyxNQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFO0tBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxHQUFJLEtBQ1osQ0FBRSxLQUFNO0tBQUksSUFDWixDQUFFLEtBQU0sR0FBSSxJQUNaLENBQUUsTUFBTyxHQUFJLElBQ2IsQ0FBRSxNQUFPLEtBQU0sTUFDZixDQUFFLE1BQU8sS0FBTSxNQUNmLENBQUUsS0FBTTtLQUFNLE1BQ2QsQ0FBRSxLQUFNLElBQUssTUFDYixDQUFFLE1BQU8sSUFBSyxNQUNkLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxNQUFPLElBQUssS0FDZCxDQUFFLEtBQU07S0FBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxHQUFJLEtBQ1osQ0FBRSxLQUFNLEdBQUk7S0FDWixDQUFFLEtBQU0sR0FBSSxJQUNaLENBQUUsTUFBTyxHQUFJLElBQ2IsQ0FBRSxNQUFPLEdBQUksSUFDYixDQUFFLE1BQU8sR0FBSSxJQUNiLENBQUUsS0FBTSxJQUFLLE1BQ2IsQ0FBRTtLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTTtLQUFLLEtBQ2IsQ0FBRSxLQUFNLEdBQUksS0FDWixDQUFFLEtBQU0sR0FBSSxJQUNaLENBQUUsS0FBTSxHQUFJLElBQ1osQ0FBRSxNQUFPLEdBQUksSUFDYixDQUFFLE1BQU8sR0FBSSxJQUNiLENBQUU7S0FBTyxHQUFJLElBSWIsQ0FBRSxjQUFlLElBQUssSUFBSyxNQUMzQixDQUFFLFNBQVUsSUFBSyxHQUFJLE1BQ3JCLENBQUUsUUFBUyxJQUFLLEdBQUk7S0FDcEIsQ0FBRSxlQUFnQixFQUFHLEVBQUcsTUFDeEIsQ0FBRSxTQUFVLEdBQUksR0FBSSxNQUNwQixDQUFFLFVBQVcsR0FBSSxHQUFJLE1BQ3JCLENBQUU7S0FBVSxJQUFLLEtBQU0sTUFDdkIsQ0FBRSxTQUFVLEtBQU0sS0FBTSxNQUN4QixDQUFFLFNBQVUsS0FBTSxLQUFNLE1BQ3hCLENBQUU7S0FBVSxLQUFNLEtBQU0sTUFDeEIsQ0FBRSxTQUFVLEtBQU0sS0FBTSxNQUN4QixDQUFFLFNBQVUsRUFBRyxHQUFJLE1BQ25CLENBQUUsU0FBVSxHQUFJO0tBQUksTUFDcEIsQ0FBRSxTQUFVLEdBQUksR0FBSSxNQUNwQixDQUFFLFNBQVUsR0FBSSxHQUFJLE1BQ3BCLENBQUUsU0FBVSxHQUFJLEdBQUksTUFDcEIsQ0FBRTtLQUFXLEdBQUksR0FBSSxNQUNyQixDQUFFLFVBQVcsR0FBSSxHQUFJLE1BQ3JCLENBQUUsVUFBVyxHQUFJLEdBQUk7QUFHdkIsa0JBQWUsSUFBQSxDQUFLLE1BQUwsV0FBYSxJQUFNLEVBQUEsUUFBUDtLQUN6QixJQUFNLE9BQU87U0FDWCxPQUFPLE1BQUEsQ0FBTyxFQUFQLElBQWEsWUFEVDtTQUVYLFlBQVksQ0FBRSxNQUFBLENBQU8sR0FBSSxNQUFBLENBQU87O0tBRWxDLElBQUEsQ0FBSyxNQUFBLENBQU8sR0FBWixHQUFrQjtLQUNsQixJQUFBLENBQUssTUFBQSxDQUFPLEVBQVAsQ0FBVSxPQUFWLENBQWtCLE1BQU0sS0FBN0IsR0FBcUM7S0FDckMsT0FBTztJQUNOOztDQ2hHSCxhQUFjLEdBQUcsWUFBWTtLQUN6QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtTQUN2QyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLEVBQUUsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDdkQ7RUFDSixDQUFDOztDQ0hGLElBQUksS0FBSyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDOztDQUU5RCxJQUFJLFdBQVcsR0FBRzs7R0FFaEIsQ0FBQyxFQUFFO0tBQ0QsTUFBTSxFQUFFLFFBQVE7S0FDaEIsTUFBTSxFQUFFLENBQUM7SUFDVjtHQUNELEVBQUUsRUFBRTtLQUNGLE1BQU0sRUFBRSxRQUFRO0tBQ2hCLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRztJQUNoQjtHQUNELEVBQUUsRUFBRTtLQUNGLE1BQU0sRUFBRSxRQUFRO0tBQ2hCLE1BQU0sRUFBRSxDQUFDLEdBQUcsSUFBSTtJQUNqQjs7R0FFRCxFQUFFLEVBQUU7S0FDRixNQUFNLEVBQUUsVUFBVTtLQUNsQixNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7SUFDZjtHQUNELEVBQUUsRUFBRTtLQUNGLE1BQU0sRUFBRSxVQUFVO0tBQ2xCLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQztJQUNkO0dBQ0QsRUFBRSxFQUFFO0tBQ0YsTUFBTSxFQUFFLFVBQVU7S0FDbEIsTUFBTSxFQUFFLENBQUM7SUFDVjtHQUNELEVBQUUsRUFBRTtLQUNGLE1BQU0sRUFBRSxVQUFVO0tBQ2xCLE1BQU0sRUFBRSxFQUFFO0lBQ1g7RUFDRixDQUFDOztDQUVGLE1BQU0sT0FBTyxHQUFHO0dBQ2QsTUFBTSxFQUFFO0tBQ04sSUFBSSxFQUFFLEdBQUc7S0FDVCxLQUFLLEVBQUUsQ0FBQyxHQUFHLE1BQU07SUFDbEI7R0FDRCxRQUFRLEVBQUU7S0FDUixJQUFJLEVBQUUsSUFBSTtLQUNWLEtBQUssRUFBRSxNQUFNO0lBQ2Q7RUFDRixDQUFDOztDQUVGLFNBQVMsS0FBSyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUU7R0FDL0IsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLFFBQVEsQ0FBQyxHQUFHLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQztFQUNyRTs7Q0FFRCxTQUFTLGVBQWUsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7R0FDdkQsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0dBQ3BHLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDOztHQUU1RSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztHQUNsQixJQUFJLGFBQWEsR0FBRyxTQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUMsQ0FBQztHQUNwRCxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO0dBQy9CLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLEtBQUssS0FBSyxDQUFDOztHQUUzQyxRQUFRLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0dBQ2xDLE1BQU0sR0FBRyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7O0dBRTlCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixHQUFHLFFBQVEsR0FBRyxxQkFBcUIsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7R0FDakksSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLEdBQUcsTUFBTSxHQUFHLHFCQUFxQixHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs7R0FFN0gsSUFBSSxRQUFRLEtBQUssTUFBTSxFQUFFOztLQUV2QixPQUFPLEtBQUssQ0FBQztJQUNkOztHQUVELElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztHQUNqQixJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7R0FDbkIsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDOztHQUV0QixJQUFJLFFBQVEsS0FBSyxJQUFJLEVBQUU7S0FDckIsVUFBVSxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUM7S0FDL0IsUUFBUSxHQUFHLElBQUksQ0FBQztJQUNqQjtHQUNELElBQUksTUFBTSxLQUFLLElBQUksRUFBRTtLQUNuQixTQUFTLEdBQUcsSUFBSSxDQUFDO0tBQ2pCLFFBQVEsR0FBRyxhQUFhLENBQUM7S0FDekIsTUFBTSxHQUFHLElBQUksQ0FBQztJQUNmOztHQUVELElBQUksWUFBWSxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztHQUN6QyxJQUFJLFVBQVUsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7OztHQUdyQyxJQUFJLE1BQU0sR0FBRyxLQUFLLEdBQUcsWUFBWSxDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUM7OztHQUd0RCxJQUFJLFlBQVksQ0FBQyxNQUFNLEtBQUssVUFBVSxDQUFDLE1BQU0sRUFBRTs7S0FFN0MsTUFBTSxJQUFJLE9BQU8sQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQzlDOztHQUVELElBQUksTUFBTSxHQUFHLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztHQUNuRCxJQUFJLFNBQVMsSUFBSSxVQUFVLEVBQUU7S0FDM0IsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDN0IsTUFBTSxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsSUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUU7S0FDL0QsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDbkM7R0FDRCxPQUFPLE1BQU0sQ0FBQztFQUNmOztDQUVELGlCQUFjLEdBQUcsZUFBZSxDQUFDO0NBQ2pDLFdBQW9CLEdBQUcsS0FBSyxDQUFDOzs7Q0N4R3RCLFNBQVMsd0JBQXlCLFVBQVksRUFBQSxPQUFnQixFQUFBLGVBQW9CO3NDQUFwQyxHQUFVO2tEQUFNLEdBQWdCOztLQUNuRixJQUFJLE9BQU8sVUFBUCxLQUFzQixVQUFVO1NBQ2xDLElBQU0sTUFBTSxVQUFBLENBQVcsV0FBWDtTQUNaLElBQUksRUFBRSxHQUFBLElBQU8sYUFBYTthQUN4QixNQUFNLElBQUksS0FBSiw4QkFBbUM7O1NBRTNDLElBQU0sU0FBUyxVQUFBLENBQVc7U0FDMUIsT0FBTyxNQUFBLENBQU8sVUFBUCxDQUFrQixHQUFsQixXQUFzQixZQUNwQixpQkFBQSxDQUFnQixHQUFHLE1BQUEsQ0FBTyxPQUFPLFNBQVM7WUFFOUM7U0FDTCxPQUFPOzs7O0FBSVgsQ0FBTyxTQUFTLGtCQUFpQixTQUFXLEVBQUEsU0FBa0IsRUFBQSxPQUFnQixFQUFBLGVBQW9COzBDQUF0RCxHQUFZO3NDQUFNLEdBQVU7a0RBQU0sR0FBZ0I7O0tBQzVGLE9BQU8sYUFBQSxDQUFjLFdBQVcsV0FBVyxTQUFTO3dCQUNsRCxhQURrRDtTQUVsRCxXQUFXLENBRnVDO1NBR2xELFlBQVk7Ozs7Q0NuQmhCLFNBQVMscUJBQXNCLFVBQVU7S0FDdkMsSUFBSSxDQUFDLFFBQUEsQ0FBUztXQUFZLE9BQU87S0FDakMsSUFBSSxPQUFPLFFBQUEsQ0FBUyxVQUFoQixLQUErQjtXQUFVLE9BQU87S0FDcEQsSUFBSSxLQUFBLENBQU0sT0FBTixDQUFjLFFBQUEsQ0FBUyxXQUF2QixJQUFzQyxRQUFBLENBQVMsVUFBVCxDQUFvQixNQUFwQixJQUE4QjtXQUFHLE9BQU87S0FDbEYsT0FBTzs7O0NBR1QsU0FBUyxjQUFlLEtBQU8sRUFBQSxVQUFVO0tBRXZDLElBQUksQ0FBQyxTQUFBLElBQWE7U0FDaEIsT0FBTyxDQUFFLElBQUs7O0tBR2hCLElBQUksVUFBVSxRQUFBLENBQVMsTUFBVCxJQUFtQjtLQUVqQyxJQUFJLE9BQUEsS0FBWSxNQUFaLElBQ0EsT0FBQSxLQUFZLFFBRFosSUFFQSxPQUFBLEtBQVksUUFBQSxDQUFTLE1BQU07U0FDN0IsT0FBTyxDQUFFLE1BQUEsQ0FBTyxXQUFZLE1BQUEsQ0FBTztZQUM5QjtTQUNMLFVBQTBCLE9BQUEsQ0FBUSxxQkFBUjtTQUFsQjtTQUFPO1NBQ2YsT0FBTyxDQUFFLE1BQU87Ozs7QUFJcEIsQ0FBZSxTQUFTLGFBQWMsS0FBTyxFQUFBLFVBQVU7S0FDckQsSUFBSSxPQUFPO0tBQ1gsSUFBSSxZQUFZO0tBQ2hCLElBQUksYUFBYTtLQUVqQixJQUFNLFVBQVUsU0FBQTtLQUNoQixJQUFNLGFBQWEsUUFBQSxDQUFTO0tBQzVCLElBQU0sZ0JBQWdCLG9CQUFBLENBQXFCO0tBQzNDLElBQU0sWUFBWSxLQUFBLENBQU07S0FDeEIsSUFBSSxhQUFhLGFBQUEsR0FBZ0IsUUFBQSxDQUFTLFVBQVQsS0FBd0IsUUFBUTtLQUNqRSxJQUFJLGNBQWUsQ0FBQyxTQUFELElBQWMsYUFBZixHQUFnQyxRQUFBLENBQVMsY0FBYztLQUV6RSxJQUFJLENBQUM7V0FBUyxVQUFBLElBQWEsV0FBQSxHQUFjO0tBQ3pDLElBQU0sUUFBUSxRQUFBLENBQVM7S0FDdkIsSUFBTSxnQkFBaUIsT0FBTyxRQUFBLENBQVMsYUFBaEIsS0FBa0MsUUFBbEMsSUFBOEMsUUFBQSxDQUFTLFFBQUEsQ0FBUyxjQUFqRSxHQUFtRixRQUFBLENBQVMsZ0JBQWdCO0tBQ2xJLElBQU0sUUFBUSxPQUFBLENBQVEsUUFBQSxDQUFTLE9BQU87S0FFdEMsSUFBTSxtQkFBbUIsT0FBQSxHQUFVLE1BQUEsQ0FBTyxtQkFBbUI7S0FDN0QsSUFBTSxpQkFBaUIsV0FBQSxHQUFjLG1CQUFtQjtLQUV4RCxJQUFJLFlBQVk7S0FNaEIsSUFBSSxPQUFPLFFBQUEsQ0FBUyxVQUFoQixLQUErQixRQUEvQixJQUEyQyxRQUFBLENBQVMsUUFBQSxDQUFTLGFBQWE7U0FFNUUsVUFBQSxHQUFhLFFBQUEsQ0FBUztTQUN0QixnQkFBQSxHQUFtQixPQUFBLENBQVEsUUFBQSxDQUFTLGtCQUFrQjtZQUNqRDtTQUNMLElBQUksZUFBZTthQUVqQixVQUFBLEdBQWE7YUFHYixnQkFBQSxHQUFtQixPQUFBLENBQVEsUUFBQSxDQUFTLGtCQUFrQjtnQkFDakQ7YUFFTCxVQUFBLEdBQWE7YUFFYixnQkFBQSxHQUFtQixPQUFBLENBQVEsUUFBQSxDQUFTLGtCQUFrQjs7O0tBSzFELElBQUksT0FBTyxRQUFBLENBQVMsYUFBaEIsS0FBa0MsUUFBbEMsSUFBOEMsUUFBQSxDQUFTLFFBQUEsQ0FBUyxnQkFBZ0I7U0FDbEYsVUFBQSxHQUFhLElBQUEsQ0FBSyxHQUFMLENBQVMsUUFBQSxDQUFTLGVBQWU7O0tBSWhELElBQUksV0FBVztTQUNiLFVBQUEsR0FBYTs7S0FNZixVQUFvQyxhQUFBLENBQWMsT0FBTztLQUFuRDtLQUFhO0tBQ25CLElBQUksV0FBVztLQUdmLElBQUksZUFBZTtTQUNqQixJQUFNLFNBQVMsdUJBQUEsQ0FBd0IsWUFBWSxPQUFPO1NBQzFELElBQU0sVUFBVSxJQUFBLENBQUssR0FBTCxDQUFTLE1BQUEsQ0FBTyxJQUFJLE1BQUEsQ0FBTztTQUMzQyxJQUFNLFNBQVMsSUFBQSxDQUFLLEdBQUwsQ0FBUyxNQUFBLENBQU8sSUFBSSxNQUFBLENBQU87U0FDMUMsSUFBSSxRQUFBLENBQVMsYUFBYTthQUN4QixJQUFNLFlBQVksUUFBQSxDQUFTLFdBQVQsS0FBeUI7YUFDM0MsS0FBQSxHQUFRLFNBQUEsR0FBWSxVQUFVO2FBQzlCLE1BQUEsR0FBUyxTQUFBLEdBQVksU0FBUztnQkFDekI7YUFDTCxLQUFBLEdBQVEsTUFBQSxDQUFPO2FBQ2YsTUFBQSxHQUFTLE1BQUEsQ0FBTzs7U0FHbEIsU0FBQSxHQUFZO1NBQ1osVUFBQSxHQUFhO1NBR2IsS0FBQSxJQUFTLEtBQUEsR0FBUTtTQUNqQixNQUFBLElBQVUsS0FBQSxHQUFRO1lBQ2I7U0FDTCxLQUFBLEdBQVE7U0FDUixNQUFBLEdBQVM7U0FDVCxTQUFBLEdBQVk7U0FDWixVQUFBLEdBQWE7O0tBSWYsSUFBSSxZQUFZO0tBQ2hCLElBQUksYUFBYTtLQUNqQixJQUFJLGFBQUEsSUFBaUIsT0FBTztTQUUxQixTQUFBLEdBQVksaUJBQUEsQ0FBZ0IsT0FBTyxPQUFPLE1BQU07U0FDaEQsVUFBQSxHQUFhLGlCQUFBLENBQWdCLFFBQVEsT0FBTyxNQUFNOztLQUlwRCxVQUFBLEdBQWEsSUFBQSxDQUFLLEtBQUwsQ0FBVztLQUN4QixXQUFBLEdBQWMsSUFBQSxDQUFLLEtBQUwsQ0FBVztLQUd6QixJQUFJLFVBQUEsSUFBYyxDQUFDLFNBQWYsSUFBNEIsZUFBZTtTQUM3QyxJQUFNLFNBQVMsS0FBQSxHQUFRO1NBQ3ZCLElBQU0sZUFBZSxXQUFBLEdBQWM7U0FDbkMsSUFBTSxvQkFBb0IsT0FBQSxDQUFRLFFBQUEsQ0FBUyxtQkFBbUI7U0FDOUQsSUFBTSxXQUFXLElBQUEsQ0FBSyxLQUFMLENBQVcsV0FBQSxHQUFjLGlCQUFBLEdBQW9CO1NBQzlELElBQU0sWUFBWSxJQUFBLENBQUssS0FBTCxDQUFXLFlBQUEsR0FBZSxpQkFBQSxHQUFvQjtTQUNoRSxJQUFJLFVBQUEsR0FBYSxRQUFiLElBQXlCLFdBQUEsR0FBYyxXQUFXO2FBQ3BELElBQUksWUFBQSxHQUFlLFFBQVE7aUJBQ3pCLFdBQUEsR0FBYztpQkFDZCxVQUFBLEdBQWEsSUFBQSxDQUFLLEtBQUwsQ0FBVyxXQUFBLEdBQWM7b0JBQ2pDO2lCQUNMLFVBQUEsR0FBYTtpQkFDYixXQUFBLEdBQWMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxVQUFBLEdBQWE7Ozs7S0FLNUMsV0FBQSxHQUFjLFdBQUEsR0FBYyxJQUFBLENBQUssS0FBTCxDQUFXLFVBQUEsR0FBYSxjQUFjLElBQUEsQ0FBSyxLQUFMLENBQVcsVUFBQSxHQUFhO0tBQzFGLFlBQUEsR0FBZSxXQUFBLEdBQWMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxVQUFBLEdBQWEsZUFBZSxJQUFBLENBQUssS0FBTCxDQUFXLFVBQUEsR0FBYTtLQUU1RixJQUFNLGdCQUFnQixXQUFBLEdBQWMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxjQUFjLElBQUEsQ0FBSyxLQUFMLENBQVc7S0FDeEUsSUFBTSxpQkFBaUIsV0FBQSxHQUFjLElBQUEsQ0FBSyxLQUFMLENBQVcsZUFBZSxJQUFBLENBQUssS0FBTCxDQUFXO0tBRTFFLElBQU0sU0FBUyxXQUFBLEdBQWM7S0FDN0IsSUFBTSxTQUFTLFlBQUEsR0FBZTtLQUc5QixPQUFPO2dCQUNMLEtBREs7cUJBRUwsVUFGSztnQkFHTCxLQUhLO2lCQUlMLE1BSks7U0FLTCxZQUFZLENBQUUsTUFBTyxPQUxoQjtTQU1MLE9BQU8sS0FBQSxJQUFTLElBTlg7aUJBT0wsTUFQSztpQkFRTCxNQVJLO3dCQVNMLGFBVEs7d0JBVUwsYUFWSzt5QkFXTCxjQVhLO3NCQVlMLFdBWks7dUJBYUwsWUFiSztvQkFjTCxTQWRLO3FCQWVMLFVBZks7cUJBZ0JMLFVBaEJLO3NCQWlCTDs7OztDQzlLSixzQkFBYyxHQUFHLGlCQUFnQjtDQUNqQyxTQUFTLGdCQUFnQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7R0FDckMsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7S0FDNUIsTUFBTSxJQUFJLFNBQVMsQ0FBQywwQkFBMEIsQ0FBQztJQUNoRDs7R0FFRCxJQUFJLEdBQUcsSUFBSSxJQUFJLEdBQUU7O0dBRWpCLElBQUksT0FBTyxRQUFRLEtBQUssV0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtLQUNuRCxPQUFPLElBQUk7SUFDWjs7R0FFRCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFDO0dBQzVELElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtLQUNsQyxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFLO0lBQzFCO0dBQ0QsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssUUFBUSxFQUFFO0tBQ25DLE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU07SUFDNUI7O0dBRUQsSUFBSSxPQUFPLEdBQUcsS0FBSTtHQUNsQixJQUFJLEdBQUU7R0FDTixJQUFJO0tBQ0YsSUFBSSxLQUFLLEdBQUcsRUFBRSxJQUFJLEdBQUU7O0tBRXBCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7T0FDL0IsS0FBSyxDQUFDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxFQUFDO01BQ25DOztLQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO09BQ3JDLEVBQUUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUM7T0FDekMsSUFBSSxFQUFFLEVBQUUsT0FBTyxFQUFFO01BQ2xCO0lBQ0YsQ0FBQyxPQUFPLENBQUMsRUFBRTtLQUNWLEVBQUUsR0FBRyxLQUFJO0lBQ1Y7R0FDRCxRQUFRLEVBQUUsSUFBSSxJQUFJLENBQUM7RUFDcEI7O0NDakNELFNBQVMsc0JBQXVCO0tBQzlCLElBQUksQ0FBQyxTQUFBLElBQWE7U0FDaEIsTUFBTSxJQUFJLEtBQUosQ0FBVTs7S0FFbEIsT0FBTyxRQUFBLENBQVMsYUFBVCxDQUF1Qjs7O0FBR2hDLENBQWUsU0FBUyxhQUFjLFVBQWU7d0NBQWYsR0FBVzs7S0FDL0MsSUFBSSxTQUFTO0tBQ2IsSUFBSSxhQUFhO0tBQ2pCLElBQUksUUFBQSxDQUFTLE1BQVQsS0FBb0IsT0FBTztTQUU3QixPQUFBLEdBQVUsUUFBQSxDQUFTO1NBQ25CLElBQUksQ0FBQyxPQUFELElBQVksT0FBTyxPQUFQLEtBQW1CLFVBQVU7YUFDM0MsSUFBSSxZQUFZLFFBQUEsQ0FBUzthQUN6QixJQUFJLENBQUMsV0FBVztpQkFDZCxTQUFBLEdBQVksbUJBQUE7aUJBQ1osVUFBQSxHQUFhOzthQUVmLElBQU0sT0FBTyxPQUFBLElBQVc7YUFDeEIsSUFBSSxPQUFPLFNBQUEsQ0FBVSxVQUFqQixLQUFnQyxZQUFZO2lCQUM5QyxNQUFNLElBQUksS0FBSixDQUFVOzthQUVsQixPQUFBLEdBQVUsa0JBQUEsQ0FBaUIsTUFBTSxZQUFBLENBQU8sSUFBSSxRQUFBLENBQVMsWUFBWTtpQkFBRSxRQUFROzthQUMzRSxJQUFJLENBQUMsU0FBUztpQkFDWixNQUFNLElBQUksS0FBSixvQ0FBMEM7OztTQUlwRCxNQUFBLEdBQVMsT0FBQSxDQUFRO1NBRWpCLElBQUksUUFBQSxDQUFTLE1BQVQsSUFBbUIsTUFBQSxLQUFXLFFBQUEsQ0FBUyxRQUFRO2FBQ2pELE1BQU0sSUFBSSxLQUFKLENBQVU7O1NBSWxCLElBQUksUUFBQSxDQUFTLFdBQVc7YUFDdEIsT0FBQSxDQUFRLHFCQUFSLEdBQWdDO2FBQ2hDLE9BQUEsQ0FBUSx3QkFBUixHQUFtQzthQUNuQyxPQUFBLENBQVEsc0JBQVIsR0FBaUM7YUFDakMsT0FBQSxDQUFRLDJCQUFSLEdBQXNDO2FBQ3RDLE9BQUEsQ0FBUSx1QkFBUixHQUFrQzthQUNsQyxNQUFBLENBQU8sS0FBUCxDQUFhLGtCQUFiLEdBQWtDOzs7S0FHdEMsT0FBTztpQkFBRSxNQUFGO2tCQUFVLE9BQVY7cUJBQW1COzs7O0NDN0I1QixJQUFNLGdCQUNKLHlCQUFlOzs7U0FDYixDQUFLLFNBQUwsR0FBaUI7U0FDakIsQ0FBSyxNQUFMLEdBQWM7U0FDZCxDQUFLLE9BQUwsR0FBZTtTQUNmLENBQUssSUFBTCxHQUFZO1NBQ1osQ0FBSyxjQUFMLEdBQXNCO1NBR3RCLENBQUssaUJBQUwsR0FBeUI7U0FDekIsQ0FBSyxhQUFMLEdBQXFCO1NBRXJCLENBQUssa0JBQUwsR0FBMEIsaUJBQUEsQ0FBa0I7OEJBQ2pDLFNBQU0sTUFBQSxDQUFLLFFBQUwsQ0FBYyxPQUFkLEtBQTBCLFFBREM7eUJBRW5DO2lCQUNELEVBQUEsQ0FBRyxVQUFVO3FCQUNYLE1BQUEsQ0FBSyxLQUFMLENBQVcsV0FBVzsyQkFDeEIsQ0FBSyxTQUFMOzJCQUNBLENBQUssR0FBTDs7dUJBQ0ssTUFBQSxDQUFLLE1BQUw7b0JBQ0YsSUFBSSxDQUFDLE1BQUEsQ0FBSyxLQUFMLENBQVcsV0FBVzt1QkFDaEMsQ0FBSyxXQUFMOztVQVRzQztpQ0FZOUI7aUJBQ04sTUFBQSxDQUFLLEtBQUwsQ0FBVzttQkFBUyxNQUFBLENBQUssS0FBTDs7bUJBQ25CLE1BQUEsQ0FBSyxJQUFMO1VBZG1DOzJCQWdCakM7bUJBQ1AsQ0FBSyxXQUFMLENBQWlCO3lCQUFVOzs7O1NBSS9CLENBQUssZUFBTCxnQkFBdUIsU0FBTSxNQUFBLENBQUssT0FBTDtTQUU3QixDQUFLLGNBQUwsZ0JBQXNCO2FBQ2QsVUFBVSxNQUFBLENBQUssTUFBTDthQUVaLFNBQVM7bUJBQ1gsQ0FBSyxNQUFMOzs7Ozs7b0JBS0YseUJBQVU7WUFDTCxJQUFBLENBQUs7O29CQUdWLDJCQUFZO1lBQ1AsSUFBQSxDQUFLOztvQkFHVix3QkFBUztZQUNKLElBQUEsQ0FBSzs7eUJBR2QsOENBQWtCLFdBQWEsRUFBQSxVQUFVO1NBQ2pDLGNBQWMsT0FBTyxRQUFQLEtBQW9CLFFBQXBCLElBQWdDLFFBQUEsQ0FBUztZQUN0RCxXQUFBLEdBQWMsV0FBQSxHQUFjLFdBQVc7O3lCQUdoRCx3Q0FBZSxRQUFVLEVBQUEsSUFBTSxFQUFBLFdBQWEsRUFBQSxLQUFLO1lBQ3ZDLFFBQUEsQ0FBUyxZQUFULElBQXlCLFdBQUEsR0FBYyxDQUF4QyxHQUNILElBQUEsQ0FBSyxLQUFMLENBQVcsUUFBQSxJQUFZLFdBQUEsR0FBYyxNQUNyQyxJQUFBLENBQUssS0FBTCxDQUFXLEdBQUEsR0FBTTs7eUJBR3ZCLHdEQUF3QjtZQUNmLElBQUEsQ0FBSyxhQUFMLENBQ0wsSUFBQSxDQUFLLEtBQUwsQ0FBVyxVQUFVLElBQUEsQ0FBSyxLQUFMLENBQVcsTUFDaEMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxhQUFhLElBQUEsQ0FBSyxLQUFMLENBQVc7O3lCQUl2QywwQ0FBaUI7U0FDVCxRQUFRLElBQUEsQ0FBSztZQUNaO2dCQUNFLEtBQUEsQ0FBTSxLQURSO2lCQUVHLEtBQUEsQ0FBTSxNQUZUO3FCQUdPLEtBQUEsQ0FBTSxVQUhiO3NCQUlRLEtBQUEsQ0FBTSxXQUpkO3VCQUtTLEtBQUEsQ0FBTSxZQUxmO3dCQU1VLEtBQUEsQ0FBTSxhQU5oQjt5QkFPVyxLQUFBLENBQU07Ozt5QkFJMUIsc0JBQU87U0FDRCxDQUFDLElBQUEsQ0FBSztXQUFRLE1BQU0sSUFBSSxLQUFKLENBQVU7U0FHOUIsSUFBQSxDQUFLLFFBQUwsQ0FBYyxPQUFkLEtBQTBCLE9BQU87YUFDbkMsQ0FBSyxJQUFMOztTQUlFLE9BQU8sSUFBQSxDQUFLLE1BQUwsQ0FBWSxPQUFuQixLQUErQixZQUFZO2dCQUM3QyxDQUFRLElBQVIsQ0FBYTs7U0FJWCxDQUFDLElBQUEsQ0FBSyxLQUFMLENBQVcsU0FBUzthQUN2QixDQUFLLFlBQUw7YUFDQSxDQUFLLEtBQUwsQ0FBVyxPQUFYLEdBQXFCOztTQUl2QixDQUFLLElBQUw7U0FDQSxDQUFLLE1BQUw7WUFDTzs7eUJBR1QsOENBQW1CO1NBQ2IsSUFBQSxDQUFLLElBQUwsSUFBYSxJQUFiLElBQXFCLE9BQU8sTUFBUCxLQUFrQixXQUF2QyxJQUFzRCxPQUFPLE1BQUEsQ0FBTyxvQkFBZCxLQUF1QyxZQUFZO2VBQzNHLENBQU8sb0JBQVAsQ0FBNEIsSUFBQSxDQUFLO2FBQ2pDLENBQUssSUFBTCxHQUFZOztTQUVWLElBQUEsQ0FBSyxjQUFMLElBQXVCLE1BQU07cUJBQy9CLENBQWEsSUFBQSxDQUFLO2FBQ2xCLENBQUssY0FBTCxHQUFzQjs7O3lCQUkxQix3QkFBUTtTQUNGLFVBQVUsSUFBQSxDQUFLLFFBQUwsQ0FBYztTQUN4QixXQUFBLElBQWUsSUFBQSxDQUFLLFVBQVU7Z0JBQ2hDLEdBQVU7Z0JBQ1YsQ0FBUSxJQUFSLENBQWE7O1NBRVgsQ0FBQztXQUFTO1NBQ1YsQ0FBQyxTQUFBLElBQWE7Z0JBQ2hCLENBQVEsS0FBUixDQUFjOzs7U0FHWixJQUFBLENBQUssS0FBTCxDQUFXO1dBQVM7U0FDcEIsQ0FBQyxJQUFBLENBQUssS0FBTCxDQUFXLFNBQVM7YUFDdkIsQ0FBSyxZQUFMO2FBQ0EsQ0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQjs7U0FNdkIsQ0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQjtTQUNyQixDQUFLLGVBQUw7U0FDQSxDQUFLLFNBQUwsR0FBaUIsT0FBQTtTQUNqQixDQUFLLElBQUwsR0FBWSxNQUFBLENBQU8scUJBQVAsQ0FBNkIsSUFBQSxDQUFLOzt5QkFHaEQsMEJBQVM7U0FDSCxJQUFBLENBQUssS0FBTCxDQUFXO1dBQVcsSUFBQSxDQUFLLFNBQUw7U0FDMUIsQ0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQjtTQUVyQixDQUFLLGVBQUw7O3lCQUdGLG9DQUFjO1NBQ1IsSUFBQSxDQUFLLEtBQUwsQ0FBVztXQUFTLElBQUEsQ0FBSyxLQUFMOztXQUNuQixJQUFBLENBQUssSUFBTDs7eUJBSVAsd0JBQVE7U0FDTixDQUFLLEtBQUw7U0FDQSxDQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW1CO1NBQ25CLENBQUssS0FBTCxDQUFXLFFBQVgsR0FBc0I7U0FDdEIsQ0FBSyxLQUFMLENBQVcsSUFBWCxHQUFrQjtTQUNsQixDQUFLLEtBQUwsQ0FBVyxTQUFYLEdBQXVCO1NBQ3ZCLENBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUI7U0FDckIsQ0FBSyxNQUFMOzt5QkFHRiw0QkFBVTs7O1NBQ0osSUFBQSxDQUFLLEtBQUwsQ0FBVztXQUFXO1NBQ3RCLENBQUMsU0FBQSxJQUFhO2dCQUNoQixDQUFRLEtBQVIsQ0FBYzs7O1NBSWhCLENBQUssSUFBTDtTQUNBLENBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUI7U0FDckIsQ0FBSyxLQUFMLENBQVcsU0FBWCxHQUF1QjtTQUVqQixhQUFhLElBQUEsQ0FBSyxvQkFBTCxDQUEwQjttQkFBWTs7U0FFbkQsZ0JBQWdCLENBQUEsR0FBSSxJQUFBLENBQUssS0FBTCxDQUFXO1NBRXJDLENBQUssZUFBTDtTQUNNLG1CQUFPO2FBQ1AsQ0FBQyxNQUFBLENBQUssS0FBTCxDQUFXO2VBQVcsT0FBTyxPQUFBLENBQVEsT0FBUjtlQUNsQyxDQUFLLEtBQUwsQ0FBVyxTQUFYLEdBQXVCO2VBQ3ZCLENBQUssSUFBTDtnQkFDTyxNQUFBLENBQUssV0FBTCxDQUFpQixXQUFqQixDQUNKLElBREksYUFDQztpQkFDQSxDQUFDLE1BQUEsQ0FBSyxLQUFMLENBQVc7bUJBQVc7bUJBQzNCLENBQUssS0FBTCxDQUFXLFNBQVgsR0FBdUI7bUJBQ3ZCLENBQUssS0FBTCxDQUFXLEtBQVg7aUJBQ0ksTUFBQSxDQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW1CLE1BQUEsQ0FBSyxLQUFMLENBQVcsYUFBYTt1QkFDN0MsQ0FBSyxLQUFMLENBQVcsSUFBWCxJQUFtQjt1QkFDbkIsQ0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixNQUFBLENBQUssZ0JBQUwsQ0FBc0IsTUFBQSxDQUFLLEtBQUwsQ0FBVyxNQUFNLE1BQUEsQ0FBSyxLQUFMLENBQVc7dUJBQ3hFLENBQUssY0FBTCxHQUFzQixVQUFBLENBQVcsTUFBTTtvQkFDbEM7d0JBQ0wsQ0FBUSxHQUFSLENBQVk7dUJBQ1osQ0FBSyxVQUFMO3VCQUNBLENBQUssU0FBTDt1QkFDQSxDQUFLLElBQUw7dUJBQ0EsQ0FBSyxHQUFMOzs7O1NBTUosQ0FBQyxJQUFBLENBQUssS0FBTCxDQUFXLFNBQVM7YUFDdkIsQ0FBSyxZQUFMO2FBQ0EsQ0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQjs7U0FJbkIsSUFBQSxDQUFLLE1BQUwsSUFBZSxPQUFPLElBQUEsQ0FBSyxNQUFMLENBQVksV0FBbkIsS0FBbUMsWUFBWTthQUNoRSxDQUFLLGlCQUFMLFdBQXVCLGdCQUFTLE1BQUEsQ0FBSyxNQUFMLENBQVksV0FBWixDQUF3Qjs7Z0JBSTFELENBQVksV0FBWixDQUNHLEtBREgsV0FDUztnQkFDTCxDQUFRLEtBQVIsQ0FBYztPQUZsQixDQUlHLElBSkgsV0FJUTtlQUNKLENBQUssSUFBTCxHQUFZLE1BQUEsQ0FBTyxxQkFBUCxDQUE2Qjs7O3lCQUkvQyx3Q0FBZ0I7OztTQUNWLElBQUEsQ0FBSyxNQUFMLElBQWUsT0FBTyxJQUFBLENBQUssTUFBTCxDQUFZLEtBQW5CLEtBQTZCLFlBQVk7YUFDMUQsQ0FBSyxpQkFBTCxXQUF1QixnQkFBUyxNQUFBLENBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0I7Ozt5QkFJdEQsb0NBQWM7OztTQUNSLElBQUEsQ0FBSyxNQUFMLElBQWUsT0FBTyxJQUFBLENBQUssTUFBTCxDQUFZLEdBQW5CLEtBQTJCLFlBQVk7YUFDeEQsQ0FBSyxpQkFBTCxXQUF1QixnQkFBUyxNQUFBLENBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0I7Ozt5QkFJcEQsa0NBQWE7OztTQUNMLGVBQWUsSUFBQSxDQUFLLEtBQUwsQ0FBVztTQUVoQyxDQUFLLGVBQUw7U0FDQSxDQUFLLEtBQUwsQ0FBVyxTQUFYLEdBQXVCO1NBQ3ZCLENBQUssS0FBTCxDQUFXLFNBQVgsR0FBdUI7U0FDdkIsQ0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQjtZQUdkLFNBQUEsRUFBQSxDQUNKLEtBREksV0FDRTtnQkFDTCxDQUFRLEtBQVIsQ0FBYztPQUZYLENBSUosSUFKSSxhQUlDO2FBRUEsWUFBQSxJQUFnQixNQUFBLENBQUssTUFBckIsSUFBK0IsT0FBTyxNQUFBLENBQUssTUFBTCxDQUFZLFNBQW5CLEtBQWlDLFlBQVk7bUJBQzlFLENBQUssaUJBQUwsV0FBdUIsZ0JBQVMsTUFBQSxDQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCOzs7O3lCQUs5RCxzREFBc0IsS0FBVTtrQ0FBVixHQUFNOztZQUNuQjttQkFDSyxHQUFBLENBQUksUUFEVDtlQUVDLEdBQUEsQ0FBSSxJQUZMO2NBR0EsSUFBQSxDQUFLLEtBQUwsQ0FBVyxHQUhYO2dCQUlFLEdBQUEsQ0FBSSxRQUFKLEdBQWUsSUFBQSxDQUFLLEtBQUwsQ0FBVyxRQUFRLFNBSnBDO2VBS0MsSUFBQSxDQUFLLFFBQUwsQ0FBYyxJQUxmO2VBTUMsSUFBQSxDQUFLLFFBQUwsQ0FBYyxJQU5mO2lCQU9HLElBQUEsQ0FBSyxRQUFMLENBQWMsTUFQakI7aUJBUUcsSUFBQSxDQUFLLFFBQUwsQ0FBYyxNQVJqQjttQkFTSyxJQUFBLENBQUssUUFBTCxDQUFjLFFBVG5COzBCQVVZLElBQUEsQ0FBSyxRQUFMLENBQWMsZUFWMUI7b0JBV00sR0FBQSxDQUFJLFNBQUosSUFBaUIsWUFBQSxFQVh2QjtzQkFZUSxRQUFBLENBQVMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxZQUFwQixHQUFtQyxJQUFBLENBQUssR0FBTCxDQUFTLEdBQUcsSUFBQSxDQUFLLEtBQUwsQ0FBVyxlQUFlOzs7eUJBSTFGLG9DQUFhLEtBQVU7O2tDQUFWLEdBQU07O1NBQ2IsQ0FBQyxJQUFBLENBQUs7V0FBUSxPQUFPLE9BQUEsQ0FBUSxHQUFSLENBQVk7U0FDakMsT0FBTyxJQUFBLENBQUssTUFBTCxDQUFZLFNBQW5CLEtBQWlDLFlBQVk7YUFDL0MsQ0FBSyxNQUFMLENBQVksU0FBWjs7U0FJRSxhQUFhLElBQUEsQ0FBSyxvQkFBTCxDQUEwQjtTQUVyQyxTQUFTLFlBQUE7U0FDWCxJQUFJLE9BQUEsQ0FBUSxPQUFSO1NBQ0osTUFBQSxJQUFVLEdBQUEsQ0FBSSxNQUFkLElBQXdCLE9BQU8sTUFBQSxDQUFPLE1BQWQsS0FBeUIsWUFBWTthQUN6RCxhQUFhLFlBQUEsQ0FBTyxJQUFJO2FBQ3hCLE9BQU8sTUFBQSxDQUFPLE1BQVAsQ0FBYzthQUN2QixXQUFBLENBQVU7ZUFBTyxDQUFBLEdBQUk7O2VBQ3BCLENBQUEsR0FBSSxPQUFBLENBQVEsT0FBUixDQUFnQjs7WUFHcEIsQ0FBQSxDQUFFLElBQUYsV0FBTyxlQUNMLE1BQUEsQ0FBSyxjQUFMLENBQW9CLFlBQUEsQ0FBTyxJQUFJLFlBQVk7ZUFBUSxJQUFBLElBQVE7WUFEN0QsQ0FFSixJQUZJLFdBRUM7YUFHRixNQUFBLENBQU8sTUFBUCxLQUFrQjtlQUFHLE9BQU8sTUFBQSxDQUFPOztlQUNsQyxPQUFPOzs7eUJBSWhCLDBDQUFnQixZQUFpQjs7Z0RBQWpCLEdBQWE7O1NBQzNCLENBQUssTUFBTCxDQUFZLFNBQVosR0FBd0I7U0FHeEIsQ0FBSyxNQUFMO1NBR0ksYUFBYSxJQUFBLENBQUssTUFBTDtTQUdYLFNBQVMsSUFBQSxDQUFLLEtBQUwsQ0FBVztTQUd0QixPQUFPLFVBQVAsS0FBc0IsYUFBYTttQkFDckMsR0FBYSxDQUFFOztlQUVqQixHQUFhLEVBQUEsQ0FBRyxNQUFILENBQVUsV0FBVixDQUFzQixNQUF0QixDQUE2QjtlQUkxQyxHQUFhLFVBQUEsQ0FBVyxHQUFYLFdBQWU7YUFDcEIsZ0JBQWdCLE9BQU8sTUFBUCxLQUFrQixRQUFsQixJQUE4QixNQUE5QixLQUF5QyxNQUFBLElBQVUsTUFBVixJQUFvQixTQUFBLElBQWE7YUFDMUYsT0FBTyxhQUFBLEdBQWdCLE1BQUEsQ0FBTyxPQUFPO2FBQ3JDLE9BQU8sYUFBQSxHQUFnQixZQUFBLENBQU8sSUFBSSxRQUFRO21CQUFFO2NBQVU7bUJBQUU7O2FBQzFELFFBQUEsQ0FBUyxPQUFPO2lCQUNaLFdBQVcsSUFBQSxDQUFLLFFBQUwsSUFBaUIsVUFBQSxDQUFXO2lCQUN2QyxrQkFBa0IsT0FBQSxDQUFRLElBQUEsQ0FBSyxpQkFBaUIsVUFBQSxDQUFXLGlCQUFpQjt1QkFDN0MsWUFBQSxDQUFhLE1BQU07MkJBQUUsUUFBRjtrQ0FBWTs7aUJBQTVEO2lCQUFTO2lCQUFXO29CQUNyQixNQUFBLENBQU8sTUFBUCxDQUFjLE1BQU07MEJBQUUsT0FBRjs0QkFBVyxTQUFYO3VCQUFzQjs7Z0JBQzVDO29CQUNFOzs7U0FLWCxDQUFLLE1BQUwsQ0FBWSxTQUFaLEdBQXdCO1NBQ3hCLENBQUssTUFBTDtTQUNBLENBQUssTUFBTDtZQUdPLE9BQUEsQ0FBUSxHQUFSLENBQVksVUFBQSxDQUFXLEdBQVgsV0FBZ0IsTUFBUSxFQUFBLENBQUcsRUFBQSxXQUFaO2FBRTFCLFNBQVMsWUFBQSxDQUFPO3dCQUNULEVBRFM7cUJBRVosRUFGWTtxQkFHWjtZQUNQLFlBQVksUUFBUTtvQkFDZCxDQURjOzBCQUVSLFNBQUEsQ0FBVTs7YUFLbkIsWUFBWSxVQUFBLENBQVcsSUFBWCxLQUFvQixLQUFwQixHQUE0QixRQUFRLE1BQUEsQ0FBTztlQUM3RCxDQUFPLElBQVAsR0FBYyxTQUFBLEtBQWM7ZUFHNUIsQ0FBTyxRQUFQLEdBQWtCLGVBQUEsQ0FBZ0I7Z0JBRzNCLE1BQUEsQ0FBTztnQkFDUCxNQUFBLENBQU87Y0FHVCxJQUFJLEtBQUssUUFBUTtpQkFDaEIsT0FBTyxNQUFBLENBQU8sRUFBZCxLQUFxQjttQkFBYSxPQUFPLE1BQUEsQ0FBTzs7YUFHbEQsY0FBYyxPQUFBLENBQVEsT0FBUixDQUFnQjthQUM5QixNQUFBLENBQU8sTUFBTTtpQkFFVCxPQUFPLE1BQUEsQ0FBTztpQkFDaEIsTUFBQSxDQUFPLFNBQVM7cUJBQ1osVUFBVSxNQUFBLENBQU87NEJBQ3ZCLEdBQWMsV0FBQSxDQUFZLFNBQVM7b0JBQzlCOzRCQUNMLEdBQWMsUUFBQSxDQUFTLE1BQU07OztnQkFHMUIsV0FBQSxDQUFZLElBQVosV0FBaUIscUJBQ2YsTUFBQSxDQUFPLE1BQVAsQ0FBYyxJQUFJLFFBQVE7UUF4QzlCLENBMENILElBMUNHLFdBMENFO2FBQ0QsY0FBYyxFQUFBLENBQUcsTUFBSCxXQUFVLFlBQUssQ0FBQSxDQUFFO2FBQ2pDLFdBQUEsQ0FBWSxNQUFaLEdBQXFCLEdBQUc7aUJBRXBCLGtCQUFrQixXQUFBLENBQVksSUFBWixXQUFpQixZQUFLLENBQUEsQ0FBRTtpQkFDMUMsV0FBVyxXQUFBLENBQVksSUFBWixXQUFpQixZQUFLLENBQUEsQ0FBRTtpQkFDbkMsY0FBYyxXQUFBLENBQVksSUFBWixXQUFpQixZQUFLLENBQUEsQ0FBRTtpQkFDeEM7aUJBRUEsV0FBQSxDQUFZLE1BQVosR0FBcUI7bUJBQUcsSUFBQSxHQUFPLFdBQUEsQ0FBWTttQkFFMUMsSUFBSTttQkFBaUIsSUFBQSxHQUFPLENBQUcsZUFBQSxDQUFnQixxQkFBYyxXQUFBLENBQVksRUFBWixDQUFlOzttQkFFNUUsSUFBQSxHQUFPLE1BQUcsV0FBQSxDQUFZLEVBQVosQ0FBZTtpQkFDMUIsUUFBUTtpQkFDUixVQUFBLENBQVcsVUFBVTtxQkFDakIsaUJBQWlCLFFBQUEsQ0FBUyxNQUFBLENBQUssS0FBTCxDQUFXO3NCQUMzQyxHQUFRLGNBQUEsa0JBQTRCLFVBQUEsQ0FBVyxLQUFYLEdBQW1CLGNBQU8sTUFBQSxDQUFLLEtBQUwsQ0FBVyxxQ0FBNEIsVUFBQSxDQUFXO29CQUMzRyxJQUFJLFdBQUEsQ0FBWSxNQUFaLEdBQXFCLEdBQUc7c0JBQ2pDLEdBQVE7O2lCQUVKLFNBQVMsUUFBQSxHQUFXLHNCQUFzQjtpQkFDMUMsU0FBUyxXQUFBLEdBQWMsbUJBQW1CO29CQUNoRCxDQUFRLEdBQVIsVUFBa0Isa0JBQWEsaUJBQVksY0FBUyxRQUFTLG1CQUFtQixtQkFBbUIsc0JBQXNCOzthQUV2SCxPQUFPLE1BQUEsQ0FBSyxNQUFMLENBQVksVUFBbkIsS0FBa0MsWUFBWTttQkFDaEQsQ0FBSyxNQUFMLENBQVksVUFBWjs7Z0JBRUs7Ozt5QkFJWCxnREFBbUIsSUFBSTtTQUNyQixDQUFLLFVBQUw7T0FDQSxDQUFHLElBQUEsQ0FBSztTQUNSLENBQUssV0FBTDs7eUJBR0Ysb0NBQWM7U0FDTixRQUFRLElBQUEsQ0FBSztTQUdmLENBQUMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxFQUFaLElBQWtCLEtBQUEsQ0FBTSxPQUF4QixJQUFtQyxDQUFDLEtBQUEsQ0FBTSxJQUFJO2NBQ2hELENBQU0sT0FBTixDQUFjLElBQWQ7YUFDSSxJQUFBLENBQUssUUFBTCxDQUFjLFlBQWQsS0FBK0IsT0FBTztrQkFDeEMsQ0FBTSxPQUFOLENBQWMsS0FBZCxDQUFvQixLQUFBLENBQU0sUUFBUSxLQUFBLENBQU07O1lBRXJDLElBQUksS0FBQSxDQUFNLElBQUk7Y0FDbkIsQ0FBTSxFQUFOLENBQVMsS0FBVCxDQUFlLEtBQUEsQ0FBTSxNQUFOLEdBQWUsS0FBQSxDQUFNLFlBQVksS0FBQSxDQUFNLE1BQU4sR0FBZSxLQUFBLENBQU07Ozt5QkFJekUsc0NBQWU7U0FDUCxRQUFRLElBQUEsQ0FBSztTQUVmLENBQUMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxFQUFaLElBQWtCLEtBQUEsQ0FBTSxPQUF4QixJQUFtQyxDQUFDLEtBQUEsQ0FBTSxJQUFJO2NBQ2hELENBQU0sT0FBTixDQUFjLE9BQWQ7O1NBT0UsS0FBQSxDQUFNLEVBQU4sSUFBWSxJQUFBLENBQUssUUFBTCxDQUFjLEtBQWQsS0FBd0IsS0FBcEMsSUFBNkMsQ0FBQyxLQUFBLENBQU0sSUFBSTtjQUMxRCxDQUFNLEVBQU4sQ0FBUyxLQUFUOzs7eUJBSUosd0JBQVE7U0FDRixJQUFBLENBQUssTUFBTCxJQUFlLE9BQU8sSUFBQSxDQUFLLE1BQUwsQ0FBWSxJQUFuQixLQUE0QixZQUFZO2FBQ3pELENBQUssVUFBTDthQUNBLENBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBQSxDQUFLO2FBQ3RCLENBQUssV0FBTDs7O3lCQUlKLDRCQUFVO1NBQ0osSUFBQSxDQUFLLEtBQUwsQ0FBVyxJQUFJO2FBQ2pCLENBQUssaUJBQUwsR0FBeUI7YUFDekIsQ0FBSyxLQUFMLENBQVcsRUFBWCxDQUFjLE1BQWQ7Z0JBQ08sSUFBQSxDQUFLO1lBQ1A7Z0JBQ0UsSUFBQSxDQUFLLGNBQUw7Ozt5QkFJWCw0Q0FBa0I7U0FDWixDQUFDLElBQUEsQ0FBSztXQUFRO1NBRVosUUFBUSxJQUFBLENBQUs7U0FDbkIsQ0FBSyxVQUFMO1NBRUk7U0FFQSxPQUFPLElBQUEsQ0FBSyxNQUFaLEtBQXVCLFlBQVk7bUJBQ3JDLEdBQWEsSUFBQSxDQUFLLE1BQUwsQ0FBWTtZQUNwQixJQUFJLE9BQU8sSUFBQSxDQUFLLE1BQUwsQ0FBWSxNQUFuQixLQUE4QixZQUFZO21CQUNuRCxHQUFhLElBQUEsQ0FBSyxNQUFMLENBQVksTUFBWixDQUFtQjs7U0FHbEMsQ0FBSyxXQUFMO1lBRU87O3lCQUdULDBCQUFRLEtBQVU7O2tDQUFWLEdBQU07O1NBSU4sa0JBQWtCLENBQ3RCO1dBR0YsQ0FBTyxJQUFQLENBQVksSUFBWixDQUFpQixPQUFqQixXQUF5QjthQUNuQixlQUFBLENBQWdCLE9BQWhCLENBQXdCLElBQXhCLElBQWdDLEdBQUc7bUJBQy9CLElBQUksS0FBSixvQkFBMEI7OztTQUk5QixZQUFZLElBQUEsQ0FBSyxTQUFMLENBQWU7U0FDM0IsYUFBYSxJQUFBLENBQUssU0FBTCxDQUFlO1VBRzdCLElBQUksT0FBTyxLQUFLO2FBQ2IsUUFBUSxHQUFBLENBQUk7YUFDZCxPQUFPLEtBQVAsS0FBaUIsYUFBYTttQkFDaEMsQ0FBSyxTQUFMLENBQWUsSUFBZixHQUFzQjs7O1NBS3BCLFdBQVcsTUFBQSxDQUFPLE1BQVAsQ0FBYyxJQUFJLElBQUEsQ0FBSyxXQUFXO1NBQy9DLE1BQUEsSUFBVSxHQUFWLElBQWlCLE9BQUEsSUFBVztXQUFLLE1BQU0sSUFBSSxLQUFKLENBQVU7V0FDaEQsSUFBSSxNQUFBLElBQVU7V0FBSyxPQUFPLFFBQUEsQ0FBUztXQUNuQyxJQUFJLE9BQUEsSUFBVztXQUFLLE9BQU8sUUFBQSxDQUFTO1NBQ3JDLFVBQUEsSUFBYyxHQUFkLElBQXFCLGFBQUEsSUFBaUI7V0FBSyxNQUFNLElBQUksS0FBSixDQUFVO1dBQzFELElBQUksVUFBQSxJQUFjO1dBQUssT0FBTyxRQUFBLENBQVM7V0FDdkMsSUFBSSxhQUFBLElBQWlCO1dBQUssT0FBTyxRQUFBLENBQVM7U0FHM0MsTUFBQSxJQUFVO1dBQUssSUFBQSxDQUFLLE1BQUwsQ0FBWSxJQUFaLEdBQW1CLEdBQUEsQ0FBSTtTQUVwQyxZQUFZLElBQUEsQ0FBSyxZQUFMLENBQWtCO1dBQ3BDLENBQU8sTUFBUCxDQUFjLElBQUEsQ0FBSyxRQUFRO1NBR3ZCLFNBQUEsS0FBYyxJQUFBLENBQUssU0FBTCxDQUFlLE1BQTdCLElBQXVDLFVBQUEsS0FBZSxJQUFBLENBQUssU0FBTCxDQUFlLFNBQVM7bUJBQ3BELFlBQUEsQ0FBYSxJQUFBLENBQUs7YUFBdEM7YUFBUTthQUVoQixDQUFLLEtBQUwsQ0FBVyxNQUFYLEdBQW9CO2FBQ3BCLENBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUI7YUFHckIsQ0FBSyxXQUFMO2FBR0EsQ0FBSyxxQkFBTDs7U0FJRSxHQUFBLENBQUksRUFBSixJQUFVLE9BQU8sR0FBQSxDQUFJLEVBQVgsS0FBa0IsWUFBWTthQUMxQyxDQUFLLEtBQUwsQ0FBVyxFQUFYLEdBQWdCLEdBQUEsQ0FBSTthQUNwQixDQUFLLEtBQUwsQ0FBVyxFQUFYLENBQWMsSUFBZCxnQkFBcUI7aUJBQ2YsTUFBQSxDQUFLO21CQUFlO21CQUN4QixDQUFLLGlCQUFMLEdBQXlCLE1BQUEsQ0FBSyxjQUFMOzs7U0FLekIsU0FBQSxJQUFhLEtBQUs7YUFDaEIsR0FBQSxDQUFJO2VBQVMsSUFBQSxDQUFLLElBQUw7O2VBQ1osSUFBQSxDQUFLLEtBQUw7O2tCQUdQLENBQWMsSUFBQSxDQUFLO1NBR25CLENBQUssTUFBTDtTQUNBLENBQUssTUFBTDtZQUNPLElBQUEsQ0FBSzs7eUJBR2QsNEJBQVU7U0FDRixXQUFXLElBQUEsQ0FBSyxhQUFMO1NBRVgsV0FBVyxJQUFBLENBQUs7U0FDaEIsUUFBUSxJQUFBLENBQUs7U0FHYixXQUFXLFlBQUEsQ0FBYSxPQUFPO1dBR3JDLENBQU8sTUFBUCxDQUFjLElBQUEsQ0FBSyxRQUFRO2VBU3ZCLElBQUEsQ0FBSztTQUxQO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FJSSxTQUFTLElBQUEsQ0FBSyxLQUFMLENBQVc7U0FDdEIsTUFBQSxJQUFVLFFBQUEsQ0FBUyxZQUFULEtBQTBCLE9BQU87YUFDekMsS0FBQSxDQUFNLElBQUk7aUJBRVIsTUFBQSxDQUFPLEtBQVAsS0FBaUIsV0FBakIsSUFBZ0MsTUFBQSxDQUFPLE1BQVAsS0FBa0IsY0FBYztxQkFDbEUsQ0FBSyxhQUFMLEdBQXFCO3NCQUVyQixDQUFNLEVBQU4sQ0FBUyxZQUFULENBQXNCO3NCQUN0QixDQUFNLEVBQU4sQ0FBUyxZQUFULENBQXNCLFdBQUEsR0FBYyxZQUFZLFlBQUEsR0FBZSxZQUFZO3FCQUMzRSxDQUFLLGFBQUwsR0FBcUI7O2dCQUVsQjtpQkFFRCxNQUFBLENBQU8sS0FBUCxLQUFpQjttQkFBYSxNQUFBLENBQU8sS0FBUCxHQUFlO2lCQUM3QyxNQUFBLENBQU8sTUFBUCxLQUFrQjttQkFBYyxNQUFBLENBQU8sTUFBUCxHQUFnQjs7YUFHbEQsU0FBQSxFQUFBLElBQWUsUUFBQSxDQUFTLFdBQVQsS0FBeUIsT0FBTzttQkFDakQsQ0FBTyxLQUFQLENBQWEsS0FBYixHQUFxQjttQkFDckIsQ0FBTyxLQUFQLENBQWEsTUFBYixHQUFzQjs7O1NBSXBCLFdBQVcsSUFBQSxDQUFLLGFBQUw7U0FDYixVQUFVLENBQUMsV0FBQSxDQUFVLFVBQVU7U0FDL0IsU0FBUzthQUNYLENBQUssWUFBTDs7WUFFSzs7eUJBR1Qsd0NBQWdCO1NBRVYsSUFBQSxDQUFLLE1BQUwsSUFBZSxPQUFPLElBQUEsQ0FBSyxNQUFMLENBQVksTUFBbkIsS0FBOEIsWUFBWTthQUMzRCxDQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLElBQUEsQ0FBSzs7O3lCQUk1Qiw4QkFBVztTQUNMLENBQUMsSUFBQSxDQUFLLEtBQUwsQ0FBVztXQUFTO1NBQ3JCLENBQUMsU0FBQSxJQUFhO2dCQUNoQixDQUFRLEtBQVIsQ0FBYzs7O1NBR2hCLENBQUssSUFBTCxHQUFZLE1BQUEsQ0FBTyxxQkFBUCxDQUE2QixJQUFBLENBQUs7U0FFMUMsTUFBTSxPQUFBO1NBRUosTUFBTSxJQUFBLENBQUssS0FBTCxDQUFXO1NBQ2pCLGtCQUFrQixJQUFBLEdBQU87U0FDM0IsY0FBYyxHQUFBLEdBQU0sSUFBQSxDQUFLO1NBRXZCLFdBQVcsSUFBQSxDQUFLLEtBQUwsQ0FBVztTQUN0QixjQUFjLE9BQU8sUUFBUCxLQUFvQixRQUFwQixJQUFnQyxRQUFBLENBQVM7U0FFekQsYUFBYTtTQUNYLGVBQWUsSUFBQSxDQUFLLFFBQUwsQ0FBYztTQUMvQixZQUFBLEtBQWlCLFNBQVM7b0JBQzVCLEdBQWM7WUFDVCxJQUFJLFlBQUEsS0FBaUIsWUFBWTthQUNsQyxXQUFBLEdBQWMsaUJBQWlCO2dCQUNqQyxHQUFNLEdBQUEsR0FBTyxXQUFBLEdBQWM7aUJBQzNCLENBQUssU0FBTCxHQUFpQjtnQkFDWjt1QkFDTCxHQUFhOztZQUVWO2FBQ0wsQ0FBSyxTQUFMLEdBQWlCOztTQUdiLFlBQVksV0FBQSxHQUFjO1NBQzVCLFVBQVUsSUFBQSxDQUFLLEtBQUwsQ0FBVyxJQUFYLEdBQWtCLFNBQUEsR0FBWSxJQUFBLENBQUssS0FBTCxDQUFXO1NBR25ELE9BQUEsR0FBVSxDQUFWLElBQWUsYUFBYTtnQkFDOUIsR0FBVSxRQUFBLEdBQVc7O1NBSW5CLGFBQWE7U0FDYixjQUFjO1NBRVosVUFBVSxJQUFBLENBQUssUUFBTCxDQUFjLElBQWQsS0FBdUI7U0FFbkMsV0FBQSxJQUFlLE9BQUEsSUFBVyxVQUFVO2FBRWxDLFNBQVM7dUJBQ1gsR0FBYTtvQkFDYixHQUFVLE9BQUEsR0FBVTt3QkFDcEIsR0FBYztnQkFDVDt1QkFDTCxHQUFhO29CQUNiLEdBQVU7dUJBQ1YsR0FBYTs7YUFHZixDQUFLLFVBQUw7O1NBR0UsWUFBWTthQUNkLENBQUssS0FBTCxDQUFXLFNBQVgsR0FBdUI7YUFDdkIsQ0FBSyxLQUFMLENBQVcsSUFBWCxHQUFrQjthQUNsQixDQUFLLEtBQUwsQ0FBVyxRQUFYLEdBQXNCLElBQUEsQ0FBSyxnQkFBTCxDQUFzQixTQUFTO2FBQy9DLFlBQVksSUFBQSxDQUFLLEtBQUwsQ0FBVzthQUM3QixDQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW1CLElBQUEsQ0FBSyxvQkFBTDthQUNmO2VBQWEsSUFBQSxDQUFLLFlBQUw7YUFDYixTQUFBLEtBQWMsSUFBQSxDQUFLLEtBQUwsQ0FBVztlQUFPLElBQUEsQ0FBSyxJQUFMO2FBQ3BDLENBQUssTUFBTDthQUNBLENBQUssS0FBTCxDQUFXLFNBQVgsR0FBdUI7O1NBR3JCLFlBQVk7YUFDZCxDQUFLLEtBQUw7Ozt5QkFJSiw4QkFBVSxJQUFJO1NBQ1IsT0FBTyxFQUFQLEtBQWM7V0FBWSxNQUFNLElBQUksS0FBSixDQUFVO09BQzlDLENBQUcsSUFBQSxDQUFLO1NBQ1IsQ0FBSyxNQUFMOzt5QkFHRiwwQkFBUztTQUNQLENBQUsscUJBQUw7O3lCQUdGLDhCQUFXO1NBQ0wsU0FBQSxJQUFhO2VBQ2YsQ0FBTyxtQkFBUCxDQUEyQixVQUFVLElBQUEsQ0FBSzthQUMxQyxDQUFLLGtCQUFMLENBQXdCLE1BQXhCOztTQUVFLElBQUEsQ0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixlQUFlO2FBQ25DLENBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsYUFBbEIsQ0FBZ0MsV0FBaEMsQ0FBNEMsSUFBQSxDQUFLLEtBQUwsQ0FBVzs7O3lCQUkzRCwwREFBeUI7U0FDbkIsQ0FBQyxTQUFBO1dBQWE7U0FDZCxJQUFBLENBQUssUUFBTCxDQUFjLE1BQWQsS0FBeUIsS0FBekIsS0FBbUMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxNQUFYLElBQXFCLENBQUMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLGdCQUFnQjthQUN2RixnQkFBZ0IsSUFBQSxDQUFLLFFBQUwsQ0FBYyxNQUFkLElBQXdCLFFBQUEsQ0FBUztzQkFDdkQsQ0FBYyxXQUFkLENBQTBCLElBQUEsQ0FBSyxLQUFMLENBQVc7Ozt5QkFJekMsc0NBQWU7U0FDVCxJQUFBLENBQUssS0FBTCxDQUFXLFNBQVM7YUFDbEIsY0FBQSxDQUFlLElBQUEsQ0FBSyxLQUFMLENBQVcsVUFBVTtpQkFDdEMsQ0FBSyxNQUFMLENBQVksRUFBWixHQUFpQixJQUFBLENBQUssS0FBTCxDQUFXO2dCQUN2QjtvQkFDRSxJQUFBLENBQUssTUFBTCxDQUFZOzs7O3lCQUt6QixzQ0FBYyxVQUFlOzRDQUFmLEdBQVc7O1NBRW5CLFdBQVcsUUFBQSxDQUFTO1NBQ3BCLGNBQWMsUUFBQSxDQUFTO1NBQ3JCLFlBQVksT0FBQSxDQUFRLFFBQUEsQ0FBUyxXQUFXO1NBQ3hDLE1BQU0sT0FBQSxDQUFRLFFBQUEsQ0FBUyxLQUFLO1NBQzVCLGNBQWMsT0FBTyxRQUFQLEtBQW9CLFFBQXBCLElBQWdDLFFBQUEsQ0FBUztTQUN2RCxpQkFBaUIsT0FBTyxXQUFQLEtBQXVCLFFBQXZCLElBQW1DLFFBQUEsQ0FBUztTQUU3RCwwQkFBMEIsV0FBQSxHQUFjLElBQUEsQ0FBSyxLQUFMLENBQVcsR0FBQSxHQUFNLFlBQVk7U0FDckUsMEJBQTBCLGNBQUEsR0FBa0IsV0FBQSxHQUFjLE1BQU87U0FDbkUsV0FBQSxJQUFlLGNBQWYsSUFBaUMsdUJBQUEsS0FBNEIsYUFBYTtlQUN0RSxJQUFJLEtBQUosQ0FBVTs7U0FHZCxPQUFPLFFBQUEsQ0FBUyxVQUFoQixLQUErQixXQUEvQixJQUE4QyxPQUFPLFFBQUEsQ0FBUyxLQUFoQixLQUEwQixhQUFhO2dCQUN2RixDQUFRLElBQVIsQ0FBYTs7Z0JBR2YsR0FBYyxPQUFBLENBQVEsYUFBYSx5QkFBeUI7YUFDNUQsR0FBVyxPQUFBLENBQVEsVUFBVSx5QkFBeUI7U0FFaEQsWUFBWSxRQUFBLENBQVM7U0FDckIsYUFBYSxRQUFBLENBQVM7U0FDdEIsZUFBZSxPQUFPLFNBQVAsS0FBcUIsUUFBckIsSUFBaUMsUUFBQSxDQUFTO1NBQ3pELGdCQUFnQixPQUFPLFVBQVAsS0FBc0IsUUFBdEIsSUFBa0MsUUFBQSxDQUFTO1NBRzdELE9BQU87U0FDUCxRQUFRO1NBQ1IsV0FBVztTQUNYLFlBQUEsSUFBZ0IsZUFBZTtlQUMzQixJQUFJLEtBQUosQ0FBVTtZQUNYLElBQUksY0FBYzthQUV2QixHQUFPO2lCQUNQLEdBQVcsSUFBQSxDQUFLLGdCQUFMLENBQXNCLE1BQU07Y0FDdkMsR0FBUSxJQUFBLENBQUssYUFBTCxDQUNOLFVBQVUsTUFDVixhQUFhO1lBRVYsSUFBSSxlQUFlO2NBRXhCLEdBQVE7YUFDUixHQUFPLEtBQUEsR0FBUTtpQkFDZixHQUFXLElBQUEsQ0FBSyxnQkFBTCxDQUFzQixNQUFNOztZQUdsQzttQkFDTCxRQURLO2VBRUwsSUFGSztnQkFHTCxLQUhLO21CQUlMLFFBSks7c0JBS0wsV0FMSztjQU1MLEdBTks7b0JBT0w7Ozt5QkFJSix3QkFBTyxVQUFlOzs0Q0FBZixHQUFXOztTQUNaLElBQUEsQ0FBSztXQUFRLE1BQU0sSUFBSSxLQUFKLENBQVU7U0FFakMsQ0FBSyxTQUFMLEdBQWlCLE1BQUEsQ0FBTyxNQUFQLENBQWMsSUFBSSxVQUFVLElBQUEsQ0FBSztrQkFFbEQsQ0FBYyxJQUFBLENBQUs7ZUFHUyxZQUFBLENBQWEsSUFBQSxDQUFLO1NBQXRDO1NBQVM7U0FFWCxZQUFZLElBQUEsQ0FBSyxZQUFMLENBQWtCLElBQUEsQ0FBSztTQUd6QyxDQUFLLE1BQUwsR0FBYyxrQkFDVCxTQURTO2tCQUVaLE1BRlk7a0JBR1osT0FIWTtvQkFJRCxDQUpDO2tCQUtILEtBTEc7b0JBTUQsS0FOQztrQkFPSCxLQVBHO29CQVFELEtBUkM7bUJBU0YsSUFBQSxDQUFLLFFBVEg7ZUFVTixJQUFBLENBQUssUUFBTCxDQUFjLElBVlI7NkJBYUosU0FBTSxNQUFBLENBQUssTUFBTCxLQWJGO2lDQWNBLFNBQU0sTUFBQSxDQUFLLFVBQUwsS0FkTjs2QkFlRCxhQUFPLE1BQUEsQ0FBSyxRQUFMLENBQWMsTUFmcEI7MkJBZ0JOLFNBQU0sTUFBQSxDQUFLLElBQUwsS0FoQkE7NkJBaUJKLFNBQU0sTUFBQSxDQUFLLE1BQUwsS0FqQkY7MkJBa0JILGNBQVEsTUFBQSxDQUFLLE1BQUwsQ0FBWSxPQWxCakI7Z0NBbUJDLGNBQU8sTUFBQSxDQUFLLFdBQUwsQ0FBaUIsT0FuQnpCOzZCQW9CSixTQUFNLE1BQUEsQ0FBSyxNQUFMLEtBcEJGOzJCQXFCTixTQUFNLE1BQUEsQ0FBSyxJQUFMLEtBckJBOzRCQXNCTCxTQUFNLE1BQUEsQ0FBSyxLQUFMLEtBdEJEOzJCQXVCTixTQUFNLE1BQUEsQ0FBSyxJQUFMO1NBSWQsQ0FBSyxXQUFMO1NBSUEsQ0FBSyxNQUFMOzt5QkFHRixrQ0FBWSxZQUFjLEVBQUEsYUFBYTs7O1lBQzlCLElBQUEsQ0FBSyxJQUFMLENBQVUsY0FBYyxZQUF4QixDQUFxQyxJQUFyQyxhQUEwQztlQUMvQyxDQUFLLEdBQUw7Z0JBQ087Ozt5QkFJWCw0QkFBVTs7O1NBQ1IsQ0FBSyxLQUFMO1NBQ0ksQ0FBQyxJQUFBLENBQUs7V0FBUTtTQUNkLE9BQU8sSUFBQSxDQUFLLE1BQUwsQ0FBWSxNQUFuQixLQUE4QixZQUFZO2FBQzVDLENBQUssaUJBQUwsV0FBdUIsZ0JBQVMsTUFBQSxDQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1COztTQUVyRCxDQUFLLE9BQUwsR0FBZTs7eUJBR2pCLDhCQUFXO1NBQ1QsQ0FBSyxNQUFMO1NBQ0EsQ0FBSyxPQUFMOzt5QkFHRixzQkFBTSxZQUFjLEVBQUEsYUFBYTs7O1NBRTNCLE9BQU8sWUFBUCxLQUF3QixZQUFZO2VBQ2hDLElBQUksS0FBSixDQUFVOztTQUdkLElBQUEsQ0FBSyxRQUFRO2FBQ2YsQ0FBSyxNQUFMOztTQUdFLE9BQU8sV0FBUCxLQUF1QixhQUFhO2FBQ3RDLENBQUssTUFBTCxDQUFZOztTQU1kLENBQUssVUFBTDtTQUVJLFVBQVUsT0FBQSxDQUFRLE9BQVI7U0FJVixJQUFBLENBQUssUUFBTCxDQUFjLElBQUk7YUFDaEIsQ0FBQyxTQUFBLElBQWE7bUJBQ1YsSUFBSSxLQUFKLENBQVU7O2dCQUVsQixHQUFVLElBQUksT0FBSixXQUFZO2lCQUNoQixnQkFBZ0IsTUFBQSxDQUFLLFFBQUwsQ0FBYztpQkFDOUI7aUJBQ0EsYUFBQSxDQUFjLElBQUk7d0JBQ3BCLEdBQVUsYUFBQSxDQUFjOzhCQUN4QixHQUFnQixhQUFBLENBQWM7O2lCQUkxQixxQkFBVztxQkFFWDt1QkFBUyxFQUFBLENBQUcsT0FBSCxnQkFBYSxTQUFNLE9BQUEsQ0FBUTttQkFDeEMsQ0FBRyxLQUFILGdCQUFXO3lCQUNILFFBQVEsTUFBQSxDQUFLO3lCQUNiLE9BQU8sTUFBQSxDQUFLLFFBQUwsQ0FBYyxPQUFkLEtBQTBCO3lCQUNqQyxXQUFXLElBQUEsR0FBTyxFQUFBLENBQUcsUUFBUSxFQUFBLENBQUc7dUJBQ3RDLENBQUcsTUFBSDt1QkFDQSxDQUFHLFlBQUgsQ0FBZ0IsS0FBQSxDQUFNO3VCQUN0QixDQUFHLFlBQUgsQ0FBZ0IsS0FBQSxDQUFNLGVBQWUsS0FBQSxDQUFNLGdCQUFnQjt5QkFDdkQsSUFBQSxJQUFRLE1BQUEsQ0FBSyxRQUFMLENBQWMsWUFBWTsyQkFDcEMsQ0FBRyxhQUFILENBQWlCLE1BQUEsQ0FBSyxRQUFMLENBQWM7OzJCQUdqQyxDQUFLLE1BQUwsQ0FBWTs2QkFBRSxFQUFGO2lDQUFjLEVBQUEsQ0FBRyxNQUFqQjtrQ0FBa0MsRUFBQSxDQUFHLFNBQUgsQ0FBYTs7NEJBQzNEOzs7aUJBS0EsT0FBTyxhQUFQLEtBQXlCLFlBQVk7cUJBQ25DLGFBQUosQ0FBa0I7b0JBQ2I7cUJBQ0QsT0FBTyxNQUFBLENBQU8sWUFBZCxLQUErQixZQUFZOzJCQUN2QyxJQUFJLEtBQUosQ0FBVTs7eUJBRWxCLENBQVM7Ozs7WUFLUixPQUFBLENBQVEsSUFBUixhQUFhO2FBRWQsU0FBUyxZQUFBLENBQWEsTUFBQSxDQUFLO2FBQzNCLENBQUMsV0FBQSxDQUFVLFNBQVM7bUJBQ3RCLEdBQVMsT0FBQSxDQUFRLE9BQVIsQ0FBZ0I7O2dCQUVwQjtPQU5GLENBT0osSUFQSSxXQU9DO2FBQ0YsQ0FBQztlQUFRLE1BQUEsR0FBUztlQUN0QixDQUFLLE9BQUwsR0FBZTthQUdYLFNBQUEsSUFBYTttQkFDZixDQUFLLGtCQUFMLENBQXdCLE1BQXhCO21CQUNBLENBQU8sZ0JBQVAsQ0FBd0IsVUFBVSxNQUFBLENBQUs7O2VBR3pDLENBQUssV0FBTDtlQU1BLENBQUssWUFBTDtnQkFDTztPQXhCRixDQXlCSixLQXpCSSxXQXlCRTtnQkFDUCxDQUFRLElBQVIsQ0FBYSx5RkFBQSxHQUE0RixHQUFBLENBQUk7ZUFDdkc7Ozs7OztDQzM5QlosSUFBTSxRQUFRO0NBQ2QsSUFBTSxvQkFBb0I7Q0FFMUIsU0FBUyxjQUFlO0tBQ3RCLElBQU0sU0FBUyxZQUFBO0tBQ2YsT0FBTyxNQUFBLElBQVUsTUFBQSxDQUFPOzs7Q0FHMUIsU0FBUyxTQUFVLElBQUk7S0FDckIsSUFBTSxTQUFTLFlBQUE7S0FDZixJQUFJLENBQUM7V0FBUSxPQUFPO0tBQ3BCLE1BQUEsQ0FBTyxNQUFQLEdBQWdCLE1BQUEsQ0FBTyxNQUFQLElBQWlCO0tBQ2pDLE9BQU8sTUFBQSxDQUFPLE1BQVAsQ0FBYzs7O0NBR3ZCLFNBQVMsU0FBVSxFQUFJLEVBQUEsTUFBTTtLQUMzQixJQUFNLFNBQVMsWUFBQTtLQUNmLElBQUksQ0FBQztXQUFRLE9BQU87S0FDcEIsTUFBQSxDQUFPLE1BQVAsR0FBZ0IsTUFBQSxDQUFPLE1BQVAsSUFBaUI7S0FDakMsTUFBQSxDQUFPLE1BQVAsQ0FBYyxHQUFkLEdBQW9COzs7Q0FHdEIsU0FBUyxZQUFhLFVBQVksRUFBQSxhQUFhO0tBRTdDLE9BQU8sV0FBQSxDQUFZLE9BQVosR0FBc0I7U0FBRSxNQUFNLFVBQUEsQ0FBVyxLQUFYLENBQWlCO1NBQVM7OztDQUdqRSxTQUFTLGFBQWMsTUFBUSxFQUFBLFVBQWU7d0NBQWYsR0FBVzs7S0FDeEMsSUFBSSxRQUFBLENBQVMsSUFBSTtTQUNmLElBQUksUUFBQSxDQUFTLE1BQVQsSUFBb0IsUUFBQSxDQUFTLE9BQVQsSUFBb0IsT0FBTyxRQUFBLENBQVMsT0FBaEIsS0FBNEIsVUFBVzthQUNqRixNQUFNLElBQUksS0FBSixDQUFVOztTQUlsQixJQUFNLFVBQVUsT0FBTyxRQUFBLENBQVMsT0FBaEIsS0FBNEIsUUFBNUIsR0FBdUMsUUFBQSxDQUFTLFVBQVU7U0FDMUUsUUFBQSxHQUFXLE1BQUEsQ0FBTyxNQUFQLENBQWMsSUFBSSxVQUFVO2FBQUUsUUFBUSxLQUFWO3NCQUFpQjs7O0tBRzFELElBQU0sUUFBUSxXQUFBO0tBQ2QsSUFBSTtLQUNKLElBQUksT0FBTztTQUlULEtBQUEsR0FBUSxPQUFBLENBQVEsUUFBQSxDQUFTLElBQUk7O0tBRS9CLElBQUksY0FBYyxLQUFBLElBQVMsT0FBTyxLQUFQLEtBQWlCO0tBRTVDLElBQUksV0FBQSxJQUFlLGlCQUFBLENBQWtCLFFBQWxCLENBQTJCLFFBQVE7U0FDcEQsT0FBQSxDQUFRLElBQVIsQ0FBYSxxS0FBcUs7U0FDbEwsV0FBQSxHQUFjOztLQUdoQixJQUFJLFVBQVUsT0FBQSxDQUFRLE9BQVI7S0FFZCxJQUFJLGFBQWE7U0FFZixpQkFBQSxDQUFrQixJQUFsQixDQUF1QjtTQUV2QixJQUFNLGVBQWUsUUFBQSxDQUFTO1NBQzlCLElBQUksY0FBYzthQUNoQixJQUFNLG1CQUFPO2lCQUVYLElBQU0sV0FBVyxXQUFBLENBQVksWUFBQSxDQUFhLFNBQVM7aUJBRW5ELFlBQUEsQ0FBYSxPQUFiLENBQXFCLE9BQXJCO2lCQUVBLE9BQU87O2FBSVQsT0FBQSxHQUFVLFlBQUEsQ0FBYSxJQUFiLENBQWtCLElBQWxCLENBQXVCLEtBQXZCLENBQTZCLEtBQTdCLENBQW1DOzs7S0FJakQsT0FBTyxPQUFBLENBQVEsSUFBUixXQUFhO1NBQ2xCLElBQU0sVUFBVSxJQUFJLGFBQUo7U0FDaEIsSUFBSTtTQUNKLElBQUksUUFBUTthQUVWLFFBQUEsR0FBVyxNQUFBLENBQU8sTUFBUCxDQUFjLElBQUksVUFBVTthQUd2QyxPQUFBLENBQVEsS0FBUixDQUFjO2FBR2QsT0FBQSxDQUFRLEtBQVI7YUFHQSxNQUFBLEdBQVMsT0FBQSxDQUFRLFVBQVIsQ0FBbUI7Z0JBQ3ZCO2FBQ0wsTUFBQSxHQUFTLE9BQUEsQ0FBUSxPQUFSLENBQWdCOztTQUUzQixJQUFJLGFBQWE7YUFDZixRQUFBLENBQVMsT0FBTztpQkFBRSxNQUFNLE1BQVI7MEJBQWdCOzs7U0FFbEMsT0FBTzs7OztDQUtYLFlBQUEsQ0FBYSxZQUFiLEdBQTRCO0NBQzVCLFlBQUEsQ0FBYSxVQUFiLEdBQTBCOzs7Ozs7Ozs7O0FDMUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2duQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RsQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLy8gTWFyayBvdXRwdXQvZXhwb3J0IGFzIGVuYWJsZWQgZm9yIHRoZSBjbGllbnQgQVBJIHNjcmlwdHMuXG53aW5kb3dbJ2NhbnZhcy1za2V0Y2gtY2xpJ10gPSB3aW5kb3dbJ2NhbnZhcy1za2V0Y2gtY2xpJ10gfHwge307XG53aW5kb3dbJ2NhbnZhcy1za2V0Y2gtY2xpJ10ub3V0cHV0ID0gdHJ1ZTtcbiIsImNvbnN0IE5BTUVTUEFDRSA9ICdjYW52YXMtc2tldGNoLWNsaSc7XG5cbi8vIEdyYWIgdGhlIENMSSBuYW1lc3BhY2VcbndpbmRvd1tOQU1FU1BBQ0VdID0gd2luZG93W05BTUVTUEFDRV0gfHwge307XG5cbmlmICghd2luZG93W05BTUVTUEFDRV0uaW5pdGlhbGl6ZWQpIHtcbiAgaW5pdGlhbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplICgpIHtcbiAgLy8gQXdhaXRpbmcgZW5hYmxlL2Rpc2FibGUgZXZlbnRcbiAgd2luZG93W05BTUVTUEFDRV0ubGl2ZVJlbG9hZEVuYWJsZWQgPSB1bmRlZmluZWQ7XG4gIHdpbmRvd1tOQU1FU1BBQ0VdLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuICBjb25zdCBkZWZhdWx0UG9zdE9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgY2FjaGU6ICduby1jYWNoZScsXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcbiAgfTtcblxuICAvLyBGaWxlIHNhdmluZyB1dGlsaXR5XG4gIHdpbmRvd1tOQU1FU1BBQ0VdLnNhdmVCbG9iID0gKGJsb2IsIG9wdHMpID0+IHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIGNvbnN0IGZvcm0gPSBuZXcgd2luZG93LkZvcm1EYXRhKCk7XG4gICAgZm9ybS5hcHBlbmQoJ2ZpbGUnLCBibG9iLCBvcHRzLmZpbGVuYW1lKTtcbiAgICByZXR1cm4gd2luZG93LmZldGNoKCcvY2FudmFzLXNrZXRjaC1jbGkvc2F2ZUJsb2InLCBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UG9zdE9wdGlvbnMsIHtcbiAgICAgIGJvZHk6IGZvcm1cbiAgICB9KSkudGhlbihyZXMgPT4ge1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4odGV4dCA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRleHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgLy8gU29tZSBpc3N1ZSwganVzdCBiYWlsIG91dCBhbmQgcmV0dXJuIG5pbCBoYXNoXG4gICAgICBjb25zb2xlLndhcm4oYFRoZXJlIHdhcyBhIHByb2JsZW0gZXhwb3J0aW5nICR7b3B0cy5maWxlbmFtZX1gKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3Qgc3RyZWFtID0gKHVybCwgb3B0cykgPT4ge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgcmV0dXJuIHdpbmRvdy5mZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQb3N0T3B0aW9ucywge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBzYXZlOiBvcHRzLnNhdmUsXG4gICAgICAgIGVuY29kaW5nOiBvcHRzLmVuY29kaW5nLFxuICAgICAgICB0aW1lU3RhbXA6IG9wdHMudGltZVN0YW1wLFxuICAgICAgICBmcHM6IG9wdHMuZnBzLFxuICAgICAgICBmaWxlbmFtZTogb3B0cy5maWxlbmFtZVxuICAgICAgfSlcbiAgICB9KSlcbiAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIGlmIChyZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKHRleHQgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRleHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAvLyBTb21lIGlzc3VlLCBqdXN0IGJhaWwgb3V0IGFuZCByZXR1cm4gbmlsIGhhc2hcbiAgICAgICAgY29uc29sZS53YXJuKGBUaGVyZSB3YXMgYSBwcm9ibGVtIHN0YXJ0aW5nIHRoZSBzdHJlYW0gZXhwb3J0YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICB9O1xuXG4gIC8vIEZpbGUgc3RyZWFtaW5nIHV0aWxpdHlcbiAgd2luZG93W05BTUVTUEFDRV0uc3RyZWFtU3RhcnQgPSAob3B0cykgPT4ge1xuICAgIHJldHVybiBzdHJlYW0oJy9jYW52YXMtc2tldGNoLWNsaS9zdHJlYW0tc3RhcnQnLCBvcHRzKTtcbiAgfTtcblxuICB3aW5kb3dbTkFNRVNQQUNFXS5zdHJlYW1FbmQgPSAob3B0cykgPT4ge1xuICAgIHJldHVybiBzdHJlYW0oJy9jYW52YXMtc2tldGNoLWNsaS9zdHJlYW0tZW5kJywgb3B0cyk7XG4gIH07XG5cbiAgLy8gZ2l0IGNvbW1pdCB1dGlsaXR5XG4gIHdpbmRvd1tOQU1FU1BBQ0VdLmNvbW1pdCA9ICgpID0+IHtcbiAgICByZXR1cm4gd2luZG93LmZldGNoKCcvY2FudmFzLXNrZXRjaC1jbGkvY29tbWl0JywgZGVmYXVsdFBvc3RPcHRpb25zKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ25vdCBhIGdpdCByZXBvc2l0b3J5JykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHtyZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGlmeSB1c2VyIG9mIGNoYW5nZXNcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LmNoYW5nZWRcbiAgICAgICAgICA/IGBbZ2l0XSAke3Jlc3VsdC5oYXNofSBDb21taXR0ZWQgY2hhbmdlc2BcbiAgICAgICAgICA6IGBbZ2l0XSAke3Jlc3VsdC5oYXNofSBOb3RoaW5nIGNoYW5nZWRgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5oYXNoO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAvLyBTb21lIGlzc3VlLCBqdXN0IGJhaWwgb3V0IGFuZCByZXR1cm4gbmlsIGhhc2hcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgY29tbWl0IGNoYW5nZXMgYW5kIGZldGNoIGhhc2gnKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gIH07XG5cbiAgaWYgKCdidWRvLWxpdmVyZWxvYWQnIGluIHdpbmRvdykge1xuICAgIGNvbnN0IGNsaWVudCA9IHdpbmRvd1snYnVkby1saXZlcmVsb2FkJ107XG4gICAgY2xpZW50Lmxpc3RlbihkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLmV2ZW50ID09PSAnaG90LXJlbG9hZCcpIHtcbiAgICAgICAgc2V0dXBMaXZlUmVsb2FkKGRhdGEuZW5hYmxlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBPbiBmaXJzdCBsb2FkLCBjaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIHNldHVwIGxpdmUgcmVsb2FkIG9yIG5vdFxuICAgIGlmICh3aW5kb3dbTkFNRVNQQUNFXS5ob3QpIHtcbiAgICAgIHNldHVwTGl2ZVJlbG9hZCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dXBMaXZlUmVsb2FkKGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBMaXZlUmVsb2FkIChpc0VuYWJsZWQpIHtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHdpbmRvd1tOQU1FU1BBQ0VdLmxpdmVSZWxvYWRFbmFibGVkO1xuICBpZiAodHlwZW9mIHByZXZpb3VzU3RhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzRW5hYmxlZCAhPT0gcHJldmlvdXNTdGF0ZSkge1xuICAgIC8vIFdlIG5lZWQgdG8gcmVsb2FkIHRoZSBwYWdlIHRvIGVuc3VyZSB0aGUgbmV3IHNrZXRjaCBmdW5jdGlvbiBpc1xuICAgIC8vIG5hbWVkIGZvciBob3QgcmVsb2FkaW5nLCBhbmQvb3IgY2xlYW5lZCB1cCBhZnRlciBob3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkXG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNFbmFibGVkID09PSB3aW5kb3dbTkFNRVNQQUNFXS5saXZlUmVsb2FkRW5hYmxlZCkge1xuICAgIC8vIE5vIGNoYW5nZSBpbiBzdGF0ZVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE1hcmsgbmV3IHN0YXRlXG4gIHdpbmRvd1tOQU1FU1BBQ0VdLmxpdmVSZWxvYWRFbmFibGVkID0gaXNFbmFibGVkO1xuXG4gIGlmIChpc0VuYWJsZWQpIHtcbiAgICBpZiAoJ2J1ZG8tbGl2ZXJlbG9hZCcgaW4gd2luZG93KSB7XG4gICAgICBjb25zb2xlLmxvZyhgJWNbY2FudmFzLXNrZXRjaC1jbGldJWMg4pyoIEhvdCBSZWxvYWQgRW5hYmxlZGAsICdjb2xvcjogIzhlOGU4ZTsnLCAnY29sb3I6IGluaXRpYWw7Jyk7XG4gICAgICBjb25zdCBjbGllbnQgPSB3aW5kb3dbJ2J1ZG8tbGl2ZXJlbG9hZCddO1xuICAgICAgY2xpZW50Lmxpc3RlbihvbkNsaWVudERhdGEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNsaWVudERhdGEgKGRhdGEpIHtcbiAgY29uc3QgY2xpZW50ID0gd2luZG93WydidWRvLWxpdmVyZWxvYWQnXTtcbiAgaWYgKCFjbGllbnQpIHJldHVybjtcblxuICBpZiAoZGF0YS5ldmVudCA9PT0gJ2V2YWwnKSB7XG4gICAgaWYgKCFkYXRhLmVycm9yKSB7XG4gICAgICBjbGllbnQuY2xlYXJFcnJvcigpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZXZhbChkYXRhLmNvZGUpO1xuICAgICAgaWYgKCFkYXRhLmVycm9yKSBjb25zb2xlLmxvZyhgJWNbY2FudmFzLXNrZXRjaC1jbGldJWMg4pyoIEhvdCBSZWxvYWRlZGAsICdjb2xvcjogIzhlOGU4ZTsnLCAnY29sb3I6IGluaXRpYWw7Jyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGAlY1tjYW52YXMtc2tldGNoLWNsaV0lYyDwn5qoIEhvdCBSZWxvYWQgZXJyb3JgLCAnY29sb3I6ICM4ZThlOGU7JywgJ2NvbG9yOiBpbml0aWFsOycpO1xuICAgICAgY2xpZW50LnNob3dFcnJvcihlcnIudG9TdHJpbmcoKSk7XG5cbiAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIGxvYWQgdXAgdGhlIHByb2JsZW1hdGljIHNjcmlwdCBzbyB0aGF0IHN0YWNrIHRyYWNlcyB3aXRoXG4gICAgICAvLyBzb3VyY2UgbWFwcyBpcyB2aXNpYmxlXG4gICAgICBjb25zdCBzY3JpcHRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JpcHRFbGVtZW50KTtcbiAgICAgIH07XG4gICAgICBzY3JpcHRFbGVtZW50LnNyYyA9IGRhdGEuc3JjO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHRFbGVtZW50KTtcbiAgICB9XG4gIH1cbn0iLCIvKipcclxuICogQSBiYXNpYyBUaHJlZUpTIGN1YmUgc2NlbmUuXHJcbiAqIEBhdXRob3IgTWF0dCBEZXNMYXVyaWVycyAoQG1hdHRkZXNsKVxyXG4gKi9cclxuXHJcbmNvbnN0IGNhbnZhc1NrZXRjaCA9IHJlcXVpcmUoJ2NhbnZhcy1za2V0Y2gnKTtcclxuXHJcbi8vIEVuc3VyZSBUaHJlZUpTIGlzIGluIGdsb2JhbCBzY29wZSBmb3IgdGhlICdleGFtcGxlcy8nXHJcbmdsb2JhbC5USFJFRSA9IHJlcXVpcmUoJ3RocmVlJyk7XHJcblxyXG4vLyBJbmNsdWRlIGFueSBhZGRpdGlvbmFsIFRocmVlSlMgZXhhbXBsZXMgYmVsb3dcclxucmVxdWlyZSgndGhyZWUvZXhhbXBsZXMvanMvY29udHJvbHMvT3JiaXRDb250cm9scycpO1xyXG5cclxuY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgLy8gTWFrZSB0aGUgbG9vcCBhbmltYXRlZFxyXG4gIGFuaW1hdGU6IHRydWUsXHJcbiAgLy8gR2V0IGEgV2ViR0wgY2FudmFzIHJhdGhlciB0aGFuIDJEXHJcbiAgY29udGV4dDogJ3dlYmdsJyxcclxuICAvLyBUdXJuIG9uIE1TQUFcclxuICBhdHRyaWJ1dGVzOiB7IGFudGlhbGlhczogdHJ1ZSB9XHJcbn07XHJcblxyXG5jb25zdCBza2V0Y2ggPSAoeyBjb250ZXh0IH0pID0+IHtcclxuICAvLyBDcmVhdGUgYSByZW5kZXJlclxyXG4gIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xyXG4gICAgY29udGV4dFxyXG4gIH0pO1xyXG5cclxuICAvLyBXZWJHTCBiYWNrZ3JvdW5kIGNvbG9yXHJcbiAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcignIzAwMCcsIDEpO1xyXG5cclxuICAvLyBTZXR1cCBhIGNhbWVyYVxyXG4gIGNvbnN0IGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgMSwgMC4wMSwgMTAwKTtcclxuICBjYW1lcmEucG9zaXRpb24uc2V0KDIsIDIsIC00KTtcclxuICBjYW1lcmEubG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKCkpO1xyXG5cclxuICAvLyBTZXR1cCBjYW1lcmEgY29udHJvbGxlclxyXG4gIGNvbnN0IGNvbnRyb2xzID0gbmV3IFRIUkVFLk9yYml0Q29udHJvbHMoY2FtZXJhLCBjb250ZXh0LmNhbnZhcyk7XHJcblxyXG4gIC8vIFNldHVwIHlvdXIgc2NlbmVcclxuICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xyXG5cclxuICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goXHJcbiAgICBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMSwgMSwgMSksXHJcbiAgICBuZXcgVEhSRUUuTWVzaFBoeXNpY2FsTWF0ZXJpYWwoe1xyXG4gICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgcm91Z2huZXNzOiAwLjc1LFxyXG4gICAgICBmbGF0U2hhZGluZzogdHJ1ZVxyXG4gICAgfSlcclxuICApO1xyXG4gIHNjZW5lLmFkZChtZXNoKTtcclxuXHJcbiAgLy8gU3BlY2lmeSBhbiBhbWJpZW50L3VubGl0IGNvbG91clxyXG4gIHNjZW5lLmFkZChuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCcjNTkzMTRmJykpO1xyXG5cclxuICAvLyBBZGQgc29tZSBsaWdodFxyXG4gIGNvbnN0IGxpZ2h0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoJyM0NWNhZjcnLCAxLCAxNS41KTtcclxuICBsaWdodC5wb3NpdGlvbi5zZXQoMiwgMiwgLTQpLm11bHRpcGx5U2NhbGFyKDEuNSk7XHJcbiAgc2NlbmUuYWRkKGxpZ2h0KTtcclxuXHJcbiAgLy8gZHJhdyBlYWNoIGZyYW1lXHJcbiAgcmV0dXJuIHtcclxuICAgIC8vIEhhbmRsZSByZXNpemUgZXZlbnRzIGhlcmVcclxuICAgIHJlc2l6ZSAoeyBwaXhlbFJhdGlvLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCB9KSB7XHJcbiAgICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbyk7XHJcbiAgICAgIHJlbmRlcmVyLnNldFNpemUodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQpO1xyXG4gICAgICBjYW1lcmEuYXNwZWN0ID0gdmlld3BvcnRXaWR0aCAvIHZpZXdwb3J0SGVpZ2h0O1xyXG4gICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG4gICAgfSxcclxuICAgIC8vIEFuZCByZW5kZXIgZXZlbnRzIGhlcmVcclxuICAgIHJlbmRlciAoeyB0aW1lLCBkZWx0YVRpbWUgfSkge1xyXG4gICAgICBtZXNoLnJvdGF0aW9uLnkgPSB0aW1lICogKDEwICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgIGNvbnRyb2xzLnVwZGF0ZSgpO1xyXG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XHJcbiAgICB9LFxyXG4gICAgLy8gRGlzcG9zZSBvZiBXZWJHTCBjb250ZXh0IChvcHRpb25hbClcclxuICAgIHVubG9hZCAoKSB7XHJcbiAgICAgIHJlbmRlcmVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuY2FudmFzU2tldGNoKHNrZXRjaCwgc2V0dGluZ3MpO1xyXG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPVxuICBnbG9iYWwucGVyZm9ybWFuY2UgJiZcbiAgZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdyA/IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbiAgfSA6IERhdGUubm93IHx8IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gK25ldyBEYXRlXG4gIH1cbiIsIm1vZHVsZS5leHBvcnRzID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpc05vZGVcblxuZnVuY3Rpb24gaXNOb2RlICh2YWwpIHtcbiAgcmV0dXJuICghdmFsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKVxuICAgID8gZmFsc2VcbiAgICA6ICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygd2luZG93Lk5vZGUgPT09ICdvYmplY3QnKVxuICAgICAgPyAodmFsIGluc3RhbmNlb2Ygd2luZG93Lk5vZGUpXG4gICAgICA6ICh0eXBlb2YgdmFsLm5vZGVUeXBlID09PSAnbnVtYmVyJykgJiZcbiAgICAgICAgKHR5cGVvZiB2YWwubm9kZU5hbWUgPT09ICdzdHJpbmcnKVxufVxuIiwiLy8gVE9ETzogV2UgY2FuIHJlbW92ZSBhIGh1Z2UgY2h1bmsgb2YgYnVuZGxlIHNpemUgYnkgdXNpbmcgYSBzbWFsbGVyXG4vLyB1dGlsaXR5IG1vZHVsZSBmb3IgY29udmVydGluZyB1bml0cy5cbmltcG9ydCBpc0RPTSBmcm9tICdpcy1kb20nO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50QVBJICgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1snY2FudmFzLXNrZXRjaC1jbGknXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZWQgKCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnJvd3NlciAoKSB7XG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJHTENvbnRleHQgKGN0eCkge1xuICByZXR1cm4gdHlwZW9mIGN0eC5jbGVhciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY3R4LmNsZWFyQ29sb3IgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN0eC5idWZmZXJEYXRhID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDYW52YXMgKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzRE9NKGVsZW1lbnQpICYmIC9jYW52YXMvaS50ZXN0KGVsZW1lbnQubm9kZU5hbWUpICYmIHR5cGVvZiBlbGVtZW50LmdldENvbnRleHQgPT09ICdmdW5jdGlvbic7XG59XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuIiwidmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcbiIsInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMuanMnKTtcbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vbGliL2lzX2FyZ3VtZW50cy5qcycpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyICh4KSB7XG4gIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHgubGVuZ3RoICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwICYmIHR5cGVvZiB4WzBdICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgb3B0cykge1xuICB2YXIgaSwga2V5O1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG9wdHMpO1xuICB9XG4gIGlmIChpc0J1ZmZlcihhKSkge1xuICAgIGlmICghaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG4iLCIvKlxuICogRGF0ZSBGb3JtYXQgMS4yLjNcbiAqIChjKSAyMDA3LTIwMDkgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gKiBNSVQgbGljZW5zZVxuICpcbiAqIEluY2x1ZGVzIGVuaGFuY2VtZW50cyBieSBTY290dCBUcmVuZGEgPHNjb3R0LnRyZW5kYS5uZXQ+XG4gKiBhbmQgS3JpcyBLb3dhbCA8Y2l4YXIuY29tL35rcmlzLmtvd2FsLz5cbiAqXG4gKiBBY2NlcHRzIGEgZGF0ZSwgYSBtYXNrLCBvciBhIGRhdGUgYW5kIGEgbWFzay5cbiAqIFJldHVybnMgYSBmb3JtYXR0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSBkYXRlIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRhdGUvdGltZS5cbiAqIFRoZSBtYXNrIGRlZmF1bHRzIHRvIGRhdGVGb3JtYXQubWFza3MuZGVmYXVsdC5cbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZGF0ZUZvcm1hdCA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbiA9IC9kezEsNH18bXsxLDR9fHl5KD86eXkpP3woW0hoTXNUdF0pXFwxP3xbTGxvU1pXTl18XCJbXlwiXSpcInwnW14nXSonL2c7XG4gICAgICB2YXIgdGltZXpvbmUgPSAvXFxiKD86W1BNQ0VBXVtTRFBdVHwoPzpQYWNpZmljfE1vdW50YWlufENlbnRyYWx8RWFzdGVybnxBdGxhbnRpYykgKD86U3RhbmRhcmR8RGF5bGlnaHR8UHJldmFpbGluZykgVGltZXwoPzpHTVR8VVRDKSg/OlstK11cXGR7NH0pPylcXGIvZztcbiAgICAgIHZhciB0aW1lem9uZUNsaXAgPSAvW14tK1xcZEEtWl0vZztcbiAgXG4gICAgICAvLyBSZWdleGVzIGFuZCBzdXBwb3J0aW5nIGZ1bmN0aW9ucyBhcmUgY2FjaGVkIHRocm91Z2ggY2xvc3VyZVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBtYXNrLCB1dGMsIGdtdCkge1xuICBcbiAgICAgICAgLy8gWW91IGNhbid0IHByb3ZpZGUgdXRjIGlmIHlvdSBza2lwIG90aGVyIGFyZ3MgKHVzZSB0aGUgJ1VUQzonIG1hc2sgcHJlZml4KVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBraW5kT2YoZGF0ZSkgPT09ICdzdHJpbmcnICYmICEvXFxkLy50ZXN0KGRhdGUpKSB7XG4gICAgICAgICAgbWFzayA9IGRhdGU7XG4gICAgICAgICAgZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICBcbiAgICAgICAgZGF0ZSA9IGRhdGUgfHwgbmV3IERhdGU7XG4gIFxuICAgICAgICBpZighKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIGRhdGUnKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgbWFzayA9IFN0cmluZyhkYXRlRm9ybWF0Lm1hc2tzW21hc2tdIHx8IG1hc2sgfHwgZGF0ZUZvcm1hdC5tYXNrc1snZGVmYXVsdCddKTtcbiAgXG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgdGhlIHV0Yy9nbXQgYXJndW1lbnQgdmlhIHRoZSBtYXNrXG4gICAgICAgIHZhciBtYXNrU2xpY2UgPSBtYXNrLnNsaWNlKDAsIDQpO1xuICAgICAgICBpZiAobWFza1NsaWNlID09PSAnVVRDOicgfHwgbWFza1NsaWNlID09PSAnR01UOicpIHtcbiAgICAgICAgICBtYXNrID0gbWFzay5zbGljZSg0KTtcbiAgICAgICAgICB1dGMgPSB0cnVlO1xuICAgICAgICAgIGlmIChtYXNrU2xpY2UgPT09ICdHTVQ6Jykge1xuICAgICAgICAgICAgZ210ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBfID0gdXRjID8gJ2dldFVUQycgOiAnZ2V0JztcbiAgICAgICAgdmFyIGQgPSBkYXRlW18gKyAnRGF0ZSddKCk7XG4gICAgICAgIHZhciBEID0gZGF0ZVtfICsgJ0RheSddKCk7XG4gICAgICAgIHZhciBtID0gZGF0ZVtfICsgJ01vbnRoJ10oKTtcbiAgICAgICAgdmFyIHkgPSBkYXRlW18gKyAnRnVsbFllYXInXSgpO1xuICAgICAgICB2YXIgSCA9IGRhdGVbXyArICdIb3VycyddKCk7XG4gICAgICAgIHZhciBNID0gZGF0ZVtfICsgJ01pbnV0ZXMnXSgpO1xuICAgICAgICB2YXIgcyA9IGRhdGVbXyArICdTZWNvbmRzJ10oKTtcbiAgICAgICAgdmFyIEwgPSBkYXRlW18gKyAnTWlsbGlzZWNvbmRzJ10oKTtcbiAgICAgICAgdmFyIG8gPSB1dGMgPyAwIDogZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICB2YXIgVyA9IGdldFdlZWsoZGF0ZSk7XG4gICAgICAgIHZhciBOID0gZ2V0RGF5T2ZXZWVrKGRhdGUpO1xuICAgICAgICB2YXIgZmxhZ3MgPSB7XG4gICAgICAgICAgZDogICAgZCxcbiAgICAgICAgICBkZDogICBwYWQoZCksXG4gICAgICAgICAgZGRkOiAgZGF0ZUZvcm1hdC5pMThuLmRheU5hbWVzW0RdLFxuICAgICAgICAgIGRkZGQ6IGRhdGVGb3JtYXQuaTE4bi5kYXlOYW1lc1tEICsgN10sXG4gICAgICAgICAgbTogICAgbSArIDEsXG4gICAgICAgICAgbW06ICAgcGFkKG0gKyAxKSxcbiAgICAgICAgICBtbW06ICBkYXRlRm9ybWF0LmkxOG4ubW9udGhOYW1lc1ttXSxcbiAgICAgICAgICBtbW1tOiBkYXRlRm9ybWF0LmkxOG4ubW9udGhOYW1lc1ttICsgMTJdLFxuICAgICAgICAgIHl5OiAgIFN0cmluZyh5KS5zbGljZSgyKSxcbiAgICAgICAgICB5eXl5OiB5LFxuICAgICAgICAgIGg6ICAgIEggJSAxMiB8fCAxMixcbiAgICAgICAgICBoaDogICBwYWQoSCAlIDEyIHx8IDEyKSxcbiAgICAgICAgICBIOiAgICBILFxuICAgICAgICAgIEhIOiAgIHBhZChIKSxcbiAgICAgICAgICBNOiAgICBNLFxuICAgICAgICAgIE1NOiAgIHBhZChNKSxcbiAgICAgICAgICBzOiAgICBzLFxuICAgICAgICAgIHNzOiAgIHBhZChzKSxcbiAgICAgICAgICBsOiAgICBwYWQoTCwgMyksXG4gICAgICAgICAgTDogICAgcGFkKE1hdGgucm91bmQoTCAvIDEwKSksXG4gICAgICAgICAgdDogICAgSCA8IDEyID8gZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1swXSA6IGRhdGVGb3JtYXQuaTE4bi50aW1lTmFtZXNbMV0sXG4gICAgICAgICAgdHQ6ICAgSCA8IDEyID8gZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1syXSA6IGRhdGVGb3JtYXQuaTE4bi50aW1lTmFtZXNbM10sXG4gICAgICAgICAgVDogICAgSCA8IDEyID8gZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1s0XSA6IGRhdGVGb3JtYXQuaTE4bi50aW1lTmFtZXNbNV0sXG4gICAgICAgICAgVFQ6ICAgSCA8IDEyID8gZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1s2XSA6IGRhdGVGb3JtYXQuaTE4bi50aW1lTmFtZXNbN10sXG4gICAgICAgICAgWjogICAgZ210ID8gJ0dNVCcgOiB1dGMgPyAnVVRDJyA6IChTdHJpbmcoZGF0ZSkubWF0Y2godGltZXpvbmUpIHx8IFsnJ10pLnBvcCgpLnJlcGxhY2UodGltZXpvbmVDbGlwLCAnJyksXG4gICAgICAgICAgbzogICAgKG8gPiAwID8gJy0nIDogJysnKSArIHBhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApICogMTAwICsgTWF0aC5hYnMobykgJSA2MCwgNCksXG4gICAgICAgICAgUzogICAgWyd0aCcsICdzdCcsICduZCcsICdyZCddW2QgJSAxMCA+IDMgPyAwIDogKGQgJSAxMDAgLSBkICUgMTAgIT0gMTApICogZCAlIDEwXSxcbiAgICAgICAgICBXOiAgICBXLFxuICAgICAgICAgIE46ICAgIE5cbiAgICAgICAgfTtcbiAgXG4gICAgICAgIHJldHVybiBtYXNrLnJlcGxhY2UodG9rZW4sIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIGlmIChtYXRjaCBpbiBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIGZsYWdzW21hdGNoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDEsIG1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICBkYXRlRm9ybWF0Lm1hc2tzID0ge1xuICAgICdkZWZhdWx0JzogICAgICAgICAgICAgICAnZGRkIG1tbSBkZCB5eXl5IEhIOk1NOnNzJyxcbiAgICAnc2hvcnREYXRlJzogICAgICAgICAgICAgJ20vZC95eScsXG4gICAgJ21lZGl1bURhdGUnOiAgICAgICAgICAgICdtbW0gZCwgeXl5eScsXG4gICAgJ2xvbmdEYXRlJzogICAgICAgICAgICAgICdtbW1tIGQsIHl5eXknLFxuICAgICdmdWxsRGF0ZSc6ICAgICAgICAgICAgICAnZGRkZCwgbW1tbSBkLCB5eXl5JyxcbiAgICAnc2hvcnRUaW1lJzogICAgICAgICAgICAgJ2g6TU0gVFQnLFxuICAgICdtZWRpdW1UaW1lJzogICAgICAgICAgICAnaDpNTTpzcyBUVCcsXG4gICAgJ2xvbmdUaW1lJzogICAgICAgICAgICAgICdoOk1NOnNzIFRUIFonLFxuICAgICdpc29EYXRlJzogICAgICAgICAgICAgICAneXl5eS1tbS1kZCcsXG4gICAgJ2lzb1RpbWUnOiAgICAgICAgICAgICAgICdISDpNTTpzcycsXG4gICAgJ2lzb0RhdGVUaW1lJzogICAgICAgICAgICd5eXl5LW1tLWRkXFwnVFxcJ0hIOk1NOnNzbycsXG4gICAgJ2lzb1V0Y0RhdGVUaW1lJzogICAgICAgICdVVEM6eXl5eS1tbS1kZFxcJ1RcXCdISDpNTTpzc1xcJ1pcXCcnLFxuICAgICdleHBpcmVzSGVhZGVyRm9ybWF0JzogICAnZGRkLCBkZCBtbW0geXl5eSBISDpNTTpzcyBaJ1xuICB9O1xuXG4gIC8vIEludGVybmF0aW9uYWxpemF0aW9uIHN0cmluZ3NcbiAgZGF0ZUZvcm1hdC5pMThuID0ge1xuICAgIGRheU5hbWVzOiBbXG4gICAgICAnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0JyxcbiAgICAgICdTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSdcbiAgICBdLFxuICAgIG1vbnRoTmFtZXM6IFtcbiAgICAgICdKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYycsXG4gICAgICAnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlcidcbiAgICBdLFxuICAgIHRpbWVOYW1lczogW1xuICAgICAgJ2EnLCAncCcsICdhbScsICdwbScsICdBJywgJ1AnLCAnQU0nLCAnUE0nXG4gICAgXVxuICB9O1xuXG5mdW5jdGlvbiBwYWQodmFsLCBsZW4pIHtcbiAgdmFsID0gU3RyaW5nKHZhbCk7XG4gIGxlbiA9IGxlbiB8fCAyO1xuICB3aGlsZSAodmFsLmxlbmd0aCA8IGxlbikge1xuICAgIHZhbCA9ICcwJyArIHZhbDtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIEdldCB0aGUgSVNPIDg2MDEgd2VlayBudW1iZXJcbiAqIEJhc2VkIG9uIGNvbW1lbnRzIGZyb21cbiAqIGh0dHA6Ly90ZWNoYmxvZy5wcm9jdXJpb3Mubmwvay9uNjE4L25ld3Mvdmlldy8zMzc5Ni8xNDg2My9DYWxjdWxhdGUtSVNPLTg2MDEtd2Vlay1hbmQteWVhci1pbi1qYXZhc2NyaXB0Lmh0bWxcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBkYXRlYFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRXZWVrKGRhdGUpIHtcbiAgLy8gUmVtb3ZlIHRpbWUgY29tcG9uZW50cyBvZiBkYXRlXG4gIHZhciB0YXJnZXRUaHVyc2RheSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG5cbiAgLy8gQ2hhbmdlIGRhdGUgdG8gVGh1cnNkYXkgc2FtZSB3ZWVrXG4gIHRhcmdldFRodXJzZGF5LnNldERhdGUodGFyZ2V0VGh1cnNkYXkuZ2V0RGF0ZSgpIC0gKCh0YXJnZXRUaHVyc2RheS5nZXREYXkoKSArIDYpICUgNykgKyAzKTtcblxuICAvLyBUYWtlIEphbnVhcnkgNHRoIGFzIGl0IGlzIGFsd2F5cyBpbiB3ZWVrIDEgKHNlZSBJU08gODYwMSlcbiAgdmFyIGZpcnN0VGh1cnNkYXkgPSBuZXcgRGF0ZSh0YXJnZXRUaHVyc2RheS5nZXRGdWxsWWVhcigpLCAwLCA0KTtcblxuICAvLyBDaGFuZ2UgZGF0ZSB0byBUaHVyc2RheSBzYW1lIHdlZWtcbiAgZmlyc3RUaHVyc2RheS5zZXREYXRlKGZpcnN0VGh1cnNkYXkuZ2V0RGF0ZSgpIC0gKChmaXJzdFRodXJzZGF5LmdldERheSgpICsgNikgJSA3KSArIDMpO1xuXG4gIC8vIENoZWNrIGlmIGRheWxpZ2h0LXNhdmluZy10aW1lLXN3aXRjaCBvY2N1cnJlZCBhbmQgY29ycmVjdCBmb3IgaXRcbiAgdmFyIGRzID0gdGFyZ2V0VGh1cnNkYXkuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIGZpcnN0VGh1cnNkYXkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgdGFyZ2V0VGh1cnNkYXkuc2V0SG91cnModGFyZ2V0VGh1cnNkYXkuZ2V0SG91cnMoKSAtIGRzKTtcblxuICAvLyBOdW1iZXIgb2Ygd2Vla3MgYmV0d2VlbiB0YXJnZXQgVGh1cnNkYXkgYW5kIGZpcnN0IFRodXJzZGF5XG4gIHZhciB3ZWVrRGlmZiA9ICh0YXJnZXRUaHVyc2RheSAtIGZpcnN0VGh1cnNkYXkpIC8gKDg2NDAwMDAwKjcpO1xuICByZXR1cm4gMSArIE1hdGguZmxvb3Iod2Vla0RpZmYpO1xufVxuXG4vKipcbiAqIEdldCBJU08tODYwMSBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAqIDEgKGZvciBNb25kYXkpIHRocm91Z2ggNyAoZm9yIFN1bmRheSlcbiAqIFxuICogQHBhcmFtICB7T2JqZWN0fSBgZGF0ZWBcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0RGF5T2ZXZWVrKGRhdGUpIHtcbiAgdmFyIGRvdyA9IGRhdGUuZ2V0RGF5KCk7XG4gIGlmKGRvdyA9PT0gMCkge1xuICAgIGRvdyA9IDc7XG4gIH1cbiAgcmV0dXJuIGRvdztcbn1cblxuLyoqXG4gKiBraW5kLW9mIHNob3J0Y3V0XG4gKiBAcGFyYW0gIHsqfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuXG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlb2YgdmFsO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG5cbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwodmFsKVxuICAgIC5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcbn07XG5cblxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRhdGVGb3JtYXQ7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkYXRlRm9ybWF0O1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbC5kYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdDtcbiAgfVxufSkodGhpcyk7XG4iLCIvKiFcbiAqIHJlcGVhdC1zdHJpbmcgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3JlcGVhdC1zdHJpbmc+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXN1bHRzIGNhY2hlXG4gKi9cblxudmFyIHJlcyA9ICcnO1xudmFyIGNhY2hlO1xuXG4vKipcbiAqIEV4cG9zZSBgcmVwZWF0YFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVwZWF0O1xuXG4vKipcbiAqIFJlcGVhdCB0aGUgZ2l2ZW4gYHN0cmluZ2AgdGhlIHNwZWNpZmllZCBgbnVtYmVyYFxuICogb2YgdGltZXMuXG4gKlxuICogKipFeGFtcGxlOioqXG4gKlxuICogYGBganNcbiAqIHZhciByZXBlYXQgPSByZXF1aXJlKCdyZXBlYXQtc3RyaW5nJyk7XG4gKiByZXBlYXQoJ0EnLCA1KTtcbiAqIC8vPT4gQUFBQUFcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBUaGUgc3RyaW5nIHRvIHJlcGVhdFxuICogQHBhcmFtIHtOdW1iZXJ9IGBudW1iZXJgIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gUmVwZWF0ZWQgc3RyaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIG51bSkge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgLy8gY292ZXIgY29tbW9uLCBxdWljayB1c2UgY2FzZXNcbiAgaWYgKG51bSA9PT0gMSkgcmV0dXJuIHN0cjtcbiAgaWYgKG51bSA9PT0gMikgcmV0dXJuIHN0ciArIHN0cjtcblxuICB2YXIgbWF4ID0gc3RyLmxlbmd0aCAqIG51bTtcbiAgaWYgKGNhY2hlICE9PSBzdHIgfHwgdHlwZW9mIGNhY2hlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNhY2hlID0gc3RyO1xuICAgIHJlcyA9ICcnO1xuICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPj0gbWF4KSB7XG4gICAgcmV0dXJuIHJlcy5zdWJzdHIoMCwgbWF4KTtcbiAgfVxuXG4gIHdoaWxlIChtYXggPiByZXMubGVuZ3RoICYmIG51bSA+IDEpIHtcbiAgICBpZiAobnVtICYgMSkge1xuICAgICAgcmVzICs9IHN0cjtcbiAgICB9XG5cbiAgICBudW0gPj49IDE7XG4gICAgc3RyICs9IHN0cjtcbiAgfVxuXG4gIHJlcyArPSBzdHI7XG4gIHJlcyA9IHJlcy5zdWJzdHIoMCwgbWF4KTtcbiAgcmV0dXJuIHJlcztcbn1cbiIsIi8qIVxuICogcGFkLWxlZnQgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3BhZC1sZWZ0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXBlYXQgPSByZXF1aXJlKCdyZXBlYXQtc3RyaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFkTGVmdChzdHIsIG51bSwgY2gpIHtcbiAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XG5cbiAgaWYgKHR5cGVvZiBudW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMCkge1xuICAgIGNoID0gJzAnO1xuICB9IGVsc2UgaWYgKGNoKSB7XG4gICAgY2ggPSBjaC50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIGNoID0gJyAnO1xuICB9XG5cbiAgcmV0dXJuIHJlcGVhdChjaCwgbnVtIC0gc3RyLmxlbmd0aCkgKyBzdHI7XG59O1xuIiwiaW1wb3J0IGRhdGVmb3JtYXQgZnJvbSAnZGF0ZWZvcm1hdCc7XG5pbXBvcnQgYXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nO1xuaW1wb3J0IHBhZExlZnQgZnJvbSAncGFkLWxlZnQnO1xuaW1wb3J0IHsgZ2V0Q2xpZW50QVBJIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xubGV0IGxpbms7XG5sZXQgZGVmYXVsdEV4dHMgPSB7IGV4dGVuc2lvbjogJycsIHByZWZpeDogJycsIHN1ZmZpeDogJycgfTtcblxuLy8gQWx0ZXJuYXRpdmUgc29sdXRpb24gZm9yIHNhdmluZyBmaWxlcyxcbi8vIGEgYml0IHNsb3dlciBhbmQgZG9lcyBub3Qgd29yayBpbiBTYWZhcmlcbi8vIGZ1bmN0aW9uIGZldGNoQmxvYkZyb21EYXRhVVJMIChkYXRhVVJMKSB7XG4vLyAgIHJldHVybiB3aW5kb3cuZmV0Y2goZGF0YVVSTCkudGhlbihyZXMgPT4gcmVzLmJsb2IoKSk7XG4vLyB9XG5cbmNvbnN0IHN1cHBvcnRlZEVuY29kaW5ncyA9IFtcbiAgJ2ltYWdlL3BuZycsXG4gICdpbWFnZS9qcGVnJyxcbiAgJ2ltYWdlL3dlYnAnXG5dO1xuXG5mdW5jdGlvbiBzdHJlYW0gKGlzU3RhcnQsIG9wdHMgPSB7fSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG9wdHMgPSBhc3NpZ24oe30sIGRlZmF1bHRFeHRzLCBvcHRzKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHJlc29sdmVGaWxlbmFtZShPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICBleHRlbnNpb246ICcnLFxuICAgICAgZnJhbWU6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgICBjb25zdCBmdW5jID0gaXNTdGFydCA/ICdzdHJlYW1TdGFydCcgOiAnc3RyZWFtRW5kJztcbiAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgICBpZiAoY2xpZW50ICYmIGNsaWVudC5vdXRwdXQgJiYgdHlwZW9mIGNsaWVudFtmdW5jXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNsaWVudFtmdW5jXShhc3NpZ24oe30sIG9wdHMsIHsgZmlsZW5hbWUgfSkpXG4gICAgICAgIC50aGVuKGV2ID0+IHJlc29sdmUoZXYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc29sdmUoeyBmaWxlbmFtZSwgY2xpZW50OiBmYWxzZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtU3RhcnQgKG9wdHMgPSB7fSkge1xuICByZXR1cm4gc3RyZWFtKHRydWUsIG9wdHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtRW5kIChvcHRzID0ge30pIHtcbiAgcmV0dXJuIHN0cmVhbShmYWxzZSwgb3B0cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRDYW52YXMgKGNhbnZhcywgb3B0ID0ge30pIHtcbiAgY29uc3QgZW5jb2RpbmcgPSBvcHQuZW5jb2RpbmcgfHwgJ2ltYWdlL3BuZyc7XG4gIGlmICghc3VwcG9ydGVkRW5jb2RpbmdzLmluY2x1ZGVzKGVuY29kaW5nKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNhbnZhcyBlbmNvZGluZyAke2VuY29kaW5nfWApO1xuICBsZXQgZXh0ZW5zaW9uID0gKGVuY29kaW5nLnNwbGl0KCcvJylbMV0gfHwgJycpLnJlcGxhY2UoL2pwZWcvaSwgJ2pwZycpO1xuICBpZiAoZXh0ZW5zaW9uKSBleHRlbnNpb24gPSBgLiR7ZXh0ZW5zaW9ufWAudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHtcbiAgICBleHRlbnNpb24sXG4gICAgdHlwZTogZW5jb2RpbmcsXG4gICAgZGF0YVVSTDogY2FudmFzLnRvRGF0YVVSTChlbmNvZGluZywgb3B0LmVuY29kaW5nUXVhbGl0eSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmxvYkZyb21EYXRhVVJMIChkYXRhVVJMKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHNwbGl0SW5kZXggPSBkYXRhVVJMLmluZGV4T2YoJywnKTtcbiAgICBpZiAoc3BsaXRJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJlc29sdmUobmV3IHdpbmRvdy5CbG9iKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiYXNlNjQgPSBkYXRhVVJMLnNsaWNlKHNwbGl0SW5kZXggKyAxKTtcbiAgICBjb25zdCBieXRlU3RyaW5nID0gd2luZG93LmF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCB0eXBlID0gZGF0YVVSTC5zbGljZSgwLCBzcGxpdEluZGV4KTtcbiAgICBjb25zdCBtaW1lTWF0Y2ggPSAvZGF0YTooW147XSspLy5leGVjKHR5cGUpO1xuICAgIGNvbnN0IG1pbWUgPSAobWltZU1hdGNoID8gbWltZU1hdGNoWzFdIDogJycpIHx8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhYiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgY29uc3QgaWEgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShuZXcgd2luZG93LkJsb2IoWyBhYiBdLCB7IHR5cGU6IG1pbWUgfSkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVEYXRhVVJMIChkYXRhVVJMLCBvcHRzID0ge30pIHtcbiAgcmV0dXJuIGNyZWF0ZUJsb2JGcm9tRGF0YVVSTChkYXRhVVJMKVxuICAgIC50aGVuKGJsb2IgPT4gc2F2ZUJsb2IoYmxvYiwgb3B0cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUJsb2IgKGJsb2IsIG9wdHMgPSB7fSkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgb3B0cyA9IGFzc2lnbih7fSwgZGVmYXVsdEV4dHMsIG9wdHMpO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gb3B0cy5maWxlbmFtZTtcblxuICAgIGNvbnN0IGNsaWVudCA9IGdldENsaWVudEFQSSgpO1xuICAgIGlmIChjbGllbnQgJiYgdHlwZW9mIGNsaWVudC5zYXZlQmxvYiA9PT0gJ2Z1bmN0aW9uJyAmJiBjbGllbnQub3V0cHV0KSB7XG4gICAgICAvLyBuYXRpdmUgc2F2aW5nIHVzaW5nIGEgQ0xJIHRvb2xcbiAgICAgIHJldHVybiBjbGllbnQuc2F2ZUJsb2IoYmxvYiwgYXNzaWduKHt9LCBvcHRzLCB7IGZpbGVuYW1lIH0pKVxuICAgICAgICAudGhlbihldiA9PiByZXNvbHZlKGV2KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvcmNlIGRvd25sb2FkXG4gICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgbGluay5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGxpbmsudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICB9XG4gICAgICBsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XG4gICAgICBsaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgIGxpbmsub25jbGljayA9IG5vb3A7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgIGlmIChsaW5rLnBhcmVudEVsZW1lbnQpIGxpbmsucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgICBsaW5rLnJlbW92ZUF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgIHJlc29sdmUoeyBmaWxlbmFtZSwgY2xpZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgbGluay5jbGljaygpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlRmlsZSAoZGF0YSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHBhcnRzID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbIGRhdGEgXTtcbiAgY29uc3QgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihwYXJ0cywgeyB0eXBlOiBvcHRzLnR5cGUgfHwgJycgfSk7XG4gIHJldHVybiBzYXZlQmxvYihibG9iLCBvcHRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbWVTdGFtcCAoKSB7XG4gIGNvbnN0IGRhdGVGb3JtYXRTdHIgPSBgeXl5eS5tbS5kZC1ISC5NTS5zc2A7XG4gIHJldHVybiBkYXRlZm9ybWF0KG5ldyBEYXRlKCksIGRhdGVGb3JtYXRTdHIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEZpbGUgKHByZWZpeCA9ICcnLCBzdWZmaXggPSAnJywgZXh0KSB7XG4gIC8vIGNvbnN0IGRhdGVGb3JtYXRTdHIgPSBgeXl5eS5tbS5kZC1ISC5NTS5zc2A7XG4gIGNvbnN0IGRhdGVGb3JtYXRTdHIgPSBgeXl5eS1tbS1kZCAnYXQnIGguTU0uc3MgVFRgO1xuICByZXR1cm4gYCR7cHJlZml4fSR7ZGF0ZWZvcm1hdChuZXcgRGF0ZSgpLCBkYXRlRm9ybWF0U3RyKX0ke3N1ZmZpeH0ke2V4dH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUZpbGVuYW1lIChvcHQgPSB7fSkge1xuICBvcHQgPSBhc3NpZ24oe30sIG9wdCk7XG5cbiAgLy8gQ3VzdG9tIGZpbGVuYW1lIGZ1bmN0aW9uXG4gIGlmICh0eXBlb2Ygb3B0LmZpbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0LmZpbGUob3B0KTtcbiAgfSBlbHNlIGlmIChvcHQuZmlsZSkge1xuICAgIHJldHVybiBvcHQuZmlsZTtcbiAgfVxuXG4gIGxldCBmcmFtZSA9IG51bGw7XG4gIGxldCBleHRlbnNpb24gPSAnJztcbiAgaWYgKHR5cGVvZiBvcHQuZXh0ZW5zaW9uID09PSAnc3RyaW5nJykgZXh0ZW5zaW9uID0gb3B0LmV4dGVuc2lvbjtcblxuICBpZiAodHlwZW9mIG9wdC5mcmFtZSA9PT0gJ251bWJlcicpIHtcbiAgICBsZXQgdG90YWxGcmFtZXM7XG4gICAgaWYgKHR5cGVvZiBvcHQudG90YWxGcmFtZXMgPT09ICdudW1iZXInKSB7XG4gICAgICB0b3RhbEZyYW1lcyA9IG9wdC50b3RhbEZyYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdG90YWxGcmFtZXMgPSBNYXRoLm1heCgxMDAwMCwgb3B0LmZyYW1lKTtcbiAgICB9XG4gICAgZnJhbWUgPSBwYWRMZWZ0KFN0cmluZyhvcHQuZnJhbWUpLCBTdHJpbmcodG90YWxGcmFtZXMpLmxlbmd0aCwgJzAnKTtcbiAgfVxuXG4gIGNvbnN0IGxheWVyU3RyID0gaXNGaW5pdGUob3B0LnRvdGFsTGF5ZXJzKSAmJiBpc0Zpbml0ZShvcHQubGF5ZXIpICYmIG9wdC50b3RhbExheWVycyA+IDEgPyBgJHtvcHQubGF5ZXJ9YCA6ICcnO1xuICBpZiAoZnJhbWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBbIGxheWVyU3RyLCBmcmFtZSBdLmZpbHRlcihCb29sZWFuKS5qb2luKCctJykgKyBleHRlbnNpb247XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVmYXVsdEZpbGVOYW1lID0gb3B0LnRpbWVTdGFtcDtcbiAgICByZXR1cm4gWyBvcHQucHJlZml4LCBvcHQubmFtZSB8fCBkZWZhdWx0RmlsZU5hbWUsIGxheWVyU3RyLCBvcHQuaGFzaCwgb3B0LnN1ZmZpeCBdLmZpbHRlcihCb29sZWFuKS5qb2luKCctJykgKyBleHRlbnNpb247XG4gIH1cbn1cbiIsIi8vIEhhbmRsZSBzb21lIGNvbW1vbiB0eXBvc1xuY29uc3QgY29tbW9uVHlwb3MgPSB7XG4gIGRpbWVuc2lvbjogJ2RpbWVuc2lvbnMnLFxuICBhbmltYXRlZDogJ2FuaW1hdGUnLFxuICBhbmltYXRpbmc6ICdhbmltYXRlJyxcbiAgdW5pdDogJ3VuaXRzJyxcbiAgUDU6ICdwNScsXG4gIHBpeGVsbGF0ZWQ6ICdwaXhlbGF0ZWQnLFxuICBsb29waW5nOiAnbG9vcCcsXG4gIHBpeGVsUGVySW5jaDogJ3BpeGVscydcbn07XG5cbi8vIEhhbmRsZSBhbGwgb3RoZXIgdHlwb3NcbmNvbnN0IGFsbEtleXMgPSBbXG4gICdkaW1lbnNpb25zJywgJ3VuaXRzJywgJ3BpeGVsc1BlckluY2gnLCAnb3JpZW50YXRpb24nLFxuICAnc2NhbGVUb0ZpdCcsICdzY2FsZVRvVmlldycsICdibGVlZCcsICdwaXhlbFJhdGlvJyxcbiAgJ2V4cG9ydFBpeGVsUmF0aW8nLCAnbWF4UGl4ZWxSYXRpbycsICdzY2FsZUNvbnRleHQnLFxuICAncmVzaXplQ2FudmFzJywgJ3N0eWxlQ2FudmFzJywgJ2NhbnZhcycsICdjb250ZXh0JywgJ2F0dHJpYnV0ZXMnLFxuICAncGFyZW50JywgJ2ZpbGUnLCAnbmFtZScsICdwcmVmaXgnLCAnc3VmZml4JywgJ2FuaW1hdGUnLCAncGxheWluZycsXG4gICdsb29wJywgJ2R1cmF0aW9uJywgJ3RvdGFsRnJhbWVzJywgJ2ZwcycsICdwbGF5YmFja1JhdGUnLCAndGltZVNjYWxlJyxcbiAgJ2ZyYW1lJywgJ3RpbWUnLCAnZmx1c2gnLCAncGl4ZWxhdGVkJywgJ2hvdGtleXMnLCAncDUnLCAnaWQnLFxuICAnc2NhbGVUb0ZpdFBhZGRpbmcnLCAnZGF0YScsICdwYXJhbXMnLCAnZW5jb2RpbmcnLCAnZW5jb2RpbmdRdWFsaXR5J1xuXTtcblxuLy8gVGhpcyBpcyBmYWlybHkgb3BpbmlvbmF0ZWQgYW5kIGZvcmNlcyB1c2VycyB0byB1c2UgdGhlICdkYXRhJyBwYXJhbWV0ZXJcbi8vIGlmIHRoZXkgd2FudCB0byBwYXNzIGFsb25nIG5vbi1zZXR0aW5nIG9iamVjdHMuLi5cbmV4cG9ydCBjb25zdCBjaGVja1NldHRpbmdzID0gKHNldHRpbmdzKSA9PiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncyk7XG4gIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChrZXkgaW4gY29tbW9uVHlwb3MpIHtcbiAgICAgIGNvbnN0IGFjdHVhbCA9IGNvbW1vblR5cG9zW2tleV07XG4gICAgICBjb25zb2xlLndhcm4oYFtjYW52YXMtc2tldGNoXSBDb3VsZCBub3QgcmVjb2duaXplIHRoZSBzZXR0aW5nIFwiJHtrZXl9XCIsIGRpZCB5b3UgbWVhbiBcIiR7YWN0dWFsfVwiP2ApO1xuICAgIH0gZWxzZSBpZiAoIWFsbEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29uc29sZS53YXJuKGBbY2FudmFzLXNrZXRjaF0gQ291bGQgbm90IHJlY29nbml6ZSB0aGUgc2V0dGluZyBcIiR7a2V5fVwiYCk7XG4gICAgfVxuICB9KTtcbn07XG4iLCJpbXBvcnQgeyBnZXRDbGllbnRBUEkgfSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG9wdCA9IHt9KSB7XG4gIGNvbnN0IGhhbmRsZXIgPSBldiA9PiB7XG4gICAgaWYgKCFvcHQuZW5hYmxlZCgpKSByZXR1cm47XG5cbiAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gODMgJiYgIWV2LmFsdEtleSAmJiAoZXYubWV0YUtleSB8fCBldi5jdHJsS2V5KSkge1xuICAgICAgLy8gQ21kICsgU1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9wdC5zYXZlKGV2KTtcbiAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT09IDMyKSB7XG4gICAgICAvLyBTcGFjZVxuICAgICAgLy8gVE9ETzogd2hhdCB0byBkbyB3aXRoIHRoaXM/IGtlZXAgaXQsIG9yIHJlbW92ZSBpdD9cbiAgICAgIG9wdC50b2dnbGVQbGF5KGV2KTtcbiAgICB9IGVsc2UgaWYgKGNsaWVudCAmJiAhZXYuYWx0S2V5ICYmIGV2LmtleUNvZGUgPT09IDc1ICYmIChldi5tZXRhS2V5IHx8IGV2LmN0cmxLZXkpKSB7XG4gICAgICAvLyBDbWQgKyBLLCBvbmx5IHdoZW4gY2FudmFzLXNrZXRjaC1jbGkgaXMgdXNlZFxuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9wdC5jb21taXQoZXYpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhdHRhY2ggPSAoKSA9PiB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgfTtcblxuICBjb25zdCBkZXRhY2ggPSAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGF0dGFjaCxcbiAgICBkZXRhY2hcbiAgfTtcbn1cbiIsImNvbnN0IGRlZmF1bHRVbml0cyA9ICdtbSc7XG5cbmNvbnN0IGRhdGEgPSBbXG4gIC8vIENvbW1vbiBQYXBlciBTaXplc1xuICAvLyAoTW9zdGx5IE5vcnRoLUFtZXJpY2FuIGJhc2VkKVxuICBbICdwb3N0Y2FyZCcsIDEwMS42LCAxNTIuNCBdLFxuICBbICdwb3N0ZXItc21hbGwnLCAyODAsIDQzMCBdLFxuICBbICdwb3N0ZXInLCA0NjAsIDYxMCBdLFxuICBbICdwb3N0ZXItbGFyZ2UnLCA2MTAsIDkxMCBdLFxuICBbICdidXNpbmVzcy1jYXJkJywgNTAuOCwgODguOSBdLFxuXG4gIC8vIFBob3RvZ3JhcGhpYyBQcmludCBQYXBlciBTaXplc1xuICBbICcycicsIDY0LCA4OSBdLFxuICBbICczcicsIDg5LCAxMjcgXSxcbiAgWyAnNHInLCAxMDIsIDE1MiBdLFxuICBbICc1cicsIDEyNywgMTc4IF0sIC8vIDXigLN4N+KAs1xuICBbICc2cicsIDE1MiwgMjAzIF0sIC8vIDbigLN4OOKAs1xuICBbICc4cicsIDIwMywgMjU0IF0sIC8vIDjigLN4MTDigLNcbiAgWyAnMTByJywgMjU0LCAzMDUgXSwgLy8gMTDigLN4MTLigLNcbiAgWyAnMTFyJywgMjc5LCAzNTYgXSwgLy8gMTHigLN4MTTigLNcbiAgWyAnMTJyJywgMzA1LCAzODEgXSxcblxuICAvLyBTdGFuZGFyZCBQYXBlciBTaXplc1xuICBbICdhMCcsIDg0MSwgMTE4OSBdLFxuICBbICdhMScsIDU5NCwgODQxIF0sXG4gIFsgJ2EyJywgNDIwLCA1OTQgXSxcbiAgWyAnYTMnLCAyOTcsIDQyMCBdLFxuICBbICdhNCcsIDIxMCwgMjk3IF0sXG4gIFsgJ2E1JywgMTQ4LCAyMTAgXSxcbiAgWyAnYTYnLCAxMDUsIDE0OCBdLFxuICBbICdhNycsIDc0LCAxMDUgXSxcbiAgWyAnYTgnLCA1MiwgNzQgXSxcbiAgWyAnYTknLCAzNywgNTIgXSxcbiAgWyAnYTEwJywgMjYsIDM3IF0sXG4gIFsgJzJhMCcsIDExODksIDE2ODIgXSxcbiAgWyAnNGEwJywgMTY4MiwgMjM3OCBdLFxuICBbICdiMCcsIDEwMDAsIDE0MTQgXSxcbiAgWyAnYjEnLCA3MDcsIDEwMDAgXSxcbiAgWyAnYjErJywgNzIwLCAxMDIwIF0sXG4gIFsgJ2IyJywgNTAwLCA3MDcgXSxcbiAgWyAnYjIrJywgNTIwLCA3MjAgXSxcbiAgWyAnYjMnLCAzNTMsIDUwMCBdLFxuICBbICdiNCcsIDI1MCwgMzUzIF0sXG4gIFsgJ2I1JywgMTc2LCAyNTAgXSxcbiAgWyAnYjYnLCAxMjUsIDE3NiBdLFxuICBbICdiNycsIDg4LCAxMjUgXSxcbiAgWyAnYjgnLCA2MiwgODggXSxcbiAgWyAnYjknLCA0NCwgNjIgXSxcbiAgWyAnYjEwJywgMzEsIDQ0IF0sXG4gIFsgJ2IxMScsIDIyLCAzMiBdLFxuICBbICdiMTInLCAxNiwgMjIgXSxcbiAgWyAnYzAnLCA5MTcsIDEyOTcgXSxcbiAgWyAnYzEnLCA2NDgsIDkxNyBdLFxuICBbICdjMicsIDQ1OCwgNjQ4IF0sXG4gIFsgJ2MzJywgMzI0LCA0NTggXSxcbiAgWyAnYzQnLCAyMjksIDMyNCBdLFxuICBbICdjNScsIDE2MiwgMjI5IF0sXG4gIFsgJ2M2JywgMTE0LCAxNjIgXSxcbiAgWyAnYzcnLCA4MSwgMTE0IF0sXG4gIFsgJ2M4JywgNTcsIDgxIF0sXG4gIFsgJ2M5JywgNDAsIDU3IF0sXG4gIFsgJ2MxMCcsIDI4LCA0MCBdLFxuICBbICdjMTEnLCAyMiwgMzIgXSxcbiAgWyAnYzEyJywgMTYsIDIyIF0sXG5cbiAgLy8gVXNlIGluY2hlcyBmb3IgTm9ydGggQW1lcmljYW4gc2l6ZXMsXG4gIC8vIGFzIGl0IHByb2R1Y2VzIGxlc3MgZmxvYXQgcHJlY2lzaW9uIGVycm9yc1xuICBbICdoYWxmLWxldHRlcicsIDUuNSwgOC41LCAnaW4nIF0sXG4gIFsgJ2xldHRlcicsIDguNSwgMTEsICdpbicgXSxcbiAgWyAnbGVnYWwnLCA4LjUsIDE0LCAnaW4nIF0sXG4gIFsgJ2p1bmlvci1sZWdhbCcsIDUsIDgsICdpbicgXSxcbiAgWyAnbGVkZ2VyJywgMTEsIDE3LCAnaW4nIF0sXG4gIFsgJ3RhYmxvaWQnLCAxMSwgMTcsICdpbicgXSxcbiAgWyAnYW5zaS1hJywgOC41LCAxMS4wLCAnaW4nIF0sXG4gIFsgJ2Fuc2ktYicsIDExLjAsIDE3LjAsICdpbicgXSxcbiAgWyAnYW5zaS1jJywgMTcuMCwgMjIuMCwgJ2luJyBdLFxuICBbICdhbnNpLWQnLCAyMi4wLCAzNC4wLCAnaW4nIF0sXG4gIFsgJ2Fuc2ktZScsIDM0LjAsIDQ0LjAsICdpbicgXSxcbiAgWyAnYXJjaC1hJywgOSwgMTIsICdpbicgXSxcbiAgWyAnYXJjaC1iJywgMTIsIDE4LCAnaW4nIF0sXG4gIFsgJ2FyY2gtYycsIDE4LCAyNCwgJ2luJyBdLFxuICBbICdhcmNoLWQnLCAyNCwgMzYsICdpbicgXSxcbiAgWyAnYXJjaC1lJywgMzYsIDQ4LCAnaW4nIF0sXG4gIFsgJ2FyY2gtZTEnLCAzMCwgNDIsICdpbicgXSxcbiAgWyAnYXJjaC1lMicsIDI2LCAzOCwgJ2luJyBdLFxuICBbICdhcmNoLWUzJywgMjcsIDM5LCAnaW4nIF1cbl07XG5cbmV4cG9ydCBkZWZhdWx0IGRhdGEucmVkdWNlKChkaWN0LCBwcmVzZXQpID0+IHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICB1bml0czogcHJlc2V0WzNdIHx8IGRlZmF1bHRVbml0cyxcbiAgICBkaW1lbnNpb25zOiBbIHByZXNldFsxXSwgcHJlc2V0WzJdIF1cbiAgfTtcbiAgZGljdFtwcmVzZXRbMF1dID0gaXRlbTtcbiAgZGljdFtwcmVzZXRbMF0ucmVwbGFjZSgvLS9nLCAnICcpXSA9IGl0ZW07XG4gIHJldHVybiBkaWN0O1xufSwge30pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbn07XG4iLCJ2YXIgZGVmaW5lZCA9IHJlcXVpcmUoJ2RlZmluZWQnKTtcbnZhciB1bml0cyA9IFsgJ21tJywgJ2NtJywgJ20nLCAncGMnLCAncHQnLCAnaW4nLCAnZnQnLCAncHgnIF07XG5cbnZhciBjb252ZXJzaW9ucyA9IHtcbiAgLy8gbWV0cmljXG4gIG06IHtcbiAgICBzeXN0ZW06ICdtZXRyaWMnLFxuICAgIGZhY3RvcjogMVxuICB9LFxuICBjbToge1xuICAgIHN5c3RlbTogJ21ldHJpYycsXG4gICAgZmFjdG9yOiAxIC8gMTAwXG4gIH0sXG4gIG1tOiB7XG4gICAgc3lzdGVtOiAnbWV0cmljJyxcbiAgICBmYWN0b3I6IDEgLyAxMDAwXG4gIH0sXG4gIC8vIGltcGVyaWFsXG4gIHB0OiB7XG4gICAgc3lzdGVtOiAnaW1wZXJpYWwnLFxuICAgIGZhY3RvcjogMSAvIDcyXG4gIH0sXG4gIHBjOiB7XG4gICAgc3lzdGVtOiAnaW1wZXJpYWwnLFxuICAgIGZhY3RvcjogMSAvIDZcbiAgfSxcbiAgaW46IHtcbiAgICBzeXN0ZW06ICdpbXBlcmlhbCcsXG4gICAgZmFjdG9yOiAxXG4gIH0sXG4gIGZ0OiB7XG4gICAgc3lzdGVtOiAnaW1wZXJpYWwnLFxuICAgIGZhY3RvcjogMTJcbiAgfVxufTtcblxuY29uc3QgYW5jaG9ycyA9IHtcbiAgbWV0cmljOiB7XG4gICAgdW5pdDogJ20nLFxuICAgIHJhdGlvOiAxIC8gMC4wMjU0XG4gIH0sXG4gIGltcGVyaWFsOiB7XG4gICAgdW5pdDogJ2luJyxcbiAgICByYXRpbzogMC4wMjU0XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJvdW5kICh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE51bWJlcihNYXRoLnJvdW5kKHZhbHVlICsgJ2UnICsgZGVjaW1hbHMpICsgJ2UtJyArIGRlY2ltYWxzKTtcbn1cblxuZnVuY3Rpb24gY29udmVydERpc3RhbmNlICh2YWx1ZSwgZnJvbVVuaXQsIHRvVW5pdCwgb3B0cykge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUodmFsdWUpKSB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyJyk7XG4gIGlmICghZnJvbVVuaXQgfHwgIXRvVW5pdCkgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgZnJvbSBhbmQgdG8gdW5pdHMnKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHBpeGVsc1BlckluY2ggPSBkZWZpbmVkKG9wdHMucGl4ZWxzUGVySW5jaCwgOTYpO1xuICB2YXIgcHJlY2lzaW9uID0gb3B0cy5wcmVjaXNpb247XG4gIHZhciByb3VuZFBpeGVsID0gb3B0cy5yb3VuZFBpeGVsICE9PSBmYWxzZTtcblxuICBmcm9tVW5pdCA9IGZyb21Vbml0LnRvTG93ZXJDYXNlKCk7XG4gIHRvVW5pdCA9IHRvVW5pdC50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmICh1bml0cy5pbmRleE9mKGZyb21Vbml0KSA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmcm9tIHVuaXQgXCInICsgZnJvbVVuaXQgKyAnXCIsIG11c3QgYmUgb25lIG9mOiAnICsgdW5pdHMuam9pbignLCAnKSk7XG4gIGlmICh1bml0cy5pbmRleE9mKHRvVW5pdCkgPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZnJvbSB1bml0IFwiJyArIHRvVW5pdCArICdcIiwgbXVzdCBiZSBvbmUgb2Y6ICcgKyB1bml0cy5qb2luKCcsICcpKTtcblxuICBpZiAoZnJvbVVuaXQgPT09IHRvVW5pdCkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29udmVydCBmcm9tIEEgdG8gQiBzaW5jZSB0aGV5IGFyZSB0aGUgc2FtZSBhbHJlYWR5XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIHRvRmFjdG9yID0gMTtcbiAgdmFyIGZyb21GYWN0b3IgPSAxO1xuICB2YXIgaXNUb1BpeGVsID0gZmFsc2U7XG5cbiAgaWYgKGZyb21Vbml0ID09PSAncHgnKSB7XG4gICAgZnJvbUZhY3RvciA9IDEgLyBwaXhlbHNQZXJJbmNoO1xuICAgIGZyb21Vbml0ID0gJ2luJztcbiAgfVxuICBpZiAodG9Vbml0ID09PSAncHgnKSB7XG4gICAgaXNUb1BpeGVsID0gdHJ1ZTtcbiAgICB0b0ZhY3RvciA9IHBpeGVsc1BlckluY2g7XG4gICAgdG9Vbml0ID0gJ2luJztcbiAgfVxuXG4gIHZhciBmcm9tVW5pdERhdGEgPSBjb252ZXJzaW9uc1tmcm9tVW5pdF07XG4gIHZhciB0b1VuaXREYXRhID0gY29udmVyc2lvbnNbdG9Vbml0XTtcblxuICAvLyBzb3VyY2UgdG8gYW5jaG9yIGluc2lkZSBzb3VyY2UncyBzeXN0ZW1cbiAgdmFyIGFuY2hvciA9IHZhbHVlICogZnJvbVVuaXREYXRhLmZhY3RvciAqIGZyb21GYWN0b3I7XG5cbiAgLy8gaWYgc3lzdGVtcyBkaWZmZXIsIGNvbnZlcnQgb25lIHRvIGFub3RoZXJcbiAgaWYgKGZyb21Vbml0RGF0YS5zeXN0ZW0gIT09IHRvVW5pdERhdGEuc3lzdGVtKSB7XG4gICAgLy8gcmVndWxhciAnbScgdG8gJ2luJyBhbmQgc28gZm9ydGhcbiAgICBhbmNob3IgKj0gYW5jaG9yc1tmcm9tVW5pdERhdGEuc3lzdGVtXS5yYXRpbztcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBhbmNob3IgLyB0b1VuaXREYXRhLmZhY3RvciAqIHRvRmFjdG9yO1xuICBpZiAoaXNUb1BpeGVsICYmIHJvdW5kUGl4ZWwpIHtcbiAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByZWNpc2lvbiA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUocHJlY2lzaW9uKSkge1xuICAgIHJlc3VsdCA9IHJvdW5kKHJlc3VsdCwgcHJlY2lzaW9uKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnREaXN0YW5jZTtcbm1vZHVsZS5leHBvcnRzLnVuaXRzID0gdW5pdHM7XG4iLCJpbXBvcnQgcGFwZXJTaXplcyBmcm9tICcuL3BhcGVyLXNpemVzJztcbmltcG9ydCBjb252ZXJ0TGVuZ3RoIGZyb20gJ2NvbnZlcnQtbGVuZ3RoJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpbWVuc2lvbnNGcm9tUHJlc2V0IChkaW1lbnNpb25zLCB1bml0c1RvID0gJ3B4JywgcGl4ZWxzUGVySW5jaCA9IDcyKSB7XG4gIGlmICh0eXBlb2YgZGltZW5zaW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBrZXkgPSBkaW1lbnNpb25zLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCEoa2V5IGluIHBhcGVyU2l6ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkaW1lbnNpb24gcHJlc2V0IFwiJHtkaW1lbnNpb25zfVwiIGlzIG5vdCBzdXBwb3J0ZWQgb3IgY291bGQgbm90IGJlIGZvdW5kOyB0cnkgdXNpbmcgYTQsIGEzLCBwb3N0Y2FyZCwgbGV0dGVyLCBldGMuYClcbiAgICB9XG4gICAgY29uc3QgcHJlc2V0ID0gcGFwZXJTaXplc1trZXldO1xuICAgIHJldHVybiBwcmVzZXQuZGltZW5zaW9ucy5tYXAoZCA9PiB7XG4gICAgICByZXR1cm4gY29udmVydERpc3RhbmNlKGQsIHByZXNldC51bml0cywgdW5pdHNUbywgcGl4ZWxzUGVySW5jaCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREaXN0YW5jZSAoZGltZW5zaW9uLCB1bml0c0Zyb20gPSAncHgnLCB1bml0c1RvID0gJ3B4JywgcGl4ZWxzUGVySW5jaCA9IDcyKSB7XG4gIHJldHVybiBjb252ZXJ0TGVuZ3RoKGRpbWVuc2lvbiwgdW5pdHNGcm9tLCB1bml0c1RvLCB7XG4gICAgcGl4ZWxzUGVySW5jaCxcbiAgICBwcmVjaXNpb246IDQsXG4gICAgcm91bmRQaXhlbDogdHJ1ZVxuICB9KTtcbn1cbiIsImltcG9ydCB7IGdldERpbWVuc2lvbnNGcm9tUHJlc2V0LCBjb252ZXJ0RGlzdGFuY2UgfSBmcm9tICcuLi9kaXN0YW5jZXMnO1xuaW1wb3J0IHsgaXNCcm93c2VyLCBkZWZpbmVkIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmZ1bmN0aW9uIGNoZWNrSWZIYXNEaW1lbnNpb25zIChzZXR0aW5ncykge1xuICBpZiAoIXNldHRpbmdzLmRpbWVuc2lvbnMpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBzZXR0aW5ncy5kaW1lbnNpb25zID09PSAnc3RyaW5nJykgcmV0dXJuIHRydWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHNldHRpbmdzLmRpbWVuc2lvbnMpICYmIHNldHRpbmdzLmRpbWVuc2lvbnMubGVuZ3RoID49IDIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFNpemUgKHByb3BzLCBzZXR0aW5ncykge1xuICAvLyBXaGVuIG5vIHsgZGltZW5zaW9uIH0gaXMgcGFzc2VkIGluIG5vZGUsIHdlIGRlZmF1bHQgdG8gSFRNTCBjYW52YXMgc2l6ZVxuICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgcmV0dXJuIFsgMzAwLCAxNTAgXTtcbiAgfVxuXG4gIGxldCBlbGVtZW50ID0gc2V0dGluZ3MucGFyZW50IHx8IHdpbmRvdztcblxuICBpZiAoZWxlbWVudCA9PT0gd2luZG93IHx8XG4gICAgICBlbGVtZW50ID09PSBkb2N1bWVudCB8fFxuICAgICAgZWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBbIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQgXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFsgd2lkdGgsIGhlaWdodCBdO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlc2l6ZUNhbnZhcyAocHJvcHMsIHNldHRpbmdzKSB7XG4gIGxldCB3aWR0aCwgaGVpZ2h0O1xuICBsZXQgc3R5bGVXaWR0aCwgc3R5bGVIZWlnaHQ7XG4gIGxldCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0O1xuXG4gIGNvbnN0IGJyb3dzZXIgPSBpc0Jyb3dzZXIoKTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHNldHRpbmdzLmRpbWVuc2lvbnM7XG4gIGNvbnN0IGhhc0RpbWVuc2lvbnMgPSBjaGVja0lmSGFzRGltZW5zaW9ucyhzZXR0aW5ncyk7XG4gIGNvbnN0IGV4cG9ydGluZyA9IHByb3BzLmV4cG9ydGluZztcbiAgbGV0IHNjYWxlVG9GaXQgPSBoYXNEaW1lbnNpb25zID8gc2V0dGluZ3Muc2NhbGVUb0ZpdCAhPT0gZmFsc2UgOiBmYWxzZTtcbiAgbGV0IHNjYWxlVG9WaWV3ID0gKCFleHBvcnRpbmcgJiYgaGFzRGltZW5zaW9ucykgPyBzZXR0aW5ncy5zY2FsZVRvVmlldyA6IHRydWU7XG4gIC8vIGluIG5vZGUsIGNhbmNlbCBib3RoIG9mIHRoZXNlIG9wdGlvbnNcbiAgaWYgKCFicm93c2VyKSBzY2FsZVRvRml0ID0gc2NhbGVUb1ZpZXcgPSBmYWxzZTtcbiAgY29uc3QgdW5pdHMgPSBzZXR0aW5ncy51bml0cztcbiAgY29uc3QgcGl4ZWxzUGVySW5jaCA9ICh0eXBlb2Ygc2V0dGluZ3MucGl4ZWxzUGVySW5jaCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoc2V0dGluZ3MucGl4ZWxzUGVySW5jaCkpID8gc2V0dGluZ3MucGl4ZWxzUGVySW5jaCA6IDcyO1xuICBjb25zdCBibGVlZCA9IGRlZmluZWQoc2V0dGluZ3MuYmxlZWQsIDApO1xuXG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBicm93c2VyID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICBjb25zdCBiYXNlUGl4ZWxSYXRpbyA9IHNjYWxlVG9WaWV3ID8gZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG5cbiAgbGV0IHBpeGVsUmF0aW8sIGV4cG9ydFBpeGVsUmF0aW87XG5cbiAgLy8gSWYgYSBwaXhlbCByYXRpbyBpcyBzcGVjaWZpZWQsIHdlIHdpbGwgdXNlIGl0LlxuICAvLyBPdGhlcndpc2U6XG4gIC8vICAtPiBJZiBkaW1lbnNpb24gaXMgc3BlY2lmaWVkLCB1c2UgYmFzZSByYXRpbyAoaS5lLiBzaXplIGZvciBleHBvcnQpXG4gIC8vICAtPiBJZiBubyBkaW1lbnNpb24gaXMgc3BlY2lmaWVkLCB1c2UgZGV2aWNlIHJhdGlvIChpLmUuIHNpemUgZm9yIHNjcmVlbilcbiAgaWYgKHR5cGVvZiBzZXR0aW5ncy5waXhlbFJhdGlvID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShzZXR0aW5ncy5waXhlbFJhdGlvKSkge1xuICAgIC8vIFdoZW4geyBwaXhlbFJhdGlvIH0gaXMgc3BlY2lmaWVkLCBpdCdzIGFsc28gdXNlZCBhcyBkZWZhdWx0IGV4cG9ydFBpeGVsUmF0aW8uXG4gICAgcGl4ZWxSYXRpbyA9IHNldHRpbmdzLnBpeGVsUmF0aW87XG4gICAgZXhwb3J0UGl4ZWxSYXRpbyA9IGRlZmluZWQoc2V0dGluZ3MuZXhwb3J0UGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGhhc0RpbWVuc2lvbnMpIHtcbiAgICAgIC8vIFdoZW4gYSBkaW1lbnNpb24gaXMgc3BlY2lmaWVkLCB1c2UgdGhlIGJhc2UgcmF0aW8gcmF0aGVyIHRoYW4gc2NyZWVuIHJhdGlvXG4gICAgICBwaXhlbFJhdGlvID0gYmFzZVBpeGVsUmF0aW87XG4gICAgICAvLyBEZWZhdWx0IHRvIGEgcGl4ZWwgcmF0aW8gb2YgMSBzbyB0aGF0IHlvdSBlbmQgdXAgd2l0aCB0aGUgc2FtZSBkaW1lbnNpb25cbiAgICAgIC8vIHlvdSBzcGVjaWZpZWQsIGkuZS4gWyA1MDAsIDUwMCBdIGlzIGV4cG9ydGVkIGFzIDUwMHg1MDAgcHhcbiAgICAgIGV4cG9ydFBpeGVsUmF0aW8gPSBkZWZpbmVkKHNldHRpbmdzLmV4cG9ydFBpeGVsUmF0aW8sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBkaW1lbnNpb24gaXMgc3BlY2lmaWVkLCBhc3N1bWUgZnVsbC1zY3JlZW4gcmV0aW5hIHNpemluZ1xuICAgICAgcGl4ZWxSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87XG4gICAgICAvLyBEZWZhdWx0IHRvIHNjcmVlbiBwaXhlbCByYXRpbywgc28gdGhhdCBpdCdzIGxpa2UgdGFraW5nIGEgZGV2aWNlIHNjcmVlbnNob3RcbiAgICAgIGV4cG9ydFBpeGVsUmF0aW8gPSBkZWZpbmVkKHNldHRpbmdzLmV4cG9ydFBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsYW1wIHBpeGVsIHJhdGlvXG4gIGlmICh0eXBlb2Ygc2V0dGluZ3MubWF4UGl4ZWxSYXRpbyA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoc2V0dGluZ3MubWF4UGl4ZWxSYXRpbykpIHtcbiAgICBwaXhlbFJhdGlvID0gTWF0aC5taW4oc2V0dGluZ3MubWF4UGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gIH1cblxuICAvLyBIYW5kbGUgZXhwb3J0IHBpeGVsIHJhdGlvXG4gIGlmIChleHBvcnRpbmcpIHtcbiAgICBwaXhlbFJhdGlvID0gZXhwb3J0UGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8vIHBhcmVudFdpZHRoID0gdHlwZW9mIHBhcmVudFdpZHRoID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHROb2RlU2l6ZVswXSA6IHBhcmVudFdpZHRoO1xuICAvLyBwYXJlbnRIZWlnaHQgPSB0eXBlb2YgcGFyZW50SGVpZ2h0ID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHROb2RlU2l6ZVsxXSA6IHBhcmVudEhlaWdodDtcblxuICBsZXQgWyBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0IF0gPSBnZXRQYXJlbnRTaXplKHByb3BzLCBzZXR0aW5ncyk7XG4gIGxldCB0cmltV2lkdGgsIHRyaW1IZWlnaHQ7XG5cbiAgLy8gWW91IGNhbiBzcGVjaWZ5IGEgZGltZW5zaW9ucyBpbiBwaXhlbHMgb3IgY20vbS9pbi9ldGNcbiAgaWYgKGhhc0RpbWVuc2lvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXREaW1lbnNpb25zRnJvbVByZXNldChkaW1lbnNpb25zLCB1bml0cywgcGl4ZWxzUGVySW5jaCk7XG4gICAgY29uc3QgaGlnaGVzdCA9IE1hdGgubWF4KHJlc3VsdFswXSwgcmVzdWx0WzFdKTtcbiAgICBjb25zdCBsb3dlc3QgPSBNYXRoLm1pbihyZXN1bHRbMF0sIHJlc3VsdFsxXSk7XG4gICAgaWYgKHNldHRpbmdzLm9yaWVudGF0aW9uKSB7XG4gICAgICBjb25zdCBsYW5kc2NhcGUgPSBzZXR0aW5ncy5vcmllbnRhdGlvbiA9PT0gJ2xhbmRzY2FwZSc7XG4gICAgICB3aWR0aCA9IGxhbmRzY2FwZSA/IGhpZ2hlc3QgOiBsb3dlc3Q7XG4gICAgICBoZWlnaHQgPSBsYW5kc2NhcGUgPyBsb3dlc3QgOiBoaWdoZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IHJlc3VsdFswXTtcbiAgICAgIGhlaWdodCA9IHJlc3VsdFsxXTtcbiAgICB9XG5cbiAgICB0cmltV2lkdGggPSB3aWR0aDtcbiAgICB0cmltSGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLy8gQXBwbHkgYmxlZWQgd2hpY2ggaXMgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSB1bml0c1xuICAgIHdpZHRoICs9IGJsZWVkICogMjtcbiAgICBoZWlnaHQgKz0gYmxlZWQgKiAyO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgaGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRyaW1XaWR0aCA9IHdpZHRoO1xuICAgIHRyaW1IZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICAvLyBSZWFsIHNpemUgaW4gcGl4ZWxzIGFmdGVyIFBQSSBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgbGV0IHJlYWxXaWR0aCA9IHdpZHRoO1xuICBsZXQgcmVhbEhlaWdodCA9IGhlaWdodDtcbiAgaWYgKGhhc0RpbWVuc2lvbnMgJiYgdW5pdHMpIHtcbiAgICAvLyBDb252ZXJ0IHRvIGRpZ2l0YWwvcGl4ZWwgdW5pdHMgaWYgbmVjZXNzYXJ5XG4gICAgcmVhbFdpZHRoID0gY29udmVydERpc3RhbmNlKHdpZHRoLCB1bml0cywgJ3B4JywgcGl4ZWxzUGVySW5jaCk7XG4gICAgcmVhbEhlaWdodCA9IGNvbnZlcnREaXN0YW5jZShoZWlnaHQsIHVuaXRzLCAncHgnLCBwaXhlbHNQZXJJbmNoKTtcbiAgfVxuXG4gIC8vIEhvdyBiaWcgdG8gc2V0IHRoZSAndmlldycgb2YgdGhlIGNhbnZhcyBpbiB0aGUgYnJvd3NlciAoaS5lLiBzdHlsZSlcbiAgc3R5bGVXaWR0aCA9IE1hdGgucm91bmQocmVhbFdpZHRoKTtcbiAgc3R5bGVIZWlnaHQgPSBNYXRoLnJvdW5kKHJlYWxIZWlnaHQpO1xuXG4gIC8vIElmIHdlIHdpc2ggdG8gc2NhbGUgdGhlIHZpZXcgdG8gdGhlIGJyb3dzZXIgd2luZG93XG4gIGlmIChzY2FsZVRvRml0ICYmICFleHBvcnRpbmcgJiYgaGFzRGltZW5zaW9ucykge1xuICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHdpbmRvd0FzcGVjdCA9IHBhcmVudFdpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlVG9GaXRQYWRkaW5nID0gZGVmaW5lZChzZXR0aW5ncy5zY2FsZVRvRml0UGFkZGluZywgNDApO1xuICAgIGNvbnN0IG1heFdpZHRoID0gTWF0aC5yb3VuZChwYXJlbnRXaWR0aCAtIHNjYWxlVG9GaXRQYWRkaW5nICogMik7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5yb3VuZChwYXJlbnRIZWlnaHQgLSBzY2FsZVRvRml0UGFkZGluZyAqIDIpO1xuICAgIGlmIChzdHlsZVdpZHRoID4gbWF4V2lkdGggfHwgc3R5bGVIZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICAgIGlmICh3aW5kb3dBc3BlY3QgPiBhc3BlY3QpIHtcbiAgICAgICAgc3R5bGVIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgIHN0eWxlV2lkdGggPSBNYXRoLnJvdW5kKHN0eWxlSGVpZ2h0ICogYXNwZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlV2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgc3R5bGVIZWlnaHQgPSBNYXRoLnJvdW5kKHN0eWxlV2lkdGggLyBhc3BlY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhbnZhc1dpZHRoID0gc2NhbGVUb1ZpZXcgPyBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBzdHlsZVdpZHRoKSA6IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHJlYWxXaWR0aCk7XG4gIGNhbnZhc0hlaWdodCA9IHNjYWxlVG9WaWV3ID8gTWF0aC5yb3VuZChwaXhlbFJhdGlvICogc3R5bGVIZWlnaHQpIDogTWF0aC5yb3VuZChwaXhlbFJhdGlvICogcmVhbEhlaWdodCk7XG5cbiAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IHNjYWxlVG9WaWV3ID8gTWF0aC5yb3VuZChzdHlsZVdpZHRoKSA6IE1hdGgucm91bmQocmVhbFdpZHRoKTtcbiAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBzY2FsZVRvVmlldyA/IE1hdGgucm91bmQoc3R5bGVIZWlnaHQpIDogTWF0aC5yb3VuZChyZWFsSGVpZ2h0KTtcblxuICBjb25zdCBzY2FsZVggPSBjYW52YXNXaWR0aCAvIHdpZHRoO1xuICBjb25zdCBzY2FsZVkgPSBjYW52YXNIZWlnaHQgLyBoZWlnaHQ7XG5cbiAgLy8gQXNzaWduIHRvIGN1cnJlbnQgcHJvcHNcbiAgcmV0dXJuIHtcbiAgICBibGVlZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBkaW1lbnNpb25zOiBbIHdpZHRoLCBoZWlnaHQgXSxcbiAgICB1bml0czogdW5pdHMgfHwgJ3B4JyxcbiAgICBzY2FsZVgsXG4gICAgc2NhbGVZLFxuICAgIHBpeGVsc1BlckluY2gsXG4gICAgdmlld3BvcnRXaWR0aCxcbiAgICB2aWV3cG9ydEhlaWdodCxcbiAgICBjYW52YXNXaWR0aCxcbiAgICBjYW52YXNIZWlnaHQsXG4gICAgdHJpbVdpZHRoLFxuICAgIHRyaW1IZWlnaHQsXG4gICAgc3R5bGVXaWR0aCxcbiAgICBzdHlsZUhlaWdodFxuICB9O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBnZXRDYW52YXNDb250ZXh0XG5mdW5jdGlvbiBnZXRDYW52YXNDb250ZXh0ICh0eXBlLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHNwZWNpZnkgdHlwZSBzdHJpbmcnKVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyAmJiAhb3B0cy5jYW52YXMpIHtcbiAgICByZXR1cm4gbnVsbCAvLyBjaGVjayBmb3IgTm9kZVxuICB9XG5cbiAgdmFyIGNhbnZhcyA9IG9wdHMuY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gIGlmICh0eXBlb2Ygb3B0cy53aWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICBjYW52YXMud2lkdGggPSBvcHRzLndpZHRoXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRzLmhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICBjYW52YXMuaGVpZ2h0ID0gb3B0cy5oZWlnaHRcbiAgfVxuXG4gIHZhciBhdHRyaWJzID0gb3B0c1xuICB2YXIgZ2xcbiAgdHJ5IHtcbiAgICB2YXIgbmFtZXMgPSBbIHR5cGUgXVxuICAgIC8vIHByZWZpeCBHTCBjb250ZXh0c1xuICAgIGlmICh0eXBlLmluZGV4T2YoJ3dlYmdsJykgPT09IDApIHtcbiAgICAgIG5hbWVzLnB1c2goJ2V4cGVyaW1lbnRhbC0nICsgdHlwZSlcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWVzW2ldLCBhdHRyaWJzKVxuICAgICAgaWYgKGdsKSByZXR1cm4gZ2xcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBnbCA9IG51bGxcbiAgfVxuICByZXR1cm4gKGdsIHx8IG51bGwpIC8vIGVuc3VyZSBudWxsIG9uIGZhaWxcbn1cbiIsImltcG9ydCBhc3NpZ24gZnJvbSAnb2JqZWN0LWFzc2lnbic7XG5pbXBvcnQgZ2V0Q2FudmFzQ29udGV4dCBmcm9tICdnZXQtY2FudmFzLWNvbnRleHQnO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0VsZW1lbnQgKCkge1xuICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJdCBhcHBlYXJzIHlvdSBhcmUgcnVuaW5nIGZyb20gTm9kZS5qcyBvciBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiBUcnkgcGFzc2luZyBpbiBhbiBleGlzdGluZyB7IGNhbnZhcyB9IGludGVyZmFjZSBpbnN0ZWFkLicpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzIChzZXR0aW5ncyA9IHt9KSB7XG4gIGxldCBjb250ZXh0LCBjYW52YXM7XG4gIGxldCBvd25zQ2FudmFzID0gZmFsc2U7XG4gIGlmIChzZXR0aW5ncy5jYW52YXMgIT09IGZhbHNlKSB7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBjYW52YXMgYW5kIGNvbnRleHQgdG8gY3JlYXRlXG4gICAgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHQ7XG4gICAgaWYgKCFjb250ZXh0IHx8IHR5cGVvZiBjb250ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IG5ld0NhbnZhcyA9IHNldHRpbmdzLmNhbnZhcztcbiAgICAgIGlmICghbmV3Q2FudmFzKSB7XG4gICAgICAgIG5ld0NhbnZhcyA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgb3duc0NhbnZhcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gY29udGV4dCB8fCAnMmQnO1xuICAgICAgaWYgKHR5cGVvZiBuZXdDYW52YXMuZ2V0Q29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzcGVjaWZpZWQgeyBjYW52YXMgfSBlbGVtZW50IGRvZXMgbm90IGhhdmUgYSBnZXRDb250ZXh0KCkgZnVuY3Rpb24sIG1heWJlIGl0IGlzIG5vdCBhIDxjYW52YXM+IHRhZz9gKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQgPSBnZXRDYW52YXNDb250ZXh0KHR5cGUsIGFzc2lnbih7fSwgc2V0dGluZ3MuYXR0cmlidXRlcywgeyBjYW52YXM6IG5ld0NhbnZhcyB9KSk7XG4gICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgYXQgY2FudmFzLmdldENvbnRleHQoJyR7dHlwZX0nKSAtIHRoZSBicm93c2VyIG1heSBub3Qgc3VwcG9ydCB0aGlzIGNvbnRleHQsIG9yIGEgZGlmZmVyZW50IGNvbnRleHQgbWF5IGFscmVhZHkgYmUgaW4gdXNlIHdpdGggdGhpcyBjYW52YXMuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgLy8gRW5zdXJlIGNvbnRleHQgbWF0Y2hlcyB1c2VyJ3MgY2FudmFzIGV4cGVjdGF0aW9uc1xuICAgIGlmIChzZXR0aW5ncy5jYW52YXMgJiYgY2FudmFzICE9PSBzZXR0aW5ncy5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHsgY2FudmFzIH0gYW5kIHsgY29udGV4dCB9IHNldHRpbmdzIG11c3QgcG9pbnQgdG8gdGhlIHNhbWUgdW5kZXJseWluZyBjYW52YXMgZWxlbWVudCcpO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHBpeGVsYXRpb24gdG8gY2FudmFzIGlmIG5lY2Vzc2FyeSwgdGhpcyBpcyBtb3N0bHkgYSBjb252ZW5pZW5jZSB1dGlsaXR5XG4gICAgaWYgKHNldHRpbmdzLnBpeGVsYXRlZCkge1xuICAgICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICBjYW52YXMuc3R5bGVbJ2ltYWdlLXJlbmRlcmluZyddID0gJ3BpeGVsYXRlZCc7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGNhbnZhcywgY29udGV4dCwgb3duc0NhbnZhcyB9O1xufVxuIiwiaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QtYXNzaWduJztcbmltcG9ydCByaWdodE5vdyBmcm9tICdyaWdodC1ub3cnO1xuaW1wb3J0IGlzUHJvbWlzZSBmcm9tICdpcy1wcm9taXNlJztcbmltcG9ydCB7IGlzQnJvd3NlciwgZGVmaW5lZCwgaXNXZWJHTENvbnRleHQsIGlzQ2FudmFzLCBnZXRDbGllbnRBUEkgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBkZWVwRXF1YWwgZnJvbSAnZGVlcC1lcXVhbCc7XG5pbXBvcnQge1xuICByZXNvbHZlRmlsZW5hbWUsXG4gIHNhdmVGaWxlLFxuICBzYXZlRGF0YVVSTCxcbiAgZ2V0VGltZVN0YW1wLFxuICBleHBvcnRDYW52YXMsXG4gIHN0cmVhbVN0YXJ0LFxuICBzdHJlYW1FbmRcbn0gZnJvbSAnLi4vc2F2ZSc7XG5pbXBvcnQgeyBjaGVja1NldHRpbmdzIH0gZnJvbSAnLi4vYWNjZXNzaWJpbGl0eSc7XG5cbmltcG9ydCBrZXlib2FyZFNob3J0Y3V0cyBmcm9tICcuL2tleWJvYXJkU2hvcnRjdXRzJztcbmltcG9ydCByZXNpemVDYW52YXMgZnJvbSAnLi9yZXNpemVDYW52YXMnO1xuaW1wb3J0IGNyZWF0ZUNhbnZhcyBmcm9tICcuL2NyZWF0ZUNhbnZhcyc7XG5cbmNsYXNzIFNrZXRjaE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSB7fTtcbiAgICB0aGlzLl9wcm9wcyA9IHt9O1xuICAgIHRoaXMuX3NrZXRjaCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yYWYgPSBudWxsO1xuICAgIHRoaXMuX3JlY29yZFRpbWVvdXQgPSBudWxsO1xuXG4gICAgLy8gU29tZSBoYWNreSB0aGluZ3MgcmVxdWlyZWQgdG8gZ2V0IGFyb3VuZCBwNS5qcyBzdHJ1Y3R1cmVcbiAgICB0aGlzLl9sYXN0UmVkcmF3UmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2lzUDVSZXNpemluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fa2V5Ym9hcmRTaG9ydGN1dHMgPSBrZXlib2FyZFNob3J0Y3V0cyh7XG4gICAgICBlbmFibGVkOiAoKSA9PiB0aGlzLnNldHRpbmdzLmhvdGtleXMgIT09IGZhbHNlLFxuICAgICAgc2F2ZTogKGV2KSA9PiB7XG4gICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgIGlmICh0aGlzLnByb3BzLnJlY29yZGluZykge1xuICAgICAgICAgICAgdGhpcy5lbmRSZWNvcmQoKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgICAgfSBlbHNlIHRoaXMucmVjb3JkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucHJvcHMucmVjb3JkaW5nKSB7XG4gICAgICAgICAgdGhpcy5leHBvcnRGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9nZ2xlUGxheTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5wbGF5aW5nKSB0aGlzLnBhdXNlKCk7XG4gICAgICAgIGVsc2UgdGhpcy5wbGF5KCk7XG4gICAgICB9LFxuICAgICAgY29tbWl0OiAoZXYpID0+IHtcbiAgICAgICAgdGhpcy5leHBvcnRGcmFtZSh7IGNvbW1pdDogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX2FuaW1hdGVIYW5kbGVyID0gKCkgPT4gdGhpcy5hbmltYXRlKCk7XG5cbiAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMucmVzaXplKCk7XG4gICAgICAvLyBPbmx5IHJlLXJlbmRlciB3aGVuIHNpemUgYWN0dWFsbHkgY2hhbmdlc1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZ2V0IHNrZXRjaCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NrZXRjaDtcbiAgfVxuXG4gIGdldCBzZXR0aW5ncyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xuICB9XG5cbiAgZ2V0IHByb3BzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHM7XG4gIH1cblxuICBfY29tcHV0ZVBsYXloZWFkIChjdXJyZW50VGltZSwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoZHVyYXRpb24pO1xuICAgIHJldHVybiBoYXNEdXJhdGlvbiA/IGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gOiAwO1xuICB9XG5cbiAgX2NvbXB1dGVGcmFtZSAocGxheWhlYWQsIHRpbWUsIHRvdGFsRnJhbWVzLCBmcHMpIHtcbiAgICByZXR1cm4gKGlzRmluaXRlKHRvdGFsRnJhbWVzKSAmJiB0b3RhbEZyYW1lcyA+IDEpXG4gICAgICA/IE1hdGguZmxvb3IocGxheWhlYWQgKiAodG90YWxGcmFtZXMgLSAxKSlcbiAgICAgIDogTWF0aC5mbG9vcihmcHMgKiB0aW1lKTtcbiAgfVxuXG4gIF9jb21wdXRlQ3VycmVudEZyYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcHV0ZUZyYW1lKFxuICAgICAgdGhpcy5wcm9wcy5wbGF5aGVhZCwgdGhpcy5wcm9wcy50aW1lLFxuICAgICAgdGhpcy5wcm9wcy50b3RhbEZyYW1lcywgdGhpcy5wcm9wcy5mcHNcbiAgICApO1xuICB9XG5cbiAgX2dldFNpemVQcm9wcyAoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHByb3BzLmhlaWdodCxcbiAgICAgIHBpeGVsUmF0aW86IHByb3BzLnBpeGVsUmF0aW8sXG4gICAgICBjYW52YXNXaWR0aDogcHJvcHMuY2FudmFzV2lkdGgsXG4gICAgICBjYW52YXNIZWlnaHQ6IHByb3BzLmNhbnZhc0hlaWdodCxcbiAgICAgIHZpZXdwb3J0V2lkdGg6IHByb3BzLnZpZXdwb3J0V2lkdGgsXG4gICAgICB2aWV3cG9ydEhlaWdodDogcHJvcHMudmlld3BvcnRIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgcnVuICgpIHtcbiAgICBpZiAoIXRoaXMuc2tldGNoKSB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCB3YWl0IHVudGlsIHNrZXRjaCBpcyBsb2FkZWQgYmVmb3JlIHRyeWluZyB0byBwbGF5KCknKTtcblxuICAgIC8vIFN0YXJ0IGFuIGFuaW1hdGlvbiBmcmFtZSBsb29wIGlmIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLnNldHRpbmdzLnBsYXlpbmcgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICAvLyBMZXQncyBsZXQgdGhpcyB3YXJuaW5nIGhhbmcgYXJvdW5kIGZvciBhIGZldyB2ZXJzaW9ucy4uLlxuICAgIGlmICh0eXBlb2YgdGhpcy5za2V0Y2guZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKCdJbiBjYW52YXMtc2tldGNoQDAuMC4yMyB0aGUgZGlzcG9zZSgpIGV2ZW50IGhhcyBiZWVuIHJlbmFtZWQgdG8gdW5sb2FkKCknKTtcbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIHdlIGFyZW4ndCBwbGF5aW5nIG9yIGFuaW1hdGVkLCBtYWtlIHN1cmUgd2Ugc3RpbGwgdHJpZ2dlciBiZWdpbiBtZXNzYWdlLi4uXG4gICAgaWYgKCF0aGlzLnByb3BzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX3NpZ25hbEJlZ2luKCk7XG4gICAgICB0aGlzLnByb3BzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciBhbiBpbml0aWFsIGZyYW1lXG4gICAgdGhpcy50aWNrKCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9jYW5jZWxUaW1lb3V0cyAoKSB7XG4gICAgaWYgKHRoaXMuX3JhZiAhPSBudWxsICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yYWYpO1xuICAgICAgdGhpcy5fcmFmID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlY29yZFRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlY29yZFRpbWVvdXQpO1xuICAgICAgdGhpcy5fcmVjb3JkVGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcGxheSAoKSB7XG4gICAgbGV0IGFuaW1hdGUgPSB0aGlzLnNldHRpbmdzLmFuaW1hdGU7XG4gICAgaWYgKCdhbmltYXRpb24nIGluIHRoaXMuc2V0dGluZ3MpIHtcbiAgICAgIGFuaW1hdGUgPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKCdbY2FudmFzLXNrZXRjaF0geyBhbmltYXRpb24gfSBoYXMgYmVlbiByZW5hbWVkIHRvIHsgYW5pbWF0ZSB9Jyk7XG4gICAgfVxuICAgIGlmICghYW5pbWF0ZSkgcmV0dXJuO1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjYW52YXMtc2tldGNoXSBXQVJOOiBVc2luZyB7IGFuaW1hdGUgfSBpbiBOb2RlLmpzIGlzIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLnBsYXlpbmcpIHJldHVybjtcbiAgICBpZiAoIXRoaXMucHJvcHMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5fc2lnbmFsQmVnaW4oKTtcbiAgICAgIHRoaXMucHJvcHMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ3BsYXknLCB0aGlzLnByb3BzLnRpbWUpXG5cbiAgICAvLyBTdGFydCBhIHJlbmRlciBsb29wXG4gICAgdGhpcy5wcm9wcy5wbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9jYW5jZWxUaW1lb3V0cygpO1xuICAgIHRoaXMuX2xhc3RUaW1lID0gcmlnaHROb3coKTtcbiAgICB0aGlzLl9yYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGVIYW5kbGVyKTtcbiAgfVxuXG4gIHBhdXNlICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5yZWNvcmRpbmcpIHRoaXMuZW5kUmVjb3JkKCk7XG4gICAgdGhpcy5wcm9wcy5wbGF5aW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLl9jYW5jZWxUaW1lb3V0cygpO1xuICB9XG5cbiAgdG9nZ2xlUGxheSAoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMucGxheWluZykgdGhpcy5wYXVzZSgpO1xuICAgIGVsc2UgdGhpcy5wbGF5KCk7XG4gIH1cblxuICAvLyBTdG9wIGFuZCByZXNldCB0byBmcmFtZSB6ZXJvXG4gIHN0b3AgKCkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgICB0aGlzLnByb3BzLmZyYW1lID0gMDtcbiAgICB0aGlzLnByb3BzLnBsYXloZWFkID0gMDtcbiAgICB0aGlzLnByb3BzLnRpbWUgPSAwO1xuICAgIHRoaXMucHJvcHMuZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLnByb3BzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgcmVjb3JkICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5yZWNvcmRpbmcpIHJldHVybjtcbiAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbY2FudmFzLXNrZXRjaF0gV0FSTjogUmVjb3JkaW5nIGZyb20gTm9kZS5qcyBpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMucHJvcHMucGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5wcm9wcy5yZWNvcmRpbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgZXhwb3J0T3B0cyA9IHRoaXMuX2NyZWF0ZUV4cG9ydE9wdGlvbnMoeyBzZXF1ZW5jZTogdHJ1ZSB9KTtcblxuICAgIGNvbnN0IGZyYW1lSW50ZXJ2YWwgPSAxIC8gdGhpcy5wcm9wcy5mcHM7XG4gICAgLy8gUmVuZGVyIGVhY2ggZnJhbWUgaW4gdGhlIHNlcXVlbmNlXG4gICAgdGhpcy5fY2FuY2VsVGltZW91dHMoKTtcbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnByb3BzLnJlY29yZGluZykgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5wcm9wcy5kZWx0YVRpbWUgPSBmcmFtZUludGVydmFsO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgICByZXR1cm4gdGhpcy5leHBvcnRGcmFtZShleHBvcnRPcHRzKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLnByb3BzLnJlY29yZGluZykgcmV0dXJuOyAvLyB3YXMgY2FuY2VsbGVkIGJlZm9yZVxuICAgICAgICAgIHRoaXMucHJvcHMuZGVsdGFUaW1lID0gMDtcbiAgICAgICAgICB0aGlzLnByb3BzLmZyYW1lKys7XG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMuZnJhbWUgPCB0aGlzLnByb3BzLnRvdGFsRnJhbWVzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnRpbWUgKz0gZnJhbWVJbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMucHJvcHMucGxheWhlYWQgPSB0aGlzLl9jb21wdXRlUGxheWhlYWQodGhpcy5wcm9wcy50aW1lLCB0aGlzLnByb3BzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmluaXNoZWQgcmVjb3JkaW5nJyk7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWxFbmQoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kUmVjb3JkKCk7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gVHJpZ2dlciBhIHN0YXJ0IGV2ZW50IGJlZm9yZSB3ZSBiZWdpbiByZWNvcmRpbmdcbiAgICBpZiAoIXRoaXMucHJvcHMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5fc2lnbmFsQmVnaW4oKTtcbiAgICAgIHRoaXMucHJvcHMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciAnYmVnaW4gcmVjb3JkJyBldmVudFxuICAgIGlmICh0aGlzLnNrZXRjaCAmJiB0eXBlb2YgdGhpcy5za2V0Y2guYmVnaW5SZWNvcmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3dyYXBDb250ZXh0U2NhbGUocHJvcHMgPT4gdGhpcy5za2V0Y2guYmVnaW5SZWNvcmQocHJvcHMpKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWF0ZSBhIHN0cmVhbWluZyBzdGFydCBpZiBuZWNlc3NhcnlcbiAgICBzdHJlYW1TdGFydChleHBvcnRPcHRzKVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHRoaXMuX3JhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gICAgICB9KTtcbiAgfVxuXG4gIF9zaWduYWxCZWdpbiAoKSB7XG4gICAgaWYgKHRoaXMuc2tldGNoICYmIHR5cGVvZiB0aGlzLnNrZXRjaC5iZWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd3JhcENvbnRleHRTY2FsZShwcm9wcyA9PiB0aGlzLnNrZXRjaC5iZWdpbihwcm9wcykpO1xuICAgIH1cbiAgfVxuXG4gIF9zaWduYWxFbmQgKCkge1xuICAgIGlmICh0aGlzLnNrZXRjaCAmJiB0eXBlb2YgdGhpcy5za2V0Y2guZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl93cmFwQ29udGV4dFNjYWxlKHByb3BzID0+IHRoaXMuc2tldGNoLmVuZChwcm9wcykpO1xuICAgIH1cbiAgfVxuXG4gIGVuZFJlY29yZCAoKSB7XG4gICAgY29uc3Qgd2FzUmVjb3JkaW5nID0gdGhpcy5wcm9wcy5yZWNvcmRpbmc7XG5cbiAgICB0aGlzLl9jYW5jZWxUaW1lb3V0cygpO1xuICAgIHRoaXMucHJvcHMucmVjb3JkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wcy5kZWx0YVRpbWUgPSAwO1xuICAgIHRoaXMucHJvcHMucGxheWluZyA9IGZhbHNlO1xuXG4gICAgLy8gdGVsbCBDTEkgdGhhdCBzdHJlYW0gaGFzIGZpbmlzaGVkXG4gICAgcmV0dXJuIHN0cmVhbUVuZCgpXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgLy8gVHJpZ2dlciAnZW5kIHJlY29yZCcgZXZlbnRcbiAgICAgICAgaWYgKHdhc1JlY29yZGluZyAmJiB0aGlzLnNrZXRjaCAmJiB0eXBlb2YgdGhpcy5za2V0Y2guZW5kUmVjb3JkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fd3JhcENvbnRleHRTY2FsZShwcm9wcyA9PiB0aGlzLnNrZXRjaC5lbmRSZWNvcmQocHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBfY3JlYXRlRXhwb3J0T3B0aW9ucyAob3B0ID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VxdWVuY2U6IG9wdC5zZXF1ZW5jZSxcbiAgICAgIHNhdmU6IG9wdC5zYXZlLFxuICAgICAgZnBzOiB0aGlzLnByb3BzLmZwcyxcbiAgICAgIGZyYW1lOiBvcHQuc2VxdWVuY2UgPyB0aGlzLnByb3BzLmZyYW1lIDogdW5kZWZpbmVkLFxuICAgICAgZmlsZTogdGhpcy5zZXR0aW5ncy5maWxlLFxuICAgICAgbmFtZTogdGhpcy5zZXR0aW5ncy5uYW1lLFxuICAgICAgcHJlZml4OiB0aGlzLnNldHRpbmdzLnByZWZpeCxcbiAgICAgIHN1ZmZpeDogdGhpcy5zZXR0aW5ncy5zdWZmaXgsXG4gICAgICBlbmNvZGluZzogdGhpcy5zZXR0aW5ncy5lbmNvZGluZyxcbiAgICAgIGVuY29kaW5nUXVhbGl0eTogdGhpcy5zZXR0aW5ncy5lbmNvZGluZ1F1YWxpdHksXG4gICAgICB0aW1lU3RhbXA6IG9wdC50aW1lU3RhbXAgfHwgZ2V0VGltZVN0YW1wKCksXG4gICAgICB0b3RhbEZyYW1lczogaXNGaW5pdGUodGhpcy5wcm9wcy50b3RhbEZyYW1lcykgPyBNYXRoLm1heCgwLCB0aGlzLnByb3BzLnRvdGFsRnJhbWVzKSA6IDEwMDBcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0RnJhbWUgKG9wdCA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnNrZXRjaCkgcmV0dXJuIFByb21pc2UuYWxsKFtdKTtcbiAgICBpZiAodHlwZW9mIHRoaXMuc2tldGNoLnByZUV4cG9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5za2V0Y2gucHJlRXhwb3J0KCk7XG4gICAgfVxuXG4gICAgLy8gT3B0aW9ucyBmb3IgZXhwb3J0IGZ1bmN0aW9uXG4gICAgbGV0IGV4cG9ydE9wdHMgPSB0aGlzLl9jcmVhdGVFeHBvcnRPcHRpb25zKG9wdCk7XG5cbiAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmIChjbGllbnQgJiYgb3B0LmNvbW1pdCAmJiB0eXBlb2YgY2xpZW50LmNvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgY29tbWl0T3B0cyA9IGFzc2lnbih7fSwgZXhwb3J0T3B0cyk7XG4gICAgICBjb25zdCBoYXNoID0gY2xpZW50LmNvbW1pdChjb21taXRPcHRzKTtcbiAgICAgIGlmIChpc1Byb21pc2UoaGFzaCkpIHAgPSBoYXNoO1xuICAgICAgZWxzZSBwID0gUHJvbWlzZS5yZXNvbHZlKGhhc2gpO1xuICAgIH1cblxuICAgIHJldHVybiBwLnRoZW4oaGFzaCA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fZG9FeHBvcnRGcmFtZShhc3NpZ24oe30sIGV4cG9ydE9wdHMsIHsgaGFzaDogaGFzaCB8fCAnJyB9KSk7XG4gICAgfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgLy8gTW9zdCBjb21tb24gdXNlY2FzZSBpcyB0byBleHBvcnQgYSBzaW5nbGUgbGF5ZXIsXG4gICAgICAvLyBzbyBsZXQncyBvcHRpbWl6ZSB0aGUgdXNlciBleHBlcmllbmNlIGZvciB0aGF0LlxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHJldHVybiByZXN1bHRbMF07XG4gICAgICBlbHNlIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICBfZG9FeHBvcnRGcmFtZSAoZXhwb3J0T3B0cyA9IHt9KSB7XG4gICAgdGhpcy5fcHJvcHMuZXhwb3J0aW5nID0gdHJ1ZTtcblxuICAgIC8vIFJlc2l6ZSB0byBvdXRwdXQgcmVzb2x1dGlvblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAvLyBEcmF3IGF0IHRoaXMgb3V0cHV0IHJlc29sdXRpb25cbiAgICBsZXQgZHJhd1Jlc3VsdCA9IHRoaXMucmVuZGVyKCk7XG5cbiAgICAvLyBUaGUgc2VsZiBvd25lZCBjYW52YXMgKG1heSBiZSB1bmRlZmluZWQuLi4hKVxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMucHJvcHMuY2FudmFzO1xuXG4gICAgLy8gR2V0IGxpc3Qgb2YgcmVzdWx0cyBmcm9tIHJlbmRlclxuICAgIGlmICh0eXBlb2YgZHJhd1Jlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRyYXdSZXN1bHQgPSBbIGNhbnZhcyBdO1xuICAgIH1cbiAgICBkcmF3UmVzdWx0ID0gW10uY29uY2F0KGRyYXdSZXN1bHQpLmZpbHRlcihCb29sZWFuKTtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgY2FudmFzL2ZpbGUgZGVzY3JpcHRvcnMgaW50byBhIGNvbnNpc3RlbnQgZm9ybWF0LFxuICAgIC8vIGFuZCBwdWxsIG91dCBhbnkgZGF0YSBVUkxzIGZyb20gY2FudmFzIGVsZW1lbnRzXG4gICAgZHJhd1Jlc3VsdCA9IGRyYXdSZXN1bHQubWFwKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBoYXNEYXRhT2JqZWN0ID0gdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmICgnZGF0YScgaW4gcmVzdWx0IHx8ICdkYXRhVVJMJyBpbiByZXN1bHQpO1xuICAgICAgY29uc3QgZGF0YSA9IGhhc0RhdGFPYmplY3QgPyByZXN1bHQuZGF0YSA6IHJlc3VsdDtcbiAgICAgIGNvbnN0IG9wdHMgPSBoYXNEYXRhT2JqZWN0ID8gYXNzaWduKHt9LCByZXN1bHQsIHsgZGF0YSB9KSA6IHsgZGF0YSB9O1xuICAgICAgaWYgKGlzQ2FudmFzKGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCBleHBvcnRPcHRzLmVuY29kaW5nO1xuICAgICAgICBjb25zdCBlbmNvZGluZ1F1YWxpdHkgPSBkZWZpbmVkKG9wdHMuZW5jb2RpbmdRdWFsaXR5LCBleHBvcnRPcHRzLmVuY29kaW5nUXVhbGl0eSwgMC45NSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YVVSTCwgZXh0ZW5zaW9uLCB0eXBlIH0gPSBleHBvcnRDYW52YXMoZGF0YSwgeyBlbmNvZGluZywgZW5jb2RpbmdRdWFsaXR5IH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvcHRzLCB7IGRhdGFVUkwsIGV4dGVuc2lvbiwgdHlwZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTm93IHJldHVybiB0byByZWd1bGFyIHJlbmRlcmluZyBtb2RlXG4gICAgdGhpcy5fcHJvcHMuZXhwb3J0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5yZXNpemUoKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgLy8gQW5kIG5vdyB3ZSBjYW4gc2F2ZSBlYWNoIHJlc3VsdFxuICAgIHJldHVybiBQcm9taXNlLmFsbChkcmF3UmVzdWx0Lm1hcCgocmVzdWx0LCBpLCBsYXllckxpc3QpID0+IHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGlmIHJlbmRlcmluZyBtdWx0aXBsZSBsYXllcnMgd2Ugd2lsbCBnaXZlIHRoZW0gaW5kaWNlc1xuICAgICAgY29uc3QgY3VyT3B0ID0gYXNzaWduKHtcbiAgICAgICAgZXh0ZW5zaW9uOiAnJyxcbiAgICAgICAgcHJlZml4OiAnJyxcbiAgICAgICAgc3VmZml4OiAnJ1xuICAgICAgfSwgZXhwb3J0T3B0cywgcmVzdWx0LCB7XG4gICAgICAgIGxheWVyOiBpLFxuICAgICAgICB0b3RhbExheWVyczogbGF5ZXJMaXN0Lmxlbmd0aFxuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIGV4cG9ydCBpcyBleHBsaWNpdGx5IG5vdCBzYXZpbmcsIG1ha2Ugc3VyZSBub3RoaW5nIHNhdmVzXG4gICAgICAvLyBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgbGF5ZXIgc2F2ZSBvcHRpb24sIG9yIGZhbGxiYWNrIHRvIHRydWVcbiAgICAgIGNvbnN0IHNhdmVQYXJhbSA9IGV4cG9ydE9wdHMuc2F2ZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHJlc3VsdC5zYXZlO1xuICAgICAgY3VyT3B0LnNhdmUgPSBzYXZlUGFyYW0gIT09IGZhbHNlO1xuXG4gICAgICAvLyBSZXNvbHZlIGEgZnVsbCBmaWxlbmFtZSBmcm9tIGFsbCB0aGUgb3B0aW9uc1xuICAgICAgY3VyT3B0LmZpbGVuYW1lID0gcmVzb2x2ZUZpbGVuYW1lKGN1ck9wdCk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHNvbWUgcGFyYW1ldGVycyB0aGF0IG1heSBiZSBhbWJpZ3VvdXMgdG8gdGhlIHVzZXJcbiAgICAgIGRlbGV0ZSBjdXJPcHQuZW5jb2Rpbmc7XG4gICAgICBkZWxldGUgY3VyT3B0LmVuY29kaW5nUXVhbGl0eTtcblxuICAgICAgLy8gQ2xlYW4gaXQgdXAgZnVydGhlciBieSBqdXN0IHJlbW92aW5nIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgIGZvciAobGV0IGsgaW4gY3VyT3B0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3VyT3B0W2tdID09PSAndW5kZWZpbmVkJykgZGVsZXRlIGN1ck9wdFtrXTtcbiAgICAgIH1cblxuICAgICAgbGV0IHNhdmVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICAgIGlmIChjdXJPcHQuc2F2ZSkge1xuICAgICAgICAvLyBXaGV0aGVyIHRvIGFjdHVhbGx5IHNhdmUgKGRvd25sb2FkKSB0aGlzIGZyYWdtZW50XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjdXJPcHQuZGF0YTtcbiAgICAgICAgaWYgKGN1ck9wdC5kYXRhVVJMKSB7XG4gICAgICAgICAgY29uc3QgZGF0YVVSTCA9IGN1ck9wdC5kYXRhVVJMO1xuICAgICAgICAgIHNhdmVQcm9taXNlID0gc2F2ZURhdGFVUkwoZGF0YVVSTCwgY3VyT3B0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYXZlUHJvbWlzZSA9IHNhdmVGaWxlKGRhdGEsIGN1ck9wdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzYXZlUHJvbWlzZS50aGVuKHNhdmVSZXN1bHQgPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY3VyT3B0LCBzYXZlUmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pKS50aGVuKGV2ID0+IHtcbiAgICAgIGNvbnN0IHNhdmVkRXZlbnRzID0gZXYuZmlsdGVyKGUgPT4gZS5zYXZlKTtcbiAgICAgIGlmIChzYXZlZEV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIExvZyB0aGUgc2F2ZWQgZXhwb3J0c1xuICAgICAgICBjb25zdCBldmVudFdpdGhPdXRwdXQgPSBzYXZlZEV2ZW50cy5maW5kKGUgPT4gZS5vdXRwdXROYW1lKTtcbiAgICAgICAgY29uc3QgaXNDbGllbnQgPSBzYXZlZEV2ZW50cy5zb21lKGUgPT4gZS5jbGllbnQpO1xuICAgICAgICBjb25zdCBpc1N0cmVhbWluZyA9IHNhdmVkRXZlbnRzLnNvbWUoZSA9PiBlLnN0cmVhbSk7XG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICAvLyBtYW55IGZpbGVzLCBqdXN0IGxvZyBob3cgbWFueSB3ZXJlIGV4cG9ydGVkXG4gICAgICAgIGlmIChzYXZlZEV2ZW50cy5sZW5ndGggPiAxKSBpdGVtID0gc2F2ZWRFdmVudHMubGVuZ3RoO1xuICAgICAgICAvLyBpbiBDTEksIHdlIGtub3cgZXhhY3QgcGF0aCBkaXJuYW1lXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50V2l0aE91dHB1dCkgaXRlbSA9IGAke2V2ZW50V2l0aE91dHB1dC5vdXRwdXROYW1lfS8ke3NhdmVkRXZlbnRzWzBdLmZpbGVuYW1lfWA7XG4gICAgICAgIC8vIGluIGJyb3dzZXIsIHdlIGNhbiBvbmx5IGtub3cgaXQgd2VudCB0byBcImJyb3dzZXIgZG93bmxvYWQgZm9sZGVyXCJcbiAgICAgICAgZWxzZSBpdGVtID0gYCR7c2F2ZWRFdmVudHNbMF0uZmlsZW5hbWV9YDtcbiAgICAgICAgbGV0IG9mU2VxID0gJyc7XG4gICAgICAgIGlmIChleHBvcnRPcHRzLnNlcXVlbmNlKSB7XG4gICAgICAgICAgY29uc3QgaGFzVG90YWxGcmFtZXMgPSBpc0Zpbml0ZSh0aGlzLnByb3BzLnRvdGFsRnJhbWVzKTtcbiAgICAgICAgICBvZlNlcSA9IGhhc1RvdGFsRnJhbWVzID8gYCAoZnJhbWUgJHtleHBvcnRPcHRzLmZyYW1lICsgMX0gLyAke3RoaXMucHJvcHMudG90YWxGcmFtZXN9KWAgOiBgIChmcmFtZSAke2V4cG9ydE9wdHMuZnJhbWV9KWA7XG4gICAgICAgIH0gZWxzZSBpZiAoc2F2ZWRFdmVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIG9mU2VxID0gYCBmaWxlc2A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gaXNDbGllbnQgPyAnY2FudmFzLXNrZXRjaC1jbGknIDogJ2NhbnZhcy1za2V0Y2gnO1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBpc1N0cmVhbWluZyA/ICdTdHJlYW1pbmcgaW50bycgOiAnRXhwb3J0ZWQnO1xuICAgICAgICBjb25zb2xlLmxvZyhgJWNbJHtjbGllbnR9XSVjICR7YWN0aW9ufSAlYyR7aXRlbX0lYyR7b2ZTZXF9YCwgJ2NvbG9yOiAjOGU4ZThlOycsICdjb2xvcjogaW5pdGlhbDsnLCAnZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2ZvbnQtd2VpZ2h0OiBpbml0aWFsOycpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNrZXRjaC5wb3N0RXhwb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuc2tldGNoLnBvc3RFeHBvcnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldjtcbiAgICB9KTtcbiAgfVxuXG4gIF93cmFwQ29udGV4dFNjYWxlIChjYikge1xuICAgIHRoaXMuX3ByZVJlbmRlcigpO1xuICAgIGNiKHRoaXMucHJvcHMpO1xuICAgIHRoaXMuX3Bvc3RSZW5kZXIoKTtcbiAgfVxuXG4gIF9wcmVSZW5kZXIgKCkge1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFNjYWxlIGNvbnRleHQgZm9yIHVuaXQgc2l6aW5nXG4gICAgaWYgKCF0aGlzLnByb3BzLmdsICYmIHByb3BzLmNvbnRleHQgJiYgIXByb3BzLnA1KSB7XG4gICAgICBwcm9wcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNjYWxlQ29udGV4dCAhPT0gZmFsc2UpIHtcbiAgICAgICAgcHJvcHMuY29udGV4dC5zY2FsZShwcm9wcy5zY2FsZVgsIHByb3BzLnNjYWxlWSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wcy5wNSkge1xuICAgICAgcHJvcHMucDUuc2NhbGUocHJvcHMuc2NhbGVYIC8gcHJvcHMucGl4ZWxSYXRpbywgcHJvcHMuc2NhbGVZIC8gcHJvcHMucGl4ZWxSYXRpbyk7XG4gICAgfVxuICB9XG5cbiAgX3Bvc3RSZW5kZXIgKCkge1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghdGhpcy5wcm9wcy5nbCAmJiBwcm9wcy5jb250ZXh0ICYmICFwcm9wcy5wNSkge1xuICAgICAgcHJvcHMuY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggYnkgZGVmYXVsdCwgdGhpcyBtYXkgYmUgcmV2aXNpdGVkIGF0IGEgbGF0ZXIgcG9pbnQuXG4gICAgLy8gV2UgZG8gdGhpcyB0byBlbnN1cmUgdG9EYXRhVVJMIGNhbiBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgLy8gTW9zdCBsaWtlbHkgYnJvd3NlcnMgYWxyZWFkeSBoYW5kbGUgdGhpcywgc28gd2UgbWF5IHJldmlzaXQgdGhpcyBhbmRcbiAgICAvLyByZW1vdmUgaXQgaWYgaXQgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugd2l0aG91dCBhbnkgdXNhYmlsaXR5IGlzc3Vlcy5cbiAgICBpZiAocHJvcHMuZ2wgJiYgdGhpcy5zZXR0aW5ncy5mbHVzaCAhPT0gZmFsc2UgJiYgIXByb3BzLnA1KSB7XG4gICAgICBwcm9wcy5nbC5mbHVzaCgpO1xuICAgIH1cbiAgfVxuXG4gIHRpY2sgKCkge1xuICAgIGlmICh0aGlzLnNrZXRjaCAmJiB0eXBlb2YgdGhpcy5za2V0Y2gudGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcHJlUmVuZGVyKCk7XG4gICAgICB0aGlzLnNrZXRjaC50aWNrKHRoaXMucHJvcHMpO1xuICAgICAgdGhpcy5fcG9zdFJlbmRlcigpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMucDUpIHtcbiAgICAgIHRoaXMuX2xhc3RSZWRyYXdSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnByb3BzLnA1LnJlZHJhdygpO1xuICAgICAgcmV0dXJuIHRoaXMuX2xhc3RSZWRyYXdSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnN1Ym1pdERyYXdDYWxsKCk7XG4gICAgfVxuICB9XG5cbiAgc3VibWl0RHJhd0NhbGwgKCkge1xuICAgIGlmICghdGhpcy5za2V0Y2gpIHJldHVybjtcblxuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLl9wcmVSZW5kZXIoKTtcblxuICAgIGxldCBkcmF3UmVzdWx0O1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNrZXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZHJhd1Jlc3VsdCA9IHRoaXMuc2tldGNoKHByb3BzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNrZXRjaC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRyYXdSZXN1bHQgPSB0aGlzLnNrZXRjaC5yZW5kZXIocHJvcHMpO1xuICAgIH1cblxuICAgIHRoaXMuX3Bvc3RSZW5kZXIoKTtcblxuICAgIHJldHVybiBkcmF3UmVzdWx0O1xuICB9XG5cbiAgdXBkYXRlIChvcHQgPSB7fSkge1xuICAgIC8vIEN1cnJlbnRseSB1cGRhdGUoKSBpcyBvbmx5IGZvY3VzZWQgb24gcmVzaXppbmcsXG4gICAgLy8gYnV0IGxhdGVyIHdlIHdpbGwgc3VwcG9ydCBvdGhlciBvcHRpb25zIGxpa2Ugc3dpdGNoaW5nXG4gICAgLy8gZnJhbWVzIGFuZCBzdWNoLlxuICAgIGNvbnN0IG5vdFlldFN1cHBvcnRlZCA9IFtcbiAgICAgICdhbmltYXRlJ1xuICAgIF07XG5cbiAgICBPYmplY3Qua2V5cyhvcHQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChub3RZZXRTdXBwb3J0ZWQuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb3JyeSwgdGhlIHsgJHtrZXl9IH0gb3B0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIHdpdGggdXBkYXRlKCkuYCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbGRDYW52YXMgPSB0aGlzLl9zZXR0aW5ncy5jYW52YXM7XG4gICAgY29uc3Qgb2xkQ29udGV4dCA9IHRoaXMuX3NldHRpbmdzLmNvbnRleHQ7XG5cbiAgICAvLyBNZXJnZSBuZXcgb3B0aW9ucyBpbnRvIHNldHRpbmdzXG4gICAgZm9yIChsZXQga2V5IGluIG9wdCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7IC8vIGlnbm9yZSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5fc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1lcmdlIGluIHRpbWUgcHJvcHNcbiAgICBjb25zdCB0aW1lT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3NldHRpbmdzLCBvcHQpO1xuICAgIGlmICgndGltZScgaW4gb3B0ICYmICdmcmFtZScgaW4gb3B0KSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzaG91bGQgc3BlY2lmeSB7IHRpbWUgfSBvciB7IGZyYW1lIH0gYnV0IG5vdCBib3RoJyk7XG4gICAgZWxzZSBpZiAoJ3RpbWUnIGluIG9wdCkgZGVsZXRlIHRpbWVPcHRzLmZyYW1lO1xuICAgIGVsc2UgaWYgKCdmcmFtZScgaW4gb3B0KSBkZWxldGUgdGltZU9wdHMudGltZTtcbiAgICBpZiAoJ2R1cmF0aW9uJyBpbiBvcHQgJiYgJ3RvdGFsRnJhbWVzJyBpbiBvcHQpIHRocm93IG5ldyBFcnJvcignWW91IHNob3VsZCBzcGVjaWZ5IHsgZHVyYXRpb24gfSBvciB7IHRvdGFsRnJhbWVzIH0gYnV0IG5vdCBib3RoJyk7XG4gICAgZWxzZSBpZiAoJ2R1cmF0aW9uJyBpbiBvcHQpIGRlbGV0ZSB0aW1lT3B0cy50b3RhbEZyYW1lcztcbiAgICBlbHNlIGlmICgndG90YWxGcmFtZXMnIGluIG9wdCkgZGVsZXRlIHRpbWVPcHRzLmR1cmF0aW9uO1xuXG4gICAgLy8gTWVyZ2UgaW4gdXNlciBkYXRhIHdpdGhvdXQgY29weWluZ1xuICAgIGlmICgnZGF0YScgaW4gb3B0KSB0aGlzLl9wcm9wcy5kYXRhID0gb3B0LmRhdGE7XG5cbiAgICBjb25zdCB0aW1lUHJvcHMgPSB0aGlzLmdldFRpbWVQcm9wcyh0aW1lT3B0cyk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wcm9wcywgdGltZVByb3BzKTtcblxuICAgIC8vIElmIGVpdGhlciBjYW52YXMgb3IgY29udGV4dCBpcyBjaGFuZ2VkLCB3ZSBzaG91bGQgcmUtdXBkYXRlXG4gICAgaWYgKG9sZENhbnZhcyAhPT0gdGhpcy5fc2V0dGluZ3MuY2FudmFzIHx8IG9sZENvbnRleHQgIT09IHRoaXMuX3NldHRpbmdzLmNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHsgY2FudmFzLCBjb250ZXh0IH0gPSBjcmVhdGVDYW52YXModGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgICB0aGlzLnByb3BzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMucHJvcHMuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAgIC8vIERlbGV0ZSBvciBhZGQgYSAnZ2wnIHByb3AgZm9yIGNvbnZlbmllbmNlXG4gICAgICB0aGlzLl9zZXR1cEdMS2V5KCk7XG5cbiAgICAgIC8vIFJlLW1vdW50IHRoZSBuZXcgY2FudmFzIGlmIGl0IGhhcyBubyBwYXJlbnRcbiAgICAgIHRoaXMuX2FwcGVuZENhbnZhc0lmTmVlZGVkKCk7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgUDUuanNcbiAgICBpZiAob3B0LnA1ICYmIHR5cGVvZiBvcHQucDUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucHJvcHMucDUgPSBvcHQucDU7XG4gICAgICB0aGlzLnByb3BzLnA1LmRyYXcgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pc1A1UmVzaXppbmcpIHJldHVybjtcbiAgICAgICAgdGhpcy5fbGFzdFJlZHJhd1Jlc3VsdCA9IHRoaXMuc3VibWl0RHJhd0NhbGwoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHBsYXlpbmcgc3RhdGUgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKCdwbGF5aW5nJyBpbiBvcHQpIHtcbiAgICAgIGlmIChvcHQucGxheWluZykgdGhpcy5wbGF5KCk7XG4gICAgICBlbHNlIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICBjaGVja1NldHRpbmdzKHRoaXMuX3NldHRpbmdzKTtcblxuICAgIC8vIERyYXcgbmV3IGZyYW1lXG4gICAgdGhpcy5yZXNpemUoKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHJldHVybiB0aGlzLnByb3BzO1xuICB9XG5cbiAgcmVzaXplICgpIHtcbiAgICBjb25zdCBvbGRTaXplcyA9IHRoaXMuX2dldFNpemVQcm9wcygpO1xuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFJlY29tcHV0ZSBuZXcgcHJvcGVydGllcyBiYXNlZCBvbiBjdXJyZW50IHNldHVwXG4gICAgY29uc3QgbmV3UHJvcHMgPSByZXNpemVDYW52YXMocHJvcHMsIHNldHRpbmdzKTtcblxuICAgIC8vIEFzc2lnbiB0byBjdXJyZW50IHByb3BzXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wcm9wcywgbmV3UHJvcHMpO1xuXG4gICAgLy8gTm93IHdlIGFjdHVhbGx5IHVwZGF0ZSB0aGUgY2FudmFzIHdpZHRoL2hlaWdodCBhbmQgc3R5bGUgcHJvcHNcbiAgICBjb25zdCB7XG4gICAgICBwaXhlbFJhdGlvLFxuICAgICAgY2FudmFzV2lkdGgsXG4gICAgICBjYW52YXNIZWlnaHQsXG4gICAgICBzdHlsZVdpZHRoLFxuICAgICAgc3R5bGVIZWlnaHRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFVwZGF0ZSBjYW52YXMgc2V0dGluZ3NcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLnByb3BzLmNhbnZhcztcbiAgICBpZiAoY2FudmFzICYmIHNldHRpbmdzLnJlc2l6ZUNhbnZhcyAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChwcm9wcy5wNSkge1xuICAgICAgICAvLyBQNS5qcyBzcGVjaWZpYyBlZGdlIGNhc2VcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5faXNQNVJlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAvLyBUaGlzIGNhdXNlcyBhIHJlLWRyYXcgOlxcIHNvIHdlIGlnbm9yZSBkcmF3cyBpbiB0aGUgbWVhbiB0aW1lLi4uIHNvcnRhIGhhY2t5XG4gICAgICAgICAgcHJvcHMucDUucGl4ZWxEZW5zaXR5KHBpeGVsUmF0aW8pO1xuICAgICAgICAgIHByb3BzLnA1LnJlc2l6ZUNhbnZhcyhjYW52YXNXaWR0aCAvIHBpeGVsUmF0aW8sIGNhbnZhc0hlaWdodCAvIHBpeGVsUmF0aW8sIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9pc1A1UmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yY2UgY2FudmFzIHNpemVcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGgpIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIGNhbnZhcyBzdHlsZVxuICAgICAgaWYgKGlzQnJvd3NlcigpICYmIHNldHRpbmdzLnN0eWxlQ2FudmFzICE9PSBmYWxzZSkge1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtzdHlsZVdpZHRofXB4YDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke3N0eWxlSGVpZ2h0fXB4YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXdTaXplcyA9IHRoaXMuX2dldFNpemVQcm9wcygpO1xuICAgIGxldCBjaGFuZ2VkID0gIWRlZXBFcXVhbChvbGRTaXplcywgbmV3U2l6ZXMpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9zaXplQ2hhbmdlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIF9zaXplQ2hhbmdlZCAoKSB7XG4gICAgLy8gU2VuZCByZXNpemUgZXZlbnQgdG8gc2tldGNoXG4gICAgaWYgKHRoaXMuc2tldGNoICYmIHR5cGVvZiB0aGlzLnNrZXRjaC5yZXNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuc2tldGNoLnJlc2l6ZSh0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1cblxuICBhbmltYXRlICgpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMucGxheWluZykgcmV0dXJuO1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjYW52YXMtc2tldGNoXSBXQVJOOiBBbmltYXRpb24gaW4gTm9kZS5qcyBpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGVIYW5kbGVyKTtcblxuICAgIGxldCBub3cgPSByaWdodE5vdygpO1xuXG4gICAgY29uc3QgZnBzID0gdGhpcy5wcm9wcy5mcHM7XG4gICAgY29uc3QgZnJhbWVJbnRlcnZhbE1TID0gMTAwMCAvIGZwcztcbiAgICBsZXQgZGVsdGFUaW1lTVMgPSBub3cgLSB0aGlzLl9sYXN0VGltZTtcblxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5wcm9wcy5kdXJhdGlvbjtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoZHVyYXRpb24pO1xuXG4gICAgbGV0IGlzTmV3RnJhbWUgPSB0cnVlO1xuICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9IHRoaXMuc2V0dGluZ3MucGxheWJhY2tSYXRlO1xuICAgIGlmIChwbGF5YmFja1JhdGUgPT09ICdmaXhlZCcpIHtcbiAgICAgIGRlbHRhVGltZU1TID0gZnJhbWVJbnRlcnZhbE1TO1xuICAgIH0gZWxzZSBpZiAocGxheWJhY2tSYXRlID09PSAndGhyb3R0bGUnKSB7XG4gICAgICBpZiAoZGVsdGFUaW1lTVMgPiBmcmFtZUludGVydmFsTVMpIHtcbiAgICAgICAgbm93ID0gbm93IC0gKGRlbHRhVGltZU1TICUgZnJhbWVJbnRlcnZhbE1TKTtcbiAgICAgICAgdGhpcy5fbGFzdFRpbWUgPSBub3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc05ld0ZyYW1lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xhc3RUaW1lID0gbm93O1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhVGltZSA9IGRlbHRhVGltZU1TIC8gMTAwMDtcbiAgICBsZXQgbmV3VGltZSA9IHRoaXMucHJvcHMudGltZSArIGRlbHRhVGltZSAqIHRoaXMucHJvcHMudGltZVNjYWxlO1xuXG4gICAgLy8gSGFuZGxlIHJldmVyc2UgdGltZSBzY2FsZVxuICAgIGlmIChuZXdUaW1lIDwgMCAmJiBoYXNEdXJhdGlvbikge1xuICAgICAgbmV3VGltZSA9IGR1cmF0aW9uICsgbmV3VGltZTtcbiAgICB9XG5cbiAgICAvLyBSZS1zdGFydCBhbmltYXRpb25cbiAgICBsZXQgaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIGxldCBpc0xvb3BTdGFydCA9IGZhbHNlO1xuXG4gICAgY29uc3QgbG9vcGluZyA9IHRoaXMuc2V0dGluZ3MubG9vcCAhPT0gZmFsc2U7XG5cbiAgICBpZiAoaGFzRHVyYXRpb24gJiYgbmV3VGltZSA+PSBkdXJhdGlvbikge1xuICAgICAgLy8gUmUtc3RhcnQgYW5pbWF0aW9uXG4gICAgICBpZiAobG9vcGluZykge1xuICAgICAgICBpc05ld0ZyYW1lID0gdHJ1ZTtcbiAgICAgICAgbmV3VGltZSA9IG5ld1RpbWUgJSBkdXJhdGlvbjtcbiAgICAgICAgaXNMb29wU3RhcnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNOZXdGcmFtZSA9IGZhbHNlO1xuICAgICAgICBuZXdUaW1lID0gZHVyYXRpb247XG4gICAgICAgIGlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zaWduYWxFbmQoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXdGcmFtZSkge1xuICAgICAgdGhpcy5wcm9wcy5kZWx0YVRpbWUgPSBkZWx0YVRpbWU7XG4gICAgICB0aGlzLnByb3BzLnRpbWUgPSBuZXdUaW1lO1xuICAgICAgdGhpcy5wcm9wcy5wbGF5aGVhZCA9IHRoaXMuX2NvbXB1dGVQbGF5aGVhZChuZXdUaW1lLCBkdXJhdGlvbik7XG4gICAgICBjb25zdCBsYXN0RnJhbWUgPSB0aGlzLnByb3BzLmZyYW1lO1xuICAgICAgdGhpcy5wcm9wcy5mcmFtZSA9IHRoaXMuX2NvbXB1dGVDdXJyZW50RnJhbWUoKTtcbiAgICAgIGlmIChpc0xvb3BTdGFydCkgdGhpcy5fc2lnbmFsQmVnaW4oKTtcbiAgICAgIGlmIChsYXN0RnJhbWUgIT09IHRoaXMucHJvcHMuZnJhbWUpIHRoaXMudGljaygpO1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIHRoaXMucHJvcHMuZGVsdGFUaW1lID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNGaW5pc2hlZCkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRpc3BhdGNoIChjYikge1xuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignbXVzdCBwYXNzIGZ1bmN0aW9uIGludG8gZGlzcGF0Y2goKScpO1xuICAgIGNiKHRoaXMucHJvcHMpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICBtb3VudCAoKSB7XG4gICAgdGhpcy5fYXBwZW5kQ2FudmFzSWZOZWVkZWQoKTtcbiAgfVxuXG4gIHVubW91bnQgKCkge1xuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpO1xuICAgICAgdGhpcy5fa2V5Ym9hcmRTaG9ydGN1dHMuZGV0YWNoKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLmNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0aGlzLnByb3BzLmNhbnZhcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMucHJvcHMuY2FudmFzKTtcbiAgICB9XG4gIH1cblxuICBfYXBwZW5kQ2FudmFzSWZOZWVkZWQgKCkge1xuICAgIGlmICghaXNCcm93c2VyKCkpIHJldHVybjtcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5wYXJlbnQgIT09IGZhbHNlICYmICh0aGlzLnByb3BzLmNhbnZhcyAmJiAhdGhpcy5wcm9wcy5jYW52YXMucGFyZW50RWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRQYXJlbnQgPSB0aGlzLnNldHRpbmdzLnBhcmVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgZGVmYXVsdFBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLnByb3BzLmNhbnZhcyk7XG4gICAgfVxuICB9XG5cbiAgX3NldHVwR0xLZXkgKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmNvbnRleHQpIHtcbiAgICAgIGlmIChpc1dlYkdMQ29udGV4dCh0aGlzLnByb3BzLmNvbnRleHQpKSB7XG4gICAgICAgIHRoaXMuX3Byb3BzLmdsID0gdGhpcy5wcm9wcy5jb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Byb3BzLmdsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldFRpbWVQcm9wcyAoc2V0dGluZ3MgPSB7fSkge1xuICAgIC8vIEdldCB0aW1pbmcgZGF0YVxuICAgIGxldCBkdXJhdGlvbiA9IHNldHRpbmdzLmR1cmF0aW9uO1xuICAgIGxldCB0b3RhbEZyYW1lcyA9IHNldHRpbmdzLnRvdGFsRnJhbWVzO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IGRlZmluZWQoc2V0dGluZ3MudGltZVNjYWxlLCAxKTtcbiAgICBjb25zdCBmcHMgPSBkZWZpbmVkKHNldHRpbmdzLmZwcywgMjQpO1xuICAgIGNvbnN0IGhhc0R1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShkdXJhdGlvbik7XG4gICAgY29uc3QgaGFzVG90YWxGcmFtZXMgPSB0eXBlb2YgdG90YWxGcmFtZXMgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHRvdGFsRnJhbWVzKTtcblxuICAgIGNvbnN0IHRvdGFsRnJhbWVzRnJvbUR1cmF0aW9uID0gaGFzRHVyYXRpb24gPyBNYXRoLmZsb29yKGZwcyAqIGR1cmF0aW9uKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBkdXJhdGlvbkZyb21Ub3RhbEZyYW1lcyA9IGhhc1RvdGFsRnJhbWVzID8gKHRvdGFsRnJhbWVzIC8gZnBzKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoaGFzRHVyYXRpb24gJiYgaGFzVG90YWxGcmFtZXMgJiYgdG90YWxGcmFtZXNGcm9tRHVyYXRpb24gIT09IHRvdGFsRnJhbWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzaG91bGQgc3BlY2lmeSBlaXRoZXIgZHVyYXRpb24gb3IgdG90YWxGcmFtZXMsIGJ1dCBub3QgYm90aC4gT3IsIHRoZXkgbXVzdCBtYXRjaCBleGFjdGx5LicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZGltZW5zaW9ucyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHNldHRpbmdzLnVuaXRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKGBZb3UndmUgc3BlY2lmaWVkIGEgeyB1bml0cyB9IHNldHRpbmcgYnV0IG5vIHsgZGltZW5zaW9uIH0sIHNvIHRoZSB1bml0cyB3aWxsIGJlIGlnbm9yZWQuYCk7XG4gICAgfVxuXG4gICAgdG90YWxGcmFtZXMgPSBkZWZpbmVkKHRvdGFsRnJhbWVzLCB0b3RhbEZyYW1lc0Zyb21EdXJhdGlvbiwgSW5maW5pdHkpO1xuICAgIGR1cmF0aW9uID0gZGVmaW5lZChkdXJhdGlvbiwgZHVyYXRpb25Gcm9tVG90YWxGcmFtZXMsIEluZmluaXR5KTtcblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNldHRpbmdzLnRpbWU7XG4gICAgY29uc3Qgc3RhcnRGcmFtZSA9IHNldHRpbmdzLmZyYW1lO1xuICAgIGNvbnN0IGhhc1N0YXJ0VGltZSA9IHR5cGVvZiBzdGFydFRpbWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHN0YXJ0VGltZSk7XG4gICAgY29uc3QgaGFzU3RhcnRGcmFtZSA9IHR5cGVvZiBzdGFydEZyYW1lID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShzdGFydEZyYW1lKTtcblxuICAgIC8vIHN0YXJ0IGF0IHplcm8gdW5sZXNzIHVzZXIgc3BlY2lmaWVzIGZyYW1lIG9yIHRpbWUgKGJ1dCBub3QgYm90aCBtaXNtYXRjaGVkKVxuICAgIGxldCB0aW1lID0gMDtcbiAgICBsZXQgZnJhbWUgPSAwO1xuICAgIGxldCBwbGF5aGVhZCA9IDA7XG4gICAgaWYgKGhhc1N0YXJ0VGltZSAmJiBoYXNTdGFydEZyYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzaG91bGQgc3BlY2lmeSBlaXRoZXIgc3RhcnQgZnJhbWUgb3IgdGltZSwgYnV0IG5vdCBib3RoLicpO1xuICAgIH0gZWxzZSBpZiAoaGFzU3RhcnRUaW1lKSB7XG4gICAgICAvLyBVc2VyIHNwZWNpZmllcyB0aW1lLCB3ZSBpbmZlciBmcmFtZXMgZnJvbSBGUFNcbiAgICAgIHRpbWUgPSBzdGFydFRpbWU7XG4gICAgICBwbGF5aGVhZCA9IHRoaXMuX2NvbXB1dGVQbGF5aGVhZCh0aW1lLCBkdXJhdGlvbik7XG4gICAgICBmcmFtZSA9IHRoaXMuX2NvbXB1dGVGcmFtZShcbiAgICAgICAgcGxheWhlYWQsIHRpbWUsXG4gICAgICAgIHRvdGFsRnJhbWVzLCBmcHNcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChoYXNTdGFydEZyYW1lKSB7XG4gICAgICAvLyBVc2VyIHNwZWNpZmllcyBmcmFtZSBudW1iZXIsIHdlIGluZmVyIHRpbWUgZnJvbSBGUFNcbiAgICAgIGZyYW1lID0gc3RhcnRGcmFtZTtcbiAgICAgIHRpbWUgPSBmcmFtZSAvIGZwcztcbiAgICAgIHBsYXloZWFkID0gdGhpcy5fY29tcHV0ZVBsYXloZWFkKHRpbWUsIGR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGxheWhlYWQsXG4gICAgICB0aW1lLFxuICAgICAgZnJhbWUsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHRvdGFsRnJhbWVzLFxuICAgICAgZnBzLFxuICAgICAgdGltZVNjYWxlXG4gICAgfTtcbiAgfVxuXG4gIHNldHVwIChzZXR0aW5ncyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuc2tldGNoKSB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNldHVwKCkgY2FsbHMgbm90IHlldCBzdXBwb3J0ZWQuJyk7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzLCB0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICBjaGVja1NldHRpbmdzKHRoaXMuX3NldHRpbmdzKTtcblxuICAgIC8vIEdldCBpbml0aWFsIGNhbnZhcyAmIGNvbnRleHRcbiAgICBjb25zdCB7IGNvbnRleHQsIGNhbnZhcyB9ID0gY3JlYXRlQ2FudmFzKHRoaXMuX3NldHRpbmdzKTtcblxuICAgIGNvbnN0IHRpbWVQcm9wcyA9IHRoaXMuZ2V0VGltZVByb3BzKHRoaXMuX3NldHRpbmdzKTtcblxuICAgIC8vIEluaXRpYWwgcmVuZGVyIHN0YXRlIGZlYXR1cmVzXG4gICAgdGhpcy5fcHJvcHMgPSB7XG4gICAgICAuLi50aW1lUHJvcHMsXG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgZGVsdGFUaW1lOiAwLFxuICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICBleHBvcnRpbmc6IGZhbHNlLFxuICAgICAgcGxheWluZzogZmFsc2UsXG4gICAgICByZWNvcmRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICBkYXRhOiB0aGlzLnNldHRpbmdzLmRhdGEsXG5cbiAgICAgIC8vIEV4cG9ydCBzb21lIHNwZWNpZmljIGFjdGlvbnMgdG8gdGhlIHNrZXRjaFxuICAgICAgcmVuZGVyOiAoKSA9PiB0aGlzLnJlbmRlcigpLFxuICAgICAgdG9nZ2xlUGxheTogKCkgPT4gdGhpcy50b2dnbGVQbGF5KCksXG4gICAgICBkaXNwYXRjaDogKGNiKSA9PiB0aGlzLmRpc3BhdGNoKGNiKSxcbiAgICAgIHRpY2s6ICgpID0+IHRoaXMudGljaygpLFxuICAgICAgcmVzaXplOiAoKSA9PiB0aGlzLnJlc2l6ZSgpLFxuICAgICAgdXBkYXRlOiAob3B0KSA9PiB0aGlzLnVwZGF0ZShvcHQpLFxuICAgICAgZXhwb3J0RnJhbWU6IG9wdCA9PiB0aGlzLmV4cG9ydEZyYW1lKG9wdCksXG4gICAgICByZWNvcmQ6ICgpID0+IHRoaXMucmVjb3JkKCksXG4gICAgICBwbGF5OiAoKSA9PiB0aGlzLnBsYXkoKSxcbiAgICAgIHBhdXNlOiAoKSA9PiB0aGlzLnBhdXNlKCksXG4gICAgICBzdG9wOiAoKSA9PiB0aGlzLnN0b3AoKVxuICAgIH07XG5cbiAgICAvLyBGb3IgV2ViR0wgc2tldGNoZXMsIGEgZ2wgdmFyaWFibGUgcmVhZHMgYSBiaXQgYmV0dGVyXG4gICAgdGhpcy5fc2V0dXBHTEtleSgpO1xuXG4gICAgLy8gVHJpZ2dlciBpbml0aWFsIHJlc2l6ZSBub3cgc28gdGhhdCBjYW52YXMgaXMgYWxyZWFkeSBzaXplZFxuICAgIC8vIGJ5IHRoZSB0aW1lIHdlIGxvYWQgdGhlIHNrZXRjaFxuICAgIHRoaXMucmVzaXplKCk7XG4gIH1cblxuICBsb2FkQW5kUnVuIChjYW52YXNTa2V0Y2gsIG5ld1NldHRpbmdzKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZChjYW52YXNTa2V0Y2gsIG5ld1NldHRpbmdzKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuXG4gIHVubG9hZCAoKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIGlmICghdGhpcy5za2V0Y2gpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRoaXMuc2tldGNoLnVubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd3JhcENvbnRleHRTY2FsZShwcm9wcyA9PiB0aGlzLnNrZXRjaC51bmxvYWQocHJvcHMpKTtcbiAgICB9XG4gICAgdGhpcy5fc2tldGNoID0gbnVsbDtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMudW5sb2FkKCk7XG4gICAgdGhpcy51bm1vdW50KCk7XG4gIH1cblxuICBsb2FkIChjcmVhdGVTa2V0Y2gsIG5ld1NldHRpbmdzKSB7XG4gICAgLy8gVXNlciBkaWRuJ3Qgc3BlY2lmeSBhIGZ1bmN0aW9uXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVTa2V0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIG11c3QgdGFrZSBpbiBhIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuIEV4YW1wbGU6XFxuICBjYW52YXNTa2V0Y2hlcigoKSA9PiB7IC4uLiB9LCBzZXR0aW5ncyknKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5za2V0Y2gpIHtcbiAgICAgIHRoaXMudW5sb2FkKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdTZXR0aW5ncyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudXBkYXRlKG5ld1NldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgdHJpY2t5IGNhc2U7IHdlIHNldCB1cCB0aGUgYXV0by1zY2FsaW5nIGhlcmVcbiAgICAvLyBpbiBjYXNlIHRoZSB1c2VyIGRlY2lkZXMgdG8gcmVuZGVyIGFueXRoaW5nIHRvIHRoZSBjb250ZXh0ICpiZWZvcmUqIHRoZVxuICAgIC8vIHJlbmRlcigpIGZ1bmN0aW9uLi4uIEhvd2V2ZXIsIHVzZXJzIHNob3VsZCBpbnN0ZWFkIHVzZSBiZWdpbigpIGZ1bmN0aW9uIGZvciB0aGF0LlxuICAgIHRoaXMuX3ByZVJlbmRlcigpO1xuXG4gICAgbGV0IHByZWxvYWQgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIC8vIEJlY2F1c2Ugb2YgUDUuanMncyB1bnVzdWFsIHN0cnVjdHVyZSwgd2UgaGF2ZSB0byBkbyBhIGJpdCBvZlxuICAgIC8vIGxpYnJhcnktc3BlY2lmaWMgY2hhbmdlcyB0byBzdXBwb3J0IGl0IHByb3Blcmx5LlxuICAgIGlmICh0aGlzLnNldHRpbmdzLnA1KSB7XG4gICAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2NhbnZhcy1za2V0Y2hdIEVSUk9SOiBVc2luZyBwNS5qcyBpbiBOb2RlLmpzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHByZWxvYWQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgbGV0IFA1Q29uc3RydWN0b3IgPSB0aGlzLnNldHRpbmdzLnA1O1xuICAgICAgICBsZXQgcHJlbG9hZDtcbiAgICAgICAgaWYgKFA1Q29uc3RydWN0b3IucDUpIHtcbiAgICAgICAgICBwcmVsb2FkID0gUDVDb25zdHJ1Y3Rvci5wcmVsb2FkO1xuICAgICAgICAgIFA1Q29uc3RydWN0b3IgPSBQNUNvbnN0cnVjdG9yLnA1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHNrZXRjaCBzZXR1cDsgZGlzYWJsZSBsb29wLCBzZXQgc2l6aW5nLCBldGMuXG4gICAgICAgIGNvbnN0IHA1U2tldGNoID0gcDUgPT4ge1xuICAgICAgICAgIC8vIEhvb2sgaW4gcHJlbG9hZCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBpZiAocHJlbG9hZCkgcDUucHJlbG9hZCA9ICgpID0+IHByZWxvYWQocDUpO1xuICAgICAgICAgIHA1LnNldHVwID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgaXNHTCA9IHRoaXMuc2V0dGluZ3MuY29udGV4dCA9PT0gJ3dlYmdsJztcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gaXNHTCA/IHA1LldFQkdMIDogcDUuUDJEO1xuICAgICAgICAgICAgcDUubm9Mb29wKCk7XG4gICAgICAgICAgICBwNS5waXhlbERlbnNpdHkocHJvcHMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBwNS5jcmVhdGVDYW52YXMocHJvcHMudmlld3BvcnRXaWR0aCwgcHJvcHMudmlld3BvcnRIZWlnaHQsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgIGlmIChpc0dMICYmIHRoaXMuc2V0dGluZ3MuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBwNS5zZXRBdHRyaWJ1dGVzKHRoaXMuc2V0dGluZ3MuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgcDUsIGNhbnZhczogcDUuY2FudmFzLCBjb250ZXh0OiBwNS5fcmVuZGVyZXIuZHJhd2luZ0NvbnRleHQgfSk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTdXBwb3J0IGdsb2JhbCBhbmQgaW5zdGFuY2UgUDUuanMgbW9kZXNcbiAgICAgICAgaWYgKHR5cGVvZiBQNUNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbmV3IFA1Q29uc3RydWN0b3IocDVTa2V0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmNyZWF0ZUNhbnZhcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieyBwNSB9IHNldHRpbmcgaXMgcGFzc2VkIGJ1dCBjYW4ndCBmaW5kIHA1LmpzIGluIGdsb2JhbCAod2luZG93KSBzY29wZS4gTWF5YmUgeW91IGRpZCBub3QgY3JlYXRlIGl0IGdsb2JhbGx5P1xcbm5ldyBwNSgpOyAvLyA8LS0gYXR0YWNoZXMgdG8gZ2xvYmFsIHNjb3BlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwNVNrZXRjaCh3aW5kb3cpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlbG9hZC50aGVuKCgpID0+IHtcbiAgICAgIC8vIExvYWQgdGhlIHVzZXIncyBza2V0Y2hcbiAgICAgIGxldCBsb2FkZXIgPSBjcmVhdGVTa2V0Y2godGhpcy5wcm9wcyk7XG4gICAgICBpZiAoIWlzUHJvbWlzZShsb2FkZXIpKSB7XG4gICAgICAgIGxvYWRlciA9IFByb21pc2UucmVzb2x2ZShsb2FkZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9KS50aGVuKHNrZXRjaCA9PiB7XG4gICAgICBpZiAoIXNrZXRjaCkgc2tldGNoID0ge307XG4gICAgICB0aGlzLl9za2V0Y2ggPSBza2V0Y2g7XG5cbiAgICAgIC8vIE9uY2UgdGhlIHNrZXRjaCBpcyBsb2FkZWQgd2UgY2FuIGFkZCB0aGUgZXZlbnRzXG4gICAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgdGhpcy5fa2V5Ym9hcmRTaG9ydGN1dHMuYXR0YWNoKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9yZXNpemVIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcG9zdFJlbmRlcigpO1xuXG4gICAgICAvLyBUaGUgaW5pdGlhbCByZXNpemUoKSBpbiB0aGUgY29uc3RydWN0b3Igd2lsbCBub3QgaGF2ZVxuICAgICAgLy8gdHJpZ2dlcmVkIGEgcmVzaXplKCkgZXZlbnQgb24gdGhlIHNrZXRjaCwgc2luY2UgaXQgd2FzIGJlZm9yZVxuICAgICAgLy8gdGhlIHNrZXRjaCB3YXMgbG9hZGVkLiBTbyB3ZSBzZW5kIHRoZSBzaWduYWwgaGVyZSwgYWxsb3dpbmdcbiAgICAgIC8vIHVzZXJzIHRvIHJlYWN0IHRvIHRoZSBpbml0aWFsIHNpemUgYmVmb3JlIGZpcnN0IHJlbmRlci5cbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc3RhcnQgc2tldGNoLCB0aGUgYXN5bmMgbG9hZGluZyBmdW5jdGlvbiByZWplY3RlZCB3aXRoIGFuIGVycm9yOlxcbiAgICBFcnJvcjogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTa2V0Y2hNYW5hZ2VyO1xuIiwiaW1wb3J0IFNrZXRjaE1hbmFnZXIgZnJvbSAnLi9jb3JlL1NrZXRjaE1hbmFnZXInO1xuaW1wb3J0IFBhcGVyU2l6ZXMgZnJvbSAnLi9wYXBlci1zaXplcyc7XG5pbXBvcnQgeyBnZXRDbGllbnRBUEksIGRlZmluZWQgfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBDQUNIRSA9ICdob3QtaWQtY2FjaGUnO1xuY29uc3QgcnVudGltZUNvbGxpc2lvbnMgPSBbXTtcblxuZnVuY3Rpb24gaXNIb3RSZWxvYWQgKCkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgcmV0dXJuIGNsaWVudCAmJiBjbGllbnQuaG90O1xufVxuXG5mdW5jdGlvbiBjYWNoZUdldCAoaWQpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50QVBJKCk7XG4gIGlmICghY2xpZW50KSByZXR1cm4gdW5kZWZpbmVkO1xuICBjbGllbnRbQ0FDSEVdID0gY2xpZW50W0NBQ0hFXSB8fCB7fTtcbiAgcmV0dXJuIGNsaWVudFtDQUNIRV1baWRdO1xufVxuXG5mdW5jdGlvbiBjYWNoZVB1dCAoaWQsIGRhdGEpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50QVBJKCk7XG4gIGlmICghY2xpZW50KSByZXR1cm4gdW5kZWZpbmVkO1xuICBjbGllbnRbQ0FDSEVdID0gY2xpZW50W0NBQ0hFXSB8fCB7fTtcbiAgY2xpZW50W0NBQ0hFXVtpZF0gPSBkYXRhO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lUHJvcCAob2xkTWFuYWdlciwgbmV3U2V0dGluZ3MpIHtcbiAgLy8gU3RhdGljIHNrZXRjaGVzIGlnbm9yZSB0aGUgdGltZSBwZXJzaXN0ZW5jeVxuICByZXR1cm4gbmV3U2V0dGluZ3MuYW5pbWF0ZSA/IHsgdGltZTogb2xkTWFuYWdlci5wcm9wcy50aW1lIH0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGNhbnZhc1NrZXRjaCAoc2tldGNoLCBzZXR0aW5ncyA9IHt9KSB7XG4gIGlmIChzZXR0aW5ncy5wNSkge1xuICAgIGlmIChzZXR0aW5ncy5jYW52YXMgfHwgKHNldHRpbmdzLmNvbnRleHQgJiYgdHlwZW9mIHNldHRpbmdzLmNvbnRleHQgIT09ICdzdHJpbmcnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbiB7IHA1IH0gbW9kZSwgeW91IGNhbid0IHBhc3MgeW91ciBvd24gY2FudmFzIG9yIGNvbnRleHQsIHVubGVzcyB0aGUgY29udGV4dCBpcyBhIFwid2ViZ2xcIiBvciBcIjJkXCIgc3RyaW5nYCk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGNyZWF0ZSBhIGNhbnZhcyBvbiBzdGFydHVwLCBzaW5jZSBQNS5qcyBkb2VzIHRoYXQgZm9yIHVzXG4gICAgY29uc3QgY29udGV4dCA9IHR5cGVvZiBzZXR0aW5ncy5jb250ZXh0ID09PSAnc3RyaW5nJyA/IHNldHRpbmdzLmNvbnRleHQgOiBmYWxzZTtcbiAgICBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzLCB7IGNhbnZhczogZmFsc2UsIGNvbnRleHQgfSk7XG4gIH1cblxuICBjb25zdCBpc0hvdCA9IGlzSG90UmVsb2FkKCk7XG4gIGxldCBob3RJRDtcbiAgaWYgKGlzSG90KSB7XG4gICAgLy8gVXNlIGEgbWFnaWMgbmFtZSBieSBkZWZhdWx0LCBmb3JjZSB1c2VyIHRvIGRlZmluZSBlYWNoIHNrZXRjaCBpZiB0aGV5XG4gICAgLy8gcmVxdWlyZSBtb3JlIHRoYW4gb25lIGluIGFuIGFwcGxpY2F0aW9uLiBPcGVuIHRvIG90aGVyIGlkZWFzIG9uIGhvdyB0byB0YWNrbGVcbiAgICAvLyB0aGlzIGFzIHdlbGwuLi5cbiAgICBob3RJRCA9IGRlZmluZWQoc2V0dGluZ3MuaWQsICckX19ERUZBVUxUX0NBTlZBU19TS0VUQ0hfSURfXyQnKTtcbiAgfVxuICBsZXQgaXNJbmplY3RpbmcgPSBpc0hvdCAmJiB0eXBlb2YgaG90SUQgPT09ICdzdHJpbmcnO1xuXG4gIGlmIChpc0luamVjdGluZyAmJiBydW50aW1lQ29sbGlzaW9ucy5pbmNsdWRlcyhob3RJRCkpIHtcbiAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IFlvdSBoYXZlIG11bHRpcGxlIGNhbGxzIHRvIGNhbnZhc1NrZXRjaCgpIGluIC0taG90IG1vZGUuIFlvdSBtdXN0IHBhc3MgdW5pcXVlIHsgaWQgfSBzdHJpbmdzIGluIHNldHRpbmdzIHRvIGVuYWJsZSBob3QgcmVsb2FkIGFjcm9zcyBtdWx0aXBsZSBza2V0Y2hlcy4gYCwgaG90SUQpO1xuICAgIGlzSW5qZWN0aW5nID0gZmFsc2U7XG4gIH1cblxuICBsZXQgcHJlbG9hZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIGlmIChpc0luamVjdGluZykge1xuICAgIC8vIE1hcmsgdGhpcyBhcyBhbHJlYWR5IHNwb3R0ZWQgaW4gdGhpcyBydW50aW1lIGluc3RhbmNlXG4gICAgcnVudGltZUNvbGxpc2lvbnMucHVzaChob3RJRCk7XG5cbiAgICBjb25zdCBwcmV2aW91c0RhdGEgPSBjYWNoZUdldChob3RJRCk7XG4gICAgaWYgKHByZXZpb3VzRGF0YSkge1xuICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgLy8gR3JhYiBuZXcgcHJvcHMgZnJvbSBvbGQgc2tldGNoIGluc3RhbmNlXG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0gZ2V0VGltZVByb3AocHJldmlvdXNEYXRhLm1hbmFnZXIsIHNldHRpbmdzKTtcbiAgICAgICAgLy8gRGVzdHJveSB0aGUgb2xkIGluc3RhbmNlXG4gICAgICAgIHByZXZpb3VzRGF0YS5tYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gUGFzcyBhbG9uZyBuZXcgcHJvcHNcbiAgICAgICAgcmV0dXJuIG5ld1Byb3BzO1xuICAgICAgfTtcblxuICAgICAgLy8gTW92ZSBhbG9uZyB0aGUgbmV4dCBkYXRhLi4uXG4gICAgICBwcmVsb2FkID0gcHJldmlvdXNEYXRhLmxvYWQudGhlbihuZXh0KS5jYXRjaChuZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJlbG9hZC50aGVuKG5ld1Byb3BzID0+IHtcbiAgICBjb25zdCBtYW5hZ2VyID0gbmV3IFNrZXRjaE1hbmFnZXIoKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChza2V0Y2gpIHtcbiAgICAgIC8vIE1lcmdlIHdpdGggaW5jb21pbmcgZGF0YVxuICAgICAgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncywgbmV3UHJvcHMpO1xuXG4gICAgICAvLyBBcHBseSBzZXR0aW5ncyBhbmQgY3JlYXRlIGEgY2FudmFzXG4gICAgICBtYW5hZ2VyLnNldHVwKHNldHRpbmdzKTtcblxuICAgICAgLy8gTW91bnQgdG8gRE9NXG4gICAgICBtYW5hZ2VyLm1vdW50KCk7XG5cbiAgICAgIC8vIGxvYWQgdGhlIHNrZXRjaCBmaXJzdFxuICAgICAgcmVzdWx0ID0gbWFuYWdlci5sb2FkQW5kUnVuKHNrZXRjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShtYW5hZ2VyKTtcbiAgICB9XG4gICAgaWYgKGlzSW5qZWN0aW5nKSB7XG4gICAgICBjYWNoZVB1dChob3RJRCwgeyBsb2FkOiByZXN1bHQsIG1hbmFnZXIgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG4vLyBUT0RPOiBGaWd1cmUgb3V0IGEgbmljZSB3YXkgdG8gZXhwb3J0IHRoaW5ncy5cbmNhbnZhc1NrZXRjaC5jYW52YXNTa2V0Y2ggPSBjYW52YXNTa2V0Y2g7XG5jYW52YXNTa2V0Y2guUGFwZXJTaXplcyA9IFBhcGVyU2l6ZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNhbnZhc1NrZXRjaDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEwLTIwMjEgVGhyZWUuanMgQXV0aG9yc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLlRIUkVFID0ge30pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuXHRjb25zdCBSRVZJU0lPTiA9ICcxMzEnO1xuXHRjb25zdCBNT1VTRSA9IHtcblx0XHRMRUZUOiAwLFxuXHRcdE1JRERMRTogMSxcblx0XHRSSUdIVDogMixcblx0XHRST1RBVEU6IDAsXG5cdFx0RE9MTFk6IDEsXG5cdFx0UEFOOiAyXG5cdH07XG5cdGNvbnN0IFRPVUNIID0ge1xuXHRcdFJPVEFURTogMCxcblx0XHRQQU46IDEsXG5cdFx0RE9MTFlfUEFOOiAyLFxuXHRcdERPTExZX1JPVEFURTogM1xuXHR9O1xuXHRjb25zdCBDdWxsRmFjZU5vbmUgPSAwO1xuXHRjb25zdCBDdWxsRmFjZUJhY2sgPSAxO1xuXHRjb25zdCBDdWxsRmFjZUZyb250ID0gMjtcblx0Y29uc3QgQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xuXHRjb25zdCBCYXNpY1NoYWRvd01hcCA9IDA7XG5cdGNvbnN0IFBDRlNoYWRvd01hcCA9IDE7XG5cdGNvbnN0IFBDRlNvZnRTaGFkb3dNYXAgPSAyO1xuXHRjb25zdCBWU01TaGFkb3dNYXAgPSAzO1xuXHRjb25zdCBGcm9udFNpZGUgPSAwO1xuXHRjb25zdCBCYWNrU2lkZSA9IDE7XG5cdGNvbnN0IERvdWJsZVNpZGUgPSAyO1xuXHRjb25zdCBGbGF0U2hhZGluZyA9IDE7XG5cdGNvbnN0IFNtb290aFNoYWRpbmcgPSAyO1xuXHRjb25zdCBOb0JsZW5kaW5nID0gMDtcblx0Y29uc3QgTm9ybWFsQmxlbmRpbmcgPSAxO1xuXHRjb25zdCBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcblx0Y29uc3QgU3VidHJhY3RpdmVCbGVuZGluZyA9IDM7XG5cdGNvbnN0IE11bHRpcGx5QmxlbmRpbmcgPSA0O1xuXHRjb25zdCBDdXN0b21CbGVuZGluZyA9IDU7XG5cdGNvbnN0IEFkZEVxdWF0aW9uID0gMTAwO1xuXHRjb25zdCBTdWJ0cmFjdEVxdWF0aW9uID0gMTAxO1xuXHRjb25zdCBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcblx0Y29uc3QgTWluRXF1YXRpb24gPSAxMDM7XG5cdGNvbnN0IE1heEVxdWF0aW9uID0gMTA0O1xuXHRjb25zdCBaZXJvRmFjdG9yID0gMjAwO1xuXHRjb25zdCBPbmVGYWN0b3IgPSAyMDE7XG5cdGNvbnN0IFNyY0NvbG9yRmFjdG9yID0gMjAyO1xuXHRjb25zdCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuXHRjb25zdCBTcmNBbHBoYUZhY3RvciA9IDIwNDtcblx0Y29uc3QgT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcblx0Y29uc3QgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5cdGNvbnN0IE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5cdGNvbnN0IERzdENvbG9yRmFjdG9yID0gMjA4O1xuXHRjb25zdCBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuXHRjb25zdCBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gMjEwO1xuXHRjb25zdCBOZXZlckRlcHRoID0gMDtcblx0Y29uc3QgQWx3YXlzRGVwdGggPSAxO1xuXHRjb25zdCBMZXNzRGVwdGggPSAyO1xuXHRjb25zdCBMZXNzRXF1YWxEZXB0aCA9IDM7XG5cdGNvbnN0IEVxdWFsRGVwdGggPSA0O1xuXHRjb25zdCBHcmVhdGVyRXF1YWxEZXB0aCA9IDU7XG5cdGNvbnN0IEdyZWF0ZXJEZXB0aCA9IDY7XG5cdGNvbnN0IE5vdEVxdWFsRGVwdGggPSA3O1xuXHRjb25zdCBNdWx0aXBseU9wZXJhdGlvbiA9IDA7XG5cdGNvbnN0IE1peE9wZXJhdGlvbiA9IDE7XG5cdGNvbnN0IEFkZE9wZXJhdGlvbiA9IDI7XG5cdGNvbnN0IE5vVG9uZU1hcHBpbmcgPSAwO1xuXHRjb25zdCBMaW5lYXJUb25lTWFwcGluZyA9IDE7XG5cdGNvbnN0IFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xuXHRjb25zdCBDaW5lb25Ub25lTWFwcGluZyA9IDM7XG5cdGNvbnN0IEFDRVNGaWxtaWNUb25lTWFwcGluZyA9IDQ7XG5cdGNvbnN0IEN1c3RvbVRvbmVNYXBwaW5nID0gNTtcblx0Y29uc3QgVVZNYXBwaW5nID0gMzAwO1xuXHRjb25zdCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG5cdGNvbnN0IEN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcblx0Y29uc3QgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDM7XG5cdGNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuXHRjb25zdCBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IDMwNjtcblx0Y29uc3QgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDc7XG5cdGNvbnN0IFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcblx0Y29uc3QgQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XG5cdGNvbnN0IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xuXHRjb25zdCBOZWFyZXN0RmlsdGVyID0gMTAwMztcblx0Y29uc3QgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuXHRjb25zdCBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5cdGNvbnN0IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuXHRjb25zdCBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcblx0Y29uc3QgTGluZWFyRmlsdGVyID0gMTAwNjtcblx0Y29uc3QgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5cdGNvbnN0IExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuXHRjb25zdCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuXHRjb25zdCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuXHRjb25zdCBVbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcblx0Y29uc3QgQnl0ZVR5cGUgPSAxMDEwO1xuXHRjb25zdCBTaG9ydFR5cGUgPSAxMDExO1xuXHRjb25zdCBVbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XG5cdGNvbnN0IEludFR5cGUgPSAxMDEzO1xuXHRjb25zdCBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuXHRjb25zdCBGbG9hdFR5cGUgPSAxMDE1O1xuXHRjb25zdCBIYWxmRmxvYXRUeXBlID0gMTAxNjtcblx0Y29uc3QgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcblx0Y29uc3QgVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxODtcblx0Y29uc3QgVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE5O1xuXHRjb25zdCBVbnNpZ25lZEludDI0OFR5cGUgPSAxMDIwO1xuXHRjb25zdCBBbHBoYUZvcm1hdCA9IDEwMjE7XG5cdGNvbnN0IFJHQkZvcm1hdCA9IDEwMjI7XG5cdGNvbnN0IFJHQkFGb3JtYXQgPSAxMDIzO1xuXHRjb25zdCBMdW1pbmFuY2VGb3JtYXQgPSAxMDI0O1xuXHRjb25zdCBMdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjU7XG5cdGNvbnN0IFJHQkVGb3JtYXQgPSBSR0JBRm9ybWF0O1xuXHRjb25zdCBEZXB0aEZvcm1hdCA9IDEwMjY7XG5cdGNvbnN0IERlcHRoU3RlbmNpbEZvcm1hdCA9IDEwMjc7XG5cdGNvbnN0IFJlZEZvcm1hdCA9IDEwMjg7XG5cdGNvbnN0IFJlZEludGVnZXJGb3JtYXQgPSAxMDI5O1xuXHRjb25zdCBSR0Zvcm1hdCA9IDEwMzA7XG5cdGNvbnN0IFJHSW50ZWdlckZvcm1hdCA9IDEwMzE7XG5cdGNvbnN0IFJHQkludGVnZXJGb3JtYXQgPSAxMDMyO1xuXHRjb25zdCBSR0JBSW50ZWdlckZvcm1hdCA9IDEwMzM7XG5cdGNvbnN0IFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3NzY7XG5cdGNvbnN0IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDMzNzc3O1xuXHRjb25zdCBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAzMzc3ODtcblx0Y29uc3QgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMzM3Nzk7XG5cdGNvbnN0IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMzU4NDA7XG5cdGNvbnN0IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDE7XG5cdGNvbnN0IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQyO1xuXHRjb25zdCBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAzNTg0Mztcblx0Y29uc3QgUkdCX0VUQzFfRm9ybWF0ID0gMzYxOTY7XG5cdGNvbnN0IFJHQl9FVEMyX0Zvcm1hdCA9IDM3NDkyO1xuXHRjb25zdCBSR0JBX0VUQzJfRUFDX0Zvcm1hdCA9IDM3NDk2O1xuXHRjb25zdCBSR0JBX0FTVENfNHg0X0Zvcm1hdCA9IDM3ODA4O1xuXHRjb25zdCBSR0JBX0FTVENfNXg0X0Zvcm1hdCA9IDM3ODA5O1xuXHRjb25zdCBSR0JBX0FTVENfNXg1X0Zvcm1hdCA9IDM3ODEwO1xuXHRjb25zdCBSR0JBX0FTVENfNng1X0Zvcm1hdCA9IDM3ODExO1xuXHRjb25zdCBSR0JBX0FTVENfNng2X0Zvcm1hdCA9IDM3ODEyO1xuXHRjb25zdCBSR0JBX0FTVENfOHg1X0Zvcm1hdCA9IDM3ODEzO1xuXHRjb25zdCBSR0JBX0FTVENfOHg2X0Zvcm1hdCA9IDM3ODE0O1xuXHRjb25zdCBSR0JBX0FTVENfOHg4X0Zvcm1hdCA9IDM3ODE1O1xuXHRjb25zdCBSR0JBX0FTVENfMTB4NV9Gb3JtYXQgPSAzNzgxNjtcblx0Y29uc3QgUkdCQV9BU1RDXzEweDZfRm9ybWF0ID0gMzc4MTc7XG5cdGNvbnN0IFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCA9IDM3ODE4O1xuXHRjb25zdCBSR0JBX0FTVENfMTB4MTBfRm9ybWF0ID0gMzc4MTk7XG5cdGNvbnN0IFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQgPSAzNzgyMDtcblx0Y29uc3QgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCA9IDM3ODIxO1xuXHRjb25zdCBSR0JBX0JQVENfRm9ybWF0ID0gMzY0OTI7XG5cdGNvbnN0IFNSR0I4X0FMUEhBOF9BU1RDXzR4NF9Gb3JtYXQgPSAzNzg0MDtcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfNXg0X0Zvcm1hdCA9IDM3ODQxO1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ181eDVfRm9ybWF0ID0gMzc4NDI7XG5cdGNvbnN0IFNSR0I4X0FMUEhBOF9BU1RDXzZ4NV9Gb3JtYXQgPSAzNzg0Mztcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfNng2X0Zvcm1hdCA9IDM3ODQ0O1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ184eDVfRm9ybWF0ID0gMzc4NDU7XG5cdGNvbnN0IFNSR0I4X0FMUEhBOF9BU1RDXzh4Nl9Gb3JtYXQgPSAzNzg0Njtcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfOHg4X0Zvcm1hdCA9IDM3ODQ3O1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ18xMHg1X0Zvcm1hdCA9IDM3ODQ4O1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ18xMHg2X0Zvcm1hdCA9IDM3ODQ5O1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ18xMHg4X0Zvcm1hdCA9IDM3ODUwO1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ18xMHgxMF9Gb3JtYXQgPSAzNzg1MTtcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTBfRm9ybWF0ID0gMzc4NTI7XG5cdGNvbnN0IFNSR0I4X0FMUEhBOF9BU1RDXzEyeDEyX0Zvcm1hdCA9IDM3ODUzO1xuXHRjb25zdCBMb29wT25jZSA9IDIyMDA7XG5cdGNvbnN0IExvb3BSZXBlYXQgPSAyMjAxO1xuXHRjb25zdCBMb29wUGluZ1BvbmcgPSAyMjAyO1xuXHRjb25zdCBJbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcblx0Y29uc3QgSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xuXHRjb25zdCBJbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XG5cdGNvbnN0IFplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xuXHRjb25zdCBaZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xuXHRjb25zdCBXcmFwQXJvdW5kRW5kaW5nID0gMjQwMjtcblx0Y29uc3QgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMDtcblx0Y29uc3QgQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGUgPSAyNTAxO1xuXHRjb25zdCBUcmlhbmdsZXNEcmF3TW9kZSA9IDA7XG5cdGNvbnN0IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XG5cdGNvbnN0IFRyaWFuZ2xlRmFuRHJhd01vZGUgPSAyO1xuXHRjb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG5cdGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5cdGNvbnN0IEdhbW1hRW5jb2RpbmcgPSAzMDA3O1xuXHRjb25zdCBSR0JFRW5jb2RpbmcgPSAzMDAyO1xuXHRjb25zdCBMb2dMdXZFbmNvZGluZyA9IDMwMDM7XG5cdGNvbnN0IFJHQk03RW5jb2RpbmcgPSAzMDA0O1xuXHRjb25zdCBSR0JNMTZFbmNvZGluZyA9IDMwMDU7XG5cdGNvbnN0IFJHQkRFbmNvZGluZyA9IDMwMDY7XG5cdGNvbnN0IEJhc2ljRGVwdGhQYWNraW5nID0gMzIwMDtcblx0Y29uc3QgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XG5cdGNvbnN0IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IDA7XG5cdGNvbnN0IE9iamVjdFNwYWNlTm9ybWFsTWFwID0gMTtcblx0Y29uc3QgWmVyb1N0ZW5jaWxPcCA9IDA7XG5cdGNvbnN0IEtlZXBTdGVuY2lsT3AgPSA3NjgwO1xuXHRjb25zdCBSZXBsYWNlU3RlbmNpbE9wID0gNzY4MTtcblx0Y29uc3QgSW5jcmVtZW50U3RlbmNpbE9wID0gNzY4Mjtcblx0Y29uc3QgRGVjcmVtZW50U3RlbmNpbE9wID0gNzY4Mztcblx0Y29uc3QgSW5jcmVtZW50V3JhcFN0ZW5jaWxPcCA9IDM0MDU1O1xuXHRjb25zdCBEZWNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTY7XG5cdGNvbnN0IEludmVydFN0ZW5jaWxPcCA9IDUzODY7XG5cdGNvbnN0IE5ldmVyU3RlbmNpbEZ1bmMgPSA1MTI7XG5cdGNvbnN0IExlc3NTdGVuY2lsRnVuYyA9IDUxMztcblx0Y29uc3QgRXF1YWxTdGVuY2lsRnVuYyA9IDUxNDtcblx0Y29uc3QgTGVzc0VxdWFsU3RlbmNpbEZ1bmMgPSA1MTU7XG5cdGNvbnN0IEdyZWF0ZXJTdGVuY2lsRnVuYyA9IDUxNjtcblx0Y29uc3QgTm90RXF1YWxTdGVuY2lsRnVuYyA9IDUxNztcblx0Y29uc3QgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmMgPSA1MTg7XG5cdGNvbnN0IEFsd2F5c1N0ZW5jaWxGdW5jID0gNTE5O1xuXHRjb25zdCBTdGF0aWNEcmF3VXNhZ2UgPSAzNTA0NDtcblx0Y29uc3QgRHluYW1pY0RyYXdVc2FnZSA9IDM1MDQ4O1xuXHRjb25zdCBTdHJlYW1EcmF3VXNhZ2UgPSAzNTA0MDtcblx0Y29uc3QgU3RhdGljUmVhZFVzYWdlID0gMzUwNDU7XG5cdGNvbnN0IER5bmFtaWNSZWFkVXNhZ2UgPSAzNTA0OTtcblx0Y29uc3QgU3RyZWFtUmVhZFVzYWdlID0gMzUwNDE7XG5cdGNvbnN0IFN0YXRpY0NvcHlVc2FnZSA9IDM1MDQ2O1xuXHRjb25zdCBEeW5hbWljQ29weVVzYWdlID0gMzUwNTA7XG5cdGNvbnN0IFN0cmVhbUNvcHlVc2FnZSA9IDM1MDQyO1xuXHRjb25zdCBHTFNMMSA9ICcxMDAnO1xuXHRjb25zdCBHTFNMMyA9ICczMDAgZXMnO1xuXG5cdC8qKlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cblx0ICovXG5cdGNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG5cdFx0YWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuXHRcdFx0aWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuXHRcdFx0XHRsaXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFzRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0XHRyZXR1cm4gbGlzdGVuZXJzW3R5cGVdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpICE9PSAtMTtcblx0XHR9XG5cblx0XHRyZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0XHRpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRcdGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbdHlwZV07XG5cblx0XHRcdGlmIChsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YobGlzdGVuZXIpO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRsaXN0ZW5lckFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG5cdFx0XHRpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRcdGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbZXZlbnQudHlwZV07XG5cblx0XHRcdGlmIChsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZXZlbnQudGFyZ2V0ID0gdGhpczsgLy8gTWFrZSBhIGNvcHksIGluIGNhc2UgbGlzdGVuZXJzIGFyZSByZW1vdmVkIHdoaWxlIGl0ZXJhdGluZy5cblxuXHRcdFx0XHRjb25zdCBhcnJheSA9IGxpc3RlbmVyQXJyYXkuc2xpY2UoMCk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRhcnJheVtpXS5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfbHV0ID0gW107XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHRcdF9sdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNik7XG5cdH1cblxuXHRsZXQgX3NlZWQgPSAxMjM0NTY3O1xuXHRjb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcblx0Y29uc3QgUkFEMkRFRyA9IDE4MCAvIE1hdGguUEk7IC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblx0XHRjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0XHRjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0XHRjb25zdCBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0XHRjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0XHRjb25zdCB1dWlkID0gX2x1dFtkMCAmIDB4ZmZdICsgX2x1dFtkMCA+PiA4ICYgMHhmZl0gKyBfbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QwID4+IDI0ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QxICYgMHhmZl0gKyBfbHV0W2QxID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDEgPj4gMTYgJiAweDBmIHwgMHg0MF0gKyBfbHV0W2QxID4+IDI0ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QyICYgMHgzZiB8IDB4ODBdICsgX2x1dFtkMiA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QyID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QyID4+IDI0ICYgMHhmZl0gKyBfbHV0W2QzICYgMHhmZl0gKyBfbHV0W2QzID4+IDggJiAweGZmXSArIF9sdXRbZDMgPj4gMTYgJiAweGZmXSArIF9sdXRbZDMgPj4gMjQgJiAweGZmXTsgLy8gLnRvVXBwZXJDYXNlKCkgaGVyZSBmbGF0dGVucyBjb25jYXRlbmF0ZWQgc3RyaW5ncyB0byBzYXZlIGhlYXAgbWVtb3J5IHNwYWNlLlxuXG5cdFx0cmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcblx0fSAvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuXG5cblx0ZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKG4sIG0pIHtcblx0XHRyZXR1cm4gKG4gJSBtICsgbSkgJSBtO1xuXHR9IC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuXG5cdGZ1bmN0aW9uIG1hcExpbmVhcih4LCBhMSwgYTIsIGIxLCBiMikge1xuXHRcdHJldHVybiBiMSArICh4IC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xuXHR9IC8vIGh0dHBzOi8vd3d3LmdhbWVkZXYubmV0L3R1dG9yaWFscy9wcm9ncmFtbWluZy9nZW5lcmFsLWFuZC1nYW1lcGxheS1wcm9ncmFtbWluZy9pbnZlcnNlLWxlcnAtYS1zdXBlci11c2VmdWwteWV0LW9mdGVuLW92ZXJsb29rZWQtZnVuY3Rpb24tcjUyMzAvXG5cblxuXHRmdW5jdGlvbiBpbnZlcnNlTGVycCh4LCB5LCB2YWx1ZSkge1xuXHRcdGlmICh4ICE9PSB5KSB7XG5cdFx0XHRyZXR1cm4gKHZhbHVlIC0geCkgLyAoeSAtIHgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdH0gLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cblxuXG5cdGZ1bmN0aW9uIGxlcnAoeCwgeSwgdCkge1xuXHRcdHJldHVybiAoMSAtIHQpICogeCArIHQgKiB5O1xuXHR9IC8vIGh0dHA6Ly93d3cucm9yeWRyaXNjb2xsLmNvbS8yMDE2LzAzLzA3L2ZyYW1lLXJhdGUtaW5kZXBlbmRlbnQtZGFtcGluZy11c2luZy1sZXJwL1xuXG5cblx0ZnVuY3Rpb24gZGFtcCh4LCB5LCBsYW1iZGEsIGR0KSB7XG5cdFx0cmV0dXJuIGxlcnAoeCwgeSwgMSAtIE1hdGguZXhwKC1sYW1iZGEgKiBkdCkpO1xuXHR9IC8vIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci92Y3Nqbnl6N3g0XG5cblxuXHRmdW5jdGlvbiBwaW5ncG9uZyh4LCBsZW5ndGggPSAxKSB7XG5cdFx0cmV0dXJuIGxlbmd0aCAtIE1hdGguYWJzKGV1Y2xpZGVhbk1vZHVsbyh4LCBsZW5ndGggKiAyKSAtIGxlbmd0aCk7XG5cdH0gLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwXG5cblxuXHRmdW5jdGlvbiBzbW9vdGhzdGVwKHgsIG1pbiwgbWF4KSB7XG5cdFx0aWYgKHggPD0gbWluKSByZXR1cm4gMDtcblx0XHRpZiAoeCA+PSBtYXgpIHJldHVybiAxO1xuXHRcdHggPSAoeCAtIG1pbikgLyAobWF4IC0gbWluKTtcblx0XHRyZXR1cm4geCAqIHggKiAoMyAtIDIgKiB4KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNtb290aGVyc3RlcCh4LCBtaW4sIG1heCkge1xuXHRcdGlmICh4IDw9IG1pbikgcmV0dXJuIDA7XG5cdFx0aWYgKHggPj0gbWF4KSByZXR1cm4gMTtcblx0XHR4ID0gKHggLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cdFx0cmV0dXJuIHggKiB4ICogeCAqICh4ICogKHggKiA2IC0gMTUpICsgMTApO1xuXHR9IC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXG5cdGZ1bmN0aW9uIHJhbmRJbnQobG93LCBoaWdoKSB7XG5cdFx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93ICsgMSkpO1xuXHR9IC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblxuXHRmdW5jdGlvbiByYW5kRmxvYXQobG93LCBoaWdoKSB7XG5cdFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdyk7XG5cdH0gLy8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuXG5cblx0ZnVuY3Rpb24gcmFuZEZsb2F0U3ByZWFkKHJhbmdlKSB7XG5cdFx0cmV0dXJuIHJhbmdlICogKDAuNSAtIE1hdGgucmFuZG9tKCkpO1xuXHR9IC8vIERldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgWyAwLCAxIF1cblxuXG5cdGZ1bmN0aW9uIHNlZWRlZFJhbmRvbShzKSB7XG5cdFx0aWYgKHMgIT09IHVuZGVmaW5lZCkgX3NlZWQgPSBzICUgMjE0NzQ4MzY0NzsgLy8gUGFyay1NaWxsZXIgYWxnb3JpdGhtXG5cblx0XHRfc2VlZCA9IF9zZWVkICogMTY4MDcgJSAyMTQ3NDgzNjQ3O1xuXHRcdHJldHVybiAoX3NlZWQgLSAxKSAvIDIxNDc0ODM2NDY7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWdUb1JhZChkZWdyZWVzKSB7XG5cdFx0cmV0dXJuIGRlZ3JlZXMgKiBERUcyUkFEO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmFkVG9EZWcocmFkaWFucykge1xuXHRcdHJldHVybiByYWRpYW5zICogUkFEMkRFRztcblx0fVxuXG5cdGZ1bmN0aW9uIGlzUG93ZXJPZlR3byh2YWx1ZSkge1xuXHRcdHJldHVybiAodmFsdWUgJiB2YWx1ZSAtIDEpID09PSAwICYmIHZhbHVlICE9PSAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2VpbFBvd2VyT2ZUd28odmFsdWUpIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBmbG9vclBvd2VyT2ZUd28odmFsdWUpIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMikpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcihxLCBhLCBiLCBjLCBvcmRlcikge1xuXHRcdC8vIEludHJpbnNpYyBQcm9wZXIgRXVsZXIgQW5nbGVzIC0gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1bGVyX2FuZ2xlc1xuXHRcdC8vIHJvdGF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgYXhlcyBpbiB0aGUgb3JkZXIgc3BlY2lmaWVkIGJ5ICdvcmRlcidcblx0XHQvLyByb3RhdGlvbiBieSBhbmdsZSAnYScgaXMgYXBwbGllZCBmaXJzdCwgdGhlbiBieSBhbmdsZSAnYicsIHRoZW4gYnkgYW5nbGUgJ2MnXG5cdFx0Ly8gYW5nbGVzIGFyZSBpbiByYWRpYW5zXG5cdFx0Y29uc3QgY29zID0gTWF0aC5jb3M7XG5cdFx0Y29uc3Qgc2luID0gTWF0aC5zaW47XG5cdFx0Y29uc3QgYzIgPSBjb3MoYiAvIDIpO1xuXHRcdGNvbnN0IHMyID0gc2luKGIgLyAyKTtcblx0XHRjb25zdCBjMTMgPSBjb3MoKGEgKyBjKSAvIDIpO1xuXHRcdGNvbnN0IHMxMyA9IHNpbigoYSArIGMpIC8gMik7XG5cdFx0Y29uc3QgYzFfMyA9IGNvcygoYSAtIGMpIC8gMik7XG5cdFx0Y29uc3QgczFfMyA9IHNpbigoYSAtIGMpIC8gMik7XG5cdFx0Y29uc3QgYzNfMSA9IGNvcygoYyAtIGEpIC8gMik7XG5cdFx0Y29uc3QgczNfMSA9IHNpbigoYyAtIGEpIC8gMik7XG5cblx0XHRzd2l0Y2ggKG9yZGVyKSB7XG5cdFx0XHRjYXNlICdYWVgnOlxuXHRcdFx0XHRxLnNldChjMiAqIHMxMywgczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogYzEzKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1laWSc6XG5cdFx0XHRcdHEuc2V0KHMyICogczFfMywgYzIgKiBzMTMsIHMyICogYzFfMywgYzIgKiBjMTMpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWlhaJzpcblx0XHRcdFx0cS5zZXQoczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogczEzLCBjMiAqIGMxMyk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdYWlgnOlxuXHRcdFx0XHRxLnNldChjMiAqIHMxMywgczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogYzEzKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1lYWSc6XG5cdFx0XHRcdHEuc2V0KHMyICogYzNfMSwgYzIgKiBzMTMsIHMyICogczNfMSwgYzIgKiBjMTMpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWllaJzpcblx0XHRcdFx0cS5zZXQoczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogczEzLCBjMiAqIGMxMyk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBNYXRoVXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0X19wcm90b19fOiBudWxsLFxuXHRcdERFRzJSQUQ6IERFRzJSQUQsXG5cdFx0UkFEMkRFRzogUkFEMkRFRyxcblx0XHRnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0XHRjbGFtcDogY2xhbXAsXG5cdFx0ZXVjbGlkZWFuTW9kdWxvOiBldWNsaWRlYW5Nb2R1bG8sXG5cdFx0bWFwTGluZWFyOiBtYXBMaW5lYXIsXG5cdFx0aW52ZXJzZUxlcnA6IGludmVyc2VMZXJwLFxuXHRcdGxlcnA6IGxlcnAsXG5cdFx0ZGFtcDogZGFtcCxcblx0XHRwaW5ncG9uZzogcGluZ3BvbmcsXG5cdFx0c21vb3Roc3RlcDogc21vb3Roc3RlcCxcblx0XHRzbW9vdGhlcnN0ZXA6IHNtb290aGVyc3RlcCxcblx0XHRyYW5kSW50OiByYW5kSW50LFxuXHRcdHJhbmRGbG9hdDogcmFuZEZsb2F0LFxuXHRcdHJhbmRGbG9hdFNwcmVhZDogcmFuZEZsb2F0U3ByZWFkLFxuXHRcdHNlZWRlZFJhbmRvbTogc2VlZGVkUmFuZG9tLFxuXHRcdGRlZ1RvUmFkOiBkZWdUb1JhZCxcblx0XHRyYWRUb0RlZzogcmFkVG9EZWcsXG5cdFx0aXNQb3dlck9mVHdvOiBpc1Bvd2VyT2ZUd28sXG5cdFx0Y2VpbFBvd2VyT2ZUd286IGNlaWxQb3dlck9mVHdvLFxuXHRcdGZsb29yUG93ZXJPZlR3bzogZmxvb3JQb3dlck9mVHdvLFxuXHRcdHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXI6IHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXJcblx0fSk7XG5cblx0Y2xhc3MgVmVjdG9yMiB7XG5cdFx0Y29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKSB7XG5cdFx0XHR0aGlzLnggPSB4O1xuXHRcdFx0dGhpcy55ID0geTtcblx0XHR9XG5cblx0XHRnZXQgd2lkdGgoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy54O1xuXHRcdH1cblxuXHRcdHNldCB3aWR0aCh2YWx1ZSkge1xuXHRcdFx0dGhpcy54ID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Z2V0IGhlaWdodCgpIHtcblx0XHRcdHJldHVybiB0aGlzLnk7XG5cdFx0fVxuXG5cdFx0c2V0IGhlaWdodCh2YWx1ZSkge1xuXHRcdFx0dGhpcy55ID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0c2V0KHgsIHkpIHtcblx0XHRcdHRoaXMueCA9IHg7XG5cdFx0XHR0aGlzLnkgPSB5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0U2NhbGFyKHNjYWxhcikge1xuXHRcdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ID0gc2NhbGFyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WCh4KSB7XG5cdFx0XHR0aGlzLnggPSB4O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WSh5KSB7XG5cdFx0XHR0aGlzLnkgPSB5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0Q29tcG9uZW50KGluZGV4LCB2YWx1ZSkge1xuXHRcdFx0c3dpdGNoIChpbmRleCkge1xuXHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0dGhpcy54ID0gdmFsdWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdHRoaXMueSA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldENvbXBvbmVudChpbmRleCkge1xuXHRcdFx0c3dpdGNoIChpbmRleCkge1xuXHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMueDtcblxuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMueTtcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCwgdGhpcy55KTtcblx0XHR9XG5cblx0XHRjb3B5KHYpIHtcblx0XHRcdHRoaXMueCA9IHYueDtcblx0XHRcdHRoaXMueSA9IHYueTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZCh2LCB3KSB7XG5cdFx0XHRpZiAodyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKHYsIHcpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggKz0gdi54O1xuXHRcdFx0dGhpcy55ICs9IHYueTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFNjYWxhcihzKSB7XG5cdFx0XHR0aGlzLnggKz0gcztcblx0XHRcdHRoaXMueSArPSBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkVmVjdG9ycyhhLCBiKSB7XG5cdFx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRTY2FsZWRWZWN0b3Iodiwgcykge1xuXHRcdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHN1Yih2LCB3KSB7XG5cdFx0XHRpZiAodyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKHYsIHcpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggLT0gdi54O1xuXHRcdFx0dGhpcy55IC09IHYueTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHN1YlNjYWxhcihzKSB7XG5cdFx0XHR0aGlzLnggLT0gcztcblx0XHRcdHRoaXMueSAtPSBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c3ViVmVjdG9ycyhhLCBiKSB7XG5cdFx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtdWx0aXBseSh2KSB7XG5cdFx0XHR0aGlzLnggKj0gdi54O1xuXHRcdFx0dGhpcy55ICo9IHYueTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5U2NhbGFyKHNjYWxhcikge1xuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRkaXZpZGUodikge1xuXHRcdFx0dGhpcy54IC89IHYueDtcblx0XHRcdHRoaXMueSAvPSB2Lnk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRkaXZpZGVTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxIC8gc2NhbGFyKTtcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDMobSkge1xuXHRcdFx0Y29uc3QgeCA9IHRoaXMueCxcblx0XHRcdFx0XHRcdHkgPSB0aGlzLnk7XG5cdFx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblx0XHRcdHRoaXMueCA9IGVbMF0gKiB4ICsgZVszXSAqIHkgKyBlWzZdO1xuXHRcdFx0dGhpcy55ID0gZVsxXSAqIHggKyBlWzRdICogeSArIGVbN107XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtaW4odikge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5taW4odGhpcy54LCB2LngpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5taW4odGhpcy55LCB2LnkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWF4KHYpIHtcblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgdi54KTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWF4KHRoaXMueSwgdi55KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsYW1wKG1pbiwgbWF4KSB7XG5cdFx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgobWluLngsIE1hdGgubWluKG1heC54LCB0aGlzLngpKTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWF4KG1pbi55LCBNYXRoLm1pbihtYXgueSwgdGhpcy55KSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbGFtcFNjYWxhcihtaW5WYWwsIG1heFZhbCkge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueCkpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueSkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xhbXBMZW5ndGgobWluLCBtYXgpIHtcblx0XHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobGVuZ3RoIHx8IDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBsZW5ndGgpKSk7XG5cdFx0fVxuXG5cdFx0Zmxvb3IoKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjZWlsKCkge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJvdW5kKCkge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm91bmRUb1plcm8oKSB7XG5cdFx0XHR0aGlzLnggPSB0aGlzLnggPCAwID8gTWF0aC5jZWlsKHRoaXMueCkgOiBNYXRoLmZsb29yKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSB0aGlzLnkgPCAwID8gTWF0aC5jZWlsKHRoaXMueSkgOiBNYXRoLmZsb29yKHRoaXMueSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRuZWdhdGUoKSB7XG5cdFx0XHR0aGlzLnggPSAtdGhpcy54O1xuXHRcdFx0dGhpcy55ID0gLXRoaXMueTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRvdCh2KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXHRcdH1cblxuXHRcdGNyb3NzKHYpIHtcblx0XHRcdHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG5cdFx0fVxuXG5cdFx0bGVuZ3RoU3EoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXHRcdH1cblxuXHRcdGxlbmd0aCgpIHtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcblx0XHR9XG5cblx0XHRtYW5oYXR0YW5MZW5ndGgoKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSk7XG5cdFx0fVxuXG5cdFx0bm9ybWFsaXplKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7XG5cdFx0fVxuXG5cdFx0YW5nbGUoKSB7XG5cdFx0XHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xuXHRcdFx0Y29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKC10aGlzLnksIC10aGlzLngpICsgTWF0aC5QSTtcblx0XHRcdHJldHVybiBhbmdsZTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVRvKHYpIHtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh2KSk7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2VUb1NxdWFyZWQodikge1xuXHRcdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsXG5cdFx0XHRcdFx0XHRkeSA9IHRoaXMueSAtIHYueTtcblx0XHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblx0XHR9XG5cblx0XHRtYW5oYXR0YW5EaXN0YW5jZVRvKHYpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyh0aGlzLnggLSB2LngpICsgTWF0aC5hYnModGhpcy55IC0gdi55KTtcblx0XHR9XG5cblx0XHRzZXRMZW5ndGgobGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuXHRcdH1cblxuXHRcdGxlcnAodiwgYWxwaGEpIHtcblx0XHRcdHRoaXMueCArPSAodi54IC0gdGhpcy54KSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ICs9ICh2LnkgLSB0aGlzLnkpICogYWxwaGE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRsZXJwVmVjdG9ycyh2MSwgdjIsIGFscGhhKSB7XG5cdFx0XHR0aGlzLnggPSB2MS54ICsgKHYyLnggLSB2MS54KSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ID0gdjEueSArICh2Mi55IC0gdjEueSkgKiBhbHBoYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyh2KSB7XG5cdFx0XHRyZXR1cm4gdi54ID09PSB0aGlzLnggJiYgdi55ID09PSB0aGlzLnk7XG5cdFx0fVxuXG5cdFx0ZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG5cdFx0XHR0aGlzLnggPSBhcnJheVtvZmZzZXRdO1xuXHRcdFx0dGhpcy55ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRcdGFycmF5W29mZnNldF0gPSB0aGlzLng7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMueTtcblx0XHRcdHJldHVybiBhcnJheTtcblx0XHR9XG5cblx0XHRmcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCkge1xuXHRcdFx0aWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMjogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WChpbmRleCk7XG5cdFx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WShpbmRleCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyb3RhdGVBcm91bmQoY2VudGVyLCBhbmdsZSkge1xuXHRcdFx0Y29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdFx0XHRcdHMgPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRjb25zdCB4ID0gdGhpcy54IC0gY2VudGVyLng7XG5cdFx0XHRjb25zdCB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cdFx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XG5cdFx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyYW5kb20oKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0VmVjdG9yMi5wcm90b3R5cGUuaXNWZWN0b3IyID0gdHJ1ZTtcblxuXHRjbGFzcyBNYXRyaXgzIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMuZWxlbWVudHMgPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV07XG5cblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNldChuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHR0ZVswXSA9IG4xMTtcblx0XHRcdHRlWzFdID0gbjIxO1xuXHRcdFx0dGVbMl0gPSBuMzE7XG5cdFx0XHR0ZVszXSA9IG4xMjtcblx0XHRcdHRlWzRdID0gbjIyO1xuXHRcdFx0dGVbNV0gPSBuMzI7XG5cdFx0XHR0ZVs2XSA9IG4xMztcblx0XHRcdHRlWzddID0gbjIzO1xuXHRcdFx0dGVbOF0gPSBuMzM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZGVudGl0eSgpIHtcblx0XHRcdHRoaXMuc2V0KDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShtKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cdFx0XHR0ZVswXSA9IG1lWzBdO1xuXHRcdFx0dGVbMV0gPSBtZVsxXTtcblx0XHRcdHRlWzJdID0gbWVbMl07XG5cdFx0XHR0ZVszXSA9IG1lWzNdO1xuXHRcdFx0dGVbNF0gPSBtZVs0XTtcblx0XHRcdHRlWzVdID0gbWVbNV07XG5cdFx0XHR0ZVs2XSA9IG1lWzZdO1xuXHRcdFx0dGVbN10gPSBtZVs3XTtcblx0XHRcdHRlWzhdID0gbWVbOF07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRleHRyYWN0QmFzaXMoeEF4aXMsIHlBeGlzLCB6QXhpcykge1xuXHRcdFx0eEF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywgMCk7XG5cdFx0XHR5QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLCAxKTtcblx0XHRcdHpBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsIDIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbU1hdHJpeDQobSkge1xuXHRcdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0dGhpcy5zZXQobWVbMF0sIG1lWzRdLCBtZVs4XSwgbWVbMV0sIG1lWzVdLCBtZVs5XSwgbWVbMl0sIG1lWzZdLCBtZVsxMF0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHkobSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLCBtKTtcblx0XHR9XG5cblx0XHRwcmVtdWx0aXBseShtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKG0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5TWF0cmljZXMoYSwgYikge1xuXHRcdFx0Y29uc3QgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgYTExID0gYWVbMF0sXG5cdFx0XHRcdFx0XHRhMTIgPSBhZVszXSxcblx0XHRcdFx0XHRcdGExMyA9IGFlWzZdO1xuXHRcdFx0Y29uc3QgYTIxID0gYWVbMV0sXG5cdFx0XHRcdFx0XHRhMjIgPSBhZVs0XSxcblx0XHRcdFx0XHRcdGEyMyA9IGFlWzddO1xuXHRcdFx0Y29uc3QgYTMxID0gYWVbMl0sXG5cdFx0XHRcdFx0XHRhMzIgPSBhZVs1XSxcblx0XHRcdFx0XHRcdGEzMyA9IGFlWzhdO1xuXHRcdFx0Y29uc3QgYjExID0gYmVbMF0sXG5cdFx0XHRcdFx0XHRiMTIgPSBiZVszXSxcblx0XHRcdFx0XHRcdGIxMyA9IGJlWzZdO1xuXHRcdFx0Y29uc3QgYjIxID0gYmVbMV0sXG5cdFx0XHRcdFx0XHRiMjIgPSBiZVs0XSxcblx0XHRcdFx0XHRcdGIyMyA9IGJlWzddO1xuXHRcdFx0Y29uc3QgYjMxID0gYmVbMl0sXG5cdFx0XHRcdFx0XHRiMzIgPSBiZVs1XSxcblx0XHRcdFx0XHRcdGIzMyA9IGJlWzhdO1xuXHRcdFx0dGVbMF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0XHR0ZVszXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHRcdHRlWzZdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xuXHRcdFx0dGVbMV0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzE7XG5cdFx0XHR0ZVs0XSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMjtcblx0XHRcdHRlWzddID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzO1xuXHRcdFx0dGVbMl0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XG5cdFx0XHR0ZVs1XSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMjtcblx0XHRcdHRlWzhdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHlTY2FsYXIocykge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dGVbMF0gKj0gcztcblx0XHRcdHRlWzNdICo9IHM7XG5cdFx0XHR0ZVs2XSAqPSBzO1xuXHRcdFx0dGVbMV0gKj0gcztcblx0XHRcdHRlWzRdICo9IHM7XG5cdFx0XHR0ZVs3XSAqPSBzO1xuXHRcdFx0dGVbMl0gKj0gcztcblx0XHRcdHRlWzVdICo9IHM7XG5cdFx0XHR0ZVs4XSAqPSBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGV0ZXJtaW5hbnQoKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRjb25zdCBhID0gdGVbMF0sXG5cdFx0XHRcdFx0XHRiID0gdGVbMV0sXG5cdFx0XHRcdFx0XHRjID0gdGVbMl0sXG5cdFx0XHRcdFx0XHRkID0gdGVbM10sXG5cdFx0XHRcdFx0XHRlID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRmID0gdGVbNV0sXG5cdFx0XHRcdFx0XHRnID0gdGVbNl0sXG5cdFx0XHRcdFx0XHRoID0gdGVbN10sXG5cdFx0XHRcdFx0XHRpID0gdGVbOF07XG5cdFx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXHRcdH1cblxuXHRcdGludmVydCgpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcblx0XHRcdFx0XHRcdG4xMSA9IHRlWzBdLFxuXHRcdFx0XHRcdFx0bjIxID0gdGVbMV0sXG5cdFx0XHRcdFx0XHRuMzEgPSB0ZVsyXSxcblx0XHRcdFx0XHRcdG4xMiA9IHRlWzNdLFxuXHRcdFx0XHRcdFx0bjIyID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRuMzIgPSB0ZVs1XSxcblx0XHRcdFx0XHRcdG4xMyA9IHRlWzZdLFxuXHRcdFx0XHRcdFx0bjIzID0gdGVbN10sXG5cdFx0XHRcdFx0XHRuMzMgPSB0ZVs4XSxcblx0XHRcdFx0XHRcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcblx0XHRcdFx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcblx0XHRcdFx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblx0XHRcdFx0XHRcdGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMztcblx0XHRcdGlmIChkZXQgPT09IDApIHJldHVybiB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcblx0XHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cdFx0XHR0ZVswXSA9IHQxMSAqIGRldEludjtcblx0XHRcdHRlWzFdID0gKG4zMSAqIG4yMyAtIG4zMyAqIG4yMSkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsyXSA9IChuMzIgKiBuMjEgLSBuMzEgKiBuMjIpICogZGV0SW52O1xuXHRcdFx0dGVbM10gPSB0MTIgKiBkZXRJbnY7XG5cdFx0XHR0ZVs0XSA9IChuMzMgKiBuMTEgLSBuMzEgKiBuMTMpICogZGV0SW52O1xuXHRcdFx0dGVbNV0gPSAobjMxICogbjEyIC0gbjMyICogbjExKSAqIGRldEludjtcblx0XHRcdHRlWzZdID0gdDEzICogZGV0SW52O1xuXHRcdFx0dGVbN10gPSAobjIxICogbjEzIC0gbjIzICogbjExKSAqIGRldEludjtcblx0XHRcdHRlWzhdID0gKG4yMiAqIG4xMSAtIG4yMSAqIG4xMikgKiBkZXRJbnY7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0cmFuc3Bvc2UoKSB7XG5cdFx0XHRsZXQgdG1wO1xuXHRcdFx0Y29uc3QgbSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHR0bXAgPSBtWzFdO1xuXHRcdFx0bVsxXSA9IG1bM107XG5cdFx0XHRtWzNdID0gdG1wO1xuXHRcdFx0dG1wID0gbVsyXTtcblx0XHRcdG1bMl0gPSBtWzZdO1xuXHRcdFx0bVs2XSA9IHRtcDtcblx0XHRcdHRtcCA9IG1bNV07XG5cdFx0XHRtWzVdID0gbVs3XTtcblx0XHRcdG1bN10gPSB0bXA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXROb3JtYWxNYXRyaXgobWF0cml4NCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeDQobWF0cml4NCkuaW52ZXJ0KCkudHJhbnNwb3NlKCk7XG5cdFx0fVxuXG5cdFx0dHJhbnNwb3NlSW50b0FycmF5KHIpIHtcblx0XHRcdGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0clswXSA9IG1bMF07XG5cdFx0XHRyWzFdID0gbVszXTtcblx0XHRcdHJbMl0gPSBtWzZdO1xuXHRcdFx0clszXSA9IG1bMV07XG5cdFx0XHRyWzRdID0gbVs0XTtcblx0XHRcdHJbNV0gPSBtWzddO1xuXHRcdFx0cls2XSA9IG1bMl07XG5cdFx0XHRyWzddID0gbVs1XTtcblx0XHRcdHJbOF0gPSBtWzhdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0VXZUcmFuc2Zvcm0odHgsIHR5LCBzeCwgc3ksIHJvdGF0aW9uLCBjeCwgY3kpIHtcblx0XHRcdGNvbnN0IGMgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG5cdFx0XHRjb25zdCBzID0gTWF0aC5zaW4ocm90YXRpb24pO1xuXHRcdFx0dGhpcy5zZXQoc3ggKiBjLCBzeCAqIHMsIC1zeCAqIChjICogY3ggKyBzICogY3kpICsgY3ggKyB0eCwgLXN5ICogcywgc3kgKiBjLCAtc3kgKiAoLXMgKiBjeCArIGMgKiBjeSkgKyBjeSArIHR5LCAwLCAwLCAxKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNjYWxlKHN4LCBzeSkge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dGVbMF0gKj0gc3g7XG5cdFx0XHR0ZVszXSAqPSBzeDtcblx0XHRcdHRlWzZdICo9IHN4O1xuXHRcdFx0dGVbMV0gKj0gc3k7XG5cdFx0XHR0ZVs0XSAqPSBzeTtcblx0XHRcdHRlWzddICo9IHN5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm90YXRlKHRoZXRhKSB7XG5cdFx0XHRjb25zdCBjID0gTWF0aC5jb3ModGhldGEpO1xuXHRcdFx0Y29uc3QgcyA9IE1hdGguc2luKHRoZXRhKTtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IGExMSA9IHRlWzBdLFxuXHRcdFx0XHRcdFx0YTEyID0gdGVbM10sXG5cdFx0XHRcdFx0XHRhMTMgPSB0ZVs2XTtcblx0XHRcdGNvbnN0IGEyMSA9IHRlWzFdLFxuXHRcdFx0XHRcdFx0YTIyID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRhMjMgPSB0ZVs3XTtcblx0XHRcdHRlWzBdID0gYyAqIGExMSArIHMgKiBhMjE7XG5cdFx0XHR0ZVszXSA9IGMgKiBhMTIgKyBzICogYTIyO1xuXHRcdFx0dGVbNl0gPSBjICogYTEzICsgcyAqIGEyMztcblx0XHRcdHRlWzFdID0gLXMgKiBhMTEgKyBjICogYTIxO1xuXHRcdFx0dGVbNF0gPSAtcyAqIGExMiArIGMgKiBhMjI7XG5cdFx0XHR0ZVs3XSA9IC1zICogYTEzICsgYyAqIGEyMztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRyYW5zbGF0ZSh0eCwgdHkpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHRlWzBdICs9IHR4ICogdGVbMl07XG5cdFx0XHR0ZVszXSArPSB0eCAqIHRlWzVdO1xuXHRcdFx0dGVbNl0gKz0gdHggKiB0ZVs4XTtcblx0XHRcdHRlWzFdICs9IHR5ICogdGVbMl07XG5cdFx0XHR0ZVs0XSArPSB0eSAqIHRlWzVdO1xuXHRcdFx0dGVbN10gKz0gdHkgKiB0ZVs4XTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyhtYXRyaXgpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHRpZiAodGVbaV0gIT09IG1lW2ldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IGFycmF5W2kgKyBvZmZzZXRdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGFycmF5W29mZnNldF0gPSB0ZVswXTtcblx0XHRcdGFycmF5W29mZnNldCArIDFdID0gdGVbMV07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAyXSA9IHRlWzJdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgM10gPSB0ZVszXTtcblx0XHRcdGFycmF5W29mZnNldCArIDRdID0gdGVbNF07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyA1XSA9IHRlWzVdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgNl0gPSB0ZVs2XTtcblx0XHRcdGFycmF5W29mZnNldCArIDddID0gdGVbN107XG5cdFx0XHRhcnJheVtvZmZzZXQgKyA4XSA9IHRlWzhdO1xuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpO1xuXHRcdH1cblxuXHR9XG5cblx0TWF0cml4My5wcm90b3R5cGUuaXNNYXRyaXgzID0gdHJ1ZTtcblxuXHRsZXQgX2NhbnZhcztcblxuXHRjbGFzcyBJbWFnZVV0aWxzIHtcblx0XHRzdGF0aWMgZ2V0RGF0YVVSTChpbWFnZSkge1xuXHRcdFx0aWYgKC9eZGF0YTovaS50ZXN0KGltYWdlLnNyYykpIHtcblx0XHRcdFx0cmV0dXJuIGltYWdlLnNyYztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCA9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm4gaW1hZ2Uuc3JjO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgY2FudmFzO1xuXG5cdFx0XHRpZiAoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuXHRcdFx0XHRjYW52YXMgPSBpbWFnZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChfY2FudmFzID09PSB1bmRlZmluZWQpIF9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyk7XG5cdFx0XHRcdF9jYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHRcdFx0X2NhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHRcdFx0Y29uc3QgY29udGV4dCA9IF9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdFx0XHRpZiAoaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcblx0XHRcdFx0XHRjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FudmFzID0gX2NhbnZhcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMnLCBpbWFnZSk7XG5cdFx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMC42KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdGxldCB0ZXh0dXJlSWQgPSAwO1xuXG5cdGNsYXNzIFRleHR1cmUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXHRcdGNvbnN0cnVjdG9yKGltYWdlID0gVGV4dHVyZS5ERUZBVUxUX0lNQUdFLCBtYXBwaW5nID0gVGV4dHVyZS5ERUZBVUxUX01BUFBJTkcsIHdyYXBTID0gQ2xhbXBUb0VkZ2VXcmFwcGluZywgd3JhcFQgPSBDbGFtcFRvRWRnZVdyYXBwaW5nLCBtYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXIsIG1pbkZpbHRlciA9IExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgZm9ybWF0ID0gUkdCQUZvcm1hdCwgdHlwZSA9IFVuc2lnbmVkQnl0ZVR5cGUsIGFuaXNvdHJvcHkgPSAxLCBlbmNvZGluZyA9IExpbmVhckVuY29kaW5nKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcblx0XHRcdFx0dmFsdWU6IHRleHR1cmVJZCsrXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0XHR0aGlzLmltYWdlID0gaW1hZ2U7XG5cdFx0XHR0aGlzLm1pcG1hcHMgPSBbXTtcblx0XHRcdHRoaXMubWFwcGluZyA9IG1hcHBpbmc7XG5cdFx0XHR0aGlzLndyYXBTID0gd3JhcFM7XG5cdFx0XHR0aGlzLndyYXBUID0gd3JhcFQ7XG5cdFx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlcjtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyO1xuXHRcdFx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcblx0XHRcdHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHRcdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IG51bGw7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdFx0dGhpcy5vZmZzZXQgPSBuZXcgVmVjdG9yMigwLCAwKTtcblx0XHRcdHRoaXMucmVwZWF0ID0gbmV3IFZlY3RvcjIoMSwgMSk7XG5cdFx0XHR0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IyKDAsIDApO1xuXHRcdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cdFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4MygpO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuXHRcdFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG5cdFx0XHR0aGlzLmZsaXBZID0gdHJ1ZTtcblx0XHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDsgLy8gdmFsaWQgdmFsdWVzOiAxLCAyLCA0LCA4IChzZWUgaHR0cDovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xQaXhlbFN0b3JlaS54bWwpXG5cdFx0XHQvLyBWYWx1ZXMgb2YgZW5jb2RpbmcgIT09IFRIUkVFLkxpbmVhckVuY29kaW5nIG9ubHkgc3VwcG9ydGVkIG9uIG1hcCwgZW52TWFwIGFuZCBlbWlzc2l2ZU1hcC5cblx0XHRcdC8vXG5cdFx0XHQvLyBBbHNvIGNoYW5naW5nIHRoZSBlbmNvZGluZyBhZnRlciBhbHJlYWR5IHVzZWQgYnkgYSBNYXRlcmlhbCB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IG1ha2UgdGhlIE1hdGVyaWFsXG5cdFx0XHQvLyB1cGRhdGUuIFlvdSBuZWVkIHRvIGV4cGxpY2l0bHkgY2FsbCBNYXRlcmlhbC5uZWVkc1VwZGF0ZSB0byB0cmlnZ2VyIGl0IHRvIHJlY29tcGlsZS5cblxuXHRcdFx0dGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuXHRcdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0XHRcdHRoaXMub25VcGRhdGUgPSBudWxsO1xuXHRcdFx0dGhpcy5pc1JlbmRlclRhcmdldFRleHR1cmUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXgoKSB7XG5cdFx0XHR0aGlzLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSh0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55LCB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55LCB0aGlzLnJvdGF0aW9uLCB0aGlzLmNlbnRlci54LCB0aGlzLmNlbnRlci55KTtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdFx0dGhpcy5pbWFnZSA9IHNvdXJjZS5pbWFnZTtcblx0XHRcdHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKDApO1xuXHRcdFx0dGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XG5cdFx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xuXHRcdFx0dGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcblx0XHRcdHRoaXMubWFnRmlsdGVyID0gc291cmNlLm1hZ0ZpbHRlcjtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gc291cmNlLm1pbkZpbHRlcjtcblx0XHRcdHRoaXMuYW5pc290cm9weSA9IHNvdXJjZS5hbmlzb3Ryb3B5O1xuXHRcdFx0dGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xuXHRcdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IHNvdXJjZS5pbnRlcm5hbEZvcm1hdDtcblx0XHRcdHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xuXHRcdFx0dGhpcy5vZmZzZXQuY29weShzb3VyY2Uub2Zmc2V0KTtcblx0XHRcdHRoaXMucmVwZWF0LmNvcHkoc291cmNlLnJlcGVhdCk7XG5cdFx0XHR0aGlzLmNlbnRlci5jb3B5KHNvdXJjZS5jZW50ZXIpO1xuXHRcdFx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdFx0dGhpcy5tYXRyaXguY29weShzb3VyY2UubWF0cml4KTtcblx0XHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcblx0XHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xuXHRcdFx0dGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcblx0XHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcblx0XHRcdHRoaXMuZW5jb2RpbmcgPSBzb3VyY2UuZW5jb2Rpbmc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04obWV0YSkge1xuXHRcdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJztcblxuXHRcdFx0aWYgKCFpc1Jvb3RPYmplY3QgJiYgbWV0YS50ZXh0dXJlc1t0aGlzLnV1aWRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIG1ldGEudGV4dHVyZXNbdGhpcy51dWlkXTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgb3V0cHV0ID0ge1xuXHRcdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHRcdHZlcnNpb246IDQuNSxcblx0XHRcdFx0XHR0eXBlOiAnVGV4dHVyZScsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0XHRtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG5cdFx0XHRcdHJlcGVhdDogW3RoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnldLFxuXHRcdFx0XHRvZmZzZXQ6IFt0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55XSxcblx0XHRcdFx0Y2VudGVyOiBbdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueV0sXG5cdFx0XHRcdHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuXHRcdFx0XHR3cmFwOiBbdGhpcy53cmFwUywgdGhpcy53cmFwVF0sXG5cdFx0XHRcdGZvcm1hdDogdGhpcy5mb3JtYXQsXG5cdFx0XHRcdHR5cGU6IHRoaXMudHlwZSxcblx0XHRcdFx0ZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmcsXG5cdFx0XHRcdG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsXG5cdFx0XHRcdG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXG5cdFx0XHRcdGFuaXNvdHJvcHk6IHRoaXMuYW5pc290cm9weSxcblx0XHRcdFx0ZmxpcFk6IHRoaXMuZmxpcFksXG5cdFx0XHRcdHByZW11bHRpcGx5QWxwaGE6IHRoaXMucHJlbXVsdGlwbHlBbHBoYSxcblx0XHRcdFx0dW5wYWNrQWxpZ25tZW50OiB0aGlzLnVucGFja0FsaWdubWVudFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXG5cdFx0XHRcdGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcblxuXHRcdFx0XHRpZiAoaW1hZ2UudXVpZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aW1hZ2UudXVpZCA9IGdlbmVyYXRlVVVJRCgpOyAvLyBVR0hcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaXNSb290T2JqZWN0ICYmIG1ldGEuaW1hZ2VzW2ltYWdlLnV1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRsZXQgdXJsO1xuXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoaW1hZ2UpKSB7XG5cdFx0XHRcdFx0XHQvLyBwcm9jZXNzIGFycmF5IG9mIGltYWdlcyBlLmcuIEN1YmVUZXh0dXJlXG5cdFx0XHRcdFx0XHR1cmwgPSBbXTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBpbWFnZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Ly8gY2hlY2sgY3ViZSB0ZXh0dXJlIHdpdGggZGF0YSB0ZXh0dXJlc1xuXHRcdFx0XHRcdFx0XHRpZiAoaW1hZ2VbaV0uaXNEYXRhVGV4dHVyZSkge1xuXHRcdFx0XHRcdFx0XHRcdHVybC5wdXNoKHNlcmlhbGl6ZUltYWdlKGltYWdlW2ldLmltYWdlKSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dXJsLnB1c2goc2VyaWFsaXplSW1hZ2UoaW1hZ2VbaV0pKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBwcm9jZXNzIHNpbmdsZSBpbWFnZVxuXHRcdFx0XHRcdFx0dXJsID0gc2VyaWFsaXplSW1hZ2UoaW1hZ2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1ldGEuaW1hZ2VzW2ltYWdlLnV1aWRdID0ge1xuXHRcdFx0XHRcdFx0dXVpZDogaW1hZ2UudXVpZCxcblx0XHRcdFx0XHRcdHVybDogdXJsXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5pbWFnZSA9IGltYWdlLnV1aWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNSb290T2JqZWN0KSB7XG5cdFx0XHRcdG1ldGEudGV4dHVyZXNbdGhpcy51dWlkXSA9IG91dHB1dDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0dHlwZTogJ2Rpc3Bvc2UnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0cmFuc2Zvcm1Vdih1dikge1xuXHRcdFx0aWYgKHRoaXMubWFwcGluZyAhPT0gVVZNYXBwaW5nKSByZXR1cm4gdXY7XG5cdFx0XHR1di5hcHBseU1hdHJpeDModGhpcy5tYXRyaXgpO1xuXG5cdFx0XHRpZiAodXYueCA8IDAgfHwgdXYueCA+IDEpIHtcblx0XHRcdFx0c3dpdGNoICh0aGlzLndyYXBTKSB7XG5cdFx0XHRcdFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcblx0XHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vcih1di54KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxuXHRcdFx0XHRcdFx0dXYueCA9IHV2LnggPCAwID8gMCA6IDE7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyhNYXRoLmZsb29yKHV2LngpICUgMikgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0dXYueCA9IE1hdGguY2VpbCh1di54KSAtIHV2Lng7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IodXYueCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1di55IDwgMCB8fCB1di55ID4gMSkge1xuXHRcdFx0XHRzd2l0Y2ggKHRoaXMud3JhcFQpIHtcblx0XHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxuXHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKHV2LnkpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIENsYW1wVG9FZGdlV3JhcHBpbmc6XG5cdFx0XHRcdFx0XHR1di55ID0gdXYueSA8IDAgPyAwIDogMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKE1hdGguZmxvb3IodXYueSkgJSAyKSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHR1di55ID0gTWF0aC5jZWlsKHV2LnkpIC0gdXYueTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vcih1di55KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZmxpcFkpIHtcblx0XHRcdFx0dXYueSA9IDEgLSB1di55O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdXY7XG5cdFx0fVxuXG5cdFx0c2V0IG5lZWRzVXBkYXRlKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgPT09IHRydWUpIHRoaXMudmVyc2lvbisrO1xuXHRcdH1cblxuXHR9XG5cblx0VGV4dHVyZS5ERUZBVUxUX0lNQUdFID0gdW5kZWZpbmVkO1xuXHRUZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFVWTWFwcGluZztcblx0VGV4dHVyZS5wcm90b3R5cGUuaXNUZXh0dXJlID0gdHJ1ZTtcblxuXHRmdW5jdGlvbiBzZXJpYWxpemVJbWFnZShpbWFnZSkge1xuXHRcdGlmICh0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCB0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcblx0XHRcdC8vIGRlZmF1bHQgaW1hZ2VzXG5cdFx0XHRyZXR1cm4gSW1hZ2VVdGlscy5nZXREYXRhVVJMKGltYWdlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGltYWdlLmRhdGEpIHtcblx0XHRcdFx0Ly8gaW1hZ2VzIG9mIERhdGFUZXh0dXJlXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW1hZ2UuZGF0YSksXG5cdFx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0LFxuXHRcdFx0XHRcdHR5cGU6IGltYWdlLmRhdGEuY29uc3RydWN0b3IubmFtZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5UZXh0dXJlOiBVbmFibGUgdG8gc2VyaWFsaXplIFRleHR1cmUuJyk7XG5cdFx0XHRcdHJldHVybiB7fTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRjbGFzcyBWZWN0b3I0IHtcblx0XHRjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSkge1xuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHR0aGlzLnogPSB6O1xuXHRcdFx0dGhpcy53ID0gdztcblx0XHR9XG5cblx0XHRnZXQgd2lkdGgoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy56O1xuXHRcdH1cblxuXHRcdHNldCB3aWR0aCh2YWx1ZSkge1xuXHRcdFx0dGhpcy56ID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Z2V0IGhlaWdodCgpIHtcblx0XHRcdHJldHVybiB0aGlzLnc7XG5cdFx0fVxuXG5cdFx0c2V0IGhlaWdodCh2YWx1ZSkge1xuXHRcdFx0dGhpcy53ID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0c2V0KHgsIHksIHosIHcpIHtcblx0XHRcdHRoaXMueCA9IHg7XG5cdFx0XHR0aGlzLnkgPSB5O1xuXHRcdFx0dGhpcy56ID0gejtcblx0XHRcdHRoaXMudyA9IHc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHR0aGlzLnggPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnogPSBzY2FsYXI7XG5cdFx0XHR0aGlzLncgPSBzY2FsYXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRYKHgpIHtcblx0XHRcdHRoaXMueCA9IHg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRZKHkpIHtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRaKHopIHtcblx0XHRcdHRoaXMueiA9IHo7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRXKHcpIHtcblx0XHRcdHRoaXMudyA9IHc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRDb21wb25lbnQoaW5kZXgsIHZhbHVlKSB7XG5cdFx0XHRzd2l0Y2ggKGluZGV4KSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHR0aGlzLnggPSB2YWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0dGhpcy55ID0gdmFsdWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdHRoaXMueiA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHR0aGlzLncgPSB2YWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRDb21wb25lbnQoaW5kZXgpIHtcblx0XHRcdHN3aXRjaCAoaW5kZXgpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLng7XG5cblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnk7XG5cblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLno7XG5cblx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnc7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xuXHRcdH1cblxuXHRcdGNvcHkodikge1xuXHRcdFx0dGhpcy54ID0gdi54O1xuXHRcdFx0dGhpcy55ID0gdi55O1xuXHRcdFx0dGhpcy56ID0gdi56O1xuXHRcdFx0dGhpcy53ID0gdi53ICE9PSB1bmRlZmluZWQgPyB2LncgOiAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkKHYsIHcpIHtcblx0XHRcdGlmICh3ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnModiwgdyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCArPSB2Lng7XG5cdFx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdFx0dGhpcy56ICs9IHYuejtcblx0XHRcdHRoaXMudyArPSB2Lnc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRTY2FsYXIocykge1xuXHRcdFx0dGhpcy54ICs9IHM7XG5cdFx0XHR0aGlzLnkgKz0gcztcblx0XHRcdHRoaXMueiArPSBzO1xuXHRcdFx0dGhpcy53ICs9IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRWZWN0b3JzKGEsIGIpIHtcblx0XHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiArIGIuejtcblx0XHRcdHRoaXMudyA9IGEudyArIGIudztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFNjYWxlZFZlY3Rvcih2LCBzKSB7XG5cdFx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdFx0dGhpcy56ICs9IHYueiAqIHM7XG5cdFx0XHR0aGlzLncgKz0gdi53ICogcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHN1Yih2LCB3KSB7XG5cdFx0XHRpZiAodyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKHYsIHcpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggLT0gdi54O1xuXHRcdFx0dGhpcy55IC09IHYueTtcblx0XHRcdHRoaXMueiAtPSB2Lno7XG5cdFx0XHR0aGlzLncgLT0gdi53O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c3ViU2NhbGFyKHMpIHtcblx0XHRcdHRoaXMueCAtPSBzO1xuXHRcdFx0dGhpcy55IC09IHM7XG5cdFx0XHR0aGlzLnogLT0gcztcblx0XHRcdHRoaXMudyAtPSBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c3ViVmVjdG9ycyhhLCBiKSB7XG5cdFx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cdFx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cdFx0XHR0aGlzLncgPSBhLncgLSBiLnc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtdWx0aXBseSh2KSB7XG5cdFx0XHR0aGlzLnggKj0gdi54O1xuXHRcdFx0dGhpcy55ICo9IHYueTtcblx0XHRcdHRoaXMueiAqPSB2Lno7XG5cdFx0XHR0aGlzLncgKj0gdi53O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHlTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cdFx0XHR0aGlzLncgKj0gc2NhbGFyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG0pIHtcblx0XHRcdGNvbnN0IHggPSB0aGlzLngsXG5cdFx0XHRcdFx0XHR5ID0gdGhpcy55LFxuXHRcdFx0XHRcdFx0eiA9IHRoaXMueixcblx0XHRcdFx0XHRcdHcgPSB0aGlzLnc7XG5cdFx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblx0XHRcdHRoaXMueCA9IGVbMF0gKiB4ICsgZVs0XSAqIHkgKyBlWzhdICogeiArIGVbMTJdICogdztcblx0XHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICogeiArIGVbMTNdICogdztcblx0XHRcdHRoaXMueiA9IGVbMl0gKiB4ICsgZVs2XSAqIHkgKyBlWzEwXSAqIHogKyBlWzE0XSAqIHc7XG5cdFx0XHR0aGlzLncgPSBlWzNdICogeCArIGVbN10gKiB5ICsgZVsxMV0gKiB6ICsgZVsxNV0gKiB3O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGl2aWRlU2NhbGFyKHNjYWxhcikge1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHNjYWxhcik7XG5cdFx0fVxuXG5cdFx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb24ocSkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxuXHRcdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblx0XHRcdHRoaXMudyA9IDIgKiBNYXRoLmFjb3MocS53KTtcblx0XHRcdGNvbnN0IHMgPSBNYXRoLnNxcnQoMSAtIHEudyAqIHEudyk7XG5cblx0XHRcdGlmIChzIDwgMC4wMDAxKSB7XG5cdFx0XHRcdHRoaXMueCA9IDE7XG5cdFx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHRcdHRoaXMueiA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnggPSBxLnggLyBzO1xuXHRcdFx0XHR0aGlzLnkgPSBxLnkgLyBzO1xuXHRcdFx0XHR0aGlzLnogPSBxLnogLyBzO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXgobSkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXG5cdFx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXHRcdFx0bGV0IGFuZ2xlLCB4LCB5LCB6OyAvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuXG5cdFx0XHRjb25zdCBlcHNpbG9uID0gMC4wMSxcblx0XHRcdFx0XHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXG5cdFx0XHRlcHNpbG9uMiA9IDAuMSxcblx0XHRcdFx0XHRcdC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXG5cdFx0XHR0ZSA9IG0uZWxlbWVudHMsXG5cdFx0XHRcdFx0XHRtMTEgPSB0ZVswXSxcblx0XHRcdFx0XHRcdG0xMiA9IHRlWzRdLFxuXHRcdFx0XHRcdFx0bTEzID0gdGVbOF0sXG5cdFx0XHRcdFx0XHRtMjEgPSB0ZVsxXSxcblx0XHRcdFx0XHRcdG0yMiA9IHRlWzVdLFxuXHRcdFx0XHRcdFx0bTIzID0gdGVbOV0sXG5cdFx0XHRcdFx0XHRtMzEgPSB0ZVsyXSxcblx0XHRcdFx0XHRcdG0zMiA9IHRlWzZdLFxuXHRcdFx0XHRcdFx0bTMzID0gdGVbMTBdO1xuXG5cdFx0XHRpZiAoTWF0aC5hYnMobTEyIC0gbTIxKSA8IGVwc2lsb24gJiYgTWF0aC5hYnMobTEzIC0gbTMxKSA8IGVwc2lsb24gJiYgTWF0aC5hYnMobTIzIC0gbTMyKSA8IGVwc2lsb24pIHtcblx0XHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcblx0XHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xuXHRcdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXG5cdFx0XHRcdGlmIChNYXRoLmFicyhtMTIgKyBtMjEpIDwgZXBzaWxvbjIgJiYgTWF0aC5hYnMobTEzICsgbTMxKSA8IGVwc2lsb24yICYmIE1hdGguYWJzKG0yMyArIG0zMikgPCBlcHNpbG9uMiAmJiBNYXRoLmFicyhtMTEgKyBtMjIgKyBtMzMgLSAzKSA8IGVwc2lsb24yKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXG5cdFx0XHRcdFx0dGhpcy5zZXQoMSwgMCwgMCwgMCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXG5cdFx0XHRcdH0gLy8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcblxuXG5cdFx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcblx0XHRcdFx0Y29uc3QgeHggPSAobTExICsgMSkgLyAyO1xuXHRcdFx0XHRjb25zdCB5eSA9IChtMjIgKyAxKSAvIDI7XG5cdFx0XHRcdGNvbnN0IHp6ID0gKG0zMyArIDEpIC8gMjtcblx0XHRcdFx0Y29uc3QgeHkgPSAobTEyICsgbTIxKSAvIDQ7XG5cdFx0XHRcdGNvbnN0IHh6ID0gKG0xMyArIG0zMSkgLyA0O1xuXHRcdFx0XHRjb25zdCB5eiA9IChtMjMgKyBtMzIpIC8gNDtcblxuXHRcdFx0XHRpZiAoeHggPiB5eSAmJiB4eCA+IHp6KSB7XG5cdFx0XHRcdFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblx0XHRcdFx0XHRpZiAoeHggPCBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0XHR4ID0gMDtcblx0XHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eCA9IE1hdGguc3FydCh4eCk7XG5cdFx0XHRcdFx0XHR5ID0geHkgLyB4O1xuXHRcdFx0XHRcdFx0eiA9IHh6IC8geDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoeXkgPiB6eikge1xuXHRcdFx0XHRcdC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cdFx0XHRcdFx0aWYgKHl5IDwgZXBzaWxvbikge1xuXHRcdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHkgPSBNYXRoLnNxcnQoeXkpO1xuXHRcdFx0XHRcdFx0eCA9IHh5IC8geTtcblx0XHRcdFx0XHRcdHogPSB5eiAvIHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcblx0XHRcdFx0XHRpZiAoenogPCBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0XHR6ID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eiA9IE1hdGguc3FydCh6eik7XG5cdFx0XHRcdFx0XHR4ID0geHogLyB6O1xuXHRcdFx0XHRcdFx0eSA9IHl6IC8gejtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnNldCh4LCB5LCB6LCBhbmdsZSk7XG5cdFx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxuXHRcdFx0fSAvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XG5cblxuXHRcdFx0bGV0IHMgPSBNYXRoLnNxcnQoKG0zMiAtIG0yMykgKiAobTMyIC0gbTIzKSArIChtMTMgLSBtMzEpICogKG0xMyAtIG0zMSkgKyAobTIxIC0gbTEyKSAqIChtMjEgLSBtMTIpKTsgLy8gdXNlZCB0byBub3JtYWxpemVcblxuXHRcdFx0aWYgKE1hdGguYWJzKHMpIDwgMC4wMDEpIHMgPSAxOyAvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXG5cdFx0XHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcblxuXHRcdFx0dGhpcy54ID0gKG0zMiAtIG0yMykgLyBzO1xuXHRcdFx0dGhpcy55ID0gKG0xMyAtIG0zMSkgLyBzO1xuXHRcdFx0dGhpcy56ID0gKG0yMSAtIG0xMikgLyBzO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5hY29zKChtMTEgKyBtMjIgKyBtMzMgLSAxKSAvIDIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWluKHYpIHtcblx0XHRcdHRoaXMueCA9IE1hdGgubWluKHRoaXMueCwgdi54KTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgdi55KTtcblx0XHRcdHRoaXMueiA9IE1hdGgubWluKHRoaXMueiwgdi56KTtcblx0XHRcdHRoaXMudyA9IE1hdGgubWluKHRoaXMudywgdi53KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1heCh2KSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heCh0aGlzLngsIHYueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIHYueSk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIHYueik7XG5cdFx0XHR0aGlzLncgPSBNYXRoLm1heCh0aGlzLncsIHYudyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbGFtcChtaW4sIG1heCkge1xuXHRcdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2Vcblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KG1pbi54LCBNYXRoLm1pbihtYXgueCwgdGhpcy54KSk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heChtaW4ueSwgTWF0aC5taW4obWF4LnksIHRoaXMueSkpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5tYXgobWluLnosIE1hdGgubWluKG1heC56LCB0aGlzLnopKTtcblx0XHRcdHRoaXMudyA9IE1hdGgubWF4KG1pbi53LCBNYXRoLm1pbihtYXgudywgdGhpcy53KSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbGFtcFNjYWxhcihtaW5WYWwsIG1heFZhbCkge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueCkpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueSkpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueikpO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMudykpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xhbXBMZW5ndGgobWluLCBtYXgpIHtcblx0XHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobGVuZ3RoIHx8IDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBsZW5ndGgpKSk7XG5cdFx0fVxuXG5cdFx0Zmxvb3IoKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLmZsb29yKHRoaXMueik7XG5cdFx0XHR0aGlzLncgPSBNYXRoLmZsb29yKHRoaXMudyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjZWlsKCkge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcblx0XHRcdHRoaXMueiA9IE1hdGguY2VpbCh0aGlzLnopO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5jZWlsKHRoaXMudyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyb3VuZCgpIHtcblx0XHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcblx0XHRcdHRoaXMueiA9IE1hdGgucm91bmQodGhpcy56KTtcblx0XHRcdHRoaXMudyA9IE1hdGgucm91bmQodGhpcy53KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJvdW5kVG9aZXJvKCkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy54IDwgMCA/IE1hdGguY2VpbCh0aGlzLngpIDogTWF0aC5mbG9vcih0aGlzLngpO1xuXHRcdFx0dGhpcy55ID0gdGhpcy55IDwgMCA/IE1hdGguY2VpbCh0aGlzLnkpIDogTWF0aC5mbG9vcih0aGlzLnkpO1xuXHRcdFx0dGhpcy56ID0gdGhpcy56IDwgMCA/IE1hdGguY2VpbCh0aGlzLnopIDogTWF0aC5mbG9vcih0aGlzLnopO1xuXHRcdFx0dGhpcy53ID0gdGhpcy53IDwgMCA/IE1hdGguY2VpbCh0aGlzLncpIDogTWF0aC5mbG9vcih0aGlzLncpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bmVnYXRlKCkge1xuXHRcdFx0dGhpcy54ID0gLXRoaXMueDtcblx0XHRcdHRoaXMueSA9IC10aGlzLnk7XG5cdFx0XHR0aGlzLnogPSAtdGhpcy56O1xuXHRcdFx0dGhpcy53ID0gLXRoaXMudztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRvdCh2KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xuXHRcdH1cblxuXHRcdGxlbmd0aFNxKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcblx0XHR9XG5cblx0XHRsZW5ndGgoKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyk7XG5cdFx0fVxuXG5cdFx0bWFuaGF0dGFuTGVuZ3RoKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCkgKyBNYXRoLmFicyh0aGlzLnkpICsgTWF0aC5hYnModGhpcy56KSArIE1hdGguYWJzKHRoaXMudyk7XG5cdFx0fVxuXG5cdFx0bm9ybWFsaXplKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7XG5cdFx0fVxuXG5cdFx0c2V0TGVuZ3RoKGxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcblx0XHR9XG5cblx0XHRsZXJwKHYsIGFscGhhKSB7XG5cdFx0XHR0aGlzLnggKz0gKHYueCAtIHRoaXMueCkgKiBhbHBoYTtcblx0XHRcdHRoaXMueSArPSAodi55IC0gdGhpcy55KSAqIGFscGhhO1xuXHRcdFx0dGhpcy56ICs9ICh2LnogLSB0aGlzLnopICogYWxwaGE7XG5cdFx0XHR0aGlzLncgKz0gKHYudyAtIHRoaXMudykgKiBhbHBoYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGxlcnBWZWN0b3JzKHYxLCB2MiwgYWxwaGEpIHtcblx0XHRcdHRoaXMueCA9IHYxLnggKyAodjIueCAtIHYxLngpICogYWxwaGE7XG5cdFx0XHR0aGlzLnkgPSB2MS55ICsgKHYyLnkgLSB2MS55KSAqIGFscGhhO1xuXHRcdFx0dGhpcy56ID0gdjEueiArICh2Mi56IC0gdjEueikgKiBhbHBoYTtcblx0XHRcdHRoaXMudyA9IHYxLncgKyAodjIudyAtIHYxLncpICogYWxwaGE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlcXVhbHModikge1xuXHRcdFx0cmV0dXJuIHYueCA9PT0gdGhpcy54ICYmIHYueSA9PT0gdGhpcy55ICYmIHYueiA9PT0gdGhpcy56ICYmIHYudyA9PT0gdGhpcy53O1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0dGhpcy54ID0gYXJyYXlbb2Zmc2V0XTtcblx0XHRcdHRoaXMueSA9IGFycmF5W29mZnNldCArIDFdO1xuXHRcdFx0dGhpcy56ID0gYXJyYXlbb2Zmc2V0ICsgMl07XG5cdFx0XHR0aGlzLncgPSBhcnJheVtvZmZzZXQgKyAzXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0YXJyYXlbb2Zmc2V0XSA9IHRoaXMueDtcblx0XHRcdGFycmF5W29mZnNldCArIDFdID0gdGhpcy55O1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLno7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAzXSA9IHRoaXMudztcblx0XHRcdHJldHVybiBhcnJheTtcblx0XHR9XG5cblx0XHRmcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCkge1xuXHRcdFx0aWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yNDogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WChpbmRleCk7XG5cdFx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WShpbmRleCk7XG5cdFx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WihpbmRleCk7XG5cdFx0XHR0aGlzLncgPSBhdHRyaWJ1dGUuZ2V0VyhpbmRleCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyYW5kb20oKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHRcdHRoaXMueiA9IE1hdGgucmFuZG9tKCk7XG5cdFx0XHR0aGlzLncgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRWZWN0b3I0LnByb3RvdHlwZS5pc1ZlY3RvcjQgPSB0cnVlO1xuXG5cdC8qXG5cdCBJbiBvcHRpb25zLCB3ZSBjYW4gc3BlY2lmeTpcblx0ICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxuXHQgKiBkZXB0aEJ1ZmZlci9zdGVuY2lsQnVmZmVyOiBCb29sZWFucyB0byBpbmRpY2F0ZSBpZiB3ZSBzaG91bGQgZ2VuZXJhdGUgdGhlc2UgYnVmZmVyc1xuXHQqL1xuXG5cdGNsYXNzIFdlYkdMUmVuZGVyVGFyZ2V0IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdHRoaXMuZGVwdGggPSAxO1xuXHRcdFx0dGhpcy5zY2lzc29yID0gbmV3IFZlY3RvcjQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLnNjaXNzb3JUZXN0ID0gZmFsc2U7XG5cdFx0XHR0aGlzLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZSh1bmRlZmluZWQsIG9wdGlvbnMubWFwcGluZywgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuZW5jb2RpbmcpO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cdFx0XHR0aGlzLnRleHR1cmUuaW1hZ2UgPSB7XG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdGRlcHRoOiAxXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuXHRcdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcblx0XHRcdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcblx0XHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVuY2lsQnVmZmVyIDogZmFsc2U7XG5cdFx0XHR0aGlzLmRlcHRoVGV4dHVyZSA9IG9wdGlvbnMuZGVwdGhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoVGV4dHVyZSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0c2V0VGV4dHVyZSh0ZXh0dXJlKSB7XG5cdFx0XHR0ZXh0dXJlLmltYWdlID0ge1xuXHRcdFx0XHR3aWR0aDogdGhpcy53aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiB0aGlzLmhlaWdodCxcblx0XHRcdFx0ZGVwdGg6IHRoaXMuZGVwdGhcblx0XHRcdH07XG5cdFx0XHR0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuXHRcdH1cblxuXHRcdHNldFNpemUod2lkdGgsIGhlaWdodCwgZGVwdGggPSAxKSB7XG5cdFx0XHRpZiAodGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCB8fCB0aGlzLmRlcHRoICE9PSBkZXB0aCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5pbWFnZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0XHR0aGlzLnRleHR1cmUuaW1hZ2UuZGVwdGggPSBkZXB0aDtcblx0XHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudmlld3BvcnQuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0dGhpcy5zY2lzc29yLnNldCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cdFx0XHR0aGlzLmRlcHRoID0gc291cmNlLmRlcHRoO1xuXHRcdFx0dGhpcy52aWV3cG9ydC5jb3B5KHNvdXJjZS52aWV3cG9ydCk7XG5cdFx0XHR0aGlzLnRleHR1cmUgPSBzb3VyY2UudGV4dHVyZS5jbG9uZSgpO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmltYWdlID0geyAuLi50aGlzLnRleHR1cmUuaW1hZ2Vcblx0XHRcdH07IC8vIFNlZSAjMjAzMjguXG5cblx0XHRcdHRoaXMuZGVwdGhCdWZmZXIgPSBzb3VyY2UuZGVwdGhCdWZmZXI7XG5cdFx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcblx0XHRcdHRoaXMuZGVwdGhUZXh0dXJlID0gc291cmNlLmRlcHRoVGV4dHVyZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHR0eXBlOiAnZGlzcG9zZSdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9XG5cblx0V2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLmlzV2ViR0xSZW5kZXJUYXJnZXQgPSB0cnVlO1xuXG5cdGNsYXNzIFdlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzIGV4dGVuZHMgV2ViR0xSZW5kZXJUYXJnZXQge1xuXHRcdGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIGNvdW50KSB7XG5cdFx0XHRzdXBlcih3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG5cdFx0XHR0aGlzLnRleHR1cmUgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMudGV4dHVyZVtpXSA9IHRleHR1cmUuY2xvbmUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXRTaXplKHdpZHRoLCBoZWlnaHQsIGRlcHRoID0gMSkge1xuXHRcdFx0aWYgKHRoaXMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgdGhpcy5kZXB0aCAhPT0gZGVwdGgpIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMudGV4dHVyZS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy50ZXh0dXJlW2ldLmltYWdlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdFx0dGhpcy50ZXh0dXJlW2ldLmltYWdlLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdFx0XHR0aGlzLnRleHR1cmVbaV0uaW1hZ2UuZGVwdGggPSBkZXB0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnZpZXdwb3J0LnNldCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdHRoaXMuc2Npc3Nvci5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXHRcdFx0dGhpcy5kZXB0aCA9IHNvdXJjZS5kZXB0aDtcblx0XHRcdHRoaXMudmlld3BvcnQuc2V0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRcdHRoaXMuc2Npc3Nvci5zZXQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHRcdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcblx0XHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xuXHRcdFx0dGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmxlbmd0aCA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHNvdXJjZS50ZXh0dXJlLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0dGhpcy50ZXh0dXJlW2ldID0gc291cmNlLnRleHR1cmVbaV0uY2xvbmUoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cy5wcm90b3R5cGUuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9IHRydWU7XG5cblx0Y2xhc3MgV2ViR0xNdWx0aXNhbXBsZVJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblx0XHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG5cdFx0XHRzdXBlcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcblx0XHRcdHRoaXMuc2FtcGxlcyA9IDQ7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXHRcdFx0dGhpcy5zYW1wbGVzID0gc291cmNlLnNhbXBsZXM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFdlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQucHJvdG90eXBlLmlzV2ViR0xNdWx0aXNhbXBsZVJlbmRlclRhcmdldCA9IHRydWU7XG5cblx0Y2xhc3MgUXVhdGVybmlvbiB7XG5cdFx0Y29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEpIHtcblx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0dGhpcy5feSA9IHk7XG5cdFx0XHR0aGlzLl96ID0gejtcblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdH1cblxuXHRcdHN0YXRpYyBzbGVycChxYSwgcWIsIHFtLCB0KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlF1YXRlcm5pb246IFN0YXRpYyAuc2xlcnAoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgcW0uc2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkgaW5zdGVhZC4nKTtcblx0XHRcdHJldHVybiBxbS5zbGVycFF1YXRlcm5pb25zKHFhLCBxYiwgdCk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIHNsZXJwRmxhdChkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCkge1xuXHRcdFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxuXHRcdFx0bGV0IHgwID0gc3JjMFtzcmNPZmZzZXQwICsgMF0sXG5cdFx0XHRcdFx0eTAgPSBzcmMwW3NyY09mZnNldDAgKyAxXSxcblx0XHRcdFx0XHR6MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDJdLFxuXHRcdFx0XHRcdHcwID0gc3JjMFtzcmNPZmZzZXQwICsgM107XG5cdFx0XHRjb25zdCB4MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDBdLFxuXHRcdFx0XHRcdFx0eTEgPSBzcmMxW3NyY09mZnNldDEgKyAxXSxcblx0XHRcdFx0XHRcdHoxID0gc3JjMVtzcmNPZmZzZXQxICsgMl0sXG5cdFx0XHRcdFx0XHR3MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDNdO1xuXG5cdFx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0XHRkc3RbZHN0T2Zmc2V0ICsgMF0gPSB4MDtcblx0XHRcdFx0ZHN0W2RzdE9mZnNldCArIDFdID0geTA7XG5cdFx0XHRcdGRzdFtkc3RPZmZzZXQgKyAyXSA9IHowO1xuXHRcdFx0XHRkc3RbZHN0T2Zmc2V0ICsgM10gPSB3MDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0XHRkc3RbZHN0T2Zmc2V0ICsgMF0gPSB4MTtcblx0XHRcdFx0ZHN0W2RzdE9mZnNldCArIDFdID0geTE7XG5cdFx0XHRcdGRzdFtkc3RPZmZzZXQgKyAyXSA9IHoxO1xuXHRcdFx0XHRkc3RbZHN0T2Zmc2V0ICsgM10gPSB3MTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxKSB7XG5cdFx0XHRcdGxldCBzID0gMSAtIHQ7XG5cdFx0XHRcdGNvbnN0IGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXG5cdFx0XHRcdFx0XHRcdGRpciA9IGNvcyA+PSAwID8gMSA6IC0xLFxuXHRcdFx0XHRcdFx0XHRzcXJTaW4gPSAxIC0gY29zICogY29zOyAvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxuXG5cdFx0XHRcdGlmIChzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc3FydChzcXJTaW4pLFxuXHRcdFx0XHRcdFx0XHRcdGxlbiA9IE1hdGguYXRhbjIoc2luLCBjb3MgKiBkaXIpO1xuXHRcdFx0XHRcdHMgPSBNYXRoLnNpbihzICogbGVuKSAvIHNpbjtcblx0XHRcdFx0XHR0ID0gTWF0aC5zaW4odCAqIGxlbikgLyBzaW47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB0RGlyID0gdCAqIGRpcjtcblx0XHRcdFx0eDAgPSB4MCAqIHMgKyB4MSAqIHREaXI7XG5cdFx0XHRcdHkwID0geTAgKiBzICsgeTEgKiB0RGlyO1xuXHRcdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdFx0dzAgPSB3MCAqIHMgKyB3MSAqIHREaXI7IC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcblxuXHRcdFx0XHRpZiAocyA9PT0gMSAtIHQpIHtcblx0XHRcdFx0XHRjb25zdCBmID0gMSAvIE1hdGguc3FydCh4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwKTtcblx0XHRcdFx0XHR4MCAqPSBmO1xuXHRcdFx0XHRcdHkwICo9IGY7XG5cdFx0XHRcdFx0ejAgKj0gZjtcblx0XHRcdFx0XHR3MCAqPSBmO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGRzdFtkc3RPZmZzZXRdID0geDA7XG5cdFx0XHRkc3RbZHN0T2Zmc2V0ICsgMV0gPSB5MDtcblx0XHRcdGRzdFtkc3RPZmZzZXQgKyAyXSA9IHowO1xuXHRcdFx0ZHN0W2RzdE9mZnNldCArIDNdID0gdzA7XG5cdFx0fVxuXG5cdFx0c3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxKSB7XG5cdFx0XHRjb25zdCB4MCA9IHNyYzBbc3JjT2Zmc2V0MF07XG5cdFx0XHRjb25zdCB5MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDFdO1xuXHRcdFx0Y29uc3QgejAgPSBzcmMwW3NyY09mZnNldDAgKyAyXTtcblx0XHRcdGNvbnN0IHcwID0gc3JjMFtzcmNPZmZzZXQwICsgM107XG5cdFx0XHRjb25zdCB4MSA9IHNyYzFbc3JjT2Zmc2V0MV07XG5cdFx0XHRjb25zdCB5MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDFdO1xuXHRcdFx0Y29uc3QgejEgPSBzcmMxW3NyY09mZnNldDEgKyAyXTtcblx0XHRcdGNvbnN0IHcxID0gc3JjMVtzcmNPZmZzZXQxICsgM107XG5cdFx0XHRkc3RbZHN0T2Zmc2V0XSA9IHgwICogdzEgKyB3MCAqIHgxICsgeTAgKiB6MSAtIHowICogeTE7XG5cdFx0XHRkc3RbZHN0T2Zmc2V0ICsgMV0gPSB5MCAqIHcxICsgdzAgKiB5MSArIHowICogeDEgLSB4MCAqIHoxO1xuXHRcdFx0ZHN0W2RzdE9mZnNldCArIDJdID0gejAgKiB3MSArIHcwICogejEgKyB4MCAqIHkxIC0geTAgKiB4MTtcblx0XHRcdGRzdFtkc3RPZmZzZXQgKyAzXSA9IHcwICogdzEgLSB4MCAqIHgxIC0geTAgKiB5MSAtIHowICogejE7XG5cdFx0XHRyZXR1cm4gZHN0O1xuXHRcdH1cblxuXHRcdGdldCB4KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3g7XG5cdFx0fVxuXG5cdFx0c2V0IHgodmFsdWUpIHtcblx0XHRcdHRoaXMuX3ggPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGdldCB5KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3k7XG5cdFx0fVxuXG5cdFx0c2V0IHkodmFsdWUpIHtcblx0XHRcdHRoaXMuX3kgPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGdldCB6KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3o7XG5cdFx0fVxuXG5cdFx0c2V0IHoodmFsdWUpIHtcblx0XHRcdHRoaXMuX3ogPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGdldCB3KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3c7XG5cdFx0fVxuXG5cdFx0c2V0IHcodmFsdWUpIHtcblx0XHRcdHRoaXMuX3cgPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdHNldCh4LCB5LCB6LCB3KSB7XG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cdFx0XHR0aGlzLl93ID0gdztcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93KTtcblx0XHR9XG5cblx0XHRjb3B5KHF1YXRlcm5pb24pIHtcblx0XHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG5cdFx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuXHRcdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcblx0XHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbUV1bGVyKGV1bGVyLCB1cGRhdGUpIHtcblx0XHRcdGlmICghKGV1bGVyICYmIGV1bGVyLmlzRXVsZXIpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHggPSBldWxlci5feCxcblx0XHRcdFx0XHRcdHkgPSBldWxlci5feSxcblx0XHRcdFx0XHRcdHogPSBldWxlci5feixcblx0XHRcdFx0XHRcdG9yZGVyID0gZXVsZXIuX29yZGVyOyAvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuXHRcdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxuXG5cdFx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luO1xuXHRcdFx0Y29uc3QgYzEgPSBjb3MoeCAvIDIpO1xuXHRcdFx0Y29uc3QgYzIgPSBjb3MoeSAvIDIpO1xuXHRcdFx0Y29uc3QgYzMgPSBjb3MoeiAvIDIpO1xuXHRcdFx0Y29uc3QgczEgPSBzaW4oeCAvIDIpO1xuXHRcdFx0Y29uc3QgczIgPSBzaW4oeSAvIDIpO1xuXHRcdFx0Y29uc3QgczMgPSBzaW4oeiAvIDIpO1xuXG5cdFx0XHRzd2l0Y2ggKG9yZGVyKSB7XG5cdFx0XHRcdGNhc2UgJ1hZWic6XG5cdFx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdZWFonOlxuXHRcdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWlhZJzpcblx0XHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1pZWCc6XG5cdFx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdZWlgnOlxuXHRcdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWFpZJzpcblx0XHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHVwZGF0ZSAhPT0gZmFsc2UpIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cblx0XHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cdFx0XHRjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsXG5cdFx0XHRcdFx0XHRzID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcblx0XHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuXHRcdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcblx0XHRcdHRoaXMuX3cgPSBNYXRoLmNvcyhoYWxmQW5nbGUpO1xuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21Sb3RhdGlvbk1hdHJpeChtKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXHRcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblx0XHRcdGNvbnN0IHRlID0gbS5lbGVtZW50cyxcblx0XHRcdFx0XHRcdG0xMSA9IHRlWzBdLFxuXHRcdFx0XHRcdFx0bTEyID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRtMTMgPSB0ZVs4XSxcblx0XHRcdFx0XHRcdG0yMSA9IHRlWzFdLFxuXHRcdFx0XHRcdFx0bTIyID0gdGVbNV0sXG5cdFx0XHRcdFx0XHRtMjMgPSB0ZVs5XSxcblx0XHRcdFx0XHRcdG0zMSA9IHRlWzJdLFxuXHRcdFx0XHRcdFx0bTMyID0gdGVbNl0sXG5cdFx0XHRcdFx0XHRtMzMgPSB0ZVsxMF0sXG5cdFx0XHRcdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcblxuXHRcdFx0aWYgKHRyYWNlID4gMCkge1xuXHRcdFx0XHRjb25zdCBzID0gMC41IC8gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKTtcblx0XHRcdFx0dGhpcy5fdyA9IDAuMjUgLyBzO1xuXHRcdFx0XHR0aGlzLl94ID0gKG0zMiAtIG0yMykgKiBzO1xuXHRcdFx0XHR0aGlzLl95ID0gKG0xMyAtIG0zMSkgKiBzO1xuXHRcdFx0XHR0aGlzLl96ID0gKG0yMSAtIG0xMikgKiBzO1xuXHRcdFx0fSBlbHNlIGlmIChtMTEgPiBtMjIgJiYgbTExID4gbTMzKSB7XG5cdFx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTExIC0gbTIyIC0gbTMzKTtcblx0XHRcdFx0dGhpcy5fdyA9IChtMzIgLSBtMjMpIC8gcztcblx0XHRcdFx0dGhpcy5feCA9IDAuMjUgKiBzO1xuXHRcdFx0XHR0aGlzLl95ID0gKG0xMiArIG0yMSkgLyBzO1xuXHRcdFx0XHR0aGlzLl96ID0gKG0xMyArIG0zMSkgLyBzO1xuXHRcdFx0fSBlbHNlIGlmIChtMjIgPiBtMzMpIHtcblx0XHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCgxLjAgKyBtMjIgLSBtMTEgLSBtMzMpO1xuXHRcdFx0XHR0aGlzLl93ID0gKG0xMyAtIG0zMSkgLyBzO1xuXHRcdFx0XHR0aGlzLl94ID0gKG0xMiArIG0yMSkgLyBzO1xuXHRcdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG5cdFx0XHRcdHRoaXMuX3ogPSAobTIzICsgbTMyKSAvIHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KDEuMCArIG0zMyAtIG0xMSAtIG0yMik7XG5cdFx0XHRcdHRoaXMuX3cgPSAobTIxIC0gbTEyKSAvIHM7XG5cdFx0XHRcdHRoaXMuX3ggPSAobTEzICsgbTMxKSAvIHM7XG5cdFx0XHRcdHRoaXMuX3kgPSAobTIzICsgbTMyKSAvIHM7XG5cdFx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tVW5pdFZlY3RvcnModkZyb20sIHZUbykge1xuXHRcdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXG5cdFx0XHRsZXQgciA9IHZGcm9tLmRvdCh2VG8pICsgMTtcblxuXHRcdFx0aWYgKHIgPCBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHQvLyB2RnJvbSBhbmQgdlRvIHBvaW50IGluIG9wcG9zaXRlIGRpcmVjdGlvbnNcblx0XHRcdFx0ciA9IDA7XG5cblx0XHRcdFx0aWYgKE1hdGguYWJzKHZGcm9tLngpID4gTWF0aC5hYnModkZyb20ueikpIHtcblx0XHRcdFx0XHR0aGlzLl94ID0gLXZGcm9tLnk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IHZGcm9tLng7XG5cdFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHRcdFx0dGhpcy5fdyA9IHI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feSA9IC12RnJvbS56O1xuXHRcdFx0XHRcdHRoaXMuX3ogPSB2RnJvbS55O1xuXHRcdFx0XHRcdHRoaXMuX3cgPSByO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBjcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTsgLy8gaW5saW5lZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSBvbiBWZWN0b3IzXG5cdFx0XHRcdHRoaXMuX3ggPSB2RnJvbS55ICogdlRvLnogLSB2RnJvbS56ICogdlRvLnk7XG5cdFx0XHRcdHRoaXMuX3kgPSB2RnJvbS56ICogdlRvLnggLSB2RnJvbS54ICogdlRvLno7XG5cdFx0XHRcdHRoaXMuX3ogPSB2RnJvbS54ICogdlRvLnkgLSB2RnJvbS55ICogdlRvLng7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblx0XHR9XG5cblx0XHRhbmdsZVRvKHEpIHtcblx0XHRcdHJldHVybiAyICogTWF0aC5hY29zKE1hdGguYWJzKGNsYW1wKHRoaXMuZG90KHEpLCAtMSwgMSkpKTtcblx0XHR9XG5cblx0XHRyb3RhdGVUb3dhcmRzKHEsIHN0ZXApIHtcblx0XHRcdGNvbnN0IGFuZ2xlID0gdGhpcy5hbmdsZVRvKHEpO1xuXHRcdFx0aWYgKGFuZ2xlID09PSAwKSByZXR1cm4gdGhpcztcblx0XHRcdGNvbnN0IHQgPSBNYXRoLm1pbigxLCBzdGVwIC8gYW5nbGUpO1xuXHRcdFx0dGhpcy5zbGVycChxLCB0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlkZW50aXR5KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KDAsIDAsIDAsIDEpO1xuXHRcdH1cblxuXHRcdGludmVydCgpIHtcblx0XHRcdC8vIHF1YXRlcm5pb24gaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cdFx0XHRyZXR1cm4gdGhpcy5jb25qdWdhdGUoKTtcblx0XHR9XG5cblx0XHRjb25qdWdhdGUoKSB7XG5cdFx0XHR0aGlzLl94ICo9IC0xO1xuXHRcdFx0dGhpcy5feSAqPSAtMTtcblx0XHRcdHRoaXMuX3ogKj0gLTE7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZG90KHYpIHtcblx0XHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblx0XHR9XG5cblx0XHRsZW5ndGhTcSgpIHtcblx0XHRcdHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcblx0XHR9XG5cblx0XHRsZW5ndGgoKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93KTtcblx0XHR9XG5cblx0XHRub3JtYWxpemUoKSB7XG5cdFx0XHRsZXQgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRcdGlmIChsID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHRcdHRoaXMuX3cgPSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bCA9IDEgLyBsO1xuXHRcdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdFx0dGhpcy5feiA9IHRoaXMuX3ogKiBsO1xuXHRcdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHkocSwgcCkge1xuXHRcdFx0aWYgKHAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHEsIHApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHRoaXMsIHEpO1xuXHRcdH1cblxuXHRcdHByZW11bHRpcGx5KHEpIHtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMocSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHlRdWF0ZXJuaW9ucyhhLCBiKSB7XG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cblx0XHRcdGNvbnN0IHFheCA9IGEuX3gsXG5cdFx0XHRcdFx0XHRxYXkgPSBhLl95LFxuXHRcdFx0XHRcdFx0cWF6ID0gYS5feixcblx0XHRcdFx0XHRcdHFhdyA9IGEuX3c7XG5cdFx0XHRjb25zdCBxYnggPSBiLl94LFxuXHRcdFx0XHRcdFx0cWJ5ID0gYi5feSxcblx0XHRcdFx0XHRcdHFieiA9IGIuX3osXG5cdFx0XHRcdFx0XHRxYncgPSBiLl93O1xuXHRcdFx0dGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcblx0XHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdFx0dGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzbGVycChxYiwgdCkge1xuXHRcdFx0aWYgKHQgPT09IDApIHJldHVybiB0aGlzO1xuXHRcdFx0aWYgKHQgPT09IDEpIHJldHVybiB0aGlzLmNvcHkocWIpO1xuXHRcdFx0Y29uc3QgeCA9IHRoaXMuX3gsXG5cdFx0XHRcdFx0XHR5ID0gdGhpcy5feSxcblx0XHRcdFx0XHRcdHogPSB0aGlzLl96LFxuXHRcdFx0XHRcdFx0dyA9IHRoaXMuX3c7IC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHRcdGxldCBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XG5cblx0XHRcdGlmIChjb3NIYWxmVGhldGEgPCAwKSB7XG5cdFx0XHRcdHRoaXMuX3cgPSAtcWIuX3c7XG5cdFx0XHRcdHRoaXMuX3ggPSAtcWIuX3g7XG5cdFx0XHRcdHRoaXMuX3kgPSAtcWIuX3k7XG5cdFx0XHRcdHRoaXMuX3ogPSAtcWIuX3o7XG5cdFx0XHRcdGNvc0hhbGZUaGV0YSA9IC1jb3NIYWxmVGhldGE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNvcHkocWIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY29zSGFsZlRoZXRhID49IDEuMCkge1xuXHRcdFx0XHR0aGlzLl93ID0gdztcblx0XHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0XHR0aGlzLl96ID0gejtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNxclNpbkhhbGZUaGV0YSA9IDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YTtcblxuXHRcdFx0aWYgKHNxclNpbkhhbGZUaGV0YSA8PSBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cdFx0XHRcdHRoaXMuX3cgPSBzICogdyArIHQgKiB0aGlzLl93O1xuXHRcdFx0XHR0aGlzLl94ID0gcyAqIHggKyB0ICogdGhpcy5feDtcblx0XHRcdFx0dGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG5cdFx0XHRcdHRoaXMuX3ogPSBzICogeiArIHQgKiB0aGlzLl96O1xuXHRcdFx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KHNxclNpbkhhbGZUaGV0YSk7XG5cdFx0XHRjb25zdCBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhKTtcblx0XHRcdGNvbnN0IHJhdGlvQSA9IE1hdGguc2luKCgxIC0gdCkgKiBoYWxmVGhldGEpIC8gc2luSGFsZlRoZXRhLFxuXHRcdFx0XHRcdFx0cmF0aW9CID0gTWF0aC5zaW4odCAqIGhhbGZUaGV0YSkgLyBzaW5IYWxmVGhldGE7XG5cdFx0XHR0aGlzLl93ID0gdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0I7XG5cdFx0XHR0aGlzLl94ID0geCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0I7XG5cdFx0XHR0aGlzLl95ID0geSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0I7XG5cdFx0XHR0aGlzLl96ID0geiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0I7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2xlcnBRdWF0ZXJuaW9ucyhxYSwgcWIsIHQpIHtcblx0XHRcdHRoaXMuY29weShxYSkuc2xlcnAocWIsIHQpO1xuXHRcdH1cblxuXHRcdGVxdWFscyhxdWF0ZXJuaW9uKSB7XG5cdFx0XHRyZXR1cm4gcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCAmJiBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICYmIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogJiYgcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdztcblx0XHR9XG5cblx0XHRmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcblx0XHRcdHRoaXMuX3ggPSBhcnJheVtvZmZzZXRdO1xuXHRcdFx0dGhpcy5feSA9IGFycmF5W29mZnNldCArIDFdO1xuXHRcdFx0dGhpcy5feiA9IGFycmF5W29mZnNldCArIDJdO1xuXHRcdFx0dGhpcy5fdyA9IGFycmF5W29mZnNldCArIDNdO1xuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0YXJyYXlbb2Zmc2V0XSA9IHRoaXMuX3g7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMuX3k7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAyXSA9IHRoaXMuX3o7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAzXSA9IHRoaXMuX3c7XG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0fVxuXG5cdFx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGV4KSB7XG5cdFx0XHR0aGlzLl94ID0gYXR0cmlidXRlLmdldFgoaW5kZXgpO1xuXHRcdFx0dGhpcy5feSA9IGF0dHJpYnV0ZS5nZXRZKGluZGV4KTtcblx0XHRcdHRoaXMuX3ogPSBhdHRyaWJ1dGUuZ2V0WihpbmRleCk7XG5cdFx0XHR0aGlzLl93ID0gYXR0cmlidXRlLmdldFcoaW5kZXgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0X29uQ2hhbmdlKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cblx0fVxuXG5cdFF1YXRlcm5pb24ucHJvdG90eXBlLmlzUXVhdGVybmlvbiA9IHRydWU7XG5cblx0Y2xhc3MgVmVjdG9yMyB7XG5cdFx0Y29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCkge1xuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHR0aGlzLnogPSB6O1xuXHRcdH1cblxuXHRcdHNldCh4LCB5LCB6KSB7XG5cdFx0XHRpZiAoeiA9PT0gdW5kZWZpbmVkKSB6ID0gdGhpcy56OyAvLyBzcHJpdGUuc2NhbGUuc2V0KHgseSlcblxuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHR0aGlzLnogPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0U2NhbGFyKHNjYWxhcikge1xuXHRcdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ID0gc2NhbGFyO1xuXHRcdFx0dGhpcy56ID0gc2NhbGFyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WCh4KSB7XG5cdFx0XHR0aGlzLnggPSB4O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WSh5KSB7XG5cdFx0XHR0aGlzLnkgPSB5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0Wih6KSB7XG5cdFx0XHR0aGlzLnogPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0Q29tcG9uZW50KGluZGV4LCB2YWx1ZSkge1xuXHRcdFx0c3dpdGNoIChpbmRleCkge1xuXHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0dGhpcy54ID0gdmFsdWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdHRoaXMueSA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHR0aGlzLnogPSB2YWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRDb21wb25lbnQoaW5kZXgpIHtcblx0XHRcdHN3aXRjaCAoaW5kZXgpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLng7XG5cblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnk7XG5cblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLno7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcblx0XHR9XG5cblx0XHRjb3B5KHYpIHtcblx0XHRcdHRoaXMueCA9IHYueDtcblx0XHRcdHRoaXMueSA9IHYueTtcblx0XHRcdHRoaXMueiA9IHYuejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZCh2LCB3KSB7XG5cdFx0XHRpZiAodyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKHYsIHcpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggKz0gdi54O1xuXHRcdFx0dGhpcy55ICs9IHYueTtcblx0XHRcdHRoaXMueiArPSB2Lno7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRTY2FsYXIocykge1xuXHRcdFx0dGhpcy54ICs9IHM7XG5cdFx0XHR0aGlzLnkgKz0gcztcblx0XHRcdHRoaXMueiArPSBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkVmVjdG9ycyhhLCBiKSB7XG5cdFx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cdFx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRTY2FsZWRWZWN0b3Iodiwgcykge1xuXHRcdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHRcdHRoaXMueiArPSB2LnogKiBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c3ViKHYsIHcpIHtcblx0XHRcdGlmICh3ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnModiwgdyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdFx0dGhpcy56IC09IHYuejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHN1YlNjYWxhcihzKSB7XG5cdFx0XHR0aGlzLnggLT0gcztcblx0XHRcdHRoaXMueSAtPSBzO1xuXHRcdFx0dGhpcy56IC09IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzdWJWZWN0b3JzKGEsIGIpIHtcblx0XHRcdHRoaXMueCA9IGEueCAtIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiAtIGIuejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5KHYsIHcpIHtcblx0XHRcdGlmICh3ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnModiwgdyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdFx0dGhpcy56ICo9IHYuejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5U2NhbGFyKHNjYWxhcikge1xuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHlWZWN0b3JzKGEsIGIpIHtcblx0XHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSAqIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiAqIGIuejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFwcGx5RXVsZXIoZXVsZXIpIHtcblx0XHRcdGlmICghKGV1bGVyICYmIGV1bGVyLmlzRXVsZXIpKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlZlY3RvcjM6IC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYW4gRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKF9xdWF0ZXJuaW9uJDQuc2V0RnJvbUV1bGVyKGV1bGVyKSk7XG5cdFx0fVxuXG5cdFx0YXBwbHlBeGlzQW5nbGUoYXhpcywgYW5nbGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihfcXVhdGVybmlvbiQ0LnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpKTtcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDMobSkge1xuXHRcdFx0Y29uc3QgeCA9IHRoaXMueCxcblx0XHRcdFx0XHRcdHkgPSB0aGlzLnksXG5cdFx0XHRcdFx0XHR6ID0gdGhpcy56O1xuXHRcdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cdFx0XHR0aGlzLnggPSBlWzBdICogeCArIGVbM10gKiB5ICsgZVs2XSAqIHo7XG5cdFx0XHR0aGlzLnkgPSBlWzFdICogeCArIGVbNF0gKiB5ICsgZVs3XSAqIHo7XG5cdFx0XHR0aGlzLnogPSBlWzJdICogeCArIGVbNV0gKiB5ICsgZVs4XSAqIHo7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhcHBseU5vcm1hbE1hdHJpeChtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDMobSkubm9ybWFsaXplKCk7XG5cdFx0fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG0pIHtcblx0XHRcdGNvbnN0IHggPSB0aGlzLngsXG5cdFx0XHRcdFx0XHR5ID0gdGhpcy55LFxuXHRcdFx0XHRcdFx0eiA9IHRoaXMuejtcblx0XHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgdyA9IDEgLyAoZVszXSAqIHggKyBlWzddICogeSArIGVbMTFdICogeiArIGVbMTVdKTtcblx0XHRcdHRoaXMueCA9IChlWzBdICogeCArIGVbNF0gKiB5ICsgZVs4XSAqIHogKyBlWzEyXSkgKiB3O1xuXHRcdFx0dGhpcy55ID0gKGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICogeiArIGVbMTNdKSAqIHc7XG5cdFx0XHR0aGlzLnogPSAoZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogeiArIGVbMTRdKSAqIHc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhcHBseVF1YXRlcm5pb24ocSkge1xuXHRcdFx0Y29uc3QgeCA9IHRoaXMueCxcblx0XHRcdFx0XHRcdHkgPSB0aGlzLnksXG5cdFx0XHRcdFx0XHR6ID0gdGhpcy56O1xuXHRcdFx0Y29uc3QgcXggPSBxLngsXG5cdFx0XHRcdFx0XHRxeSA9IHEueSxcblx0XHRcdFx0XHRcdHF6ID0gcS56LFxuXHRcdFx0XHRcdFx0cXcgPSBxLnc7IC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cblx0XHRcdGNvbnN0IGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuXHRcdFx0Y29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0XHRjb25zdCBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcblx0XHRcdGNvbnN0IGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejsgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0XHR0aGlzLnggPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuXHRcdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcblx0XHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRwcm9qZWN0KGNhbWVyYSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpLmFwcGx5TWF0cml4NChjYW1lcmEucHJvamVjdGlvbk1hdHJpeCk7XG5cdFx0fVxuXG5cdFx0dW5wcm9qZWN0KGNhbWVyYSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSkuYXBwbHlNYXRyaXg0KGNhbWVyYS5tYXRyaXhXb3JsZCk7XG5cdFx0fVxuXG5cdFx0dHJhbnNmb3JtRGlyZWN0aW9uKG0pIHtcblx0XHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXHRcdFx0Y29uc3QgeCA9IHRoaXMueCxcblx0XHRcdFx0XHRcdHkgPSB0aGlzLnksXG5cdFx0XHRcdFx0XHR6ID0gdGhpcy56O1xuXHRcdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cdFx0XHR0aGlzLnggPSBlWzBdICogeCArIGVbNF0gKiB5ICsgZVs4XSAqIHo7XG5cdFx0XHR0aGlzLnkgPSBlWzFdICogeCArIGVbNV0gKiB5ICsgZVs5XSAqIHo7XG5cdFx0XHR0aGlzLnogPSBlWzJdICogeCArIGVbNl0gKiB5ICsgZVsxMF0gKiB6O1xuXHRcdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cdFx0fVxuXG5cdFx0ZGl2aWRlKHYpIHtcblx0XHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdFx0dGhpcy56IC89IHYuejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRpdmlkZVNjYWxhcihzY2FsYXIpIHtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzY2FsYXIpO1xuXHRcdH1cblxuXHRcdG1pbih2KSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIHYueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIHYueSk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIHYueik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtYXgodikge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCB2LngpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCB2LnkpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5tYXgodGhpcy56LCB2LnopO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xhbXAobWluLCBtYXgpIHtcblx0XHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heChtaW4ueCwgTWF0aC5taW4obWF4LngsIHRoaXMueCkpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgobWluLnksIE1hdGgubWluKG1heC55LCB0aGlzLnkpKTtcblx0XHRcdHRoaXMueiA9IE1hdGgubWF4KG1pbi56LCBNYXRoLm1pbihtYXgueiwgdGhpcy56KSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbGFtcFNjYWxhcihtaW5WYWwsIG1heFZhbCkge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueCkpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueSkpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueikpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xhbXBMZW5ndGgobWluLCBtYXgpIHtcblx0XHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobGVuZ3RoIHx8IDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBsZW5ndGgpKSk7XG5cdFx0fVxuXG5cdFx0Zmxvb3IoKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLmZsb29yKHRoaXMueik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjZWlsKCkge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcblx0XHRcdHRoaXMueiA9IE1hdGguY2VpbCh0aGlzLnopO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm91bmQoKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKHRoaXMueik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyb3VuZFRvWmVybygpIHtcblx0XHRcdHRoaXMueCA9IHRoaXMueCA8IDAgPyBNYXRoLmNlaWwodGhpcy54KSA6IE1hdGguZmxvb3IodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IHRoaXMueSA8IDAgPyBNYXRoLmNlaWwodGhpcy55KSA6IE1hdGguZmxvb3IodGhpcy55KTtcblx0XHRcdHRoaXMueiA9IHRoaXMueiA8IDAgPyBNYXRoLmNlaWwodGhpcy56KSA6IE1hdGguZmxvb3IodGhpcy56KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG5lZ2F0ZSgpIHtcblx0XHRcdHRoaXMueCA9IC10aGlzLng7XG5cdFx0XHR0aGlzLnkgPSAtdGhpcy55O1xuXHRcdFx0dGhpcy56ID0gLXRoaXMuejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRvdCh2KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXHRcdH0gLy8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cblx0XHRsZW5ndGhTcSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cdFx0fVxuXG5cdFx0bGVuZ3RoKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnopO1xuXHRcdH1cblxuXHRcdG1hbmhhdHRhbkxlbmd0aCgpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KSArIE1hdGguYWJzKHRoaXMueik7XG5cdFx0fVxuXG5cdFx0bm9ybWFsaXplKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7XG5cdFx0fVxuXG5cdFx0c2V0TGVuZ3RoKGxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcblx0XHR9XG5cblx0XHRsZXJwKHYsIGFscGhhKSB7XG5cdFx0XHR0aGlzLnggKz0gKHYueCAtIHRoaXMueCkgKiBhbHBoYTtcblx0XHRcdHRoaXMueSArPSAodi55IC0gdGhpcy55KSAqIGFscGhhO1xuXHRcdFx0dGhpcy56ICs9ICh2LnogLSB0aGlzLnopICogYWxwaGE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRsZXJwVmVjdG9ycyh2MSwgdjIsIGFscGhhKSB7XG5cdFx0XHR0aGlzLnggPSB2MS54ICsgKHYyLnggLSB2MS54KSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ID0gdjEueSArICh2Mi55IC0gdjEueSkgKiBhbHBoYTtcblx0XHRcdHRoaXMueiA9IHYxLnogKyAodjIueiAtIHYxLnopICogYWxwaGE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjcm9zcyh2LCB3KSB7XG5cdFx0XHRpZiAodyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKHYsIHcpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnModGhpcywgdik7XG5cdFx0fVxuXG5cdFx0Y3Jvc3NWZWN0b3JzKGEsIGIpIHtcblx0XHRcdGNvbnN0IGF4ID0gYS54LFxuXHRcdFx0XHRcdFx0YXkgPSBhLnksXG5cdFx0XHRcdFx0XHRheiA9IGEuejtcblx0XHRcdGNvbnN0IGJ4ID0gYi54LFxuXHRcdFx0XHRcdFx0YnkgPSBiLnksXG5cdFx0XHRcdFx0XHRieiA9IGIuejtcblx0XHRcdHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuXHRcdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHByb2plY3RPblZlY3Rvcih2KSB7XG5cdFx0XHRjb25zdCBkZW5vbWluYXRvciA9IHYubGVuZ3RoU3EoKTtcblx0XHRcdGlmIChkZW5vbWluYXRvciA9PT0gMCkgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDApO1xuXHRcdFx0Y29uc3Qgc2NhbGFyID0gdi5kb3QodGhpcykgLyBkZW5vbWluYXRvcjtcblx0XHRcdHJldHVybiB0aGlzLmNvcHkodikubXVsdGlwbHlTY2FsYXIoc2NhbGFyKTtcblx0XHR9XG5cblx0XHRwcm9qZWN0T25QbGFuZShwbGFuZU5vcm1hbCkge1xuXHRcdFx0X3ZlY3RvciRjLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKHBsYW5lTm9ybWFsKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKF92ZWN0b3IkYyk7XG5cdFx0fVxuXG5cdFx0cmVmbGVjdChub3JtYWwpIHtcblx0XHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxuXHRcdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKF92ZWN0b3IkYy5jb3B5KG5vcm1hbCkubXVsdGlwbHlTY2FsYXIoMiAqIHRoaXMuZG90KG5vcm1hbCkpKTtcblx0XHR9XG5cblx0XHRhbmdsZVRvKHYpIHtcblx0XHRcdGNvbnN0IGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSk7XG5cdFx0XHRpZiAoZGVub21pbmF0b3IgPT09IDApIHJldHVybiBNYXRoLlBJIC8gMjtcblx0XHRcdGNvbnN0IHRoZXRhID0gdGhpcy5kb3QodikgLyBkZW5vbWluYXRvcjsgLy8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdFx0cmV0dXJuIE1hdGguYWNvcyhjbGFtcCh0aGV0YSwgLTEsIDEpKTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVRvKHYpIHtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh2KSk7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2VUb1NxdWFyZWQodikge1xuXHRcdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsXG5cdFx0XHRcdFx0XHRkeSA9IHRoaXMueSAtIHYueSxcblx0XHRcdFx0XHRcdGR6ID0gdGhpcy56IC0gdi56O1xuXHRcdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblx0XHR9XG5cblx0XHRtYW5oYXR0YW5EaXN0YW5jZVRvKHYpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyh0aGlzLnggLSB2LngpICsgTWF0aC5hYnModGhpcy55IC0gdi55KSArIE1hdGguYWJzKHRoaXMueiAtIHYueik7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbVNwaGVyaWNhbChzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKHMucmFkaXVzLCBzLnBoaSwgcy50aGV0YSk7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbVNwaGVyaWNhbENvb3JkcyhyYWRpdXMsIHBoaSwgdGhldGEpIHtcblx0XHRcdGNvbnN0IHNpblBoaVJhZGl1cyA9IE1hdGguc2luKHBoaSkgKiByYWRpdXM7XG5cdFx0XHR0aGlzLnggPSBzaW5QaGlSYWRpdXMgKiBNYXRoLnNpbih0aGV0YSk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmNvcyhwaGkpICogcmFkaXVzO1xuXHRcdFx0dGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3ModGhldGEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbUN5bGluZHJpY2FsKGMpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21DeWxpbmRyaWNhbENvb3JkcyhjLnJhZGl1cywgYy50aGV0YSwgYy55KTtcblx0XHR9XG5cblx0XHRzZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMocmFkaXVzLCB0aGV0YSwgeSkge1xuXHRcdFx0dGhpcy54ID0gcmFkaXVzICogTWF0aC5zaW4odGhldGEpO1xuXHRcdFx0dGhpcy55ID0geTtcblx0XHRcdHRoaXMueiA9IHJhZGl1cyAqIE1hdGguY29zKHRoZXRhKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21NYXRyaXhQb3NpdGlvbihtKSB7XG5cdFx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblx0XHRcdHRoaXMueCA9IGVbMTJdO1xuXHRcdFx0dGhpcy55ID0gZVsxM107XG5cdFx0XHR0aGlzLnogPSBlWzE0XTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21NYXRyaXhTY2FsZShtKSB7XG5cdFx0XHRjb25zdCBzeCA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAwKS5sZW5ndGgoKTtcblx0XHRcdGNvbnN0IHN5ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDEpLmxlbmd0aCgpO1xuXHRcdFx0Y29uc3Qgc3ogPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4obSwgMikubGVuZ3RoKCk7XG5cdFx0XHR0aGlzLnggPSBzeDtcblx0XHRcdHRoaXMueSA9IHN5O1xuXHRcdFx0dGhpcy56ID0gc3o7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tTWF0cml4Q29sdW1uKG0sIGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkobS5lbGVtZW50cywgaW5kZXggKiA0KTtcblx0XHR9XG5cblx0XHRzZXRGcm9tTWF0cml4M0NvbHVtbihtLCBpbmRleCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KG0uZWxlbWVudHMsIGluZGV4ICogMyk7XG5cdFx0fVxuXG5cdFx0ZXF1YWxzKHYpIHtcblx0XHRcdHJldHVybiB2LnggPT09IHRoaXMueCAmJiB2LnkgPT09IHRoaXMueSAmJiB2LnogPT09IHRoaXMuejtcblx0XHR9XG5cblx0XHRmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcblx0XHRcdHRoaXMueCA9IGFycmF5W29mZnNldF07XG5cdFx0XHR0aGlzLnkgPSBhcnJheVtvZmZzZXQgKyAxXTtcblx0XHRcdHRoaXMueiA9IGFycmF5W29mZnNldCArIDJdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG5cdFx0XHRhcnJheVtvZmZzZXRdID0gdGhpcy54O1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzLnk7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAyXSA9IHRoaXMuejtcblx0XHRcdHJldHVybiBhcnJheTtcblx0XHR9XG5cblx0XHRmcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCkge1xuXHRcdFx0aWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WChpbmRleCk7XG5cdFx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WShpbmRleCk7XG5cdFx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WihpbmRleCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyYW5kb20oKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHRcdHRoaXMueiA9IE1hdGgucmFuZG9tKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFZlY3RvcjMucHJvdG90eXBlLmlzVmVjdG9yMyA9IHRydWU7XG5cblx0Y29uc3QgX3ZlY3RvciRjID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3F1YXRlcm5pb24kNCA9IC8qQF9fUFVSRV9fKi9uZXcgUXVhdGVybmlvbigpO1xuXG5cdGNsYXNzIEJveDMge1xuXHRcdGNvbnN0cnVjdG9yKG1pbiA9IG5ldyBWZWN0b3IzKCtJbmZpbml0eSwgK0luZmluaXR5LCArSW5maW5pdHkpLCBtYXggPSBuZXcgVmVjdG9yMygtSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5KSkge1xuXHRcdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0XHR0aGlzLm1heCA9IG1heDtcblx0XHR9XG5cblx0XHRzZXQobWluLCBtYXgpIHtcblx0XHRcdHRoaXMubWluLmNvcHkobWluKTtcblx0XHRcdHRoaXMubWF4LmNvcHkobWF4KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21BcnJheShhcnJheSkge1xuXHRcdFx0bGV0IG1pblggPSArSW5maW5pdHk7XG5cdFx0XHRsZXQgbWluWSA9ICtJbmZpbml0eTtcblx0XHRcdGxldCBtaW5aID0gK0luZmluaXR5O1xuXHRcdFx0bGV0IG1heFggPSAtSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4WSA9IC1JbmZpbml0eTtcblx0XHRcdGxldCBtYXhaID0gLUluZmluaXR5O1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHRjb25zdCB4ID0gYXJyYXlbaV07XG5cdFx0XHRcdGNvbnN0IHkgPSBhcnJheVtpICsgMV07XG5cdFx0XHRcdGNvbnN0IHogPSBhcnJheVtpICsgMl07XG5cdFx0XHRcdGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG5cdFx0XHRcdGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG5cdFx0XHRcdGlmICh6IDwgbWluWikgbWluWiA9IHo7XG5cdFx0XHRcdGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG5cdFx0XHRcdGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG5cdFx0XHRcdGlmICh6ID4gbWF4WikgbWF4WiA9IHo7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWluLnNldChtaW5YLCBtaW5ZLCBtaW5aKTtcblx0XHRcdHRoaXMubWF4LnNldChtYXhYLCBtYXhZLCBtYXhaKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG5cdFx0XHRsZXQgbWluWCA9ICtJbmZpbml0eTtcblx0XHRcdGxldCBtaW5ZID0gK0luZmluaXR5O1xuXHRcdFx0bGV0IG1pblogPSArSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4WCA9IC1JbmZpbml0eTtcblx0XHRcdGxldCBtYXhZID0gLUluZmluaXR5O1xuXHRcdFx0bGV0IG1heFogPSAtSW5maW5pdHk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHggPSBhdHRyaWJ1dGUuZ2V0WChpKTtcblx0XHRcdFx0Y29uc3QgeSA9IGF0dHJpYnV0ZS5nZXRZKGkpO1xuXHRcdFx0XHRjb25zdCB6ID0gYXR0cmlidXRlLmdldFooaSk7XG5cdFx0XHRcdGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG5cdFx0XHRcdGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG5cdFx0XHRcdGlmICh6IDwgbWluWikgbWluWiA9IHo7XG5cdFx0XHRcdGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG5cdFx0XHRcdGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG5cdFx0XHRcdGlmICh6ID4gbWF4WikgbWF4WiA9IHo7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWluLnNldChtaW5YLCBtaW5ZLCBtaW5aKTtcblx0XHRcdHRoaXMubWF4LnNldChtYXhYLCBtYXhZLCBtYXhaKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHMocG9pbnRzKSB7XG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQocG9pbnRzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBzaXplKSB7XG5cdFx0XHRjb25zdCBoYWxmU2l6ZSA9IF92ZWN0b3IkYi5jb3B5KHNpemUpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoY2VudGVyKS5zdWIoaGFsZlNpemUpO1xuXHRcdFx0dGhpcy5tYXguY29weShjZW50ZXIpLmFkZChoYWxmU2l6ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tT2JqZWN0KG9iamVjdCkge1xuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcblx0XHRcdHJldHVybiB0aGlzLmV4cGFuZEJ5T2JqZWN0KG9iamVjdCk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHRcdGNvcHkoYm94KSB7XG5cdFx0XHR0aGlzLm1pbi5jb3B5KGJveC5taW4pO1xuXHRcdFx0dGhpcy5tYXguY29weShib3gubWF4KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1ha2VFbXB0eSgpIHtcblx0XHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9ICtJbmZpbml0eTtcblx0XHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC1JbmZpbml0eTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlzRW1wdHkoKSB7XG5cdFx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXHRcdFx0cmV0dXJuIHRoaXMubWF4LnggPCB0aGlzLm1pbi54IHx8IHRoaXMubWF4LnkgPCB0aGlzLm1pbi55IHx8IHRoaXMubWF4LnogPCB0aGlzLm1pbi56O1xuXHRcdH1cblxuXHRcdGdldENlbnRlcih0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoMCwgMCwgMCkgOiB0YXJnZXQuYWRkVmVjdG9ycyh0aGlzLm1pbiwgdGhpcy5tYXgpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cdFx0fVxuXG5cdFx0Z2V0U2l6ZSh0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoMCwgMCwgMCkgOiB0YXJnZXQuc3ViVmVjdG9ycyh0aGlzLm1heCwgdGhpcy5taW4pO1xuXHRcdH1cblxuXHRcdGV4cGFuZEJ5UG9pbnQocG9pbnQpIHtcblx0XHRcdHRoaXMubWluLm1pbihwb2ludCk7XG5cdFx0XHR0aGlzLm1heC5tYXgocG9pbnQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXhwYW5kQnlWZWN0b3IodmVjdG9yKSB7XG5cdFx0XHR0aGlzLm1pbi5zdWIodmVjdG9yKTtcblx0XHRcdHRoaXMubWF4LmFkZCh2ZWN0b3IpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXhwYW5kQnlTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoLXNjYWxhcik7XG5cdFx0XHR0aGlzLm1heC5hZGRTY2FsYXIoc2NhbGFyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGV4cGFuZEJ5T2JqZWN0KG9iamVjdCkge1xuXHRcdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcblx0XHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xuXHRcdFx0b2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0aWYgKGdlb21ldHJ5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfYm94JDMuY29weShnZW9tZXRyeS5ib3VuZGluZ0JveCk7XG5cblx0XHRcdFx0X2JveCQzLmFwcGx5TWF0cml4NChvYmplY3QubWF0cml4V29ybGQpO1xuXG5cdFx0XHRcdHRoaXMudW5pb24oX2JveCQzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuZXhwYW5kQnlPYmplY3QoY2hpbGRyZW5baV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb250YWluc1BvaW50KHBvaW50KSB7XG5cdFx0XHRyZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHwgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHwgcG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnNCb3goYm94KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiYgdGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiYgdGhpcy5taW4ueiA8PSBib3gubWluLnogJiYgYm94Lm1heC56IDw9IHRoaXMubWF4Lno7XG5cdFx0fVxuXG5cdFx0Z2V0UGFyYW1ldGVyKHBvaW50LCB0YXJnZXQpIHtcblx0XHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG5cdFx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoKHBvaW50LnggLSB0aGlzLm1pbi54KSAvICh0aGlzLm1heC54IC0gdGhpcy5taW4ueCksIChwb2ludC55IC0gdGhpcy5taW4ueSkgLyAodGhpcy5tYXgueSAtIHRoaXMubWluLnkpLCAocG9pbnQueiAtIHRoaXMubWluLnopIC8gKHRoaXMubWF4LnogLSB0aGlzLm1pbi56KSk7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c0JveChib3gpIHtcblx0XHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXHRcdFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHwgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSB7XG5cdFx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxuXHRcdFx0dGhpcy5jbGFtcFBvaW50KHNwaGVyZS5jZW50ZXIsIF92ZWN0b3IkYik7IC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxuXG5cdFx0XHRyZXR1cm4gX3ZlY3RvciRiLmRpc3RhbmNlVG9TcXVhcmVkKHNwaGVyZS5jZW50ZXIpIDw9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNQbGFuZShwbGFuZSkge1xuXHRcdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdFx0Ly8gYXJlIG9uIHRoZSBzYW1lIHNpZGUgKGJhY2sgb3IgZnJvbnQpIG9mIHRoZSBwbGFuZSwgdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cdFx0XHRsZXQgbWluLCBtYXg7XG5cblx0XHRcdGlmIChwbGFuZS5ub3JtYWwueCA+IDApIHtcblx0XHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54O1xuXHRcdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWF4Lng7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWF4Lng7XG5cdFx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBsYW5lLm5vcm1hbC55ID4gMCkge1xuXHRcdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblx0XHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBsYW5lLm5vcm1hbC56ID4gMCkge1xuXHRcdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xuXHRcdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1pbiA8PSAtcGxhbmUuY29uc3RhbnQgJiYgbWF4ID49IC1wbGFuZS5jb25zdGFudDtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzVHJpYW5nbGUodHJpYW5nbGUpIHtcblx0XHRcdGlmICh0aGlzLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IC8vIGNvbXB1dGUgYm94IGNlbnRlciBhbmQgZXh0ZW50c1xuXG5cblx0XHRcdHRoaXMuZ2V0Q2VudGVyKF9jZW50ZXIpO1xuXG5cdFx0XHRfZXh0ZW50cy5zdWJWZWN0b3JzKHRoaXMubWF4LCBfY2VudGVyKTsgLy8gdHJhbnNsYXRlIHRyaWFuZ2xlIHRvIGFhYmIgb3JpZ2luXG5cblxuXHRcdFx0X3YwJDIuc3ViVmVjdG9ycyh0cmlhbmdsZS5hLCBfY2VudGVyKTtcblxuXHRcdFx0X3YxJDcuc3ViVmVjdG9ycyh0cmlhbmdsZS5iLCBfY2VudGVyKTtcblxuXHRcdFx0X3YyJDMuc3ViVmVjdG9ycyh0cmlhbmdsZS5jLCBfY2VudGVyKTsgLy8gY29tcHV0ZSBlZGdlIHZlY3RvcnMgZm9yIHRyaWFuZ2xlXG5cblxuXHRcdFx0X2YwLnN1YlZlY3RvcnMoX3YxJDcsIF92MCQyKTtcblxuXHRcdFx0X2YxLnN1YlZlY3RvcnMoX3YyJDMsIF92MSQ3KTtcblxuXHRcdFx0X2YyLnN1YlZlY3RvcnMoX3YwJDIsIF92MiQzKTsgLy8gdGVzdCBhZ2FpbnN0IGF4ZXMgdGhhdCBhcmUgZ2l2ZW4gYnkgY3Jvc3MgcHJvZHVjdCBjb21iaW5hdGlvbnMgb2YgdGhlIGVkZ2VzIG9mIHRoZSB0cmlhbmdsZSBhbmQgdGhlIGVkZ2VzIG9mIHRoZSBhYWJiXG5cdFx0XHQvLyBtYWtlIGFuIGF4aXMgdGVzdGluZyBvZiBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSBhYWJiIGFnYWluc3QgZWFjaCBvZiB0aGUgMyBzaWRlcyBvZiB0aGUgdHJpYW5nbGUgPSA5IGF4aXMgb2Ygc2VwYXJhdGlvblxuXHRcdFx0Ly8gYXhpc19paiA9IHVfaSB4IGZfaiAodTAsIHUxLCB1MiA9IGZhY2Ugbm9ybWFscyBvZiBhYWJiID0geCx5LHogYXhlcyB2ZWN0b3JzIHNpbmNlIGFhYmIgaXMgYXhpcyBhbGlnbmVkKVxuXG5cblx0XHRcdGxldCBheGVzID0gWzAsIC1fZjAueiwgX2YwLnksIDAsIC1fZjEueiwgX2YxLnksIDAsIC1fZjIueiwgX2YyLnksIF9mMC56LCAwLCAtX2YwLngsIF9mMS56LCAwLCAtX2YxLngsIF9mMi56LCAwLCAtX2YyLngsIC1fZjAueSwgX2YwLngsIDAsIC1fZjEueSwgX2YxLngsIDAsIC1fZjIueSwgX2YyLngsIDBdO1xuXG5cdFx0XHRpZiAoIXNhdEZvckF4ZXMoYXhlcywgX3YwJDIsIF92MSQ3LCBfdjIkMywgX2V4dGVudHMpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gLy8gdGVzdCAzIGZhY2Ugbm9ybWFscyBmcm9tIHRoZSBhYWJiXG5cblxuXHRcdFx0YXhlcyA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcblxuXHRcdFx0aWYgKCFzYXRGb3JBeGVzKGF4ZXMsIF92MCQyLCBfdjEkNywgX3YyJDMsIF9leHRlbnRzKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IC8vIGZpbmFsbHkgdGVzdGluZyB0aGUgZmFjZSBub3JtYWwgb2YgdGhlIHRyaWFuZ2xlXG5cdFx0XHQvLyB1c2UgYWxyZWFkeSBleGlzdGluZyB0cmlhbmdsZSBlZGdlIHZlY3RvcnMgaGVyZVxuXG5cblx0XHRcdF90cmlhbmdsZU5vcm1hbC5jcm9zc1ZlY3RvcnMoX2YwLCBfZjEpO1xuXG5cdFx0XHRheGVzID0gW190cmlhbmdsZU5vcm1hbC54LCBfdHJpYW5nbGVOb3JtYWwueSwgX3RyaWFuZ2xlTm9ybWFsLnpdO1xuXHRcdFx0cmV0dXJuIHNhdEZvckF4ZXMoYXhlcywgX3YwJDIsIF92MSQ3LCBfdjIkMywgX2V4dGVudHMpO1xuXHRcdH1cblxuXHRcdGNsYW1wUG9pbnQocG9pbnQsIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KHBvaW50KS5jbGFtcCh0aGlzLm1pbiwgdGhpcy5tYXgpO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlVG9Qb2ludChwb2ludCkge1xuXHRcdFx0Y29uc3QgY2xhbXBlZFBvaW50ID0gX3ZlY3RvciRiLmNvcHkocG9pbnQpLmNsYW1wKHRoaXMubWluLCB0aGlzLm1heCk7XG5cblx0XHRcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKHBvaW50KS5sZW5ndGgoKTtcblx0XHR9XG5cblx0XHRnZXRCb3VuZGluZ1NwaGVyZSh0YXJnZXQpIHtcblx0XHRcdHRoaXMuZ2V0Q2VudGVyKHRhcmdldC5jZW50ZXIpO1xuXHRcdFx0dGFyZ2V0LnJhZGl1cyA9IHRoaXMuZ2V0U2l6ZShfdmVjdG9yJGIpLmxlbmd0aCgpICogMC41O1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3QoYm94KSB7XG5cdFx0XHR0aGlzLm1pbi5tYXgoYm94Lm1pbik7XG5cdFx0XHR0aGlzLm1heC5taW4oYm94Lm1heCk7IC8vIGVuc3VyZSB0aGF0IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAsIHRoZSByZXN1bHQgaXMgZnVsbHkgZW1wdHksIG5vdCBzbGlnaHRseSBlbXB0eSB3aXRoIG5vbi1pbmYvK2luZiB2YWx1ZXMgdGhhdCB3aWxsIGNhdXNlIHN1YnNlcXVlbmNlIGludGVyc2VjdHMgdG8gZXJyb25lb3VzbHkgcmV0dXJuIHZhbGlkIHZhbHVlcy5cblxuXHRcdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB0aGlzLm1ha2VFbXB0eSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dW5pb24oYm94KSB7XG5cdFx0XHR0aGlzLm1pbi5taW4oYm94Lm1pbik7XG5cdFx0XHR0aGlzLm1heC5tYXgoYm94Lm1heCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDQobWF0cml4KSB7XG5cdFx0XHQvLyB0cmFuc2Zvcm0gb2YgZW1wdHkgYm94IGlzIGFuIGVtcHR5IGJveC5cblx0XHRcdGlmICh0aGlzLmlzRW1wdHkoKSkgcmV0dXJuIHRoaXM7IC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG5cblx0XHRcdF9wb2ludHNbMF0uc2V0KHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAwMDBcblxuXG5cdFx0XHRfcG9pbnRzWzFdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMDAxXG5cblxuXHRcdFx0X3BvaW50c1syXS5zZXQodGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDAxMFxuXG5cblx0XHRcdF9wb2ludHNbM10uc2V0KHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAwMTFcblxuXG5cdFx0XHRfcG9pbnRzWzRdLnNldCh0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMTAwXG5cblxuXHRcdFx0X3BvaW50c1s1XS5zZXQodGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDEwMVxuXG5cblx0XHRcdF9wb2ludHNbNl0uc2V0KHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAxMTBcblxuXG5cdFx0XHRfcG9pbnRzWzddLnNldCh0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMTExXG5cblxuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKF9wb2ludHMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dHJhbnNsYXRlKG9mZnNldCkge1xuXHRcdFx0dGhpcy5taW4uYWRkKG9mZnNldCk7XG5cdFx0XHR0aGlzLm1heC5hZGQob2Zmc2V0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyhib3gpIHtcblx0XHRcdHJldHVybiBib3gubWluLmVxdWFscyh0aGlzLm1pbikgJiYgYm94Lm1heC5lcXVhbHModGhpcy5tYXgpO1xuXHRcdH1cblxuXHR9XG5cblx0Qm94My5wcm90b3R5cGUuaXNCb3gzID0gdHJ1ZTtcblx0Y29uc3QgX3BvaW50cyA9IFsvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCldO1xuXG5cdGNvbnN0IF92ZWN0b3IkYiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9ib3gkMyA9IC8qQF9fUFVSRV9fKi9uZXcgQm94MygpOyAvLyB0cmlhbmdsZSBjZW50ZXJlZCB2ZXJ0aWNlc1xuXG5cblx0Y29uc3QgX3YwJDIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdjEkNyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92MiQzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7IC8vIHRyaWFuZ2xlIGVkZ2UgdmVjdG9yc1xuXG5cblx0Y29uc3QgX2YwID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2YxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2YyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2NlbnRlciA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9leHRlbnRzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3RyaWFuZ2xlTm9ybWFsID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3Rlc3RBeGlzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0ZnVuY3Rpb24gc2F0Rm9yQXhlcyhheGVzLCB2MCwgdjEsIHYyLCBleHRlbnRzKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGogPSBheGVzLmxlbmd0aCAtIDM7IGkgPD0gajsgaSArPSAzKSB7XG5cdFx0XHRfdGVzdEF4aXMuZnJvbUFycmF5KGF4ZXMsIGkpOyAvLyBwcm9qZWN0IHRoZSBhYWJiIG9udG8gdGhlIHNlcGVyYXRpbmcgYXhpc1xuXG5cblx0XHRcdGNvbnN0IHIgPSBleHRlbnRzLnggKiBNYXRoLmFicyhfdGVzdEF4aXMueCkgKyBleHRlbnRzLnkgKiBNYXRoLmFicyhfdGVzdEF4aXMueSkgKyBleHRlbnRzLnogKiBNYXRoLmFicyhfdGVzdEF4aXMueik7IC8vIHByb2plY3QgYWxsIDMgdmVydGljZXMgb2YgdGhlIHRyaWFuZ2xlIG9udG8gdGhlIHNlcGVyYXRpbmcgYXhpc1xuXG5cdFx0XHRjb25zdCBwMCA9IHYwLmRvdChfdGVzdEF4aXMpO1xuXHRcdFx0Y29uc3QgcDEgPSB2MS5kb3QoX3Rlc3RBeGlzKTtcblx0XHRcdGNvbnN0IHAyID0gdjIuZG90KF90ZXN0QXhpcyk7IC8vIGFjdHVhbCB0ZXN0LCBiYXNpY2FsbHkgc2VlIGlmIGVpdGhlciBvZiB0aGUgbW9zdCBleHRyZW1lIG9mIHRoZSB0cmlhbmdsZSBwb2ludHMgaW50ZXJzZWN0cyByXG5cblx0XHRcdGlmIChNYXRoLm1heCgtTWF0aC5tYXgocDAsIHAxLCBwMiksIE1hdGgubWluKHAwLCBwMSwgcDIpKSA+IHIpIHtcblx0XHRcdFx0Ly8gcG9pbnRzIG9mIHRoZSBwcm9qZWN0ZWQgdHJpYW5nbGUgYXJlIG91dHNpZGUgdGhlIHByb2plY3RlZCBoYWxmLWxlbmd0aCBvZiB0aGUgYWFiYlxuXHRcdFx0XHQvLyB0aGUgYXhpcyBpcyBzZXBlcmF0aW5nIGFuZCB3ZSBjYW4gZXhpdFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRjb25zdCBfYm94JDIgPSAvKkBfX1BVUkVfXyovbmV3IEJveDMoKTtcblxuXHRjb25zdCBfdjEkNiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF90b0ZhcnRoZXN0UG9pbnQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdG9Qb2ludCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIFNwaGVyZSB7XG5cdFx0Y29uc3RydWN0b3IoY2VudGVyID0gbmV3IFZlY3RvcjMoKSwgcmFkaXVzID0gLTEpIHtcblx0XHRcdHRoaXMuY2VudGVyID0gY2VudGVyO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0fVxuXG5cdFx0c2V0KGNlbnRlciwgcmFkaXVzKSB7XG5cdFx0XHR0aGlzLmNlbnRlci5jb3B5KGNlbnRlcik7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHMocG9pbnRzLCBvcHRpb25hbENlbnRlcikge1xuXHRcdFx0Y29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG5cblx0XHRcdGlmIChvcHRpb25hbENlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNlbnRlci5jb3B5KG9wdGlvbmFsQ2VudGVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9ib3gkMi5zZXRGcm9tUG9pbnRzKHBvaW50cykuZ2V0Q2VudGVyKGNlbnRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBtYXhSYWRpdXNTcSA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgobWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChwb2ludHNbaV0pKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQobWF4UmFkaXVzU3EpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShzcGhlcmUpIHtcblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoc3BoZXJlLmNlbnRlcik7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpc0VtcHR5KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmFkaXVzIDwgMDtcblx0XHR9XG5cblx0XHRtYWtlRW1wdHkoKSB7XG5cdFx0XHR0aGlzLmNlbnRlci5zZXQoMCwgMCwgMCk7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IC0xO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnNQb2ludChwb2ludCkge1xuXHRcdFx0cmV0dXJuIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKSA8PSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlVG9Qb2ludChwb2ludCkge1xuXHRcdFx0cmV0dXJuIHBvaW50LmRpc3RhbmNlVG8odGhpcy5jZW50ZXIpIC0gdGhpcy5yYWRpdXM7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c1NwaGVyZShzcGhlcmUpIHtcblx0XHRcdGNvbnN0IHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcblx0XHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKSA8PSByYWRpdXNTdW0gKiByYWRpdXNTdW07XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c0JveChib3gpIHtcblx0XHRcdHJldHVybiBib3guaW50ZXJzZWN0c1NwaGVyZSh0aGlzKTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzUGxhbmUocGxhbmUpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyhwbGFuZS5kaXN0YW5jZVRvUG9pbnQodGhpcy5jZW50ZXIpKSA8PSB0aGlzLnJhZGl1cztcblx0XHR9XG5cblx0XHRjbGFtcFBvaW50KHBvaW50LCB0YXJnZXQpIHtcblx0XHRcdGNvbnN0IGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChwb2ludCk7XG5cdFx0XHR0YXJnZXQuY29weShwb2ludCk7XG5cblx0XHRcdGlmIChkZWx0YUxlbmd0aFNxID4gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykge1xuXHRcdFx0XHR0YXJnZXQuc3ViKHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0dGFyZ2V0Lm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKS5hZGQodGhpcy5jZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGdldEJvdW5kaW5nQm94KHRhcmdldCkge1xuXHRcdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdC8vIEVtcHR5IHNwaGVyZSBwcm9kdWNlcyBlbXB0eSBib3VuZGluZyBib3hcblx0XHRcdFx0dGFyZ2V0Lm1ha2VFbXB0eSgpO1xuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdFx0fVxuXG5cdFx0XHR0YXJnZXQuc2V0KHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlcik7XG5cdFx0XHR0YXJnZXQuZXhwYW5kQnlTY2FsYXIodGhpcy5yYWRpdXMpO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDQobWF0cml4KSB7XG5cdFx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQobWF0cml4KTtcblx0XHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRyYW5zbGF0ZShvZmZzZXQpIHtcblx0XHRcdHRoaXMuY2VudGVyLmFkZChvZmZzZXQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXhwYW5kQnlQb2ludChwb2ludCkge1xuXHRcdFx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanVqL01hdGhHZW9MaWIvYmxvYi8yOTQwYjk5Yjk5Y2ZlNTc1ZGQ0NTEwM2VmMjBmNDAxOWRlZTE1YjU0L3NyYy9HZW9tZXRyeS9TcGhlcmUuY3BwI0w2NDktTDY3MVxuXHRcdFx0X3RvUG9pbnQuc3ViVmVjdG9ycyhwb2ludCwgdGhpcy5jZW50ZXIpO1xuXG5cdFx0XHRjb25zdCBsZW5ndGhTcSA9IF90b1BvaW50Lmxlbmd0aFNxKCk7XG5cblx0XHRcdGlmIChsZW5ndGhTcSA+IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMpIHtcblx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KGxlbmd0aFNxKTtcblx0XHRcdFx0Y29uc3QgbWlzc2luZ1JhZGl1c0hhbGYgPSAobGVuZ3RoIC0gdGhpcy5yYWRpdXMpICogMC41OyAvLyBOdWRnZSB0aGlzIHNwaGVyZSB0b3dhcmRzIHRoZSB0YXJnZXQgcG9pbnQuIEFkZCBoYWxmIHRoZSBtaXNzaW5nIGRpc3RhbmNlIHRvIHJhZGl1cyxcblx0XHRcdFx0Ly8gYW5kIHRoZSBvdGhlciBoYWxmIHRvIHBvc2l0aW9uLiBUaGlzIGdpdmVzIGEgdGlnaHRlciBlbmNsb3N1cmUsIGluc3RlYWQgb2YgaWZcblx0XHRcdFx0Ly8gdGhlIHdob2xlIG1pc3NpbmcgZGlzdGFuY2Ugd2VyZSBqdXN0IGFkZGVkIHRvIHJhZGl1cy5cblxuXHRcdFx0XHR0aGlzLmNlbnRlci5hZGQoX3RvUG9pbnQubXVsdGlwbHlTY2FsYXIobWlzc2luZ1JhZGl1c0hhbGYgLyBsZW5ndGgpKTtcblx0XHRcdFx0dGhpcy5yYWRpdXMgKz0gbWlzc2luZ1JhZGl1c0hhbGY7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHVuaW9uKHNwaGVyZSkge1xuXHRcdFx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanVqL01hdGhHZW9MaWIvYmxvYi8yOTQwYjk5Yjk5Y2ZlNTc1ZGQ0NTEwM2VmMjBmNDAxOWRlZTE1YjU0L3NyYy9HZW9tZXRyeS9TcGhlcmUuY3BwI0w3NTktTDc2OVxuXHRcdFx0Ly8gVG8gZW5jbG9zZSBhbm90aGVyIHNwaGVyZSBpbnRvIHRoaXMgc3BoZXJlLCB3ZSBvbmx5IG5lZWQgdG8gZW5jbG9zZSB0d28gcG9pbnRzOlxuXHRcdFx0Ly8gMSkgRW5jbG9zZSB0aGUgZmFydGhlc3QgcG9pbnQgb24gdGhlIG90aGVyIHNwaGVyZSBpbnRvIHRoaXMgc3BoZXJlLlxuXHRcdFx0Ly8gMikgRW5jbG9zZSB0aGUgb3Bwb3NpdGUgcG9pbnQgb2YgdGhlIGZhcnRoZXN0IHBvaW50IGludG8gdGhpcyBzcGhlcmUuXG5cdFx0XHRfdG9GYXJ0aGVzdFBvaW50LnN1YlZlY3RvcnMoc3BoZXJlLmNlbnRlciwgdGhpcy5jZW50ZXIpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHNwaGVyZS5yYWRpdXMpO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoX3YxJDYuY29weShzcGhlcmUuY2VudGVyKS5hZGQoX3RvRmFydGhlc3RQb2ludCkpO1xuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KF92MSQ2LmNvcHkoc3BoZXJlLmNlbnRlcikuc3ViKF90b0ZhcnRoZXN0UG9pbnQpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyhzcGhlcmUpIHtcblx0XHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyh0aGlzLmNlbnRlcikgJiYgc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXM7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX3ZlY3RvciRhID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3NlZ0NlbnRlciA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9zZWdEaXIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfZGlmZiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9lZGdlMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9lZGdlMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9ub3JtYWwkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIFJheSB7XG5cdFx0Y29uc3RydWN0b3Iob3JpZ2luID0gbmV3IFZlY3RvcjMoKSwgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgLTEpKSB7XG5cdFx0XHR0aGlzLm9yaWdpbiA9IG9yaWdpbjtcblx0XHRcdHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXHRcdH1cblxuXHRcdHNldChvcmlnaW4sIGRpcmVjdGlvbikge1xuXHRcdFx0dGhpcy5vcmlnaW4uY29weShvcmlnaW4pO1xuXHRcdFx0dGhpcy5kaXJlY3Rpb24uY29weShkaXJlY3Rpb24pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShyYXkpIHtcblx0XHRcdHRoaXMub3JpZ2luLmNvcHkocmF5Lm9yaWdpbik7XG5cdFx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KHJheS5kaXJlY3Rpb24pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YXQodCwgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLm9yaWdpbik7XG5cdFx0fVxuXG5cdFx0bG9va0F0KHYpIHtcblx0XHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkodikuc3ViKHRoaXMub3JpZ2luKS5ub3JtYWxpemUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJlY2FzdCh0KSB7XG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KHRoaXMuYXQodCwgX3ZlY3RvciRhKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50KHBvaW50LCB0YXJnZXQpIHtcblx0XHRcdHRhcmdldC5zdWJWZWN0b3JzKHBvaW50LCB0aGlzLm9yaWdpbik7XG5cdFx0XHRjb25zdCBkaXJlY3Rpb25EaXN0YW5jZSA9IHRhcmdldC5kb3QodGhpcy5kaXJlY3Rpb24pO1xuXG5cdFx0XHRpZiAoZGlyZWN0aW9uRGlzdGFuY2UgPCAwKSB7XG5cdFx0XHRcdHJldHVybiB0YXJnZXQuY29weSh0aGlzLm9yaWdpbik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0YXJnZXQuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoZGlyZWN0aW9uRGlzdGFuY2UpLmFkZCh0aGlzLm9yaWdpbik7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2VUb1BvaW50KHBvaW50KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQocG9pbnQpKTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVNxVG9Qb2ludChwb2ludCkge1xuXHRcdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSBfdmVjdG9yJGEuc3ViVmVjdG9ycyhwb2ludCwgdGhpcy5vcmlnaW4pLmRvdCh0aGlzLmRpcmVjdGlvbik7IC8vIHBvaW50IGJlaGluZCB0aGUgcmF5XG5cblxuXHRcdFx0aWYgKGRpcmVjdGlvbkRpc3RhbmNlIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQocG9pbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRfdmVjdG9yJGEuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoZGlyZWN0aW9uRGlzdGFuY2UpLmFkZCh0aGlzLm9yaWdpbik7XG5cblx0XHRcdHJldHVybiBfdmVjdG9yJGEuZGlzdGFuY2VUb1NxdWFyZWQocG9pbnQpO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlU3FUb1NlZ21lbnQodjAsIHYxLCBvcHRpb25hbFBvaW50T25SYXksIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQpIHtcblx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVEaXN0UmF5U2VnbWVudC5oXG5cdFx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuXHRcdFx0Ly8gZGVmaW5lZCBieSB2MCBhbmQgdjFcblx0XHRcdC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XG5cdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcblx0XHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcblx0XHRcdF9zZWdDZW50ZXIuY29weSh2MCkuYWRkKHYxKS5tdWx0aXBseVNjYWxhcigwLjUpO1xuXG5cdFx0XHRfc2VnRGlyLmNvcHkodjEpLnN1Yih2MCkubm9ybWFsaXplKCk7XG5cblx0XHRcdF9kaWZmLmNvcHkodGhpcy5vcmlnaW4pLnN1Yihfc2VnQ2VudGVyKTtcblxuXHRcdFx0Y29uc3Qgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyh2MSkgKiAwLjU7XG5cdFx0XHRjb25zdCBhMDEgPSAtdGhpcy5kaXJlY3Rpb24uZG90KF9zZWdEaXIpO1xuXG5cdFx0XHRjb25zdCBiMCA9IF9kaWZmLmRvdCh0aGlzLmRpcmVjdGlvbik7XG5cblx0XHRcdGNvbnN0IGIxID0gLV9kaWZmLmRvdChfc2VnRGlyKTtcblxuXHRcdFx0Y29uc3QgYyA9IF9kaWZmLmxlbmd0aFNxKCk7XG5cblx0XHRcdGNvbnN0IGRldCA9IE1hdGguYWJzKDEgLSBhMDEgKiBhMDEpO1xuXHRcdFx0bGV0IHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xuXG5cdFx0XHRpZiAoZGV0ID4gMCkge1xuXHRcdFx0XHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXG5cdFx0XHRcdHMwID0gYTAxICogYjEgLSBiMDtcblx0XHRcdFx0czEgPSBhMDEgKiBiMCAtIGIxO1xuXHRcdFx0XHRleHREZXQgPSBzZWdFeHRlbnQgKiBkZXQ7XG5cblx0XHRcdFx0aWYgKHMwID49IDApIHtcblx0XHRcdFx0XHRpZiAoczEgPj0gLWV4dERldCkge1xuXHRcdFx0XHRcdFx0aWYgKHMxIDw9IGV4dERldCkge1xuXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMFxuXHRcdFx0XHRcdFx0XHQvLyBNaW5pbXVtIGF0IGludGVyaW9yIHBvaW50cyBvZiByYXkgYW5kIHNlZ21lbnQuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGludkRldCA9IDEgLyBkZXQ7XG5cdFx0XHRcdFx0XHRcdHMwICo9IGludkRldDtcblx0XHRcdFx0XHRcdFx0czEgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczAgKiAoczAgKyBhMDEgKiBzMSArIDIgKiBiMCkgKyBzMSAqIChhMDEgKiBzMCArIHMxICsgMiAqIGIxKSArIGM7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMVxuXHRcdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCgwLCAtKGEwMSAqIHMxICsgYjApKTtcblx0XHRcdFx0XHRcdFx0c3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoczEgKyAyICogYjEpICsgYztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDVcblx0XHRcdFx0XHRcdHMxID0gLXNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoMCwgLShhMDEgKiBzMSArIGIwKSk7XG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqIChzMSArIDIgKiBiMSkgKyBjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoczEgPD0gLWV4dERldCkge1xuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDRcblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoMCwgLSgtYTAxICogc2VnRXh0ZW50ICsgYjApKTtcblx0XHRcdFx0XHRcdHMxID0gczAgPiAwID8gLXNlZ0V4dGVudCA6IE1hdGgubWluKE1hdGgubWF4KC1zZWdFeHRlbnQsIC1iMSksIHNlZ0V4dGVudCk7XG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqIChzMSArIDIgKiBiMSkgKyBjO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoczEgPD0gZXh0RGV0KSB7XG5cdFx0XHRcdFx0XHQvLyByZWdpb24gM1xuXHRcdFx0XHRcdFx0czAgPSAwO1xuXHRcdFx0XHRcdFx0czEgPSBNYXRoLm1pbihNYXRoLm1heCgtc2VnRXh0ZW50LCAtYjEpLCBzZWdFeHRlbnQpO1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IHMxICogKHMxICsgMiAqIGIxKSArIGM7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAyXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KDAsIC0oYTAxICogc2VnRXh0ZW50ICsgYjApKTtcblx0XHRcdFx0XHRcdHMxID0gczAgPiAwID8gc2VnRXh0ZW50IDogTWF0aC5taW4oTWF0aC5tYXgoLXNlZ0V4dGVudCwgLWIxKSwgc2VnRXh0ZW50KTtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtczAgKiBzMCArIHMxICogKHMxICsgMiAqIGIxKSArIGM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxuXHRcdFx0XHRzMSA9IGEwMSA+IDAgPyAtc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xuXHRcdFx0XHRzMCA9IE1hdGgubWF4KDAsIC0oYTAxICogczEgKyBiMCkpO1xuXHRcdFx0XHRzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqIChzMSArIDIgKiBiMSkgKyBjO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9uYWxQb2ludE9uUmF5KSB7XG5cdFx0XHRcdG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihzMCkuYWRkKHRoaXMub3JpZ2luKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbmFsUG9pbnRPblNlZ21lbnQpIHtcblx0XHRcdFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KF9zZWdEaXIpLm11bHRpcGx5U2NhbGFyKHMxKS5hZGQoX3NlZ0NlbnRlcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzcXJEaXN0O1xuXHRcdH1cblxuXHRcdGludGVyc2VjdFNwaGVyZShzcGhlcmUsIHRhcmdldCkge1xuXHRcdFx0X3ZlY3RvciRhLnN1YlZlY3RvcnMoc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4pO1xuXG5cdFx0XHRjb25zdCB0Y2EgPSBfdmVjdG9yJGEuZG90KHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdFx0Y29uc3QgZDIgPSBfdmVjdG9yJGEuZG90KF92ZWN0b3IkYSkgLSB0Y2EgKiB0Y2E7XG5cdFx0XHRjb25zdCByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cdFx0XHRpZiAoZDIgPiByYWRpdXMyKSByZXR1cm4gbnVsbDtcblx0XHRcdGNvbnN0IHRoYyA9IE1hdGguc3FydChyYWRpdXMyIC0gZDIpOyAvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuXG5cdFx0XHRjb25zdCB0MCA9IHRjYSAtIHRoYzsgLy8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxuXG5cdFx0XHRjb25zdCB0MSA9IHRjYSArIHRoYzsgLy8gdGVzdCB0byBzZWUgaWYgYm90aCB0MCBhbmQgdDEgYXJlIGJlaGluZCB0aGUgcmF5IC0gaWYgc28sIHJldHVybiBudWxsXG5cblx0XHRcdGlmICh0MCA8IDAgJiYgdDEgPCAwKSByZXR1cm4gbnVsbDsgLy8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XG5cdFx0XHQvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXG5cdFx0XHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXG5cblx0XHRcdGlmICh0MCA8IDApIHJldHVybiB0aGlzLmF0KHQxLCB0YXJnZXQpOyAvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxuXG5cdFx0XHRyZXR1cm4gdGhpcy5hdCh0MCwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoc3BoZXJlLmNlbnRlcikgPD0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2VUb1BsYW5lKHBsYW5lKSB7XG5cdFx0XHRjb25zdCBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pO1xuXG5cdFx0XHRpZiAoZGVub21pbmF0b3IgPT09IDApIHtcblx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0XHRpZiAocGxhbmUuZGlzdGFuY2VUb1BvaW50KHRoaXMub3JpZ2luKSA9PT0gMCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9IC8vIE51bGwgaXMgcHJlZmVyYWJsZSB0byB1bmRlZmluZWQgc2luY2UgdW5kZWZpbmVkIG1lYW5zLi4uLiBpdCBpcyB1bmRlZmluZWRcblxuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0ID0gLSh0aGlzLm9yaWdpbi5kb3QocGxhbmUubm9ybWFsKSArIHBsYW5lLmNvbnN0YW50KSAvIGRlbm9taW5hdG9yOyAvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxuXG5cdFx0XHRyZXR1cm4gdCA+PSAwID8gdCA6IG51bGw7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0UGxhbmUocGxhbmUsIHRhcmdldCkge1xuXHRcdFx0Y29uc3QgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKHBsYW5lKTtcblxuXHRcdFx0aWYgKHQgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmF0KHQsIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c1BsYW5lKHBsYW5lKSB7XG5cdFx0XHQvLyBjaGVjayBpZiB0aGUgcmF5IGxpZXMgb24gdGhlIHBsYW5lIGZpcnN0XG5cdFx0XHRjb25zdCBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbik7XG5cblx0XHRcdGlmIChkaXN0VG9Qb2ludCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdFx0aWYgKGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSAvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXG5cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdEJveChib3gsIHRhcmdldCkge1xuXHRcdFx0bGV0IHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xuXHRcdFx0Y29uc3QgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxuXHRcdFx0XHRcdFx0aW52ZGlyeSA9IDEgLyB0aGlzLmRpcmVjdGlvbi55LFxuXHRcdFx0XHRcdFx0aW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xuXHRcdFx0Y29uc3Qgb3JpZ2luID0gdGhpcy5vcmlnaW47XG5cblx0XHRcdGlmIChpbnZkaXJ4ID49IDApIHtcblx0XHRcdFx0dG1pbiA9IChib3gubWluLnggLSBvcmlnaW4ueCkgKiBpbnZkaXJ4O1xuXHRcdFx0XHR0bWF4ID0gKGJveC5tYXgueCAtIG9yaWdpbi54KSAqIGludmRpcng7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bWluID0gKGJveC5tYXgueCAtIG9yaWdpbi54KSAqIGludmRpcng7XG5cdFx0XHRcdHRtYXggPSAoYm94Lm1pbi54IC0gb3JpZ2luLngpICogaW52ZGlyeDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGludmRpcnkgPj0gMCkge1xuXHRcdFx0XHR0eW1pbiA9IChib3gubWluLnkgLSBvcmlnaW4ueSkgKiBpbnZkaXJ5O1xuXHRcdFx0XHR0eW1heCA9IChib3gubWF4LnkgLSBvcmlnaW4ueSkgKiBpbnZkaXJ5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHltaW4gPSAoYm94Lm1heC55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcblx0XHRcdFx0dHltYXggPSAoYm94Lm1pbi55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRtaW4gPiB0eW1heCB8fCB0eW1pbiA+IHRtYXgpIHJldHVybiBudWxsOyAvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXG5cdFx0XHQvLyAocmVzdWx0IG9mIDAgKiBJbmZpbml0eSkuIHggIT09IHggcmV0dXJucyB0cnVlIGlmIHggaXMgTmFOXG5cblx0XHRcdGlmICh0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbikgdG1pbiA9IHR5bWluO1xuXHRcdFx0aWYgKHR5bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4KSB0bWF4ID0gdHltYXg7XG5cblx0XHRcdGlmIChpbnZkaXJ6ID49IDApIHtcblx0XHRcdFx0dHptaW4gPSAoYm94Lm1pbi56IC0gb3JpZ2luLnopICogaW52ZGlyejtcblx0XHRcdFx0dHptYXggPSAoYm94Lm1heC56IC0gb3JpZ2luLnopICogaW52ZGlyejtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR6bWluID0gKGJveC5tYXgueiAtIG9yaWdpbi56KSAqIGludmRpcno7XG5cdFx0XHRcdHR6bWF4ID0gKGJveC5taW4ueiAtIG9yaWdpbi56KSAqIGludmRpcno7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0bWluID4gdHptYXggfHwgdHptaW4gPiB0bWF4KSByZXR1cm4gbnVsbDtcblx0XHRcdGlmICh0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbikgdG1pbiA9IHR6bWluO1xuXHRcdFx0aWYgKHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4KSB0bWF4ID0gdHptYXg7IC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcblxuXHRcdFx0aWYgKHRtYXggPCAwKSByZXR1cm4gbnVsbDtcblx0XHRcdHJldHVybiB0aGlzLmF0KHRtaW4gPj0gMCA/IHRtaW4gOiB0bWF4LCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goYm94LCBfdmVjdG9yJGEpICE9PSBudWxsO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdFRyaWFuZ2xlKGEsIGIsIGMsIGJhY2tmYWNlQ3VsbGluZywgdGFyZ2V0KSB7XG5cdFx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cblx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXG5cdFx0XHRfZWRnZTEuc3ViVmVjdG9ycyhiLCBhKTtcblxuXHRcdFx0X2VkZ2UyLnN1YlZlY3RvcnMoYywgYSk7XG5cblx0XHRcdF9ub3JtYWwkMS5jcm9zc1ZlY3RvcnMoX2VkZ2UxLCBfZWRnZTIpOyAvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcblx0XHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcblx0XHRcdC8vXHQgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuXHRcdFx0Ly9cdCB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXG5cdFx0XHQvL1x0IHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuXG5cblx0XHRcdGxldCBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoX25vcm1hbCQxKTtcblx0XHRcdGxldCBzaWduO1xuXG5cdFx0XHRpZiAoRGROID4gMCkge1xuXHRcdFx0XHRpZiAoYmFja2ZhY2VDdWxsaW5nKSByZXR1cm4gbnVsbDtcblx0XHRcdFx0c2lnbiA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKERkTiA8IDApIHtcblx0XHRcdFx0c2lnbiA9IC0xO1xuXHRcdFx0XHREZE4gPSAtRGROO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdF9kaWZmLnN1YlZlY3RvcnModGhpcy5vcmlnaW4sIGEpO1xuXG5cdFx0XHRjb25zdCBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KF9lZGdlMi5jcm9zc1ZlY3RvcnMoX2RpZmYsIF9lZGdlMikpOyAvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxuXG5cdFx0XHRpZiAoRGRReEUyIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdChfZWRnZTEuY3Jvc3MoX2RpZmYpKTsgLy8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cblxuXHRcdFx0aWYgKERkRTF4USA8IDApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXG5cblxuXHRcdFx0aWYgKERkUXhFMiArIERkRTF4USA+IERkTikge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gLy8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cblxuXG5cdFx0XHRjb25zdCBRZE4gPSAtc2lnbiAqIF9kaWZmLmRvdChfbm9ybWFsJDEpOyAvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXG5cblxuXHRcdFx0aWYgKFFkTiA8IDApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxuXG5cblx0XHRcdHJldHVybiB0aGlzLmF0KFFkTiAvIERkTiwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDQobWF0cml4NCkge1xuXHRcdFx0dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KG1hdHJpeDQpO1xuXHRcdFx0dGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKG1hdHJpeDQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXF1YWxzKHJheSkge1xuXHRcdFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKHRoaXMub3JpZ2luKSAmJiByYXkuZGlyZWN0aW9uLmVxdWFscyh0aGlzLmRpcmVjdGlvbik7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgTWF0cml4NCB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRzID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXQobjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0KSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHR0ZVswXSA9IG4xMTtcblx0XHRcdHRlWzRdID0gbjEyO1xuXHRcdFx0dGVbOF0gPSBuMTM7XG5cdFx0XHR0ZVsxMl0gPSBuMTQ7XG5cdFx0XHR0ZVsxXSA9IG4yMTtcblx0XHRcdHRlWzVdID0gbjIyO1xuXHRcdFx0dGVbOV0gPSBuMjM7XG5cdFx0XHR0ZVsxM10gPSBuMjQ7XG5cdFx0XHR0ZVsyXSA9IG4zMTtcblx0XHRcdHRlWzZdID0gbjMyO1xuXHRcdFx0dGVbMTBdID0gbjMzO1xuXHRcdFx0dGVbMTRdID0gbjM0O1xuXHRcdFx0dGVbM10gPSBuNDE7XG5cdFx0XHR0ZVs3XSA9IG40Mjtcblx0XHRcdHRlWzExXSA9IG40Mztcblx0XHRcdHRlWzE1XSA9IG40NDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlkZW50aXR5KCkge1xuXHRcdFx0dGhpcy5zZXQoMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSh0aGlzLmVsZW1lbnRzKTtcblx0XHR9XG5cblx0XHRjb3B5KG0pIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblx0XHRcdHRlWzBdID0gbWVbMF07XG5cdFx0XHR0ZVsxXSA9IG1lWzFdO1xuXHRcdFx0dGVbMl0gPSBtZVsyXTtcblx0XHRcdHRlWzNdID0gbWVbM107XG5cdFx0XHR0ZVs0XSA9IG1lWzRdO1xuXHRcdFx0dGVbNV0gPSBtZVs1XTtcblx0XHRcdHRlWzZdID0gbWVbNl07XG5cdFx0XHR0ZVs3XSA9IG1lWzddO1xuXHRcdFx0dGVbOF0gPSBtZVs4XTtcblx0XHRcdHRlWzldID0gbWVbOV07XG5cdFx0XHR0ZVsxMF0gPSBtZVsxMF07XG5cdFx0XHR0ZVsxMV0gPSBtZVsxMV07XG5cdFx0XHR0ZVsxMl0gPSBtZVsxMl07XG5cdFx0XHR0ZVsxM10gPSBtZVsxM107XG5cdFx0XHR0ZVsxNF0gPSBtZVsxNF07XG5cdFx0XHR0ZVsxNV0gPSBtZVsxNV07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5UG9zaXRpb24obSkge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXHRcdFx0XHRcdFx0bWUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0dGVbMTJdID0gbWVbMTJdO1xuXHRcdFx0dGVbMTNdID0gbWVbMTNdO1xuXHRcdFx0dGVbMTRdID0gbWVbMTRdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbU1hdHJpeDMobSkge1xuXHRcdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0dGhpcy5zZXQobWVbMF0sIG1lWzNdLCBtZVs2XSwgMCwgbWVbMV0sIG1lWzRdLCBtZVs3XSwgMCwgbWVbMl0sIG1lWzVdLCBtZVs4XSwgMCwgMCwgMCwgMCwgMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRleHRyYWN0QmFzaXMoeEF4aXMsIHlBeGlzLCB6QXhpcykge1xuXHRcdFx0eEF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAwKTtcblx0XHRcdHlBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMSk7XG5cdFx0XHR6QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZUJhc2lzKHhBeGlzLCB5QXhpcywgekF4aXMpIHtcblx0XHRcdHRoaXMuc2V0KHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsIHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsIHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXh0cmFjdFJvdGF0aW9uKG0pIHtcblx0XHRcdC8vIHRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgcmVmbGVjdGlvbiBtYXRyaWNlc1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0XHRjb25zdCBzY2FsZVggPSAxIC8gX3YxJDUuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAwKS5sZW5ndGgoKTtcblxuXHRcdFx0Y29uc3Qgc2NhbGVZID0gMSAvIF92MSQ1LnNldEZyb21NYXRyaXhDb2x1bW4obSwgMSkubGVuZ3RoKCk7XG5cblx0XHRcdGNvbnN0IHNjYWxlWiA9IDEgLyBfdjEkNS5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDIpLmxlbmd0aCgpO1xuXG5cdFx0XHR0ZVswXSA9IG1lWzBdICogc2NhbGVYO1xuXHRcdFx0dGVbMV0gPSBtZVsxXSAqIHNjYWxlWDtcblx0XHRcdHRlWzJdID0gbWVbMl0gKiBzY2FsZVg7XG5cdFx0XHR0ZVszXSA9IDA7XG5cdFx0XHR0ZVs0XSA9IG1lWzRdICogc2NhbGVZO1xuXHRcdFx0dGVbNV0gPSBtZVs1XSAqIHNjYWxlWTtcblx0XHRcdHRlWzZdID0gbWVbNl0gKiBzY2FsZVk7XG5cdFx0XHR0ZVs3XSA9IDA7XG5cdFx0XHR0ZVs4XSA9IG1lWzhdICogc2NhbGVaO1xuXHRcdFx0dGVbOV0gPSBtZVs5XSAqIHNjYWxlWjtcblx0XHRcdHRlWzEwXSA9IG1lWzEwXSAqIHNjYWxlWjtcblx0XHRcdHRlWzExXSA9IDA7XG5cdFx0XHR0ZVsxMl0gPSAwO1xuXHRcdFx0dGVbMTNdID0gMDtcblx0XHRcdHRlWzE0XSA9IDA7XG5cdFx0XHR0ZVsxNV0gPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyKGV1bGVyKSB7XG5cdFx0XHRpZiAoIShldWxlciAmJiBldWxlci5pc0V1bGVyKSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRjb25zdCB4ID0gZXVsZXIueCxcblx0XHRcdFx0XHRcdHkgPSBldWxlci55LFxuXHRcdFx0XHRcdFx0eiA9IGV1bGVyLno7XG5cdFx0XHRjb25zdCBhID0gTWF0aC5jb3MoeCksXG5cdFx0XHRcdFx0XHRiID0gTWF0aC5zaW4oeCk7XG5cdFx0XHRjb25zdCBjID0gTWF0aC5jb3MoeSksXG5cdFx0XHRcdFx0XHRkID0gTWF0aC5zaW4oeSk7XG5cdFx0XHRjb25zdCBlID0gTWF0aC5jb3MoeiksXG5cdFx0XHRcdFx0XHRmID0gTWF0aC5zaW4oeik7XG5cblx0XHRcdGlmIChldWxlci5vcmRlciA9PT0gJ1hZWicpIHtcblx0XHRcdFx0Y29uc3QgYWUgPSBhICogZSxcblx0XHRcdFx0XHRcdFx0YWYgPSBhICogZixcblx0XHRcdFx0XHRcdFx0YmUgPSBiICogZSxcblx0XHRcdFx0XHRcdFx0YmYgPSBiICogZjtcblx0XHRcdFx0dGVbMF0gPSBjICogZTtcblx0XHRcdFx0dGVbNF0gPSAtYyAqIGY7XG5cdFx0XHRcdHRlWzhdID0gZDtcblx0XHRcdFx0dGVbMV0gPSBhZiArIGJlICogZDtcblx0XHRcdFx0dGVbNV0gPSBhZSAtIGJmICogZDtcblx0XHRcdFx0dGVbOV0gPSAtYiAqIGM7XG5cdFx0XHRcdHRlWzJdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHRcdHRlWzZdID0gYmUgKyBhZiAqIGQ7XG5cdFx0XHRcdHRlWzEwXSA9IGEgKiBjO1xuXHRcdFx0fSBlbHNlIGlmIChldWxlci5vcmRlciA9PT0gJ1lYWicpIHtcblx0XHRcdFx0Y29uc3QgY2UgPSBjICogZSxcblx0XHRcdFx0XHRcdFx0Y2YgPSBjICogZixcblx0XHRcdFx0XHRcdFx0ZGUgPSBkICogZSxcblx0XHRcdFx0XHRcdFx0ZGYgPSBkICogZjtcblx0XHRcdFx0dGVbMF0gPSBjZSArIGRmICogYjtcblx0XHRcdFx0dGVbNF0gPSBkZSAqIGIgLSBjZjtcblx0XHRcdFx0dGVbOF0gPSBhICogZDtcblx0XHRcdFx0dGVbMV0gPSBhICogZjtcblx0XHRcdFx0dGVbNV0gPSBhICogZTtcblx0XHRcdFx0dGVbOV0gPSAtYjtcblx0XHRcdFx0dGVbMl0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdFx0dGVbNl0gPSBkZiArIGNlICogYjtcblx0XHRcdFx0dGVbMTBdID0gYSAqIGM7XG5cdFx0XHR9IGVsc2UgaWYgKGV1bGVyLm9yZGVyID09PSAnWlhZJykge1xuXHRcdFx0XHRjb25zdCBjZSA9IGMgKiBlLFxuXHRcdFx0XHRcdFx0XHRjZiA9IGMgKiBmLFxuXHRcdFx0XHRcdFx0XHRkZSA9IGQgKiBlLFxuXHRcdFx0XHRcdFx0XHRkZiA9IGQgKiBmO1xuXHRcdFx0XHR0ZVswXSA9IGNlIC0gZGYgKiBiO1xuXHRcdFx0XHR0ZVs0XSA9IC1hICogZjtcblx0XHRcdFx0dGVbOF0gPSBkZSArIGNmICogYjtcblx0XHRcdFx0dGVbMV0gPSBjZiArIGRlICogYjtcblx0XHRcdFx0dGVbNV0gPSBhICogZTtcblx0XHRcdFx0dGVbOV0gPSBkZiAtIGNlICogYjtcblx0XHRcdFx0dGVbMl0gPSAtYSAqIGQ7XG5cdFx0XHRcdHRlWzZdID0gYjtcblx0XHRcdFx0dGVbMTBdID0gYSAqIGM7XG5cdFx0XHR9IGVsc2UgaWYgKGV1bGVyLm9yZGVyID09PSAnWllYJykge1xuXHRcdFx0XHRjb25zdCBhZSA9IGEgKiBlLFxuXHRcdFx0XHRcdFx0XHRhZiA9IGEgKiBmLFxuXHRcdFx0XHRcdFx0XHRiZSA9IGIgKiBlLFxuXHRcdFx0XHRcdFx0XHRiZiA9IGIgKiBmO1xuXHRcdFx0XHR0ZVswXSA9IGMgKiBlO1xuXHRcdFx0XHR0ZVs0XSA9IGJlICogZCAtIGFmO1xuXHRcdFx0XHR0ZVs4XSA9IGFlICogZCArIGJmO1xuXHRcdFx0XHR0ZVsxXSA9IGMgKiBmO1xuXHRcdFx0XHR0ZVs1XSA9IGJmICogZCArIGFlO1xuXHRcdFx0XHR0ZVs5XSA9IGFmICogZCAtIGJlO1xuXHRcdFx0XHR0ZVsyXSA9IC1kO1xuXHRcdFx0XHR0ZVs2XSA9IGIgKiBjO1xuXHRcdFx0XHR0ZVsxMF0gPSBhICogYztcblx0XHRcdH0gZWxzZSBpZiAoZXVsZXIub3JkZXIgPT09ICdZWlgnKSB7XG5cdFx0XHRcdGNvbnN0IGFjID0gYSAqIGMsXG5cdFx0XHRcdFx0XHRcdGFkID0gYSAqIGQsXG5cdFx0XHRcdFx0XHRcdGJjID0gYiAqIGMsXG5cdFx0XHRcdFx0XHRcdGJkID0gYiAqIGQ7XG5cdFx0XHRcdHRlWzBdID0gYyAqIGU7XG5cdFx0XHRcdHRlWzRdID0gYmQgLSBhYyAqIGY7XG5cdFx0XHRcdHRlWzhdID0gYmMgKiBmICsgYWQ7XG5cdFx0XHRcdHRlWzFdID0gZjtcblx0XHRcdFx0dGVbNV0gPSBhICogZTtcblx0XHRcdFx0dGVbOV0gPSAtYiAqIGU7XG5cdFx0XHRcdHRlWzJdID0gLWQgKiBlO1xuXHRcdFx0XHR0ZVs2XSA9IGFkICogZiArIGJjO1xuXHRcdFx0XHR0ZVsxMF0gPSBhYyAtIGJkICogZjtcblx0XHRcdH0gZWxzZSBpZiAoZXVsZXIub3JkZXIgPT09ICdYWlknKSB7XG5cdFx0XHRcdGNvbnN0IGFjID0gYSAqIGMsXG5cdFx0XHRcdFx0XHRcdGFkID0gYSAqIGQsXG5cdFx0XHRcdFx0XHRcdGJjID0gYiAqIGMsXG5cdFx0XHRcdFx0XHRcdGJkID0gYiAqIGQ7XG5cdFx0XHRcdHRlWzBdID0gYyAqIGU7XG5cdFx0XHRcdHRlWzRdID0gLWY7XG5cdFx0XHRcdHRlWzhdID0gZCAqIGU7XG5cdFx0XHRcdHRlWzFdID0gYWMgKiBmICsgYmQ7XG5cdFx0XHRcdHRlWzVdID0gYSAqIGU7XG5cdFx0XHRcdHRlWzldID0gYWQgKiBmIC0gYmM7XG5cdFx0XHRcdHRlWzJdID0gYmMgKiBmIC0gYWQ7XG5cdFx0XHRcdHRlWzZdID0gYiAqIGU7XG5cdFx0XHRcdHRlWzEwXSA9IGJkICogZiArIGFjO1xuXHRcdFx0fSAvLyBib3R0b20gcm93XG5cblxuXHRcdFx0dGVbM10gPSAwO1xuXHRcdFx0dGVbN10gPSAwO1xuXHRcdFx0dGVbMTFdID0gMDsgLy8gbGFzdCBjb2x1bW5cblxuXHRcdFx0dGVbMTJdID0gMDtcblx0XHRcdHRlWzEzXSA9IDA7XG5cdFx0XHR0ZVsxNF0gPSAwO1xuXHRcdFx0dGVbMTVdID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpIHtcblx0XHRcdHJldHVybiB0aGlzLmNvbXBvc2UoX3plcm8sIHEsIF9vbmUpO1xuXHRcdH1cblxuXHRcdGxvb2tBdChleWUsIHRhcmdldCwgdXApIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0X3ouc3ViVmVjdG9ycyhleWUsIHRhcmdldCk7XG5cblx0XHRcdGlmIChfei5sZW5ndGhTcSgpID09PSAwKSB7XG5cdFx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuXHRcdFx0XHRfei56ID0gMTtcblx0XHRcdH1cblxuXHRcdFx0X3oubm9ybWFsaXplKCk7XG5cblx0XHRcdF94LmNyb3NzVmVjdG9ycyh1cCwgX3opO1xuXG5cdFx0XHRpZiAoX3gubGVuZ3RoU3EoKSA9PT0gMCkge1xuXHRcdFx0XHQvLyB1cCBhbmQgeiBhcmUgcGFyYWxsZWxcblx0XHRcdFx0aWYgKE1hdGguYWJzKHVwLnopID09PSAxKSB7XG5cdFx0XHRcdFx0X3oueCArPSAwLjAwMDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3oueiArPSAwLjAwMDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfei5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRfeC5jcm9zc1ZlY3RvcnModXAsIF96KTtcblx0XHRcdH1cblxuXHRcdFx0X3gubm9ybWFsaXplKCk7XG5cblx0XHRcdF95LmNyb3NzVmVjdG9ycyhfeiwgX3gpO1xuXG5cdFx0XHR0ZVswXSA9IF94Lng7XG5cdFx0XHR0ZVs0XSA9IF95Lng7XG5cdFx0XHR0ZVs4XSA9IF96Lng7XG5cdFx0XHR0ZVsxXSA9IF94Lnk7XG5cdFx0XHR0ZVs1XSA9IF95Lnk7XG5cdFx0XHR0ZVs5XSA9IF96Lnk7XG5cdFx0XHR0ZVsyXSA9IF94Lno7XG5cdFx0XHR0ZVs2XSA9IF95Lno7XG5cdFx0XHR0ZVsxMF0gPSBfei56O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHkobSwgbikge1xuXHRcdFx0aWYgKG4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKG0sIG4pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsIG0pO1xuXHRcdH1cblxuXHRcdHByZW11bHRpcGx5KG0pIHtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMobSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHlNYXRyaWNlcyhhLCBiKSB7XG5cdFx0XHRjb25zdCBhZSA9IGEuZWxlbWVudHM7XG5cdFx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRjb25zdCBhMTEgPSBhZVswXSxcblx0XHRcdFx0XHRcdGExMiA9IGFlWzRdLFxuXHRcdFx0XHRcdFx0YTEzID0gYWVbOF0sXG5cdFx0XHRcdFx0XHRhMTQgPSBhZVsxMl07XG5cdFx0XHRjb25zdCBhMjEgPSBhZVsxXSxcblx0XHRcdFx0XHRcdGEyMiA9IGFlWzVdLFxuXHRcdFx0XHRcdFx0YTIzID0gYWVbOV0sXG5cdFx0XHRcdFx0XHRhMjQgPSBhZVsxM107XG5cdFx0XHRjb25zdCBhMzEgPSBhZVsyXSxcblx0XHRcdFx0XHRcdGEzMiA9IGFlWzZdLFxuXHRcdFx0XHRcdFx0YTMzID0gYWVbMTBdLFxuXHRcdFx0XHRcdFx0YTM0ID0gYWVbMTRdO1xuXHRcdFx0Y29uc3QgYTQxID0gYWVbM10sXG5cdFx0XHRcdFx0XHRhNDIgPSBhZVs3XSxcblx0XHRcdFx0XHRcdGE0MyA9IGFlWzExXSxcblx0XHRcdFx0XHRcdGE0NCA9IGFlWzE1XTtcblx0XHRcdGNvbnN0IGIxMSA9IGJlWzBdLFxuXHRcdFx0XHRcdFx0YjEyID0gYmVbNF0sXG5cdFx0XHRcdFx0XHRiMTMgPSBiZVs4XSxcblx0XHRcdFx0XHRcdGIxNCA9IGJlWzEyXTtcblx0XHRcdGNvbnN0IGIyMSA9IGJlWzFdLFxuXHRcdFx0XHRcdFx0YjIyID0gYmVbNV0sXG5cdFx0XHRcdFx0XHRiMjMgPSBiZVs5XSxcblx0XHRcdFx0XHRcdGIyNCA9IGJlWzEzXTtcblx0XHRcdGNvbnN0IGIzMSA9IGJlWzJdLFxuXHRcdFx0XHRcdFx0YjMyID0gYmVbNl0sXG5cdFx0XHRcdFx0XHRiMzMgPSBiZVsxMF0sXG5cdFx0XHRcdFx0XHRiMzQgPSBiZVsxNF07XG5cdFx0XHRjb25zdCBiNDEgPSBiZVszXSxcblx0XHRcdFx0XHRcdGI0MiA9IGJlWzddLFxuXHRcdFx0XHRcdFx0YjQzID0gYmVbMTFdLFxuXHRcdFx0XHRcdFx0YjQ0ID0gYmVbMTVdO1xuXHRcdFx0dGVbMF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XG5cdFx0XHR0ZVs0XSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0Mjtcblx0XHRcdHRlWzhdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xuXHRcdFx0dGVbMTJdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXHRcdFx0dGVbMV0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG5cdFx0XHR0ZVs1XSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0Mjtcblx0XHRcdHRlWzldID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuXHRcdFx0dGVbMTNdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xuXHRcdFx0dGVbMl0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0XHR0ZVs2XSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHRcdHRlWzEwXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHRcdHRlWzE0XSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblx0XHRcdHRlWzNdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuXHRcdFx0dGVbN10gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XG5cdFx0XHR0ZVsxMV0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XG5cdFx0XHR0ZVsxNV0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtdWx0aXBseVNjYWxhcihzKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHR0ZVswXSAqPSBzO1xuXHRcdFx0dGVbNF0gKj0gcztcblx0XHRcdHRlWzhdICo9IHM7XG5cdFx0XHR0ZVsxMl0gKj0gcztcblx0XHRcdHRlWzFdICo9IHM7XG5cdFx0XHR0ZVs1XSAqPSBzO1xuXHRcdFx0dGVbOV0gKj0gcztcblx0XHRcdHRlWzEzXSAqPSBzO1xuXHRcdFx0dGVbMl0gKj0gcztcblx0XHRcdHRlWzZdICo9IHM7XG5cdFx0XHR0ZVsxMF0gKj0gcztcblx0XHRcdHRlWzE0XSAqPSBzO1xuXHRcdFx0dGVbM10gKj0gcztcblx0XHRcdHRlWzddICo9IHM7XG5cdFx0XHR0ZVsxMV0gKj0gcztcblx0XHRcdHRlWzE1XSAqPSBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGV0ZXJtaW5hbnQoKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRjb25zdCBuMTEgPSB0ZVswXSxcblx0XHRcdFx0XHRcdG4xMiA9IHRlWzRdLFxuXHRcdFx0XHRcdFx0bjEzID0gdGVbOF0sXG5cdFx0XHRcdFx0XHRuMTQgPSB0ZVsxMl07XG5cdFx0XHRjb25zdCBuMjEgPSB0ZVsxXSxcblx0XHRcdFx0XHRcdG4yMiA9IHRlWzVdLFxuXHRcdFx0XHRcdFx0bjIzID0gdGVbOV0sXG5cdFx0XHRcdFx0XHRuMjQgPSB0ZVsxM107XG5cdFx0XHRjb25zdCBuMzEgPSB0ZVsyXSxcblx0XHRcdFx0XHRcdG4zMiA9IHRlWzZdLFxuXHRcdFx0XHRcdFx0bjMzID0gdGVbMTBdLFxuXHRcdFx0XHRcdFx0bjM0ID0gdGVbMTRdO1xuXHRcdFx0Y29uc3QgbjQxID0gdGVbM10sXG5cdFx0XHRcdFx0XHRuNDIgPSB0ZVs3XSxcblx0XHRcdFx0XHRcdG40MyA9IHRlWzExXSxcblx0XHRcdFx0XHRcdG40NCA9IHRlWzE1XTsgLy9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcblx0XHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG5cdFx0XHRyZXR1cm4gbjQxICogKCtuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQpICsgbjQyICogKCtuMTEgKiBuMjMgKiBuMzQgLSBuMTEgKiBuMjQgKiBuMzMgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEpICsgbjQzICogKCtuMTEgKiBuMjQgKiBuMzIgLSBuMTEgKiBuMjIgKiBuMzQgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgKyBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEpICsgbjQ0ICogKC1uMTMgKiBuMjIgKiBuMzEgLSBuMTEgKiBuMjMgKiBuMzIgKyBuMTEgKiBuMjIgKiBuMzMgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTIgKiBuMjMgKiBuMzEpO1xuXHRcdH1cblxuXHRcdHRyYW5zcG9zZSgpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGxldCB0bXA7XG5cdFx0XHR0bXAgPSB0ZVsxXTtcblx0XHRcdHRlWzFdID0gdGVbNF07XG5cdFx0XHR0ZVs0XSA9IHRtcDtcblx0XHRcdHRtcCA9IHRlWzJdO1xuXHRcdFx0dGVbMl0gPSB0ZVs4XTtcblx0XHRcdHRlWzhdID0gdG1wO1xuXHRcdFx0dG1wID0gdGVbNl07XG5cdFx0XHR0ZVs2XSA9IHRlWzldO1xuXHRcdFx0dGVbOV0gPSB0bXA7XG5cdFx0XHR0bXAgPSB0ZVszXTtcblx0XHRcdHRlWzNdID0gdGVbMTJdO1xuXHRcdFx0dGVbMTJdID0gdG1wO1xuXHRcdFx0dG1wID0gdGVbN107XG5cdFx0XHR0ZVs3XSA9IHRlWzEzXTtcblx0XHRcdHRlWzEzXSA9IHRtcDtcblx0XHRcdHRtcCA9IHRlWzExXTtcblx0XHRcdHRlWzExXSA9IHRlWzE0XTtcblx0XHRcdHRlWzE0XSA9IHRtcDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFBvc2l0aW9uKHgsIHksIHopIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0aWYgKHguaXNWZWN0b3IzKSB7XG5cdFx0XHRcdHRlWzEyXSA9IHgueDtcblx0XHRcdFx0dGVbMTNdID0geC55O1xuXHRcdFx0XHR0ZVsxNF0gPSB4Lno7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0ZVsxMl0gPSB4O1xuXHRcdFx0XHR0ZVsxM10gPSB5O1xuXHRcdFx0XHR0ZVsxNF0gPSB6O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpbnZlcnQoKSB7XG5cdFx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcblx0XHRcdFx0XHRcdG4xMSA9IHRlWzBdLFxuXHRcdFx0XHRcdFx0bjIxID0gdGVbMV0sXG5cdFx0XHRcdFx0XHRuMzEgPSB0ZVsyXSxcblx0XHRcdFx0XHRcdG40MSA9IHRlWzNdLFxuXHRcdFx0XHRcdFx0bjEyID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRuMjIgPSB0ZVs1XSxcblx0XHRcdFx0XHRcdG4zMiA9IHRlWzZdLFxuXHRcdFx0XHRcdFx0bjQyID0gdGVbN10sXG5cdFx0XHRcdFx0XHRuMTMgPSB0ZVs4XSxcblx0XHRcdFx0XHRcdG4yMyA9IHRlWzldLFxuXHRcdFx0XHRcdFx0bjMzID0gdGVbMTBdLFxuXHRcdFx0XHRcdFx0bjQzID0gdGVbMTFdLFxuXHRcdFx0XHRcdFx0bjE0ID0gdGVbMTJdLFxuXHRcdFx0XHRcdFx0bjI0ID0gdGVbMTNdLFxuXHRcdFx0XHRcdFx0bjM0ID0gdGVbMTRdLFxuXHRcdFx0XHRcdFx0bjQ0ID0gdGVbMTVdLFxuXHRcdFx0XHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxuXHRcdFx0XHRcdFx0dDEyID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0LFxuXHRcdFx0XHRcdFx0dDEzID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0LFxuXHRcdFx0XHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuXHRcdFx0Y29uc3QgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzICsgbjQxICogdDE0O1xuXHRcdFx0aWYgKGRldCA9PT0gMCkgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuXHRcdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcblx0XHRcdHRlWzBdID0gdDExICogZGV0SW52O1xuXHRcdFx0dGVbMV0gPSAobjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0KSAqIGRldEludjtcblx0XHRcdHRlWzJdID0gKG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCkgKiBkZXRJbnY7XG5cdFx0XHR0ZVszXSA9IChuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMpICogZGV0SW52O1xuXHRcdFx0dGVbNF0gPSB0MTIgKiBkZXRJbnY7XG5cdFx0XHR0ZVs1XSA9IChuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQpICogZGV0SW52O1xuXHRcdFx0dGVbNl0gPSAobjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0KSAqIGRldEludjtcblx0XHRcdHRlWzddID0gKG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MykgKiBkZXRJbnY7XG5cdFx0XHR0ZVs4XSA9IHQxMyAqIGRldEludjtcblx0XHRcdHRlWzldID0gKG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsxMF0gPSAobjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0KSAqIGRldEludjtcblx0XHRcdHRlWzExXSA9IChuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMpICogZGV0SW52O1xuXHRcdFx0dGVbMTJdID0gdDE0ICogZGV0SW52O1xuXHRcdFx0dGVbMTNdID0gKG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsxNF0gPSAobjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0KSAqIGRldEludjtcblx0XHRcdHRlWzE1XSA9IChuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMpICogZGV0SW52O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2NhbGUodikge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgeCA9IHYueCxcblx0XHRcdFx0XHRcdHkgPSB2LnksXG5cdFx0XHRcdFx0XHR6ID0gdi56O1xuXHRcdFx0dGVbMF0gKj0geDtcblx0XHRcdHRlWzRdICo9IHk7XG5cdFx0XHR0ZVs4XSAqPSB6O1xuXHRcdFx0dGVbMV0gKj0geDtcblx0XHRcdHRlWzVdICo9IHk7XG5cdFx0XHR0ZVs5XSAqPSB6O1xuXHRcdFx0dGVbMl0gKj0geDtcblx0XHRcdHRlWzZdICo9IHk7XG5cdFx0XHR0ZVsxMF0gKj0gejtcblx0XHRcdHRlWzNdICo9IHg7XG5cdFx0XHR0ZVs3XSAqPSB5O1xuXHRcdFx0dGVbMTFdICo9IHo7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRNYXhTY2FsZU9uQXhpcygpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IHNjYWxlWFNxID0gdGVbMF0gKiB0ZVswXSArIHRlWzFdICogdGVbMV0gKyB0ZVsyXSAqIHRlWzJdO1xuXHRcdFx0Y29uc3Qgc2NhbGVZU3EgPSB0ZVs0XSAqIHRlWzRdICsgdGVbNV0gKiB0ZVs1XSArIHRlWzZdICogdGVbNl07XG5cdFx0XHRjb25zdCBzY2FsZVpTcSA9IHRlWzhdICogdGVbOF0gKyB0ZVs5XSAqIHRlWzldICsgdGVbMTBdICogdGVbMTBdO1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLm1heChzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxKSk7XG5cdFx0fVxuXG5cdFx0bWFrZVRyYW5zbGF0aW9uKHgsIHksIHopIHtcblx0XHRcdHRoaXMuc2V0KDEsIDAsIDAsIHgsIDAsIDEsIDAsIHksIDAsIDAsIDEsIHosIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZVJvdGF0aW9uWCh0aGV0YSkge1xuXHRcdFx0Y29uc3QgYyA9IE1hdGguY29zKHRoZXRhKSxcblx0XHRcdFx0XHRcdHMgPSBNYXRoLnNpbih0aGV0YSk7XG5cdFx0XHR0aGlzLnNldCgxLCAwLCAwLCAwLCAwLCBjLCAtcywgMCwgMCwgcywgYywgMCwgMCwgMCwgMCwgMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtYWtlUm90YXRpb25ZKHRoZXRhKSB7XG5cdFx0XHRjb25zdCBjID0gTWF0aC5jb3ModGhldGEpLFxuXHRcdFx0XHRcdFx0cyA9IE1hdGguc2luKHRoZXRhKTtcblx0XHRcdHRoaXMuc2V0KGMsIDAsIHMsIDAsIDAsIDEsIDAsIDAsIC1zLCAwLCBjLCAwLCAwLCAwLCAwLCAxKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1ha2VSb3RhdGlvbloodGhldGEpIHtcblx0XHRcdGNvbnN0IGMgPSBNYXRoLmNvcyh0aGV0YSksXG5cdFx0XHRcdFx0XHRzID0gTWF0aC5zaW4odGhldGEpO1xuXHRcdFx0dGhpcy5zZXQoYywgLXMsIDAsIDAsIHMsIGMsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZVJvdGF0aW9uQXhpcyhheGlzLCBhbmdsZSkge1xuXHRcdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cdFx0XHRjb25zdCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0Y29uc3QgcyA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdGNvbnN0IHQgPSAxIC0gYztcblx0XHRcdGNvbnN0IHggPSBheGlzLngsXG5cdFx0XHRcdFx0XHR5ID0gYXhpcy55LFxuXHRcdFx0XHRcdFx0eiA9IGF4aXMuejtcblx0XHRcdGNvbnN0IHR4ID0gdCAqIHgsXG5cdFx0XHRcdFx0XHR0eSA9IHQgKiB5O1xuXHRcdFx0dGhpcy5zZXQodHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLCB0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsIHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCwgMCwgMCwgMCwgMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtYWtlU2NhbGUoeCwgeSwgeikge1xuXHRcdFx0dGhpcy5zZXQoeCwgMCwgMCwgMCwgMCwgeSwgMCwgMCwgMCwgMCwgeiwgMCwgMCwgMCwgMCwgMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtYWtlU2hlYXIoeHksIHh6LCB5eCwgeXosIHp4LCB6eSkge1xuXHRcdFx0dGhpcy5zZXQoMSwgeXgsIHp4LCAwLCB4eSwgMSwgenksIDAsIHh6LCB5eiwgMSwgMCwgMCwgMCwgMCwgMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb21wb3NlKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSkge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgeCA9IHF1YXRlcm5pb24uX3gsXG5cdFx0XHRcdFx0XHR5ID0gcXVhdGVybmlvbi5feSxcblx0XHRcdFx0XHRcdHogPSBxdWF0ZXJuaW9uLl96LFxuXHRcdFx0XHRcdFx0dyA9IHF1YXRlcm5pb24uX3c7XG5cdFx0XHRjb25zdCB4MiA9IHggKyB4LFxuXHRcdFx0XHRcdFx0eTIgPSB5ICsgeSxcblx0XHRcdFx0XHRcdHoyID0geiArIHo7XG5cdFx0XHRjb25zdCB4eCA9IHggKiB4Mixcblx0XHRcdFx0XHRcdHh5ID0geCAqIHkyLFxuXHRcdFx0XHRcdFx0eHogPSB4ICogejI7XG5cdFx0XHRjb25zdCB5eSA9IHkgKiB5Mixcblx0XHRcdFx0XHRcdHl6ID0geSAqIHoyLFxuXHRcdFx0XHRcdFx0enogPSB6ICogejI7XG5cdFx0XHRjb25zdCB3eCA9IHcgKiB4Mixcblx0XHRcdFx0XHRcdHd5ID0gdyAqIHkyLFxuXHRcdFx0XHRcdFx0d3ogPSB3ICogejI7XG5cdFx0XHRjb25zdCBzeCA9IHNjYWxlLngsXG5cdFx0XHRcdFx0XHRzeSA9IHNjYWxlLnksXG5cdFx0XHRcdFx0XHRzeiA9IHNjYWxlLno7XG5cdFx0XHR0ZVswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuXHRcdFx0dGVbMV0gPSAoeHkgKyB3eikgKiBzeDtcblx0XHRcdHRlWzJdID0gKHh6IC0gd3kpICogc3g7XG5cdFx0XHR0ZVszXSA9IDA7XG5cdFx0XHR0ZVs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuXHRcdFx0dGVbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcblx0XHRcdHRlWzZdID0gKHl6ICsgd3gpICogc3k7XG5cdFx0XHR0ZVs3XSA9IDA7XG5cdFx0XHR0ZVs4XSA9ICh4eiArIHd5KSAqIHN6O1xuXHRcdFx0dGVbOV0gPSAoeXogLSB3eCkgKiBzejtcblx0XHRcdHRlWzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuXHRcdFx0dGVbMTFdID0gMDtcblx0XHRcdHRlWzEyXSA9IHBvc2l0aW9uLng7XG5cdFx0XHR0ZVsxM10gPSBwb3NpdGlvbi55O1xuXHRcdFx0dGVbMTRdID0gcG9zaXRpb24uejtcblx0XHRcdHRlWzE1XSA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRkZWNvbXBvc2UocG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdGxldCBzeCA9IF92MSQ1LnNldCh0ZVswXSwgdGVbMV0sIHRlWzJdKS5sZW5ndGgoKTtcblxuXHRcdFx0Y29uc3Qgc3kgPSBfdjEkNS5zZXQodGVbNF0sIHRlWzVdLCB0ZVs2XSkubGVuZ3RoKCk7XG5cblx0XHRcdGNvbnN0IHN6ID0gX3YxJDUuc2V0KHRlWzhdLCB0ZVs5XSwgdGVbMTBdKS5sZW5ndGgoKTsgLy8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcblxuXG5cdFx0XHRjb25zdCBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG5cdFx0XHRpZiAoZGV0IDwgMCkgc3ggPSAtc3g7XG5cdFx0XHRwb3NpdGlvbi54ID0gdGVbMTJdO1xuXHRcdFx0cG9zaXRpb24ueSA9IHRlWzEzXTtcblx0XHRcdHBvc2l0aW9uLnogPSB0ZVsxNF07IC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cblx0XHRcdF9tMSQyLmNvcHkodGhpcyk7XG5cblx0XHRcdGNvbnN0IGludlNYID0gMSAvIHN4O1xuXHRcdFx0Y29uc3QgaW52U1kgPSAxIC8gc3k7XG5cdFx0XHRjb25zdCBpbnZTWiA9IDEgLyBzejtcblx0XHRcdF9tMSQyLmVsZW1lbnRzWzBdICo9IGludlNYO1xuXHRcdFx0X20xJDIuZWxlbWVudHNbMV0gKj0gaW52U1g7XG5cdFx0XHRfbTEkMi5lbGVtZW50c1syXSAqPSBpbnZTWDtcblx0XHRcdF9tMSQyLmVsZW1lbnRzWzRdICo9IGludlNZO1xuXHRcdFx0X20xJDIuZWxlbWVudHNbNV0gKj0gaW52U1k7XG5cdFx0XHRfbTEkMi5lbGVtZW50c1s2XSAqPSBpbnZTWTtcblx0XHRcdF9tMSQyLmVsZW1lbnRzWzhdICo9IGludlNaO1xuXHRcdFx0X20xJDIuZWxlbWVudHNbOV0gKj0gaW52U1o7XG5cdFx0XHRfbTEkMi5lbGVtZW50c1sxMF0gKj0gaW52U1o7XG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChfbTEkMik7XG5cdFx0XHRzY2FsZS54ID0gc3g7XG5cdFx0XHRzY2FsZS55ID0gc3k7XG5cdFx0XHRzY2FsZS56ID0gc3o7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtYWtlUGVyc3BlY3RpdmUobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIpIHtcblx0XHRcdGlmIChmYXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDQ6IC5tYWtlUGVyc3BlY3RpdmUoKSBoYXMgYmVlbiByZWRlZmluZWQgYW5kIGhhcyBhIG5ldyBzaWduYXR1cmUuIFBsZWFzZSBjaGVjayB0aGUgZG9jcy4nKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgeCA9IDIgKiBuZWFyIC8gKHJpZ2h0IC0gbGVmdCk7XG5cdFx0XHRjb25zdCB5ID0gMiAqIG5lYXIgLyAodG9wIC0gYm90dG9tKTtcblx0XHRcdGNvbnN0IGEgPSAocmlnaHQgKyBsZWZ0KSAvIChyaWdodCAtIGxlZnQpO1xuXHRcdFx0Y29uc3QgYiA9ICh0b3AgKyBib3R0b20pIC8gKHRvcCAtIGJvdHRvbSk7XG5cdFx0XHRjb25zdCBjID0gLShmYXIgKyBuZWFyKSAvIChmYXIgLSBuZWFyKTtcblx0XHRcdGNvbnN0IGQgPSAtMiAqIGZhciAqIG5lYXIgLyAoZmFyIC0gbmVhcik7XG5cdFx0XHR0ZVswXSA9IHg7XG5cdFx0XHR0ZVs0XSA9IDA7XG5cdFx0XHR0ZVs4XSA9IGE7XG5cdFx0XHR0ZVsxMl0gPSAwO1xuXHRcdFx0dGVbMV0gPSAwO1xuXHRcdFx0dGVbNV0gPSB5O1xuXHRcdFx0dGVbOV0gPSBiO1xuXHRcdFx0dGVbMTNdID0gMDtcblx0XHRcdHRlWzJdID0gMDtcblx0XHRcdHRlWzZdID0gMDtcblx0XHRcdHRlWzEwXSA9IGM7XG5cdFx0XHR0ZVsxNF0gPSBkO1xuXHRcdFx0dGVbM10gPSAwO1xuXHRcdFx0dGVbN10gPSAwO1xuXHRcdFx0dGVbMTFdID0gLTE7XG5cdFx0XHR0ZVsxNV0gPSAwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZU9ydGhvZ3JhcGhpYyhsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcikge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgdyA9IDEuMCAvIChyaWdodCAtIGxlZnQpO1xuXHRcdFx0Y29uc3QgaCA9IDEuMCAvICh0b3AgLSBib3R0b20pO1xuXHRcdFx0Y29uc3QgcCA9IDEuMCAvIChmYXIgLSBuZWFyKTtcblx0XHRcdGNvbnN0IHggPSAocmlnaHQgKyBsZWZ0KSAqIHc7XG5cdFx0XHRjb25zdCB5ID0gKHRvcCArIGJvdHRvbSkgKiBoO1xuXHRcdFx0Y29uc3QgeiA9IChmYXIgKyBuZWFyKSAqIHA7XG5cdFx0XHR0ZVswXSA9IDIgKiB3O1xuXHRcdFx0dGVbNF0gPSAwO1xuXHRcdFx0dGVbOF0gPSAwO1xuXHRcdFx0dGVbMTJdID0gLXg7XG5cdFx0XHR0ZVsxXSA9IDA7XG5cdFx0XHR0ZVs1XSA9IDIgKiBoO1xuXHRcdFx0dGVbOV0gPSAwO1xuXHRcdFx0dGVbMTNdID0gLXk7XG5cdFx0XHR0ZVsyXSA9IDA7XG5cdFx0XHR0ZVs2XSA9IDA7XG5cdFx0XHR0ZVsxMF0gPSAtMiAqIHA7XG5cdFx0XHR0ZVsxNF0gPSAtejtcblx0XHRcdHRlWzNdID0gMDtcblx0XHRcdHRlWzddID0gMDtcblx0XHRcdHRlWzExXSA9IDA7XG5cdFx0XHR0ZVsxNV0gPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXF1YWxzKG1hdHJpeCkge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHRcdFx0XHRpZiAodGVbaV0gIT09IG1lW2ldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudHNbaV0gPSBhcnJheVtpICsgb2Zmc2V0XTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRhcnJheVtvZmZzZXRdID0gdGVbMF07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxXSA9IHRlWzFdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMl0gPSB0ZVsyXTtcblx0XHRcdGFycmF5W29mZnNldCArIDNdID0gdGVbM107XG5cdFx0XHRhcnJheVtvZmZzZXQgKyA0XSA9IHRlWzRdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgNV0gPSB0ZVs1XTtcblx0XHRcdGFycmF5W29mZnNldCArIDZdID0gdGVbNl07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyA3XSA9IHRlWzddO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgOF0gPSB0ZVs4XTtcblx0XHRcdGFycmF5W29mZnNldCArIDldID0gdGVbOV07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxMF0gPSB0ZVsxMF07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxMV0gPSB0ZVsxMV07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxMl0gPSB0ZVsxMl07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxM10gPSB0ZVsxM107XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxNF0gPSB0ZVsxNF07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxNV0gPSB0ZVsxNV07XG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0fVxuXG5cdH1cblxuXHRNYXRyaXg0LnByb3RvdHlwZS5pc01hdHJpeDQgPSB0cnVlO1xuXG5cdGNvbnN0IF92MSQ1ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX20xJDIgPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfemVybyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCAwLCAwKTtcblxuXHRjb25zdCBfb25lID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDEsIDEsIDEpO1xuXG5cdGNvbnN0IF94ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3kgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfeiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9tYXRyaXgkMSA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF9xdWF0ZXJuaW9uJDMgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcblxuXHRjbGFzcyBFdWxlciB7XG5cdFx0Y29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgb3JkZXIgPSBFdWxlci5EZWZhdWx0T3JkZXIpIHtcblx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0dGhpcy5feSA9IHk7XG5cdFx0XHR0aGlzLl96ID0gejtcblx0XHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cdFx0fVxuXG5cdFx0Z2V0IHgoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5feDtcblx0XHR9XG5cblx0XHRzZXQgeCh2YWx1ZSkge1xuXHRcdFx0dGhpcy5feCA9IHZhbHVlO1xuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0fVxuXG5cdFx0Z2V0IHkoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5feTtcblx0XHR9XG5cblx0XHRzZXQgeSh2YWx1ZSkge1xuXHRcdFx0dGhpcy5feSA9IHZhbHVlO1xuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0fVxuXG5cdFx0Z2V0IHooKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fejtcblx0XHR9XG5cblx0XHRzZXQgeih2YWx1ZSkge1xuXHRcdFx0dGhpcy5feiA9IHZhbHVlO1xuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0fVxuXG5cdFx0Z2V0IG9yZGVyKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xuXHRcdH1cblxuXHRcdHNldCBvcmRlcih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdHNldCh4LCB5LCB6LCBvcmRlciA9IHRoaXMuX29yZGVyKSB7XG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cdFx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyKTtcblx0XHR9XG5cblx0XHRjb3B5KGV1bGVyKSB7XG5cdFx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XG5cdFx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XG5cdFx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tUm90YXRpb25NYXRyaXgobSwgb3JkZXIgPSB0aGlzLl9vcmRlciwgdXBkYXRlID0gdHJ1ZSkge1xuXHRcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblx0XHRcdGNvbnN0IHRlID0gbS5lbGVtZW50cztcblx0XHRcdGNvbnN0IG0xMSA9IHRlWzBdLFxuXHRcdFx0XHRcdFx0bTEyID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRtMTMgPSB0ZVs4XTtcblx0XHRcdGNvbnN0IG0yMSA9IHRlWzFdLFxuXHRcdFx0XHRcdFx0bTIyID0gdGVbNV0sXG5cdFx0XHRcdFx0XHRtMjMgPSB0ZVs5XTtcblx0XHRcdGNvbnN0IG0zMSA9IHRlWzJdLFxuXHRcdFx0XHRcdFx0bTMyID0gdGVbNl0sXG5cdFx0XHRcdFx0XHRtMzMgPSB0ZVsxMF07XG5cblx0XHRcdHN3aXRjaCAob3JkZXIpIHtcblx0XHRcdFx0Y2FzZSAnWFlaJzpcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKGNsYW1wKG0xMywgLTEsIDEpKTtcblxuXHRcdFx0XHRcdGlmIChNYXRoLmFicyhtMTMpIDwgMC45OTk5OTk5KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMigtbTIzLCBtMzMpO1xuXHRcdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoLW0xMiwgbTExKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuXHRcdFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWVhaJzpcblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKC1jbGFtcChtMjMsIC0xLCAxKSk7XG5cblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMobTIzKSA8IDAuOTk5OTk5OSkge1xuXHRcdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIobTEzLCBtMzMpO1xuXHRcdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIobTIxLCBtMjIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMigtbTMxLCBtMTEpO1xuXHRcdFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWlhZJzpcblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKGNsYW1wKG0zMiwgLTEsIDEpKTtcblxuXHRcdFx0XHRcdGlmIChNYXRoLmFicyhtMzIpIDwgMC45OTk5OTk5KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMigtbTMxLCBtMzMpO1xuXHRcdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoLW0xMiwgbTIyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMihtMjEsIG0xMSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWllYJzpcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKC1jbGFtcChtMzEsIC0xLCAxKSk7XG5cblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMobTMxKSA8IDAuOTk5OTk5OSkge1xuXHRcdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIobTMyLCBtMzMpO1xuXHRcdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIobTIxLCBtMTEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWVpYJzpcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKGNsYW1wKG0yMSwgLTEsIDEpKTtcblxuXHRcdFx0XHRcdGlmIChNYXRoLmFicyhtMjEpIDwgMC45OTk5OTk5KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMigtbTIzLCBtMjIpO1xuXHRcdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoLW0zMSwgbTExKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMihtMTMsIG0zMyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWFpZJzpcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKC1jbGFtcChtMTIsIC0xLCAxKSk7XG5cblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMobTEyKSA8IDAuOTk5OTk5OSkge1xuXHRcdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuXHRcdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIobTEzLCBtMTEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMigtbTIzLCBtMzMpO1xuXHRcdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblx0XHRcdGlmICh1cGRhdGUgPT09IHRydWUpIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21RdWF0ZXJuaW9uKHEsIG9yZGVyLCB1cGRhdGUpIHtcblx0XHRcdF9tYXRyaXgkMS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihxKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KF9tYXRyaXgkMSwgb3JkZXIsIHVwZGF0ZSk7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbVZlY3RvcjModiwgb3JkZXIgPSB0aGlzLl9vcmRlcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KHYueCwgdi55LCB2LnosIG9yZGVyKTtcblx0XHR9XG5cblx0XHRyZW9yZGVyKG5ld09yZGVyKSB7XG5cdFx0XHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXG5cdFx0XHRfcXVhdGVybmlvbiQzLnNldEZyb21FdWxlcih0aGlzKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oX3F1YXRlcm5pb24kMywgbmV3T3JkZXIpO1xuXHRcdH1cblxuXHRcdGVxdWFscyhldWxlcikge1xuXHRcdFx0cmV0dXJuIGV1bGVyLl94ID09PSB0aGlzLl94ICYmIGV1bGVyLl95ID09PSB0aGlzLl95ICYmIGV1bGVyLl96ID09PSB0aGlzLl96ICYmIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXI7XG5cdFx0fVxuXG5cdFx0ZnJvbUFycmF5KGFycmF5KSB7XG5cdFx0XHR0aGlzLl94ID0gYXJyYXlbMF07XG5cdFx0XHR0aGlzLl95ID0gYXJyYXlbMV07XG5cdFx0XHR0aGlzLl96ID0gYXJyYXlbMl07XG5cdFx0XHRpZiAoYXJyYXlbM10gIT09IHVuZGVmaW5lZCkgdGhpcy5fb3JkZXIgPSBhcnJheVszXTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRcdGFycmF5W29mZnNldF0gPSB0aGlzLl94O1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzLl95O1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLl96O1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgM10gPSB0aGlzLl9vcmRlcjtcblx0XHRcdHJldHVybiBhcnJheTtcblx0XHR9XG5cblx0XHR0b1ZlY3RvcjMob3B0aW9uYWxSZXN1bHQpIHtcblx0XHRcdGlmIChvcHRpb25hbFJlc3VsdCkge1xuXHRcdFx0XHRyZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3opO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3opO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9vbkNoYW5nZShjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuXG5cdH1cblxuXHRFdWxlci5wcm90b3R5cGUuaXNFdWxlciA9IHRydWU7XG5cdEV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xuXHRFdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnXTtcblxuXHRjbGFzcyBMYXllcnMge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0dGhpcy5tYXNrID0gMSB8IDA7XG5cdFx0fVxuXG5cdFx0c2V0KGNoYW5uZWwpIHtcblx0XHRcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbCB8IDA7XG5cdFx0fVxuXG5cdFx0ZW5hYmxlKGNoYW5uZWwpIHtcblx0XHRcdHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWwgfCAwO1xuXHRcdH1cblxuXHRcdGVuYWJsZUFsbCgpIHtcblx0XHRcdHRoaXMubWFzayA9IDB4ZmZmZmZmZmYgfCAwO1xuXHRcdH1cblxuXHRcdHRvZ2dsZShjaGFubmVsKSB7XG5cdFx0XHR0aGlzLm1hc2sgXj0gMSA8PCBjaGFubmVsIHwgMDtcblx0XHR9XG5cblx0XHRkaXNhYmxlKGNoYW5uZWwpIHtcblx0XHRcdHRoaXMubWFzayAmPSB+KDEgPDwgY2hhbm5lbCB8IDApO1xuXHRcdH1cblxuXHRcdGRpc2FibGVBbGwoKSB7XG5cdFx0XHR0aGlzLm1hc2sgPSAwO1xuXHRcdH1cblxuXHRcdHRlc3QobGF5ZXJzKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMubWFzayAmIGxheWVycy5tYXNrKSAhPT0gMDtcblx0XHR9XG5cblx0fVxuXG5cdGxldCBfb2JqZWN0M0RJZCA9IDA7XG5cblx0Y29uc3QgX3YxJDQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfcTEgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcblxuXHRjb25zdCBfbTEkMSA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF90YXJnZXQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfcG9zaXRpb24kMyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9zY2FsZSQyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3F1YXRlcm5pb24kMiA9IC8qQF9fUFVSRV9fKi9uZXcgUXVhdGVybmlvbigpO1xuXG5cdGNvbnN0IF94QXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygxLCAwLCAwKTtcblxuXHRjb25zdCBfeUF4aXMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG5cblx0Y29uc3QgX3pBeGlzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDAsIDAsIDEpO1xuXG5cdGNvbnN0IF9hZGRlZEV2ZW50ID0ge1xuXHRcdHR5cGU6ICdhZGRlZCdcblx0fTtcblx0Y29uc3QgX3JlbW92ZWRFdmVudCA9IHtcblx0XHR0eXBlOiAncmVtb3ZlZCdcblx0fTtcblxuXHRjbGFzcyBPYmplY3QzRCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcblx0XHRcdFx0dmFsdWU6IF9vYmplY3QzRElkKytcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdFx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHRcdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XG5cdFx0XHR0aGlzLnBhcmVudCA9IG51bGw7XG5cdFx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cdFx0XHR0aGlzLnVwID0gT2JqZWN0M0QuRGVmYXVsdFVwLmNsb25lKCk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCByb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXHRcdFx0Y29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0XHRjb25zdCBzY2FsZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuXG5cdFx0XHRmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xuXHRcdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlcihyb3RhdGlvbiwgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBvblF1YXRlcm5pb25DaGFuZ2UoKSB7XG5cdFx0XHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyb3RhdGlvbi5fb25DaGFuZ2Uob25Sb3RhdGlvbkNoYW5nZSk7XG5cblx0XHRcdHF1YXRlcm5pb24uX29uQ2hhbmdlKG9uUXVhdGVybmlvbkNoYW5nZSk7XG5cblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogcG9zaXRpb25cblx0XHRcdFx0fSxcblx0XHRcdFx0cm90YXRpb246IHtcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogcm90YXRpb25cblx0XHRcdFx0fSxcblx0XHRcdFx0cXVhdGVybmlvbjoge1xuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiBxdWF0ZXJuaW9uXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNjYWxlOiB7XG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHNjYWxlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1vZGVsVmlld01hdHJpeDoge1xuXHRcdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4NCgpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5vcm1hbE1hdHJpeDoge1xuXHRcdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBPYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG5cdFx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG5cdFx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblx0XHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG5cdFx0XHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblx0XHRcdHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXHRcdH1cblxuXHRcdG9uQmVmb3JlUmVuZGVyKCkge31cblxuXHRcdG9uQWZ0ZXJSZW5kZXIoKSB7fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuXHRcdFx0aWYgKHRoaXMubWF0cml4QXV0b1VwZGF0ZSkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblx0XHRcdHRoaXMubWF0cml4LnByZW11bHRpcGx5KG1hdHJpeCk7XG5cdFx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlKTtcblx0XHR9XG5cblx0XHRhcHBseVF1YXRlcm5pb24ocSkge1xuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KHEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKSB7XG5cdFx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpO1xuXHRcdH1cblxuXHRcdHNldFJvdGF0aW9uRnJvbUV1bGVyKGV1bGVyKSB7XG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGV1bGVyLCB0cnVlKTtcblx0XHR9XG5cblx0XHRzZXRSb3RhdGlvbkZyb21NYXRyaXgobSkge1xuXHRcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgobSk7XG5cdFx0fVxuXG5cdFx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbihxKSB7XG5cdFx0XHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkocSk7XG5cdFx0fVxuXG5cdFx0cm90YXRlT25BeGlzKGF4aXMsIGFuZ2xlKSB7XG5cdFx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdFx0X3ExLnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpO1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoX3ExKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJvdGF0ZU9uV29ybGRBeGlzKGF4aXMsIGFuZ2xlKSB7XG5cdFx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cdFx0XHQvLyBtZXRob2QgYXNzdW1lcyBubyByb3RhdGVkIHBhcmVudFxuXHRcdFx0X3ExLnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpO1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoX3ExKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJvdGF0ZVgoYW5nbGUpIHtcblx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhfeEF4aXMsIGFuZ2xlKTtcblx0XHR9XG5cblx0XHRyb3RhdGVZKGFuZ2xlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoX3lBeGlzLCBhbmdsZSk7XG5cdFx0fVxuXG5cdFx0cm90YXRlWihhbmdsZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKF96QXhpcywgYW5nbGUpO1xuXHRcdH1cblxuXHRcdHRyYW5zbGF0ZU9uQXhpcyhheGlzLCBkaXN0YW5jZSkge1xuXHRcdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblx0XHRcdF92MSQ0LmNvcHkoYXhpcykuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG5cblx0XHRcdHRoaXMucG9zaXRpb24uYWRkKF92MSQ0Lm11bHRpcGx5U2NhbGFyKGRpc3RhbmNlKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0cmFuc2xhdGVYKGRpc3RhbmNlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoX3hBeGlzLCBkaXN0YW5jZSk7XG5cdFx0fVxuXG5cdFx0dHJhbnNsYXRlWShkaXN0YW5jZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKF95QXhpcywgZGlzdGFuY2UpO1xuXHRcdH1cblxuXHRcdHRyYW5zbGF0ZVooZGlzdGFuY2UpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhfekF4aXMsIGRpc3RhbmNlKTtcblx0XHR9XG5cblx0XHRsb2NhbFRvV29ybGQodmVjdG9yKSB7XG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcblx0XHR9XG5cblx0XHR3b3JsZFRvTG9jYWwodmVjdG9yKSB7XG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NChfbTEkMS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpKTtcblx0XHR9XG5cblx0XHRsb29rQXQoeCwgeSwgeikge1xuXHRcdFx0Ly8gVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIGhhdmluZyBub24tdW5pZm9ybWx5LXNjYWxlZCBwYXJlbnQocylcblx0XHRcdGlmICh4LmlzVmVjdG9yMykge1xuXHRcdFx0XHRfdGFyZ2V0LmNvcHkoeCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfdGFyZ2V0LnNldCh4LCB5LCB6KTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cdFx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblxuXHRcdFx0X3Bvc2l0aW9uJDMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuXG5cdFx0XHRpZiAodGhpcy5pc0NhbWVyYSB8fCB0aGlzLmlzTGlnaHQpIHtcblx0XHRcdFx0X20xJDEubG9va0F0KF9wb3NpdGlvbiQzLCBfdGFyZ2V0LCB0aGlzLnVwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9tMSQxLmxvb2tBdChfdGFyZ2V0LCBfcG9zaXRpb24kMywgdGhpcy51cCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoX20xJDEpO1xuXG5cdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdF9tMSQxLmV4dHJhY3RSb3RhdGlvbihwYXJlbnQubWF0cml4V29ybGQpO1xuXG5cdFx0XHRcdF9xMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoX20xJDEpO1xuXG5cdFx0XHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShfcTEuaW52ZXJ0KCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFkZChvYmplY3QpIHtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9iamVjdCA9PT0gdGhpcykge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW5cXCd0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLicsIG9iamVjdCk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2JqZWN0ICYmIG9iamVjdC5pc09iamVjdDNEKSB7XG5cdFx0XHRcdGlmIChvYmplY3QucGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUob2JqZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2gob2JqZWN0KTtcblx0XHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoX2FkZGVkRXZlbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELicsIG9iamVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJlbW92ZShvYmplY3QpIHtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlKGFyZ3VtZW50c1tpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2Yob2JqZWN0KTtcblxuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudChfcmVtb3ZlZEV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlRnJvbVBhcmVudCgpIHtcblx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0XHRpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdHBhcmVudC5yZW1vdmUodGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsZWFyKCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IHRoaXMuY2hpbGRyZW5baV07XG5cdFx0XHRcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xuXHRcdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudChfcmVtb3ZlZEV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jaGlsZHJlbi5sZW5ndGggPSAwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YXR0YWNoKG9iamVjdCkge1xuXHRcdFx0Ly8gYWRkcyBvYmplY3QgYXMgYSBjaGlsZCBvZiB0aGlzLCB3aGlsZSBtYWludGFpbmluZyB0aGUgb2JqZWN0J3Mgd29ybGQgdHJhbnNmb3JtXG5cdFx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblxuXHRcdFx0X20xJDEuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblxuXHRcdFx0aWYgKG9iamVjdC5wYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdFx0b2JqZWN0LnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cblx0XHRcdFx0X20xJDEubXVsdGlwbHkob2JqZWN0LnBhcmVudC5tYXRyaXhXb3JsZCk7XG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5hcHBseU1hdHJpeDQoX20xJDEpO1xuXHRcdFx0dGhpcy5hZGQob2JqZWN0KTtcblx0XHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRPYmplY3RCeUlkKGlkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCdpZCcsIGlkKTtcblx0XHR9XG5cblx0XHRnZXRPYmplY3RCeU5hbWUobmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgnbmFtZScsIG5hbWUpO1xuXHRcdH1cblxuXHRcdGdldE9iamVjdEJ5UHJvcGVydHkobmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0aGlzW25hbWVdID09PSB2YWx1ZSkgcmV0dXJuIHRoaXM7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXHRcdFx0XHRjb25zdCBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KG5hbWUsIHZhbHVlKTtcblxuXHRcdFx0XHRpZiAob2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Z2V0V29ybGRQb3NpdGlvbih0YXJnZXQpIHtcblx0XHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7XG5cdFx0fVxuXG5cdFx0Z2V0V29ybGRRdWF0ZXJuaW9uKHRhcmdldCkge1xuXHRcdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShfcG9zaXRpb24kMywgdGFyZ2V0LCBfc2NhbGUkMik7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGdldFdvcmxkU2NhbGUodGFyZ2V0KSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKF9wb3NpdGlvbiQzLCBfcXVhdGVybmlvbiQyLCB0YXJnZXQpO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRnZXRXb3JsZERpcmVjdGlvbih0YXJnZXQpIHtcblx0XHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0Y29uc3QgZSA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnNldChlWzhdLCBlWzldLCBlWzEwXSkubm9ybWFsaXplKCk7XG5cdFx0fVxuXG5cdFx0cmF5Y2FzdCgpIHt9XG5cblx0XHR0cmF2ZXJzZShjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sodGhpcyk7XG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNoaWxkcmVuW2ldLnRyYXZlcnNlKGNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0cmF2ZXJzZVZpc2libGUoY2FsbGJhY2spIHtcblx0XHRcdGlmICh0aGlzLnZpc2libGUgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0XHRjYWxsYmFjayh0aGlzKTtcblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y2hpbGRyZW5baV0udHJhdmVyc2VWaXNpYmxlKGNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0cmF2ZXJzZUFuY2VzdG9ycyhjYWxsYmFjaykge1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRcdGlmIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdFx0Y2FsbGJhY2socGFyZW50KTtcblx0XHRcdFx0cGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKGNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXgoKSB7XG5cdFx0XHR0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG5cdFx0XHRpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHRpZiAodGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlKSB7XG5cdFx0XHRcdGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0fSAvLyB1cGRhdGUgY2hpbGRyZW5cblxuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNoaWxkcmVuW2ldLnVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR1cGRhdGVXb3JsZE1hdHJpeCh1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbikge1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRcdGlmICh1cGRhdGVQYXJlbnRzID09PSB0cnVlICYmIHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0XHRwYXJlbnQudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHRpZiAodGhpcy5wYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXgpO1xuXHRcdFx0fSAvLyB1cGRhdGUgY2hpbGRyZW5cblxuXG5cdFx0XHRpZiAodXBkYXRlQ2hpbGRyZW4gPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y2hpbGRyZW5baV0udXBkYXRlV29ybGRNYXRyaXgoZmFsc2UsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdC8vIG1ldGEgaXMgYSBzdHJpbmcgd2hlbiBjYWxsZWQgZnJvbSBKU09OLnN0cmluZ2lmeVxuXHRcdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJztcblx0XHRcdGNvbnN0IG91dHB1dCA9IHt9OyAvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuXHRcdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3Rcblx0XHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG5cblx0XHRcdGlmIChpc1Jvb3RPYmplY3QpIHtcblx0XHRcdFx0Ly8gaW5pdGlhbGl6ZSBtZXRhIG9ialxuXHRcdFx0XHRtZXRhID0ge1xuXHRcdFx0XHRcdGdlb21ldHJpZXM6IHt9LFxuXHRcdFx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRcdGltYWdlczoge30sXG5cdFx0XHRcdFx0c2hhcGVzOiB7fSxcblx0XHRcdFx0XHRza2VsZXRvbnM6IHt9LFxuXHRcdFx0XHRcdGFuaW1hdGlvbnM6IHt9XG5cdFx0XHRcdH07XG5cdFx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdFx0dHlwZTogJ09iamVjdCcsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fSAvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXG5cblxuXHRcdFx0Y29uc3Qgb2JqZWN0ID0ge307XG5cdFx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xuXHRcdFx0aWYgKHRoaXMubmFtZSAhPT0gJycpIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdFx0aWYgKHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xuXHRcdFx0aWYgKHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuXHRcdFx0aWYgKHRoaXMudmlzaWJsZSA9PT0gZmFsc2UpIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSkgb2JqZWN0LmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLnJlbmRlck9yZGVyICE9PSAwKSBvYmplY3QucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXHRcdFx0aWYgKEpTT04uc3RyaW5naWZ5KHRoaXMudXNlckRhdGEpICE9PSAne30nKSBvYmplY3QudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXHRcdFx0b2JqZWN0LmxheWVycyA9IHRoaXMubGF5ZXJzLm1hc2s7XG5cdFx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXHRcdFx0aWYgKHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gZmFsc2UpIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7IC8vIG9iamVjdCBzcGVjaWZpYyBwcm9wZXJ0aWVzXG5cblx0XHRcdGlmICh0aGlzLmlzSW5zdGFuY2VkTWVzaCkge1xuXHRcdFx0XHRvYmplY3QudHlwZSA9ICdJbnN0YW5jZWRNZXNoJztcblx0XHRcdFx0b2JqZWN0LmNvdW50ID0gdGhpcy5jb3VudDtcblx0XHRcdFx0b2JqZWN0Lmluc3RhbmNlTWF0cml4ID0gdGhpcy5pbnN0YW5jZU1hdHJpeC50b0pTT04oKTtcblx0XHRcdFx0aWYgKHRoaXMuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCkgb2JqZWN0Lmluc3RhbmNlQ29sb3IgPSB0aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCk7XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGxpYnJhcnksIGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGxpYnJhcnlbZWxlbWVudC51dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bGlicmFyeVtlbGVtZW50LnV1aWRdID0gZWxlbWVudC50b0pTT04obWV0YSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbWVudC51dWlkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5pc1NjZW5lKSB7XG5cdFx0XHRcdGlmICh0aGlzLmJhY2tncm91bmQpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5iYWNrZ3JvdW5kLmlzQ29sb3IpIHtcblx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTigpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5iYWNrZ3JvdW5kLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuZW52aXJvbm1lbnQgJiYgdGhpcy5lbnZpcm9ubWVudC5pc1RleHR1cmUpIHtcblx0XHRcdFx0XHRvYmplY3QuZW52aXJvbm1lbnQgPSB0aGlzLmVudmlyb25tZW50LnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuaXNNZXNoIHx8IHRoaXMuaXNMaW5lIHx8IHRoaXMuaXNQb2ludHMpIHtcblx0XHRcdFx0b2JqZWN0Lmdlb21ldHJ5ID0gc2VyaWFsaXplKG1ldGEuZ2VvbWV0cmllcywgdGhpcy5nZW9tZXRyeSk7XG5cdFx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XG5cblx0XHRcdFx0aWYgKHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCAmJiBwYXJhbWV0ZXJzLnNoYXBlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShzaGFwZXMpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbaV07XG5cdFx0XHRcdFx0XHRcdHNlcmlhbGl6ZShtZXRhLnNoYXBlcywgc2hhcGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZXJpYWxpemUobWV0YS5zaGFwZXMsIHNoYXBlcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmlzU2tpbm5lZE1lc2gpIHtcblx0XHRcdFx0b2JqZWN0LmJpbmRNb2RlID0gdGhpcy5iaW5kTW9kZTtcblx0XHRcdFx0b2JqZWN0LmJpbmRNYXRyaXggPSB0aGlzLmJpbmRNYXRyaXgudG9BcnJheSgpO1xuXG5cdFx0XHRcdGlmICh0aGlzLnNrZWxldG9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzZXJpYWxpemUobWV0YS5za2VsZXRvbnMsIHRoaXMuc2tlbGV0b24pO1xuXHRcdFx0XHRcdG9iamVjdC5za2VsZXRvbiA9IHRoaXMuc2tlbGV0b24udXVpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHRoaXMubWF0ZXJpYWwpKSB7XG5cdFx0XHRcdFx0Y29uc3QgdXVpZHMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5tYXRlcmlhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdHV1aWRzLnB1c2goc2VyaWFsaXplKG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsW2ldKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b2JqZWN0Lm1hdGVyaWFsID0gdXVpZHM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b2JqZWN0Lm1hdGVyaWFsID0gc2VyaWFsaXplKG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXS50b0pTT04obWV0YSkub2JqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGlmICh0aGlzLmFuaW1hdGlvbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRvYmplY3QuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zW2ldO1xuXHRcdFx0XHRcdG9iamVjdC5hbmltYXRpb25zLnB1c2goc2VyaWFsaXplKG1ldGEuYW5pbWF0aW9ucywgYW5pbWF0aW9uKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzUm9vdE9iamVjdCkge1xuXHRcdFx0XHRjb25zdCBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLmdlb21ldHJpZXMpO1xuXHRcdFx0XHRjb25zdCBtYXRlcmlhbHMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEubWF0ZXJpYWxzKTtcblx0XHRcdFx0Y29uc3QgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEudGV4dHVyZXMpO1xuXHRcdFx0XHRjb25zdCBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEuaW1hZ2VzKTtcblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLnNoYXBlcyk7XG5cdFx0XHRcdGNvbnN0IHNrZWxldG9ucyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS5za2VsZXRvbnMpO1xuXHRcdFx0XHRjb25zdCBhbmltYXRpb25zID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLmFuaW1hdGlvbnMpO1xuXHRcdFx0XHRpZiAoZ2VvbWV0cmllcy5sZW5ndGggPiAwKSBvdXRwdXQuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG5cdFx0XHRcdGlmIChtYXRlcmlhbHMubGVuZ3RoID4gMCkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcblx0XHRcdFx0aWYgKHRleHR1cmVzLmxlbmd0aCA+IDApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0XHRpZiAoaW1hZ2VzLmxlbmd0aCA+IDApIG91dHB1dC5pbWFnZXMgPSBpbWFnZXM7XG5cdFx0XHRcdGlmIChzaGFwZXMubGVuZ3RoID4gMCkgb3V0cHV0LnNoYXBlcyA9IHNoYXBlcztcblx0XHRcdFx0aWYgKHNrZWxldG9ucy5sZW5ndGggPiAwKSBvdXRwdXQuc2tlbGV0b25zID0gc2tlbGV0b25zO1xuXHRcdFx0XHRpZiAoYW5pbWF0aW9ucy5sZW5ndGggPiAwKSBvdXRwdXQuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cdFx0XHR9XG5cblx0XHRcdG91dHB1dC5vYmplY3QgPSBvYmplY3Q7XG5cdFx0XHRyZXR1cm4gb3V0cHV0OyAvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuXHRcdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuXHRcdFx0Ly8gYW5kIHJldHVybiBhcyBhcnJheVxuXG5cdFx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKGNhY2hlKSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIGNhY2hlKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlW2tleV07XG5cdFx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goZGF0YSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNsb25lKHJlY3Vyc2l2ZSkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzLCByZWN1cnNpdmUpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlLCByZWN1cnNpdmUgPSB0cnVlKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblx0XHRcdHRoaXMudXAuY29weShzb3VyY2UudXApO1xuXHRcdFx0dGhpcy5wb3NpdGlvbi5jb3B5KHNvdXJjZS5wb3NpdGlvbik7XG5cdFx0XHR0aGlzLnJvdGF0aW9uLm9yZGVyID0gc291cmNlLnJvdGF0aW9uLm9yZGVyO1xuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoc291cmNlLnF1YXRlcm5pb24pO1xuXHRcdFx0dGhpcy5zY2FsZS5jb3B5KHNvdXJjZS5zY2FsZSk7XG5cdFx0XHR0aGlzLm1hdHJpeC5jb3B5KHNvdXJjZS5tYXRyaXgpO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KHNvdXJjZS5tYXRyaXhXb3JsZCk7XG5cdFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXHRcdFx0dGhpcy5sYXllcnMubWFzayA9IHNvdXJjZS5sYXllcnMubWFzaztcblx0XHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXHRcdFx0dGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG5cdFx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcblx0XHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xuXHRcdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcblx0XHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNvdXJjZS51c2VyRGF0YSkpO1xuXG5cdFx0XHRpZiAocmVjdXJzaXZlID09PSB0cnVlKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0dGhpcy5hZGQoY2hpbGQuY2xvbmUoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRPYmplY3QzRC5EZWZhdWx0VXAgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcblx0T2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXHRPYmplY3QzRC5wcm90b3R5cGUuaXNPYmplY3QzRCA9IHRydWU7XG5cblx0Y29uc3QgX3YwJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdjEkMyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92MiQyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3YzJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdmFiID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3ZhYyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92YmMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdmFwID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3ZicCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92Y3AgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBUcmlhbmdsZSB7XG5cdFx0Y29uc3RydWN0b3IoYSA9IG5ldyBWZWN0b3IzKCksIGIgPSBuZXcgVmVjdG9yMygpLCBjID0gbmV3IFZlY3RvcjMoKSkge1xuXHRcdFx0dGhpcy5hID0gYTtcblx0XHRcdHRoaXMuYiA9IGI7XG5cdFx0XHR0aGlzLmMgPSBjO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBnZXROb3JtYWwoYSwgYiwgYywgdGFyZ2V0KSB7XG5cdFx0XHR0YXJnZXQuc3ViVmVjdG9ycyhjLCBiKTtcblxuXHRcdFx0X3YwJDEuc3ViVmVjdG9ycyhhLCBiKTtcblxuXHRcdFx0dGFyZ2V0LmNyb3NzKF92MCQxKTtcblx0XHRcdGNvbnN0IHRhcmdldExlbmd0aFNxID0gdGFyZ2V0Lmxlbmd0aFNxKCk7XG5cblx0XHRcdGlmICh0YXJnZXRMZW5ndGhTcSA+IDApIHtcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5tdWx0aXBseVNjYWxhcigxIC8gTWF0aC5zcXJ0KHRhcmdldExlbmd0aFNxKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KDAsIDAsIDApO1xuXHRcdH0gLy8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcblx0XHQvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxuXG5cblx0XHRzdGF0aWMgZ2V0QmFyeWNvb3JkKHBvaW50LCBhLCBiLCBjLCB0YXJnZXQpIHtcblx0XHRcdF92MCQxLnN1YlZlY3RvcnMoYywgYSk7XG5cblx0XHRcdF92MSQzLnN1YlZlY3RvcnMoYiwgYSk7XG5cblx0XHRcdF92MiQyLnN1YlZlY3RvcnMocG9pbnQsIGEpO1xuXG5cdFx0XHRjb25zdCBkb3QwMCA9IF92MCQxLmRvdChfdjAkMSk7XG5cblx0XHRcdGNvbnN0IGRvdDAxID0gX3YwJDEuZG90KF92MSQzKTtcblxuXHRcdFx0Y29uc3QgZG90MDIgPSBfdjAkMS5kb3QoX3YyJDIpO1xuXG5cdFx0XHRjb25zdCBkb3QxMSA9IF92MSQzLmRvdChfdjEkMyk7XG5cblx0XHRcdGNvbnN0IGRvdDEyID0gX3YxJDMuZG90KF92MiQyKTtcblxuXHRcdFx0Y29uc3QgZGVub20gPSBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMTsgLy8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG5cblx0XHRcdGlmIChkZW5vbSA9PT0gMCkge1xuXHRcdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cblx0XHRcdFx0Ly8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnNldCgtMiwgLTEsIC0xKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW52RGVub20gPSAxIC8gZGVub207XG5cdFx0XHRjb25zdCB1ID0gKGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSAqIGludkRlbm9tO1xuXHRcdFx0Y29uc3QgdiA9IChkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgKiBpbnZEZW5vbTsgLy8gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcblxuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoMSAtIHUgLSB2LCB2LCB1KTtcblx0XHR9XG5cblx0XHRzdGF0aWMgY29udGFpbnNQb2ludChwb2ludCwgYSwgYiwgYykge1xuXHRcdFx0dGhpcy5nZXRCYXJ5Y29vcmQocG9pbnQsIGEsIGIsIGMsIF92MyQxKTtcblx0XHRcdHJldHVybiBfdjMkMS54ID49IDAgJiYgX3YzJDEueSA+PSAwICYmIF92MyQxLnggKyBfdjMkMS55IDw9IDE7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGdldFVWKHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQpIHtcblx0XHRcdHRoaXMuZ2V0QmFyeWNvb3JkKHBvaW50LCBwMSwgcDIsIHAzLCBfdjMkMSk7XG5cdFx0XHR0YXJnZXQuc2V0KDAsIDApO1xuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcih1djEsIF92MyQxLngpO1xuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcih1djIsIF92MyQxLnkpO1xuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcih1djMsIF92MyQxLnopO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRzdGF0aWMgaXNGcm9udEZhY2luZyhhLCBiLCBjLCBkaXJlY3Rpb24pIHtcblx0XHRcdF92MCQxLnN1YlZlY3RvcnMoYywgYik7XG5cblx0XHRcdF92MSQzLnN1YlZlY3RvcnMoYSwgYik7IC8vIHN0cmljdGx5IGZyb250IGZhY2luZ1xuXG5cblx0XHRcdHJldHVybiBfdjAkMS5jcm9zcyhfdjEkMykuZG90KGRpcmVjdGlvbikgPCAwID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdH1cblxuXHRcdHNldChhLCBiLCBjKSB7XG5cdFx0XHR0aGlzLmEuY29weShhKTtcblx0XHRcdHRoaXMuYi5jb3B5KGIpO1xuXHRcdFx0dGhpcy5jLmNvcHkoYyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tUG9pbnRzQW5kSW5kaWNlcyhwb2ludHMsIGkwLCBpMSwgaTIpIHtcblx0XHRcdHRoaXMuYS5jb3B5KHBvaW50c1tpMF0pO1xuXHRcdFx0dGhpcy5iLmNvcHkocG9pbnRzW2kxXSk7XG5cdFx0XHR0aGlzLmMuY29weShwb2ludHNbaTJdKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHRjb3B5KHRyaWFuZ2xlKSB7XG5cdFx0XHR0aGlzLmEuY29weSh0cmlhbmdsZS5hKTtcblx0XHRcdHRoaXMuYi5jb3B5KHRyaWFuZ2xlLmIpO1xuXHRcdFx0dGhpcy5jLmNvcHkodHJpYW5nbGUuYyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRBcmVhKCkge1xuXHRcdFx0X3YwJDEuc3ViVmVjdG9ycyh0aGlzLmMsIHRoaXMuYik7XG5cblx0XHRcdF92MSQzLnN1YlZlY3RvcnModGhpcy5hLCB0aGlzLmIpO1xuXG5cdFx0XHRyZXR1cm4gX3YwJDEuY3Jvc3MoX3YxJDMpLmxlbmd0aCgpICogMC41O1xuXHRcdH1cblxuXHRcdGdldE1pZHBvaW50KHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKHRoaXMuYSwgdGhpcy5iKS5hZGQodGhpcy5jKS5tdWx0aXBseVNjYWxhcigxIC8gMyk7XG5cdFx0fVxuXG5cdFx0Z2V0Tm9ybWFsKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIFRyaWFuZ2xlLmdldE5vcm1hbCh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGdldFBsYW5lKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tQ29wbGFuYXJQb2ludHModGhpcy5hLCB0aGlzLmIsIHRoaXMuYyk7XG5cdFx0fVxuXG5cdFx0Z2V0QmFyeWNvb3JkKHBvaW50LCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiBUcmlhbmdsZS5nZXRCYXJ5Y29vcmQocG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Z2V0VVYocG9pbnQsIHV2MSwgdXYyLCB1djMsIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIFRyaWFuZ2xlLmdldFVWKHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcblx0XHRcdHJldHVybiBUcmlhbmdsZS5jb250YWluc1BvaW50KHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jKTtcblx0XHR9XG5cblx0XHRpc0Zyb250RmFjaW5nKGRpcmVjdGlvbikge1xuXHRcdFx0cmV0dXJuIFRyaWFuZ2xlLmlzRnJvbnRGYWNpbmcodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgZGlyZWN0aW9uKTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzQm94KGJveCkge1xuXHRcdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzVHJpYW5nbGUodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y2xvc2VzdFBvaW50VG9Qb2ludChwLCB0YXJnZXQpIHtcblx0XHRcdGNvbnN0IGEgPSB0aGlzLmEsXG5cdFx0XHRcdFx0XHRiID0gdGhpcy5iLFxuXHRcdFx0XHRcdFx0YyA9IHRoaXMuYztcblx0XHRcdGxldCB2LCB3OyAvLyBhbGdvcml0aG0gdGhhbmtzIHRvIFJlYWwtVGltZSBDb2xsaXNpb24gRGV0ZWN0aW9uIGJ5IENocmlzdGVyIEVyaWNzb24sXG5cdFx0XHQvLyBwdWJsaXNoZWQgYnkgTW9yZ2FuIEthdWZtYW5uIFB1Ymxpc2hlcnMsIChjKSAyMDA1IEVsc2V2aWVyIEluYy4sXG5cdFx0XHQvLyB1bmRlciB0aGUgYWNjb21wYW55aW5nIGxpY2Vuc2U7IHNlZSBjaGFwdGVyIDUuMS41IGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbi5cblx0XHRcdC8vIGJhc2ljYWxseSwgd2UncmUgZGlzdGluZ3Vpc2hpbmcgd2hpY2ggb2YgdGhlIHZvcm9ub2kgcmVnaW9ucyBvZiB0aGUgdHJpYW5nbGVcblx0XHRcdC8vIHRoZSBwb2ludCBsaWVzIGluIHdpdGggdGhlIG1pbmltdW0gYW1vdW50IG9mIHJlZHVuZGFudCBjb21wdXRhdGlvbi5cblxuXHRcdFx0X3ZhYi5zdWJWZWN0b3JzKGIsIGEpO1xuXG5cdFx0XHRfdmFjLnN1YlZlY3RvcnMoYywgYSk7XG5cblx0XHRcdF92YXAuc3ViVmVjdG9ycyhwLCBhKTtcblxuXHRcdFx0Y29uc3QgZDEgPSBfdmFiLmRvdChfdmFwKTtcblxuXHRcdFx0Y29uc3QgZDIgPSBfdmFjLmRvdChfdmFwKTtcblxuXHRcdFx0aWYgKGQxIDw9IDAgJiYgZDIgPD0gMCkge1xuXHRcdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEE7IGJhcnljZW50cmljIGNvb3JkcyAoMSwgMCwgMClcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRfdmJwLnN1YlZlY3RvcnMocCwgYik7XG5cblx0XHRcdGNvbnN0IGQzID0gX3ZhYi5kb3QoX3ZicCk7XG5cblx0XHRcdGNvbnN0IGQ0ID0gX3ZhYy5kb3QoX3ZicCk7XG5cblx0XHRcdGlmIChkMyA+PSAwICYmIGQ0IDw9IGQzKSB7XG5cdFx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQjsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLCAwKVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYik7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZjID0gZDEgKiBkNCAtIGQzICogZDI7XG5cblx0XHRcdGlmICh2YyA8PSAwICYmIGQxID49IDAgJiYgZDMgPD0gMCkge1xuXHRcdFx0XHR2ID0gZDEgLyAoZDEgLSBkMyk7IC8vIGVkZ2UgcmVnaW9uIG9mIEFCOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEtdiwgdiwgMClcblxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYSkuYWRkU2NhbGVkVmVjdG9yKF92YWIsIHYpO1xuXHRcdFx0fVxuXG5cdFx0XHRfdmNwLnN1YlZlY3RvcnMocCwgYyk7XG5cblx0XHRcdGNvbnN0IGQ1ID0gX3ZhYi5kb3QoX3ZjcCk7XG5cblx0XHRcdGNvbnN0IGQ2ID0gX3ZhYy5kb3QoX3ZjcCk7XG5cblx0XHRcdGlmIChkNiA+PSAwICYmIGQ1IDw9IGQ2KSB7XG5cdFx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAwLCAxKVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZiID0gZDUgKiBkMiAtIGQxICogZDY7XG5cblx0XHRcdGlmICh2YiA8PSAwICYmIGQyID49IDAgJiYgZDYgPD0gMCkge1xuXHRcdFx0XHR3ID0gZDIgLyAoZDIgLSBkNik7IC8vIGVkZ2UgcmVnaW9uIG9mIEFDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEtdywgMCwgdylcblxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYSkuYWRkU2NhbGVkVmVjdG9yKF92YWMsIHcpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2YSA9IGQzICogZDYgLSBkNSAqIGQ0O1xuXG5cdFx0XHRpZiAodmEgPD0gMCAmJiBkNCAtIGQzID49IDAgJiYgZDUgLSBkNiA+PSAwKSB7XG5cdFx0XHRcdF92YmMuc3ViVmVjdG9ycyhjLCBiKTtcblxuXHRcdFx0XHR3ID0gKGQ0IC0gZDMpIC8gKGQ0IC0gZDMgKyAoZDUgLSBkNikpOyAvLyBlZGdlIHJlZ2lvbiBvZiBCQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLXcsIHcpXG5cblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KGIpLmFkZFNjYWxlZFZlY3RvcihfdmJjLCB3KTsgLy8gZWRnZSByZWdpb24gb2YgQkNcblx0XHRcdH0gLy8gZmFjZSByZWdpb25cblxuXG5cdFx0XHRjb25zdCBkZW5vbSA9IDEgLyAodmEgKyB2YiArIHZjKTsgLy8gdSA9IHZhICogZGVub21cblxuXHRcdFx0diA9IHZiICogZGVub207XG5cdFx0XHR3ID0gdmMgKiBkZW5vbTtcblx0XHRcdHJldHVybiB0YXJnZXQuY29weShhKS5hZGRTY2FsZWRWZWN0b3IoX3ZhYiwgdikuYWRkU2NhbGVkVmVjdG9yKF92YWMsIHcpO1xuXHRcdH1cblxuXHRcdGVxdWFscyh0cmlhbmdsZSkge1xuXHRcdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKHRoaXMuYSkgJiYgdHJpYW5nbGUuYi5lcXVhbHModGhpcy5iKSAmJiB0cmlhbmdsZS5jLmVxdWFscyh0aGlzLmMpO1xuXHRcdH1cblxuXHR9XG5cblx0bGV0IG1hdGVyaWFsSWQgPSAwO1xuXG5cdGNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuXHRcdFx0XHR2YWx1ZTogbWF0ZXJpYWxJZCsrXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5mb2cgPSB0cnVlO1xuXHRcdFx0dGhpcy5ibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuXHRcdFx0dGhpcy5zaWRlID0gRnJvbnRTaWRlO1xuXHRcdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcblx0XHRcdHRoaXMub3BhY2l0eSA9IDE7XG5cdFx0XHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cdFx0XHR0aGlzLmJsZW5kU3JjID0gU3JjQWxwaGFGYWN0b3I7XG5cdFx0XHR0aGlzLmJsZW5kRHN0ID0gT25lTWludXNTcmNBbHBoYUZhY3Rvcjtcblx0XHRcdHRoaXMuYmxlbmRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xuXHRcdFx0dGhpcy5ibGVuZFNyY0FscGhhID0gbnVsbDtcblx0XHRcdHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cdFx0XHR0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xuXHRcdFx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuXHRcdFx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IDB4ZmY7XG5cdFx0XHR0aGlzLnN0ZW5jaWxGdW5jID0gQWx3YXlzU3RlbmNpbEZ1bmM7XG5cdFx0XHR0aGlzLnN0ZW5jaWxSZWYgPSAwO1xuXHRcdFx0dGhpcy5zdGVuY2lsRnVuY01hc2sgPSAweGZmO1xuXHRcdFx0dGhpcy5zdGVuY2lsRmFpbCA9IEtlZXBTdGVuY2lsT3A7XG5cdFx0XHR0aGlzLnN0ZW5jaWxaRmFpbCA9IEtlZXBTdGVuY2lsT3A7XG5cdFx0XHR0aGlzLnN0ZW5jaWxaUGFzcyA9IEtlZXBTdGVuY2lsT3A7XG5cdFx0XHR0aGlzLnN0ZW5jaWxXcml0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IG51bGw7XG5cdFx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBmYWxzZTtcblx0XHRcdHRoaXMuY2xpcFNoYWRvd3MgPSBmYWxzZTtcblx0XHRcdHRoaXMuc2hhZG93U2lkZSA9IG51bGw7XG5cdFx0XHR0aGlzLmNvbG9yV3JpdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxuXG5cdFx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcblx0XHRcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IDA7XG5cdFx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XG5cdFx0XHR0aGlzLmRpdGhlcmluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5hbHBoYVRlc3QgPSAwO1xuXHRcdFx0dGhpcy5hbHBoYVRvQ292ZXJhZ2UgPSBmYWxzZTtcblx0XHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG5cdFx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXHRcdFx0dGhpcy50b25lTWFwcGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblx0XHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cdFx0fVxuXG5cdFx0b25CdWlsZCgpXG5cdFx0Lyogc2hhZGVyb2JqZWN0LCByZW5kZXJlciAqL1xuXHRcdHt9XG5cblx0XHRvbkJlZm9yZUNvbXBpbGUoKVxuXHRcdC8qIHNoYWRlcm9iamVjdCwgcmVuZGVyZXIgKi9cblx0XHR7fVxuXG5cdFx0Y3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub25CZWZvcmVDb21waWxlLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0c2V0VmFsdWVzKHZhbHVlcykge1xuXHRcdFx0aWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuXHRcdFx0XHRjb25zdCBuZXdWYWx1ZSA9IHZhbHVlc1trZXldO1xuXG5cdFx0XHRcdGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRlcmlhbDogXFwnJyArIGtleSArICdcXCcgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC4nKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fSAvLyBmb3IgYmFja3dhcmQgY29tcGF0YWJpbGl0eSBpZiBzaGFkaW5nIGlzIHNldCBpbiB0aGUgY29uc3RydWN0b3JcblxuXG5cdFx0XHRcdGlmIChrZXkgPT09ICdzaGFkaW5nJykge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC5zaGFkaW5nIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB0aGUgYm9vbGVhbiAuZmxhdFNoYWRpbmcgaW5zdGVhZC4nKTtcblx0XHRcdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gbmV3VmFsdWUgPT09IEZsYXRTaGFkaW5nID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgY3VycmVudFZhbHVlID0gdGhpc1trZXldO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuJyArIHRoaXMudHlwZSArICc6IFxcJycgKyBrZXkgKyAnXFwnIGlzIG5vdCBhIHByb3BlcnR5IG9mIHRoaXMgbWF0ZXJpYWwuJyk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc0NvbG9yKSB7XG5cdFx0XHRcdFx0Y3VycmVudFZhbHVlLnNldChuZXdWYWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc1ZlY3RvcjMgJiYgbmV3VmFsdWUgJiYgbmV3VmFsdWUuaXNWZWN0b3IzKSB7XG5cdFx0XHRcdFx0Y3VycmVudFZhbHVlLmNvcHkobmV3VmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXNba2V5XSA9IG5ld1ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdGNvbnN0IGlzUm9vdCA9IG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZyc7XG5cblx0XHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdFx0bWV0YSA9IHtcblx0XHRcdFx0XHR0ZXh0dXJlczoge30sXG5cdFx0XHRcdFx0aW1hZ2VzOiB7fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHRcdHZlcnNpb246IDQuNSxcblx0XHRcdFx0XHR0eXBlOiAnTWF0ZXJpYWwnLFxuXHRcdFx0XHRcdGdlbmVyYXRvcjogJ01hdGVyaWFsLnRvSlNPTidcblx0XHRcdFx0fVxuXHRcdFx0fTsgLy8gc3RhbmRhcmQgTWF0ZXJpYWwgc2VyaWFsaXphdGlvblxuXG5cdFx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG5cdFx0XHRpZiAodGhpcy5uYW1lICE9PSAnJykgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdFx0aWYgKHRoaXMuY29sb3IgJiYgdGhpcy5jb2xvci5pc0NvbG9yKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblx0XHRcdGlmICh0aGlzLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLnJvdWdobmVzcyA9IHRoaXMucm91Z2huZXNzO1xuXHRcdFx0aWYgKHRoaXMubWV0YWxuZXNzICE9PSB1bmRlZmluZWQpIGRhdGEubWV0YWxuZXNzID0gdGhpcy5tZXRhbG5lc3M7XG5cdFx0XHRpZiAodGhpcy5zaGVlbiAmJiB0aGlzLnNoZWVuLmlzQ29sb3IpIGRhdGEuc2hlZW4gPSB0aGlzLnNoZWVuLmdldEhleCgpO1xuXHRcdFx0aWYgKHRoaXMuZW1pc3NpdmUgJiYgdGhpcy5lbWlzc2l2ZS5pc0NvbG9yKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcblx0XHRcdGlmICh0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICYmIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgIT09IDEpIGRhdGEuZW1pc3NpdmVJbnRlbnNpdHkgPSB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5O1xuXHRcdFx0aWYgKHRoaXMuc3BlY3VsYXIgJiYgdGhpcy5zcGVjdWxhci5pc0NvbG9yKSBkYXRhLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKTtcblx0XHRcdGlmICh0aGlzLnNwZWN1bGFySW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIGRhdGEuc3BlY3VsYXJJbnRlbnNpdHkgPSB0aGlzLnNwZWN1bGFySW50ZW5zaXR5O1xuXHRcdFx0aWYgKHRoaXMuc3BlY3VsYXJUaW50ICYmIHRoaXMuc3BlY3VsYXJUaW50LmlzQ29sb3IpIGRhdGEuc3BlY3VsYXJUaW50ID0gdGhpcy5zcGVjdWxhclRpbnQuZ2V0SGV4KCk7XG5cdFx0XHRpZiAodGhpcy5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcblx0XHRcdGlmICh0aGlzLmNsZWFyY29hdCAhPT0gdW5kZWZpbmVkKSBkYXRhLmNsZWFyY29hdCA9IHRoaXMuY2xlYXJjb2F0O1xuXHRcdFx0aWYgKHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzICE9PSB1bmRlZmluZWQpIGRhdGEuY2xlYXJjb2F0Um91Z2huZXNzID0gdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3M7XG5cblx0XHRcdGlmICh0aGlzLmNsZWFyY29hdE1hcCAmJiB0aGlzLmNsZWFyY29hdE1hcC5pc1RleHR1cmUpIHtcblx0XHRcdFx0ZGF0YS5jbGVhcmNvYXRNYXAgPSB0aGlzLmNsZWFyY29hdE1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwICYmIHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRkYXRhLmNsZWFyY29hdFJvdWdobmVzc01hcCA9IHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5jbGVhcmNvYXROb3JtYWxNYXAgJiYgdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdGRhdGEuY2xlYXJjb2F0Tm9ybWFsTWFwID0gdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRcdGRhdGEuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSB0aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlLnRvQXJyYXkoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMubWFwICYmIHRoaXMubWFwLmlzVGV4dHVyZSkgZGF0YS5tYXAgPSB0aGlzLm1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdGlmICh0aGlzLm1hdGNhcCAmJiB0aGlzLm1hdGNhcC5pc1RleHR1cmUpIGRhdGEubWF0Y2FwID0gdGhpcy5tYXRjYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRpZiAodGhpcy5hbHBoYU1hcCAmJiB0aGlzLmFscGhhTWFwLmlzVGV4dHVyZSkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cblx0XHRcdGlmICh0aGlzLmxpZ2h0TWFwICYmIHRoaXMubGlnaHRNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0XHRkYXRhLmxpZ2h0TWFwSW50ZW5zaXR5ID0gdGhpcy5saWdodE1hcEludGVuc2l0eTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuYW9NYXAgJiYgdGhpcy5hb01hcC5pc1RleHR1cmUpIHtcblx0XHRcdFx0ZGF0YS5hb01hcCA9IHRoaXMuYW9NYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRcdGRhdGEuYW9NYXBJbnRlbnNpdHkgPSB0aGlzLmFvTWFwSW50ZW5zaXR5O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5idW1wTWFwICYmIHRoaXMuYnVtcE1hcC5pc1RleHR1cmUpIHtcblx0XHRcdFx0ZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0XHRkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5ub3JtYWxNYXAgJiYgdGhpcy5ub3JtYWxNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRcdGRhdGEubm9ybWFsTWFwVHlwZSA9IHRoaXMubm9ybWFsTWFwVHlwZTtcblx0XHRcdFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5kaXNwbGFjZW1lbnRNYXAgJiYgdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50U2NhbGUgPSB0aGlzLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0XHRkYXRhLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUpIGRhdGEucm91Z2huZXNzTWFwID0gdGhpcy5yb3VnaG5lc3NNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRpZiAodGhpcy5tZXRhbG5lc3NNYXAgJiYgdGhpcy5tZXRhbG5lc3NNYXAuaXNUZXh0dXJlKSBkYXRhLm1ldGFsbmVzc01hcCA9IHRoaXMubWV0YWxuZXNzTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMuZW1pc3NpdmVNYXAgJiYgdGhpcy5lbWlzc2l2ZU1hcC5pc1RleHR1cmUpIGRhdGEuZW1pc3NpdmVNYXAgPSB0aGlzLmVtaXNzaXZlTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMuc3BlY3VsYXJNYXAgJiYgdGhpcy5zcGVjdWxhck1hcC5pc1RleHR1cmUpIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAgJiYgdGhpcy5zcGVjdWxhckludGVuc2l0eU1hcC5pc1RleHR1cmUpIGRhdGEuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMuc3BlY3VsYXJUaW50TWFwICYmIHRoaXMuc3BlY3VsYXJUaW50TWFwLmlzVGV4dHVyZSkgZGF0YS5zcGVjdWxhclRpbnRNYXAgPSB0aGlzLnNwZWN1bGFyVGludE1hcC50b0pTT04obWV0YSkudXVpZDtcblxuXHRcdFx0aWYgKHRoaXMuZW52TWFwICYmIHRoaXMuZW52TWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0XHRpZiAodGhpcy5jb21iaW5lICE9PSB1bmRlZmluZWQpIGRhdGEuY29tYmluZSA9IHRoaXMuY29tYmluZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZW52TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIGRhdGEuZW52TWFwSW50ZW5zaXR5ID0gdGhpcy5lbnZNYXBJbnRlbnNpdHk7XG5cdFx0XHRpZiAodGhpcy5yZWZsZWN0aXZpdHkgIT09IHVuZGVmaW5lZCkgZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcblx0XHRcdGlmICh0aGlzLnJlZnJhY3Rpb25SYXRpbyAhPT0gdW5kZWZpbmVkKSBkYXRhLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0XHRpZiAodGhpcy5ncmFkaWVudE1hcCAmJiB0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRkYXRhLmdyYWRpZW50TWFwID0gdGhpcy5ncmFkaWVudE1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMudHJhbnNtaXNzaW9uICE9PSB1bmRlZmluZWQpIGRhdGEudHJhbnNtaXNzaW9uID0gdGhpcy50cmFuc21pc3Npb247XG5cdFx0XHRpZiAodGhpcy50cmFuc21pc3Npb25NYXAgJiYgdGhpcy50cmFuc21pc3Npb25NYXAuaXNUZXh0dXJlKSBkYXRhLnRyYW5zbWlzc2lvbk1hcCA9IHRoaXMudHJhbnNtaXNzaW9uTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMudGhpY2tuZXNzICE9PSB1bmRlZmluZWQpIGRhdGEudGhpY2tuZXNzID0gdGhpcy50aGlja25lc3M7XG5cdFx0XHRpZiAodGhpcy50aGlja25lc3NNYXAgJiYgdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlKSBkYXRhLnRoaWNrbmVzc01hcCA9IHRoaXMudGhpY2tuZXNzTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSBkYXRhLmF0dGVudWF0aW9uRGlzdGFuY2UgPSB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0XHRpZiAodGhpcy5hdHRlbnVhdGlvblRpbnQgIT09IHVuZGVmaW5lZCkgZGF0YS5hdHRlbnVhdGlvblRpbnQgPSB0aGlzLmF0dGVudWF0aW9uVGludC5nZXRIZXgoKTtcblx0XHRcdGlmICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xuXHRcdFx0aWYgKHRoaXMuc2hhZG93U2lkZSAhPT0gbnVsbCkgZGF0YS5zaGFkb3dTaWRlID0gdGhpcy5zaGFkb3dTaWRlO1xuXHRcdFx0aWYgKHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQpIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cdFx0XHRpZiAodGhpcy5ibGVuZGluZyAhPT0gTm9ybWFsQmxlbmRpbmcpIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuXHRcdFx0aWYgKHRoaXMuc2lkZSAhPT0gRnJvbnRTaWRlKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cdFx0XHRpZiAodGhpcy52ZXJ0ZXhDb2xvcnMpIGRhdGEudmVydGV4Q29sb3JzID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLm9wYWNpdHkgPCAxKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cdFx0XHRpZiAodGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG5cdFx0XHRkYXRhLmRlcHRoRnVuYyA9IHRoaXMuZGVwdGhGdW5jO1xuXHRcdFx0ZGF0YS5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcblx0XHRcdGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcblx0XHRcdGRhdGEuY29sb3JXcml0ZSA9IHRoaXMuY29sb3JXcml0ZTtcblx0XHRcdGRhdGEuc3RlbmNpbFdyaXRlID0gdGhpcy5zdGVuY2lsV3JpdGU7XG5cdFx0XHRkYXRhLnN0ZW5jaWxXcml0ZU1hc2sgPSB0aGlzLnN0ZW5jaWxXcml0ZU1hc2s7XG5cdFx0XHRkYXRhLnN0ZW5jaWxGdW5jID0gdGhpcy5zdGVuY2lsRnVuYztcblx0XHRcdGRhdGEuc3RlbmNpbFJlZiA9IHRoaXMuc3RlbmNpbFJlZjtcblx0XHRcdGRhdGEuc3RlbmNpbEZ1bmNNYXNrID0gdGhpcy5zdGVuY2lsRnVuY01hc2s7XG5cdFx0XHRkYXRhLnN0ZW5jaWxGYWlsID0gdGhpcy5zdGVuY2lsRmFpbDtcblx0XHRcdGRhdGEuc3RlbmNpbFpGYWlsID0gdGhpcy5zdGVuY2lsWkZhaWw7XG5cdFx0XHRkYXRhLnN0ZW5jaWxaUGFzcyA9IHRoaXMuc3RlbmNpbFpQYXNzOyAvLyByb3RhdGlvbiAoU3ByaXRlTWF0ZXJpYWwpXG5cblx0XHRcdGlmICh0aGlzLnJvdGF0aW9uICYmIHRoaXMucm90YXRpb24gIT09IDApIGRhdGEucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXHRcdFx0aWYgKHRoaXMucG9seWdvbk9mZnNldCA9PT0gdHJ1ZSkgZGF0YS5wb2x5Z29uT2Zmc2V0ID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgIT09IDApIGRhdGEucG9seWdvbk9mZnNldEZhY3RvciA9IHRoaXMucG9seWdvbk9mZnNldEZhY3Rvcjtcblx0XHRcdGlmICh0aGlzLnBvbHlnb25PZmZzZXRVbml0cyAhPT0gMCkgZGF0YS5wb2x5Z29uT2Zmc2V0VW5pdHMgPSB0aGlzLnBvbHlnb25PZmZzZXRVbml0cztcblx0XHRcdGlmICh0aGlzLmxpbmV3aWR0aCAmJiB0aGlzLmxpbmV3aWR0aCAhPT0gMSkgZGF0YS5saW5ld2lkdGggPSB0aGlzLmxpbmV3aWR0aDtcblx0XHRcdGlmICh0aGlzLmRhc2hTaXplICE9PSB1bmRlZmluZWQpIGRhdGEuZGFzaFNpemUgPSB0aGlzLmRhc2hTaXplO1xuXHRcdFx0aWYgKHRoaXMuZ2FwU2l6ZSAhPT0gdW5kZWZpbmVkKSBkYXRhLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XG5cdFx0XHRpZiAodGhpcy5zY2FsZSAhPT0gdW5kZWZpbmVkKSBkYXRhLnNjYWxlID0gdGhpcy5zY2FsZTtcblx0XHRcdGlmICh0aGlzLmRpdGhlcmluZyA9PT0gdHJ1ZSkgZGF0YS5kaXRoZXJpbmcgPSB0cnVlO1xuXHRcdFx0aWYgKHRoaXMuYWxwaGFUZXN0ID4gMCkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcblx0XHRcdGlmICh0aGlzLmFscGhhVG9Db3ZlcmFnZSA9PT0gdHJ1ZSkgZGF0YS5hbHBoYVRvQ292ZXJhZ2UgPSB0aGlzLmFscGhhVG9Db3ZlcmFnZTtcblx0XHRcdGlmICh0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSkgZGF0YS5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0aGlzLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdGlmICh0aGlzLndpcmVmcmFtZSA9PT0gdHJ1ZSkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcblx0XHRcdGlmICh0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEpIGRhdGEud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHRpZiAodGhpcy53aXJlZnJhbWVMaW5lY2FwICE9PSAncm91bmQnKSBkYXRhLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0XHRpZiAodGhpcy53aXJlZnJhbWVMaW5lam9pbiAhPT0gJ3JvdW5kJykgZGF0YS53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XG5cdFx0XHRpZiAodGhpcy5mbGF0U2hhZGluZyA9PT0gdHJ1ZSkgZGF0YS5mbGF0U2hhZGluZyA9IHRoaXMuZmxhdFNoYWRpbmc7XG5cdFx0XHRpZiAodGhpcy52aXNpYmxlID09PSBmYWxzZSkgZGF0YS52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy50b25lTWFwcGVkID09PSBmYWxzZSkgZGF0YS50b25lTWFwcGVkID0gZmFsc2U7XG5cdFx0XHRpZiAoSlNPTi5zdHJpbmdpZnkodGhpcy51c2VyRGF0YSkgIT09ICd7fScpIGRhdGEudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhOyAvLyBUT0RPOiBDb3BpZWQgZnJvbSBPYmplY3QzRC50b0pTT05cblxuXHRcdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZShjYWNoZSkge1xuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuXHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBjYWNoZVtrZXldO1xuXHRcdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKGRhdGEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0XHRjb25zdCB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS50ZXh0dXJlcyk7XG5cdFx0XHRcdGNvbnN0IGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS5pbWFnZXMpO1xuXHRcdFx0XHRpZiAodGV4dHVyZXMubGVuZ3RoID4gMCkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0XHRpZiAoaW1hZ2VzLmxlbmd0aCA+IDApIGRhdGEuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXHRcdFx0dGhpcy5ibGVuZGluZyA9IHNvdXJjZS5ibGVuZGluZztcblx0XHRcdHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xuXHRcdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXHRcdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XG5cdFx0XHR0aGlzLnRyYW5zcGFyZW50ID0gc291cmNlLnRyYW5zcGFyZW50O1xuXHRcdFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcblx0XHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcblx0XHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xuXHRcdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cdFx0XHR0aGlzLmRlcHRoRnVuYyA9IHNvdXJjZS5kZXB0aEZ1bmM7XG5cdFx0XHR0aGlzLmRlcHRoVGVzdCA9IHNvdXJjZS5kZXB0aFRlc3Q7XG5cdFx0XHR0aGlzLmRlcHRoV3JpdGUgPSBzb3VyY2UuZGVwdGhXcml0ZTtcblx0XHRcdHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IHNvdXJjZS5zdGVuY2lsV3JpdGVNYXNrO1xuXHRcdFx0dGhpcy5zdGVuY2lsRnVuYyA9IHNvdXJjZS5zdGVuY2lsRnVuYztcblx0XHRcdHRoaXMuc3RlbmNpbFJlZiA9IHNvdXJjZS5zdGVuY2lsUmVmO1xuXHRcdFx0dGhpcy5zdGVuY2lsRnVuY01hc2sgPSBzb3VyY2Uuc3RlbmNpbEZ1bmNNYXNrO1xuXHRcdFx0dGhpcy5zdGVuY2lsRmFpbCA9IHNvdXJjZS5zdGVuY2lsRmFpbDtcblx0XHRcdHRoaXMuc3RlbmNpbFpGYWlsID0gc291cmNlLnN0ZW5jaWxaRmFpbDtcblx0XHRcdHRoaXMuc3RlbmNpbFpQYXNzID0gc291cmNlLnN0ZW5jaWxaUGFzcztcblx0XHRcdHRoaXMuc3RlbmNpbFdyaXRlID0gc291cmNlLnN0ZW5jaWxXcml0ZTtcblx0XHRcdGNvbnN0IHNyY1BsYW5lcyA9IHNvdXJjZS5jbGlwcGluZ1BsYW5lcztcblx0XHRcdGxldCBkc3RQbGFuZXMgPSBudWxsO1xuXG5cdFx0XHRpZiAoc3JjUGxhbmVzICE9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IG4gPSBzcmNQbGFuZXMubGVuZ3RoO1xuXHRcdFx0XHRkc3RQbGFuZXMgPSBuZXcgQXJyYXkobik7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRcdGRzdFBsYW5lc1tpXSA9IHNyY1BsYW5lc1tpXS5jbG9uZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBkc3RQbGFuZXM7XG5cdFx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBzb3VyY2UuY2xpcEludGVyc2VjdGlvbjtcblx0XHRcdHRoaXMuY2xpcFNoYWRvd3MgPSBzb3VyY2UuY2xpcFNoYWRvd3M7XG5cdFx0XHR0aGlzLnNoYWRvd1NpZGUgPSBzb3VyY2Uuc2hhZG93U2lkZTtcblx0XHRcdHRoaXMuY29sb3JXcml0ZSA9IHNvdXJjZS5jb2xvcldyaXRlO1xuXHRcdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xuXHRcdFx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gc291cmNlLnBvbHlnb25PZmZzZXQ7XG5cdFx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzb3VyY2UucG9seWdvbk9mZnNldEZhY3Rvcjtcblx0XHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gc291cmNlLnBvbHlnb25PZmZzZXRVbml0cztcblx0XHRcdHRoaXMuZGl0aGVyaW5nID0gc291cmNlLmRpdGhlcmluZztcblx0XHRcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcblx0XHRcdHRoaXMuYWxwaGFUb0NvdmVyYWdlID0gc291cmNlLmFscGhhVG9Db3ZlcmFnZTtcblx0XHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXHRcdFx0dGhpcy50b25lTWFwcGVkID0gc291cmNlLnRvbmVNYXBwZWQ7XG5cdFx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzb3VyY2UudXNlckRhdGEpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHR0eXBlOiAnZGlzcG9zZSdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHNldCBuZWVkc1VwZGF0ZSh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLnZlcnNpb24rKztcblx0XHR9XG5cblx0fVxuXG5cdE1hdGVyaWFsLnByb3RvdHlwZS5pc01hdGVyaWFsID0gdHJ1ZTtcblxuXHRjb25zdCBfY29sb3JLZXl3b3JkcyA9IHtcblx0XHQnYWxpY2VibHVlJzogMHhGMEY4RkYsXG5cdFx0J2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LFxuXHRcdCdhcXVhJzogMHgwMEZGRkYsXG5cdFx0J2FxdWFtYXJpbmUnOiAweDdGRkZENCxcblx0XHQnYXp1cmUnOiAweEYwRkZGRixcblx0XHQnYmVpZ2UnOiAweEY1RjVEQyxcblx0XHQnYmlzcXVlJzogMHhGRkU0QzQsXG5cdFx0J2JsYWNrJzogMHgwMDAwMDAsXG5cdFx0J2JsYW5jaGVkYWxtb25kJzogMHhGRkVCQ0QsXG5cdFx0J2JsdWUnOiAweDAwMDBGRixcblx0XHQnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxuXHRcdCdicm93bic6IDB4QTUyQTJBLFxuXHRcdCdidXJseXdvb2QnOiAweERFQjg4Nyxcblx0XHQnY2FkZXRibHVlJzogMHg1RjlFQTAsXG5cdFx0J2NoYXJ0cmV1c2UnOiAweDdGRkYwMCxcblx0XHQnY2hvY29sYXRlJzogMHhEMjY5MUUsXG5cdFx0J2NvcmFsJzogMHhGRjdGNTAsXG5cdFx0J2Nvcm5mbG93ZXJibHVlJzogMHg2NDk1RUQsXG5cdFx0J2Nvcm5zaWxrJzogMHhGRkY4REMsXG5cdFx0J2NyaW1zb24nOiAweERDMTQzQyxcblx0XHQnY3lhbic6IDB4MDBGRkZGLFxuXHRcdCdkYXJrYmx1ZSc6IDB4MDAwMDhCLFxuXHRcdCdkYXJrY3lhbic6IDB4MDA4QjhCLFxuXHRcdCdkYXJrZ29sZGVucm9kJzogMHhCODg2MEIsXG5cdFx0J2RhcmtncmF5JzogMHhBOUE5QTksXG5cdFx0J2RhcmtncmVlbic6IDB4MDA2NDAwLFxuXHRcdCdkYXJrZ3JleSc6IDB4QTlBOUE5LFxuXHRcdCdkYXJra2hha2knOiAweEJEQjc2Qixcblx0XHQnZGFya21hZ2VudGEnOiAweDhCMDA4Qixcblx0XHQnZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRixcblx0XHQnZGFya29yYW5nZSc6IDB4RkY4QzAwLFxuXHRcdCdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsXG5cdFx0J2RhcmtyZWQnOiAweDhCMDAwMCxcblx0XHQnZGFya3NhbG1vbic6IDB4RTk5NjdBLFxuXHRcdCdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4Rixcblx0XHQnZGFya3NsYXRlYmx1ZSc6IDB4NDgzRDhCLFxuXHRcdCdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsXG5cdFx0J2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0Rixcblx0XHQnZGFya3R1cnF1b2lzZSc6IDB4MDBDRUQxLFxuXHRcdCdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG5cdFx0J2RlZXBwaW5rJzogMHhGRjE0OTMsXG5cdFx0J2RlZXBza3libHVlJzogMHgwMEJGRkYsXG5cdFx0J2RpbWdyYXknOiAweDY5Njk2OSxcblx0XHQnZGltZ3JleSc6IDB4Njk2OTY5LFxuXHRcdCdkb2RnZXJibHVlJzogMHgxRTkwRkYsXG5cdFx0J2ZpcmVicmljayc6IDB4QjIyMjIyLFxuXHRcdCdmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLFxuXHRcdCdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLFxuXHRcdCdmdWNoc2lhJzogMHhGRjAwRkYsXG5cdFx0J2dhaW5zYm9ybyc6IDB4RENEQ0RDLFxuXHRcdCdnaG9zdHdoaXRlJzogMHhGOEY4RkYsXG5cdFx0J2dvbGQnOiAweEZGRDcwMCxcblx0XHQnZ29sZGVucm9kJzogMHhEQUE1MjAsXG5cdFx0J2dyYXknOiAweDgwODA4MCxcblx0XHQnZ3JlZW4nOiAweDAwODAwMCxcblx0XHQnZ3JlZW55ZWxsb3cnOiAweEFERkYyRixcblx0XHQnZ3JleSc6IDB4ODA4MDgwLFxuXHRcdCdob25leWRldyc6IDB4RjBGRkYwLFxuXHRcdCdob3RwaW5rJzogMHhGRjY5QjQsXG5cdFx0J2luZGlhbnJlZCc6IDB4Q0Q1QzVDLFxuXHRcdCdpbmRpZ28nOiAweDRCMDA4Mixcblx0XHQnaXZvcnknOiAweEZGRkZGMCxcblx0XHQna2hha2knOiAweEYwRTY4Qyxcblx0XHQnbGF2ZW5kZXInOiAweEU2RTZGQSxcblx0XHQnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LFxuXHRcdCdsYXduZ3JlZW4nOiAweDdDRkMwMCxcblx0XHQnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsXG5cdFx0J2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LFxuXHRcdCdsaWdodGNvcmFsJzogMHhGMDgwODAsXG5cdFx0J2xpZ2h0Y3lhbic6IDB4RTBGRkZGLFxuXHRcdCdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLFxuXHRcdCdsaWdodGdyYXknOiAweEQzRDNEMyxcblx0XHQnbGlnaHRncmVlbic6IDB4OTBFRTkwLFxuXHRcdCdsaWdodGdyZXknOiAweEQzRDNEMyxcblx0XHQnbGlnaHRwaW5rJzogMHhGRkI2QzEsXG5cdFx0J2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsXG5cdFx0J2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSxcblx0XHQnbGlnaHRza3libHVlJzogMHg4N0NFRkEsXG5cdFx0J2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksXG5cdFx0J2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksXG5cdFx0J2xpZ2h0c3RlZWxibHVlJzogMHhCMEM0REUsXG5cdFx0J2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsXG5cdFx0J2xpbWUnOiAweDAwRkYwMCxcblx0XHQnbGltZWdyZWVuJzogMHgzMkNEMzIsXG5cdFx0J2xpbmVuJzogMHhGQUYwRTYsXG5cdFx0J21hZ2VudGEnOiAweEZGMDBGRixcblx0XHQnbWFyb29uJzogMHg4MDAwMDAsXG5cdFx0J21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSxcblx0XHQnbWVkaXVtYmx1ZSc6IDB4MDAwMENELFxuXHRcdCdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcblx0XHQnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsXG5cdFx0J21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsXG5cdFx0J21lZGl1bXNsYXRlYmx1ZSc6IDB4N0I2OEVFLFxuXHRcdCdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLFxuXHRcdCdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcblx0XHQnbWVkaXVtdmlvbGV0cmVkJzogMHhDNzE1ODUsXG5cdFx0J21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLFxuXHRcdCdtaW50Y3JlYW0nOiAweEY1RkZGQSxcblx0XHQnbWlzdHlyb3NlJzogMHhGRkU0RTEsXG5cdFx0J21vY2Nhc2luJzogMHhGRkU0QjUsXG5cdFx0J25hdmFqb3doaXRlJzogMHhGRkRFQUQsXG5cdFx0J25hdnknOiAweDAwMDA4MCxcblx0XHQnb2xkbGFjZSc6IDB4RkRGNUU2LFxuXHRcdCdvbGl2ZSc6IDB4ODA4MDAwLFxuXHRcdCdvbGl2ZWRyYWInOiAweDZCOEUyMyxcblx0XHQnb3JhbmdlJzogMHhGRkE1MDAsXG5cdFx0J29yYW5nZXJlZCc6IDB4RkY0NTAwLFxuXHRcdCdvcmNoaWQnOiAweERBNzBENixcblx0XHQncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLFxuXHRcdCdwYWxlZ3JlZW4nOiAweDk4RkI5OCxcblx0XHQncGFsZXR1cnF1b2lzZSc6IDB4QUZFRUVFLFxuXHRcdCdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsXG5cdFx0J3BhcGF5YXdoaXAnOiAweEZGRUZENSxcblx0XHQncGVhY2hwdWZmJzogMHhGRkRBQjksXG5cdFx0J3BlcnUnOiAweENEODUzRixcblx0XHQncGluayc6IDB4RkZDMENCLFxuXHRcdCdwbHVtJzogMHhEREEwREQsXG5cdFx0J3Bvd2RlcmJsdWUnOiAweEIwRTBFNixcblx0XHQncHVycGxlJzogMHg4MDAwODAsXG5cdFx0J3JlYmVjY2FwdXJwbGUnOiAweDY2MzM5OSxcblx0XHQncmVkJzogMHhGRjAwMDAsXG5cdFx0J3Jvc3licm93bic6IDB4QkM4RjhGLFxuXHRcdCdyb3lhbGJsdWUnOiAweDQxNjlFMSxcblx0XHQnc2FkZGxlYnJvd24nOiAweDhCNDUxMyxcblx0XHQnc2FsbW9uJzogMHhGQTgwNzIsXG5cdFx0J3NhbmR5YnJvd24nOiAweEY0QTQ2MCxcblx0XHQnc2VhZ3JlZW4nOiAweDJFOEI1Nyxcblx0XHQnc2Vhc2hlbGwnOiAweEZGRjVFRSxcblx0XHQnc2llbm5hJzogMHhBMDUyMkQsXG5cdFx0J3NpbHZlcic6IDB4QzBDMEMwLFxuXHRcdCdza3libHVlJzogMHg4N0NFRUIsXG5cdFx0J3NsYXRlYmx1ZSc6IDB4NkE1QUNELFxuXHRcdCdzbGF0ZWdyYXknOiAweDcwODA5MCxcblx0XHQnc2xhdGVncmV5JzogMHg3MDgwOTAsXG5cdFx0J3Nub3cnOiAweEZGRkFGQSxcblx0XHQnc3ByaW5nZ3JlZW4nOiAweDAwRkY3Rixcblx0XHQnc3RlZWxibHVlJzogMHg0NjgyQjQsXG5cdFx0J3Rhbic6IDB4RDJCNDhDLFxuXHRcdCd0ZWFsJzogMHgwMDgwODAsXG5cdFx0J3RoaXN0bGUnOiAweEQ4QkZEOCxcblx0XHQndG9tYXRvJzogMHhGRjYzNDcsXG5cdFx0J3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuXHRcdCd2aW9sZXQnOiAweEVFODJFRSxcblx0XHQnd2hlYXQnOiAweEY1REVCMyxcblx0XHQnd2hpdGUnOiAweEZGRkZGRixcblx0XHQnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LFxuXHRcdCd5ZWxsb3cnOiAweEZGRkYwMCxcblx0XHQneWVsbG93Z3JlZW4nOiAweDlBQ0QzMlxuXHR9O1xuXHRjb25zdCBfaHNsQSA9IHtcblx0XHRoOiAwLFxuXHRcdHM6IDAsXG5cdFx0bDogMFxuXHR9O1xuXHRjb25zdCBfaHNsQiA9IHtcblx0XHRoOiAwLFxuXHRcdHM6IDAsXG5cdFx0bDogMFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuXHRcdGlmICh0IDwgMCkgdCArPSAxO1xuXHRcdGlmICh0ID4gMSkgdCAtPSAxO1xuXHRcdGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuXHRcdGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuXHRcdGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiAoMiAvIDMgLSB0KTtcblx0XHRyZXR1cm4gcDtcblx0fVxuXG5cdGZ1bmN0aW9uIFNSR0JUb0xpbmVhcihjKSB7XG5cdFx0cmV0dXJuIGMgPCAwLjA0MDQ1ID8gYyAqIDAuMDc3Mzk5MzgwOCA6IE1hdGgucG93KGMgKiAwLjk0Nzg2NzI5ODYgKyAwLjA1MjEzMjcwMTQsIDIuNCk7XG5cdH1cblxuXHRmdW5jdGlvbiBMaW5lYXJUb1NSR0IoYykge1xuXHRcdHJldHVybiBjIDwgMC4wMDMxMzA4ID8gYyAqIDEyLjkyIDogMS4wNTUgKiBNYXRoLnBvdyhjLCAwLjQxNjY2KSAtIDAuMDU1O1xuXHR9XG5cblx0Y2xhc3MgQ29sb3Ige1xuXHRcdGNvbnN0cnVjdG9yKHIsIGcsIGIpIHtcblx0XHRcdGlmIChnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIHIgaXMgVEhSRUUuQ29sb3IsIGhleCBvciBzdHJpbmdcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KHIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRSR0IociwgZywgYik7XG5cdFx0fVxuXG5cdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuaXNDb2xvcikge1xuXHRcdFx0XHR0aGlzLmNvcHkodmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHRoaXMuc2V0SGV4KHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFN0eWxlKHZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0U2NhbGFyKHNjYWxhcikge1xuXHRcdFx0dGhpcy5yID0gc2NhbGFyO1xuXHRcdFx0dGhpcy5nID0gc2NhbGFyO1xuXHRcdFx0dGhpcy5iID0gc2NhbGFyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0SGV4KGhleCkge1xuXHRcdFx0aGV4ID0gTWF0aC5mbG9vcihoZXgpO1xuXHRcdFx0dGhpcy5yID0gKGhleCA+PiAxNiAmIDI1NSkgLyAyNTU7XG5cdFx0XHR0aGlzLmcgPSAoaGV4ID4+IDggJiAyNTUpIC8gMjU1O1xuXHRcdFx0dGhpcy5iID0gKGhleCAmIDI1NSkgLyAyNTU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRSR0IociwgZywgYikge1xuXHRcdFx0dGhpcy5yID0gcjtcblx0XHRcdHRoaXMuZyA9IGc7XG5cdFx0XHR0aGlzLmIgPSBiO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0SFNMKGgsIHMsIGwpIHtcblx0XHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG5cdFx0XHRoID0gZXVjbGlkZWFuTW9kdWxvKGgsIDEpO1xuXHRcdFx0cyA9IGNsYW1wKHMsIDAsIDEpO1xuXHRcdFx0bCA9IGNsYW1wKGwsIDAsIDEpO1xuXG5cdFx0XHRpZiAocyA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgcCA9IGwgPD0gMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuXHRcdFx0XHRjb25zdCBxID0gMiAqIGwgLSBwO1xuXHRcdFx0XHR0aGlzLnIgPSBodWUycmdiKHEsIHAsIGggKyAxIC8gMyk7XG5cdFx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IocSwgcCwgaCk7XG5cdFx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IocSwgcCwgaCAtIDEgLyAzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0U3R5bGUoc3R5bGUpIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZUFscGhhKHN0cmluZykge1xuXHRcdFx0XHRpZiAoc3RyaW5nID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuXHRcdFx0XHRpZiAocGFyc2VGbG9hdChzdHJpbmcpIDwgMSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbTtcblxuXHRcdFx0aWYgKG0gPSAvXigoPzpyZ2J8aHNsKWE/KVxcKChbXlxcKV0qKVxcKS8uZXhlYyhzdHlsZSkpIHtcblx0XHRcdFx0Ly8gcmdiIC8gaHNsXG5cdFx0XHRcdGxldCBjb2xvcjtcblx0XHRcdFx0Y29uc3QgbmFtZSA9IG1bMV07XG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudHMgPSBtWzJdO1xuXG5cdFx0XHRcdHN3aXRjaCAobmFtZSkge1xuXHRcdFx0XHRcdGNhc2UgJ3JnYic6XG5cdFx0XHRcdFx0Y2FzZSAncmdiYSc6XG5cdFx0XHRcdFx0XHRpZiAoY29sb3IgPSAvXlxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoY29tcG9uZW50cykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXG5cdFx0XHRcdFx0XHRcdHRoaXMuciA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbMV0sIDEwKSkgLyAyNTU7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZyA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbMl0sIDEwKSkgLyAyNTU7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbM10sIDEwKSkgLyAyNTU7XG5cdFx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKGNvbG9yWzRdKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChjb2xvciA9IC9eXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyhjb21wb25lbnRzKSkge1xuXHRcdFx0XHRcdFx0XHQvLyByZ2IoMTAwJSwwJSwwJSkgcmdiYSgxMDAlLDAlLDAlLDAuNSlcblx0XHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oMTAwLCBwYXJzZUludChjb2xvclsxXSwgMTApKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oMTAwLCBwYXJzZUludChjb2xvclsyXSwgMTApKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oMTAwLCBwYXJzZUludChjb2xvclszXSwgMTApKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoY29sb3JbNF0pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdoc2wnOlxuXHRcdFx0XHRcdGNhc2UgJ2hzbGEnOlxuXHRcdFx0XHRcdFx0aWYgKGNvbG9yID0gL15cXHMqKFxcZCpcXC4/XFxkKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoY29tcG9uZW50cykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcblx0XHRcdFx0XHRcdFx0Y29uc3QgaCA9IHBhcnNlRmxvYXQoY29sb3JbMV0pIC8gMzYwO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzID0gcGFyc2VJbnQoY29sb3JbMl0sIDEwKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbCA9IHBhcnNlSW50KGNvbG9yWzNdLCAxMCkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKGNvbG9yWzRdKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SFNMKGgsIHMsIGwpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChtID0gL15cXCMoW0EtRmEtZlxcZF0rKSQvLmV4ZWMoc3R5bGUpKSB7XG5cdFx0XHRcdC8vIGhleCBjb2xvclxuXHRcdFx0XHRjb25zdCBoZXggPSBtWzFdO1xuXHRcdFx0XHRjb25zdCBzaXplID0gaGV4Lmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoc2l6ZSA9PT0gMykge1xuXHRcdFx0XHRcdC8vICNmZjBcblx0XHRcdFx0XHR0aGlzLnIgPSBwYXJzZUludChoZXguY2hhckF0KDApICsgaGV4LmNoYXJBdCgwKSwgMTYpIC8gMjU1O1xuXHRcdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KGhleC5jaGFyQXQoMSkgKyBoZXguY2hhckF0KDEpLCAxNikgLyAyNTU7XG5cdFx0XHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoaGV4LmNoYXJBdCgyKSArIGhleC5jaGFyQXQoMiksIDE2KSAvIDI1NTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSBlbHNlIGlmIChzaXplID09PSA2KSB7XG5cdFx0XHRcdFx0Ly8gI2ZmMDAwMFxuXHRcdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KGhleC5jaGFyQXQoMCkgKyBoZXguY2hhckF0KDEpLCAxNikgLyAyNTU7XG5cdFx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoaGV4LmNoYXJBdCgyKSArIGhleC5jaGFyQXQoMyksIDE2KSAvIDI1NTtcblx0XHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludChoZXguY2hhckF0KDQpICsgaGV4LmNoYXJBdCg1KSwgMTYpIC8gMjU1O1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNldENvbG9yTmFtZShzdHlsZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldENvbG9yTmFtZShzdHlsZSkge1xuXHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcblx0XHRcdGNvbnN0IGhleCA9IF9jb2xvcktleXdvcmRzW3N0eWxlLnRvTG93ZXJDYXNlKCldO1xuXG5cdFx0XHRpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gcmVkXG5cdFx0XHRcdHRoaXMuc2V0SGV4KGhleCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1bmtub3duIGNvbG9yXG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG5cdFx0fVxuXG5cdFx0Y29weShjb2xvcikge1xuXHRcdFx0dGhpcy5yID0gY29sb3Iucjtcblx0XHRcdHRoaXMuZyA9IGNvbG9yLmc7XG5cdFx0XHR0aGlzLmIgPSBjb2xvci5iO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weUdhbW1hVG9MaW5lYXIoY29sb3IsIGdhbW1hRmFjdG9yID0gMi4wKSB7XG5cdFx0XHR0aGlzLnIgPSBNYXRoLnBvdyhjb2xvci5yLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHR0aGlzLmcgPSBNYXRoLnBvdyhjb2xvci5nLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHR0aGlzLmIgPSBNYXRoLnBvdyhjb2xvci5iLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5TGluZWFyVG9HYW1tYShjb2xvciwgZ2FtbWFGYWN0b3IgPSAyLjApIHtcblx0XHRcdGNvbnN0IHNhZmVJbnZlcnNlID0gZ2FtbWFGYWN0b3IgPiAwID8gMS4wIC8gZ2FtbWFGYWN0b3IgOiAxLjA7XG5cdFx0XHR0aGlzLnIgPSBNYXRoLnBvdyhjb2xvci5yLCBzYWZlSW52ZXJzZSk7XG5cdFx0XHR0aGlzLmcgPSBNYXRoLnBvdyhjb2xvci5nLCBzYWZlSW52ZXJzZSk7XG5cdFx0XHR0aGlzLmIgPSBNYXRoLnBvdyhjb2xvci5iLCBzYWZlSW52ZXJzZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb252ZXJ0R2FtbWFUb0xpbmVhcihnYW1tYUZhY3Rvcikge1xuXHRcdFx0dGhpcy5jb3B5R2FtbWFUb0xpbmVhcih0aGlzLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb252ZXJ0TGluZWFyVG9HYW1tYShnYW1tYUZhY3Rvcikge1xuXHRcdFx0dGhpcy5jb3B5TGluZWFyVG9HYW1tYSh0aGlzLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5U1JHQlRvTGluZWFyKGNvbG9yKSB7XG5cdFx0XHR0aGlzLnIgPSBTUkdCVG9MaW5lYXIoY29sb3Iucik7XG5cdFx0XHR0aGlzLmcgPSBTUkdCVG9MaW5lYXIoY29sb3IuZyk7XG5cdFx0XHR0aGlzLmIgPSBTUkdCVG9MaW5lYXIoY29sb3IuYik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5TGluZWFyVG9TUkdCKGNvbG9yKSB7XG5cdFx0XHR0aGlzLnIgPSBMaW5lYXJUb1NSR0IoY29sb3Iucik7XG5cdFx0XHR0aGlzLmcgPSBMaW5lYXJUb1NSR0IoY29sb3IuZyk7XG5cdFx0XHR0aGlzLmIgPSBMaW5lYXJUb1NSR0IoY29sb3IuYik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb252ZXJ0U1JHQlRvTGluZWFyKCkge1xuXHRcdFx0dGhpcy5jb3B5U1JHQlRvTGluZWFyKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29udmVydExpbmVhclRvU1JHQigpIHtcblx0XHRcdHRoaXMuY29weUxpbmVhclRvU1JHQih0aGlzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldEhleCgpIHtcblx0XHRcdHJldHVybiB0aGlzLnIgKiAyNTUgPDwgMTYgXiB0aGlzLmcgKiAyNTUgPDwgOCBeIHRoaXMuYiAqIDI1NSA8PCAwO1xuXHRcdH1cblxuXHRcdGdldEhleFN0cmluZygpIHtcblx0XHRcdHJldHVybiAoJzAwMDAwMCcgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTYpO1xuXHRcdH1cblxuXHRcdGdldEhTTCh0YXJnZXQpIHtcblx0XHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG5cdFx0XHRjb25zdCByID0gdGhpcy5yLFxuXHRcdFx0XHRcdFx0ZyA9IHRoaXMuZyxcblx0XHRcdFx0XHRcdGIgPSB0aGlzLmI7XG5cdFx0XHRjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0XHRcdGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRcdFx0bGV0IGh1ZSwgc2F0dXJhdGlvbjtcblx0XHRcdGNvbnN0IGxpZ2h0bmVzcyA9IChtaW4gKyBtYXgpIC8gMi4wO1xuXG5cdFx0XHRpZiAobWluID09PSBtYXgpIHtcblx0XHRcdFx0aHVlID0gMDtcblx0XHRcdFx0c2F0dXJhdGlvbiA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcblx0XHRcdFx0c2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvIChtYXggKyBtaW4pIDogZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cblx0XHRcdFx0c3dpdGNoIChtYXgpIHtcblx0XHRcdFx0XHRjYXNlIHI6XG5cdFx0XHRcdFx0XHRodWUgPSAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgZzpcblx0XHRcdFx0XHRcdGh1ZSA9IChiIC0gcikgLyBkZWx0YSArIDI7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgYjpcblx0XHRcdFx0XHRcdGh1ZSA9IChyIC0gZykgLyBkZWx0YSArIDQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGh1ZSAvPSA2O1xuXHRcdFx0fVxuXG5cdFx0XHR0YXJnZXQuaCA9IGh1ZTtcblx0XHRcdHRhcmdldC5zID0gc2F0dXJhdGlvbjtcblx0XHRcdHRhcmdldC5sID0gbGlnaHRuZXNzO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRnZXRTdHlsZSgpIHtcblx0XHRcdHJldHVybiAncmdiKCcgKyAodGhpcy5yICogMjU1IHwgMCkgKyAnLCcgKyAodGhpcy5nICogMjU1IHwgMCkgKyAnLCcgKyAodGhpcy5iICogMjU1IHwgMCkgKyAnKSc7XG5cdFx0fVxuXG5cdFx0b2Zmc2V0SFNMKGgsIHMsIGwpIHtcblx0XHRcdHRoaXMuZ2V0SFNMKF9oc2xBKTtcblx0XHRcdF9oc2xBLmggKz0gaDtcblx0XHRcdF9oc2xBLnMgKz0gcztcblx0XHRcdF9oc2xBLmwgKz0gbDtcblx0XHRcdHRoaXMuc2V0SFNMKF9oc2xBLmgsIF9oc2xBLnMsIF9oc2xBLmwpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkKGNvbG9yKSB7XG5cdFx0XHR0aGlzLnIgKz0gY29sb3Iucjtcblx0XHRcdHRoaXMuZyArPSBjb2xvci5nO1xuXHRcdFx0dGhpcy5iICs9IGNvbG9yLmI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRDb2xvcnMoY29sb3IxLCBjb2xvcjIpIHtcblx0XHRcdHRoaXMuciA9IGNvbG9yMS5yICsgY29sb3IyLnI7XG5cdFx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xuXHRcdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFNjYWxhcihzKSB7XG5cdFx0XHR0aGlzLnIgKz0gcztcblx0XHRcdHRoaXMuZyArPSBzO1xuXHRcdFx0dGhpcy5iICs9IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzdWIoY29sb3IpIHtcblx0XHRcdHRoaXMuciA9IE1hdGgubWF4KDAsIHRoaXMuciAtIGNvbG9yLnIpO1xuXHRcdFx0dGhpcy5nID0gTWF0aC5tYXgoMCwgdGhpcy5nIC0gY29sb3IuZyk7XG5cdFx0XHR0aGlzLmIgPSBNYXRoLm1heCgwLCB0aGlzLmIgLSBjb2xvci5iKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5KGNvbG9yKSB7XG5cdFx0XHR0aGlzLnIgKj0gY29sb3Iucjtcblx0XHRcdHRoaXMuZyAqPSBjb2xvci5nO1xuXHRcdFx0dGhpcy5iICo9IGNvbG9yLmI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtdWx0aXBseVNjYWxhcihzKSB7XG5cdFx0XHR0aGlzLnIgKj0gcztcblx0XHRcdHRoaXMuZyAqPSBzO1xuXHRcdFx0dGhpcy5iICo9IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRsZXJwKGNvbG9yLCBhbHBoYSkge1xuXHRcdFx0dGhpcy5yICs9IChjb2xvci5yIC0gdGhpcy5yKSAqIGFscGhhO1xuXHRcdFx0dGhpcy5nICs9IChjb2xvci5nIC0gdGhpcy5nKSAqIGFscGhhO1xuXHRcdFx0dGhpcy5iICs9IChjb2xvci5iIC0gdGhpcy5iKSAqIGFscGhhO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bGVycENvbG9ycyhjb2xvcjEsIGNvbG9yMiwgYWxwaGEpIHtcblx0XHRcdHRoaXMuciA9IGNvbG9yMS5yICsgKGNvbG9yMi5yIC0gY29sb3IxLnIpICogYWxwaGE7XG5cdFx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIChjb2xvcjIuZyAtIGNvbG9yMS5nKSAqIGFscGhhO1xuXHRcdFx0dGhpcy5iID0gY29sb3IxLmIgKyAoY29sb3IyLmIgLSBjb2xvcjEuYikgKiBhbHBoYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGxlcnBIU0woY29sb3IsIGFscGhhKSB7XG5cdFx0XHR0aGlzLmdldEhTTChfaHNsQSk7XG5cdFx0XHRjb2xvci5nZXRIU0woX2hzbEIpO1xuXHRcdFx0Y29uc3QgaCA9IGxlcnAoX2hzbEEuaCwgX2hzbEIuaCwgYWxwaGEpO1xuXHRcdFx0Y29uc3QgcyA9IGxlcnAoX2hzbEEucywgX2hzbEIucywgYWxwaGEpO1xuXHRcdFx0Y29uc3QgbCA9IGxlcnAoX2hzbEEubCwgX2hzbEIubCwgYWxwaGEpO1xuXHRcdFx0dGhpcy5zZXRIU0woaCwgcywgbCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlcXVhbHMoYykge1xuXHRcdFx0cmV0dXJuIGMuciA9PT0gdGhpcy5yICYmIGMuZyA9PT0gdGhpcy5nICYmIGMuYiA9PT0gdGhpcy5iO1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0dGhpcy5yID0gYXJyYXlbb2Zmc2V0XTtcblx0XHRcdHRoaXMuZyA9IGFycmF5W29mZnNldCArIDFdO1xuXHRcdFx0dGhpcy5iID0gYXJyYXlbb2Zmc2V0ICsgMl07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRcdGFycmF5W29mZnNldF0gPSB0aGlzLnI7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMuZztcblx0XHRcdGFycmF5W29mZnNldCArIDJdID0gdGhpcy5iO1xuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHRcdGZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRleCkge1xuXHRcdFx0dGhpcy5yID0gYXR0cmlidXRlLmdldFgoaW5kZXgpO1xuXHRcdFx0dGhpcy5nID0gYXR0cmlidXRlLmdldFkoaW5kZXgpO1xuXHRcdFx0dGhpcy5iID0gYXR0cmlidXRlLmdldFooaW5kZXgpO1xuXG5cdFx0XHRpZiAoYXR0cmlidXRlLm5vcm1hbGl6ZWQgPT09IHRydWUpIHtcblx0XHRcdFx0Ly8gYXNzdW1pbmcgVWludDhBcnJheVxuXHRcdFx0XHR0aGlzLnIgLz0gMjU1O1xuXHRcdFx0XHR0aGlzLmcgLz0gMjU1O1xuXHRcdFx0XHR0aGlzLmIgLz0gMjU1O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRIZXgoKTtcblx0XHR9XG5cblx0fVxuXG5cdENvbG9yLk5BTUVTID0gX2NvbG9yS2V5d29yZHM7XG5cdENvbG9yLnByb3RvdHlwZS5pc0NvbG9yID0gdHJ1ZTtcblx0Q29sb3IucHJvdG90eXBlLnIgPSAxO1xuXHRDb2xvci5wcm90b3R5cGUuZyA9IDE7XG5cdENvbG9yLnByb3RvdHlwZS5iID0gMTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNvbG9yOiA8aGV4Pixcblx0ICpcdG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXHRtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqXHRhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqXHRzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0ZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuXHQgKlx0Y29tYmluZTogVEhSRUUuTXVsdGlwbHksXG5cdCAqXHRyZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG5cdCAqXHRyZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRkZXB0aFRlc3Q6IDxib29sPixcblx0ICpcdGRlcHRoV3JpdGU6IDxib29sPixcblx0ICpcblx0ICpcdHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKlx0d2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcigweGZmZmZmZik7IC8vIGVtaXNzaXZlXG5cblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcblx0XHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0XHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cdFx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblx0XHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaEJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdGNvbnN0IF92ZWN0b3IkOSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92ZWN0b3IyJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxuXHRjbGFzcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBpdGVtU2l6ZSA6IDA7XG5cdFx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09PSB0cnVlO1xuXHRcdFx0dGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcblx0XHRcdHRoaXMudXBkYXRlUmFuZ2UgPSB7XG5cdFx0XHRcdG9mZnNldDogMCxcblx0XHRcdFx0Y291bnQ6IC0xXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0XHR9XG5cblx0XHRvblVwbG9hZENhbGxiYWNrKCkge31cblxuXHRcdHNldCBuZWVkc1VwZGF0ZSh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLnZlcnNpb24rKztcblx0XHR9XG5cblx0XHRzZXRVc2FnZSh2YWx1ZSkge1xuXHRcdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3Ioc291cmNlLmFycmF5KTtcblx0XHRcdHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XG5cdFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG5cdFx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weUF0KGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIpIHtcblx0XHRcdGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xuXHRcdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYXJyYXlbaW5kZXgxICsgaV0gPSBhdHRyaWJ1dGUuYXJyYXlbaW5kZXgyICsgaV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHlBcnJheShhcnJheSkge1xuXHRcdFx0dGhpcy5hcnJheS5zZXQoYXJyYXkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weUNvbG9yc0FycmF5KGNvbG9ycykge1xuXHRcdFx0Y29uc3QgYXJyYXkgPSB0aGlzLmFycmF5O1xuXHRcdFx0bGV0IG9mZnNldCA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsZXQgY29sb3IgPSBjb2xvcnNbaV07XG5cblx0XHRcdFx0aWYgKGNvbG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoKTogY29sb3IgaXMgdW5kZWZpbmVkJywgaSk7XG5cdFx0XHRcdFx0Y29sb3IgPSBuZXcgQ29sb3IoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IGNvbG9yLnI7XG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IGNvbG9yLmc7XG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IGNvbG9yLmI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHlWZWN0b3Iyc0FycmF5KHZlY3RvcnMpIHtcblx0XHRcdGNvbnN0IGFycmF5ID0gdGhpcy5hcnJheTtcblx0XHRcdGxldCBvZmZzZXQgPSAwO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGxldCB2ZWN0b3IgPSB2ZWN0b3JzW2ldO1xuXG5cdFx0XHRcdGlmICh2ZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpKTtcblx0XHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLng7XG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci55O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5VmVjdG9yM3NBcnJheSh2ZWN0b3JzKSB7XG5cdFx0XHRjb25zdCBhcnJheSA9IHRoaXMuYXJyYXk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0gMDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsZXQgdmVjdG9yID0gdmVjdG9yc1tpXTtcblxuXHRcdFx0XHRpZiAodmVjdG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSk7XG5cdFx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci54O1xuXHRcdFx0XHRhcnJheVtvZmZzZXQrK10gPSB2ZWN0b3IueTtcblx0XHRcdFx0YXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLno7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHlWZWN0b3I0c0FycmF5KHZlY3RvcnMpIHtcblx0XHRcdGNvbnN0IGFycmF5ID0gdGhpcy5hcnJheTtcblx0XHRcdGxldCBvZmZzZXQgPSAwO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGxldCB2ZWN0b3IgPSB2ZWN0b3JzW2ldO1xuXG5cdFx0XHRcdGlmICh2ZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3I0c0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpKTtcblx0XHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLng7XG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci55O1xuXHRcdFx0XHRhcnJheVtvZmZzZXQrK10gPSB2ZWN0b3Iuejtcblx0XHRcdFx0YXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLnc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFwcGx5TWF0cml4MyhtKSB7XG5cdFx0XHRpZiAodGhpcy5pdGVtU2l6ZSA9PT0gMikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRfdmVjdG9yMiQxLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgaSk7XG5cblx0XHRcdFx0XHRfdmVjdG9yMiQxLmFwcGx5TWF0cml4MyhtKTtcblxuXHRcdFx0XHRcdHRoaXMuc2V0WFkoaSwgX3ZlY3RvcjIkMS54LCBfdmVjdG9yMiQxLnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuaXRlbVNpemUgPT09IDMpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0X3ZlY3RvciQ5LmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgaSk7XG5cblx0XHRcdFx0XHRfdmVjdG9yJDkuYXBwbHlNYXRyaXgzKG0pO1xuXG5cdFx0XHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG0pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDkueCA9IHRoaXMuZ2V0WChpKTtcblx0XHRcdFx0X3ZlY3RvciQ5LnkgPSB0aGlzLmdldFkoaSk7XG5cdFx0XHRcdF92ZWN0b3IkOS56ID0gdGhpcy5nZXRaKGkpO1xuXG5cdFx0XHRcdF92ZWN0b3IkOS5hcHBseU1hdHJpeDQobSk7XG5cblx0XHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFwcGx5Tm9ybWFsTWF0cml4KG0pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDkueCA9IHRoaXMuZ2V0WChpKTtcblx0XHRcdFx0X3ZlY3RvciQ5LnkgPSB0aGlzLmdldFkoaSk7XG5cdFx0XHRcdF92ZWN0b3IkOS56ID0gdGhpcy5nZXRaKGkpO1xuXG5cdFx0XHRcdF92ZWN0b3IkOS5hcHBseU5vcm1hbE1hdHJpeChtKTtcblxuXHRcdFx0XHR0aGlzLnNldFhZWihpLCBfdmVjdG9yJDkueCwgX3ZlY3RvciQ5LnksIF92ZWN0b3IkOS56KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dHJhbnNmb3JtRGlyZWN0aW9uKG0pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDkueCA9IHRoaXMuZ2V0WChpKTtcblx0XHRcdFx0X3ZlY3RvciQ5LnkgPSB0aGlzLmdldFkoaSk7XG5cdFx0XHRcdF92ZWN0b3IkOS56ID0gdGhpcy5nZXRaKGkpO1xuXG5cdFx0XHRcdF92ZWN0b3IkOS50cmFuc2Zvcm1EaXJlY3Rpb24obSk7XG5cblx0XHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldCh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0dGhpcy5hcnJheS5zZXQodmFsdWUsIG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRYKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemVdO1xuXHRcdH1cblxuXHRcdHNldFgoaW5kZXgsIHgpIHtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplXSA9IHg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRZKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxXTtcblx0XHR9XG5cblx0XHRzZXRZKGluZGV4LCB5KSB7XG5cdFx0XHR0aGlzLmFycmF5W2luZGV4ICogdGhpcy5pdGVtU2l6ZSArIDFdID0geTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldFooaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmFycmF5W2luZGV4ICogdGhpcy5pdGVtU2l6ZSArIDJdO1xuXHRcdH1cblxuXHRcdHNldFooaW5kZXgsIHopIHtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMl0gPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0VyhpbmRleCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplICsgM107XG5cdFx0fVxuXG5cdFx0c2V0VyhpbmRleCwgdykge1xuXHRcdFx0dGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzXSA9IHc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRYWShpbmRleCwgeCwgeSkge1xuXHRcdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0XHR0aGlzLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WFlaKGluZGV4LCB4LCB5LCB6KSB7XG5cdFx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXHRcdFx0dGhpcy5hcnJheVtpbmRleCArIDBdID0geDtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKyAxXSA9IHk7XG5cdFx0XHR0aGlzLmFycmF5W2luZGV4ICsgMl0gPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WFlaVyhpbmRleCwgeCwgeSwgeiwgdykge1xuXHRcdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0XHR0aGlzLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdFx0dGhpcy5hcnJheVtpbmRleCArIDJdID0gejtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKyAzXSA9IHc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRvblVwbG9hZChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmFycmF5LCB0aGlzLml0ZW1TaXplKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdGFycmF5OiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmFycmF5KSxcblx0XHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXG5cdFx0XHR9O1xuXHRcdFx0aWYgKHRoaXMubmFtZSAhPT0gJycpIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGlmICh0aGlzLnVzYWdlICE9PSBTdGF0aWNEcmF3VXNhZ2UpIGRhdGEudXNhZ2UgPSB0aGlzLnVzYWdlO1xuXHRcdFx0aWYgKHRoaXMudXBkYXRlUmFuZ2Uub2Zmc2V0ICE9PSAwIHx8IHRoaXMudXBkYXRlUmFuZ2UuY291bnQgIT09IC0xKSBkYXRhLnVwZGF0ZVJhbmdlID0gdGhpcy51cGRhdGVSYW5nZTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5pc0J1ZmZlckF0dHJpYnV0ZSA9IHRydWU7IC8vXG5cblx0Y2xhc3MgSW50OEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdFx0Y29uc3RydWN0b3IoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG5cdFx0XHRzdXBlcihuZXcgSW50OEFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgVWludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IFVpbnQ4QXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IEludDE2QXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IFVpbnQxNkFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW50MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IEludDMyQXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IFVpbnQzMkFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdFx0Y29uc3RydWN0b3IoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG5cdFx0XHRzdXBlcihuZXcgVWludDE2QXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0fVxuXG5cdH1cblxuXHRGbG9hdDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5pc0Zsb2F0MTZCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdGNsYXNzIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IEZsb2F0MzJBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IEZsb2F0NjRBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0XHR9XG5cblx0fSAvL1xuXG5cdGZ1bmN0aW9uIGFycmF5TWF4KGFycmF5KSB7XG5cdFx0aWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIC1JbmZpbml0eTtcblx0XHRsZXQgbWF4ID0gYXJyYXlbMF07XG5cblx0XHRmb3IgKGxldCBpID0gMSwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHRcdFx0aWYgKGFycmF5W2ldID4gbWF4KSBtYXggPSBhcnJheVtpXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWF4O1xuXHR9XG5cblx0Y29uc3QgVFlQRURfQVJSQVlTID0ge1xuXHRcdEludDhBcnJheTogSW50OEFycmF5LFxuXHRcdFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXG5cdFx0VWludDhDbGFtcGVkQXJyYXk6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHRcdEludDE2QXJyYXk6IEludDE2QXJyYXksXG5cdFx0VWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxuXHRcdEludDMyQXJyYXk6IEludDMyQXJyYXksXG5cdFx0VWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxuXHRcdEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxuXHRcdEZsb2F0NjRBcnJheTogRmxvYXQ2NEFycmF5XG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0VHlwZWRBcnJheSh0eXBlLCBidWZmZXIpIHtcblx0XHRyZXR1cm4gbmV3IFRZUEVEX0FSUkFZU1t0eXBlXShidWZmZXIpO1xuXHR9XG5cblx0bGV0IF9pZCA9IDA7XG5cblx0Y29uc3QgX20xID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX29iaiA9IC8qQF9fUFVSRV9fKi9uZXcgT2JqZWN0M0QoKTtcblxuXHRjb25zdCBfb2Zmc2V0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2JveCQxID0gLypAX19QVVJFX18qL25ldyBCb3gzKCk7XG5cblx0Y29uc3QgX2JveE1vcnBoVGFyZ2V0cyA9IC8qQF9fUFVSRV9fKi9uZXcgQm94MygpO1xuXG5cdGNvbnN0IF92ZWN0b3IkOCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIEJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuXHRcdFx0XHR2YWx1ZTogX2lkKytcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdFx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHRcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHRcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBmYWxzZTtcblx0XHRcdHRoaXMuZ3JvdXBzID0gW107XG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXHRcdFx0dGhpcy5kcmF3UmFuZ2UgPSB7XG5cdFx0XHRcdHN0YXJ0OiAwLFxuXHRcdFx0XHRjb3VudDogSW5maW5pdHlcblx0XHRcdH07XG5cdFx0XHR0aGlzLnVzZXJEYXRhID0ge307XG5cdFx0fVxuXG5cdFx0Z2V0SW5kZXgoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbmRleDtcblx0XHR9XG5cblx0XHRzZXRJbmRleChpbmRleCkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoaW5kZXgpKSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBuZXcgKGFycmF5TWF4KGluZGV4KSA+IDY1NTM1ID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlKShpbmRleCwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gaW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldEF0dHJpYnV0ZShuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuXHRcdH1cblxuXHRcdHNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpIHtcblx0XHRcdHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IGF0dHJpYnV0ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRlbGV0ZUF0dHJpYnV0ZShuYW1lKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aGFzQXR0cmlidXRlKG5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gIT09IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRhZGRHcm91cChzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggPSAwKSB7XG5cdFx0XHR0aGlzLmdyb3Vwcy5wdXNoKHtcblx0XHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0XHRjb3VudDogY291bnQsXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGNsZWFyR3JvdXBzKCkge1xuXHRcdFx0dGhpcy5ncm91cHMgPSBbXTtcblx0XHR9XG5cblx0XHRzZXREcmF3UmFuZ2Uoc3RhcnQsIGNvdW50KSB7XG5cdFx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuXHRcdFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBjb3VudDtcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDQobWF0cml4KSB7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0aWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cG9zaXRpb24uYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG5cdFx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0aWYgKG5vcm1hbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnN0IG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KG1hdHJpeCk7XG5cdFx0XHRcdG5vcm1hbC5hcHBseU5vcm1hbE1hdHJpeChub3JtYWxNYXRyaXgpO1xuXHRcdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0YW5nZW50ID0gdGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQ7XG5cblx0XHRcdGlmICh0YW5nZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGFuZ2VudC50cmFuc2Zvcm1EaXJlY3Rpb24obWF0cml4KTtcblx0XHRcdFx0dGFuZ2VudC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFwcGx5UXVhdGVybmlvbihxKSB7XG5cdFx0XHRfbTEubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXg0KF9tMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyb3RhdGVYKGFuZ2xlKSB7XG5cdFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xuXHRcdFx0X20xLm1ha2VSb3RhdGlvblgoYW5nbGUpO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm90YXRlWShhbmdsZSkge1xuXHRcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblx0XHRcdF9tMS5tYWtlUm90YXRpb25ZKGFuZ2xlKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeDQoX20xKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJvdGF0ZVooYW5nbGUpIHtcblx0XHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cdFx0XHRfbTEubWFrZVJvdGF0aW9uWihhbmdsZSk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXg0KF9tMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0cmFuc2xhdGUoeCwgeSwgeikge1xuXHRcdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cdFx0XHRfbTEubWFrZVRyYW5zbGF0aW9uKHgsIHksIHopO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2NhbGUoeCwgeSwgeikge1xuXHRcdFx0Ly8gc2NhbGUgZ2VvbWV0cnlcblx0XHRcdF9tMS5tYWtlU2NhbGUoeCwgeSwgeik7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXg0KF9tMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRsb29rQXQodmVjdG9yKSB7XG5cdFx0XHRfb2JqLmxvb2tBdCh2ZWN0b3IpO1xuXG5cdFx0XHRfb2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4NChfb2JqLm1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjZW50ZXIoKSB7XG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoX29mZnNldCkubmVnYXRlKCk7XG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShfb2Zmc2V0LngsIF9vZmZzZXQueSwgX29mZnNldC56KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHMocG9pbnRzKSB7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdHBvc2l0aW9uLnB1c2gocG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIDMpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcblx0XHRcdGlmICh0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGlmIChwb3NpdGlvbiAmJiBwb3NpdGlvbi5pc0dMQnVmZmVyQXR0cmlidXRlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBib3guIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldChuZXcgVmVjdG9yMygtSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5KSwgbmV3IFZlY3RvcjMoK0luZmluaXR5LCArSW5maW5pdHksICtJbmZpbml0eSkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbik7IC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdFx0aWYgKG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbltpXTtcblxuXHRcdFx0XHRcdFx0X2JveCQxLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGhBdHRyaWJ1dGUpO1xuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yJDguYWRkVmVjdG9ycyh0aGlzLmJvdW5kaW5nQm94Lm1pbiwgX2JveCQxLm1pbik7XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KF92ZWN0b3IkOCk7XG5cblx0XHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmFkZFZlY3RvcnModGhpcy5ib3VuZGluZ0JveC5tYXgsIF9ib3gkMS5tYXgpO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChfdmVjdG9yJDgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KF9ib3gkMS5taW4pO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoX2JveCQxLm1heCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueCkgfHwgaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueSkgfHwgaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueikpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcblx0XHRcdGlmICh0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0aWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLmlzR0xCdWZmZXJBdHRyaWJ1dGUpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIHNwaGVyZS4gQWx0ZXJuYXRpdmVseSBzZXQgXCJtZXNoLmZydXN0dW1DdWxsZWRcIiB0byBcImZhbHNlXCIuJywgdGhpcyk7XG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KG5ldyBWZWN0b3IzKCksIEluZmluaXR5KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocG9zaXRpb24pIHtcblx0XHRcdFx0Ly8gZmlyc3QsIGZpbmQgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgc3BoZXJlXG5cdFx0XHRcdGNvbnN0IGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuXG5cdFx0XHRcdF9ib3gkMS5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uKTsgLy8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcblxuXG5cdFx0XHRcdGlmIChtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbikge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25baV07XG5cblx0XHRcdFx0XHRcdF9ib3hNb3JwaFRhcmdldHMuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaEF0dHJpYnV0ZSk7XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGRWZWN0b3JzKF9ib3gkMS5taW4sIF9ib3hNb3JwaFRhcmdldHMubWluKTtcblxuXHRcdFx0XHRcdFx0XHRfYm94JDEuZXhwYW5kQnlQb2ludChfdmVjdG9yJDgpO1xuXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGRWZWN0b3JzKF9ib3gkMS5tYXgsIF9ib3hNb3JwaFRhcmdldHMubWF4KTtcblxuXHRcdFx0XHRcdFx0XHRfYm94JDEuZXhwYW5kQnlQb2ludChfdmVjdG9yJDgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0X2JveCQxLmV4cGFuZEJ5UG9pbnQoX2JveE1vcnBoVGFyZ2V0cy5taW4pO1xuXG5cdFx0XHRcdFx0XHRcdF9ib3gkMS5leHBhbmRCeVBvaW50KF9ib3hNb3JwaFRhcmdldHMubWF4KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfYm94JDEuZ2V0Q2VudGVyKGNlbnRlcik7IC8vIHNlY29uZCwgdHJ5IHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdFx0Ly8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxuXG5cblx0XHRcdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRfdmVjdG9yJDguZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgaSk7XG5cblx0XHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoX3ZlY3RvciQ4KSk7XG5cdFx0XHRcdH0gLy8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcblxuXG5cdFx0XHRcdGlmIChtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbikge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25baV07XG5cdFx0XHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IG1vcnBoQXR0cmlidXRlLmNvdW50OyBqIDwgamw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yJDguZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaEF0dHJpYnV0ZSwgaik7XG5cblx0XHRcdFx0XHRcdFx0aWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG5cdFx0XHRcdFx0XHRcdFx0X29mZnNldC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBqKTtcblxuXHRcdFx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGQoX29mZnNldCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoX3ZlY3RvciQ4KSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQobWF4UmFkaXVzU3EpO1xuXG5cdFx0XHRcdGlmIChpc05hTih0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cykpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbXB1dGVGYWNlTm9ybWFscygpIHsvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdH1cblxuXHRcdGNvbXB1dGVUYW5nZW50cygpIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7IC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXG5cdFx0XHQvLyAocGVyIHZlcnRleCB0YW5nZW50cylcblxuXHRcdFx0aWYgKGluZGV4ID09PSBudWxsIHx8IGF0dHJpYnV0ZXMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkIHx8IGF0dHJpYnV0ZXMudXYgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGZhaWxlZC4gTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGVzIChpbmRleCwgcG9zaXRpb24sIG5vcm1hbCBvciB1diknKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXHRcdFx0Y29uc3QgdXZzID0gYXR0cmlidXRlcy51di5hcnJheTtcblx0XHRcdGNvbnN0IG5WZXJ0aWNlcyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuXG5cdFx0XHRpZiAoYXR0cmlidXRlcy50YW5nZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3RhbmdlbnQnLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoNCAqIG5WZXJ0aWNlcyksIDQpKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGFuZ2VudHMgPSBhdHRyaWJ1dGVzLnRhbmdlbnQuYXJyYXk7XG5cdFx0XHRjb25zdCB0YW4xID0gW10sXG5cdFx0XHRcdFx0XHR0YW4yID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgblZlcnRpY2VzOyBpKyspIHtcblx0XHRcdFx0dGFuMVtpXSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHRhbjJbaV0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2QSA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHR2QiA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHR2QyA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHR1dkEgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRcdFx0dXZCID0gbmV3IFZlY3RvcjIoKSxcblx0XHRcdFx0XHRcdHV2QyA9IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdFx0XHRzZGlyID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdHRkaXIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVUcmlhbmdsZShhLCBiLCBjKSB7XG5cdFx0XHRcdHZBLmZyb21BcnJheShwb3NpdGlvbnMsIGEgKiAzKTtcblx0XHRcdFx0dkIuZnJvbUFycmF5KHBvc2l0aW9ucywgYiAqIDMpO1xuXHRcdFx0XHR2Qy5mcm9tQXJyYXkocG9zaXRpb25zLCBjICogMyk7XG5cdFx0XHRcdHV2QS5mcm9tQXJyYXkodXZzLCBhICogMik7XG5cdFx0XHRcdHV2Qi5mcm9tQXJyYXkodXZzLCBiICogMik7XG5cdFx0XHRcdHV2Qy5mcm9tQXJyYXkodXZzLCBjICogMik7XG5cdFx0XHRcdHZCLnN1Yih2QSk7XG5cdFx0XHRcdHZDLnN1Yih2QSk7XG5cdFx0XHRcdHV2Qi5zdWIodXZBKTtcblx0XHRcdFx0dXZDLnN1Yih1dkEpO1xuXHRcdFx0XHRjb25zdCByID0gMS4wIC8gKHV2Qi54ICogdXZDLnkgLSB1dkMueCAqIHV2Qi55KTsgLy8gc2lsZW50bHkgaWdub3JlIGRlZ2VuZXJhdGUgdXYgdHJpYW5nbGVzIGhhdmluZyBjb2luY2lkZW50IG9yIGNvbGluZWFyIHZlcnRpY2VzXG5cblx0XHRcdFx0aWYgKCFpc0Zpbml0ZShyKSkgcmV0dXJuO1xuXHRcdFx0XHRzZGlyLmNvcHkodkIpLm11bHRpcGx5U2NhbGFyKHV2Qy55KS5hZGRTY2FsZWRWZWN0b3IodkMsIC11dkIueSkubXVsdGlwbHlTY2FsYXIocik7XG5cdFx0XHRcdHRkaXIuY29weSh2QykubXVsdGlwbHlTY2FsYXIodXZCLngpLmFkZFNjYWxlZFZlY3Rvcih2QiwgLXV2Qy54KS5tdWx0aXBseVNjYWxhcihyKTtcblx0XHRcdFx0dGFuMVthXS5hZGQoc2Rpcik7XG5cdFx0XHRcdHRhbjFbYl0uYWRkKHNkaXIpO1xuXHRcdFx0XHR0YW4xW2NdLmFkZChzZGlyKTtcblx0XHRcdFx0dGFuMlthXS5hZGQodGRpcik7XG5cdFx0XHRcdHRhbjJbYl0uYWRkKHRkaXIpO1xuXHRcdFx0XHR0YW4yW2NdLmFkZCh0ZGlyKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0XHRpZiAoZ3JvdXBzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRncm91cHMgPSBbe1xuXHRcdFx0XHRcdHN0YXJ0OiAwLFxuXHRcdFx0XHRcdGNvdW50OiBpbmRpY2VzLmxlbmd0aFxuXHRcdFx0XHR9XTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcblx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzKSB7XG5cdFx0XHRcdFx0aGFuZGxlVHJpYW5nbGUoaW5kaWNlc1tqICsgMF0sIGluZGljZXNbaiArIDFdLCBpbmRpY2VzW2ogKyAyXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdG1wID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdHRtcDIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgbiA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRuMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZVZlcnRleCh2KSB7XG5cdFx0XHRcdG4uZnJvbUFycmF5KG5vcm1hbHMsIHYgKiAzKTtcblx0XHRcdFx0bjIuY29weShuKTtcblx0XHRcdFx0Y29uc3QgdCA9IHRhbjFbdl07IC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cblx0XHRcdFx0dG1wLmNvcHkodCk7XG5cdFx0XHRcdHRtcC5zdWIobi5tdWx0aXBseVNjYWxhcihuLmRvdCh0KSkpLm5vcm1hbGl6ZSgpOyAvLyBDYWxjdWxhdGUgaGFuZGVkbmVzc1xuXG5cdFx0XHRcdHRtcDIuY3Jvc3NWZWN0b3JzKG4yLCB0KTtcblx0XHRcdFx0Y29uc3QgdGVzdCA9IHRtcDIuZG90KHRhbjJbdl0pO1xuXHRcdFx0XHRjb25zdCB3ID0gdGVzdCA8IDAuMCA/IC0xLjAgOiAxLjA7XG5cdFx0XHRcdHRhbmdlbnRzW3YgKiA0XSA9IHRtcC54O1xuXHRcdFx0XHR0YW5nZW50c1t2ICogNCArIDFdID0gdG1wLnk7XG5cdFx0XHRcdHRhbmdlbnRzW3YgKiA0ICsgMl0gPSB0bXAuejtcblx0XHRcdFx0dGFuZ2VudHNbdiAqIDQgKyAzXSA9IHc7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuXHRcdFx0XHRjb25zdCBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMykge1xuXHRcdFx0XHRcdGhhbmRsZVZlcnRleChpbmRpY2VzW2ogKyAwXSk7XG5cdFx0XHRcdFx0aGFuZGxlVmVydGV4KGluZGljZXNbaiArIDFdKTtcblx0XHRcdFx0XHRoYW5kbGVWZXJ0ZXgoaW5kaWNlc1tqICsgMl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29tcHV0ZVZlcnRleE5vcm1hbHMoKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXG5cdFx0XHRpZiAocG9zaXRpb25BdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRsZXQgbm9ybWFsQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ25vcm1hbCcpO1xuXG5cdFx0XHRcdGlmIChub3JtYWxBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIDMpLCAzKTtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBub3JtYWxBdHRyaWJ1dGUuY291bnQ7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKGksIDAsIDAsIDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHBBID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdFx0cEIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRwQyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdGNvbnN0IG5BID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdFx0bkIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRuQyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdGNvbnN0IGNiID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdFx0YWIgPSBuZXcgVmVjdG9yMygpOyAvLyBpbmRleGVkIGVsZW1lbnRzXG5cblx0XHRcdFx0aWYgKGluZGV4KSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gaW5kZXguY291bnQ7IGkgPCBpbDsgaSArPSAzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB2QSA9IGluZGV4LmdldFgoaSArIDApO1xuXHRcdFx0XHRcdFx0Y29uc3QgdkIgPSBpbmRleC5nZXRYKGkgKyAxKTtcblx0XHRcdFx0XHRcdGNvbnN0IHZDID0gaW5kZXguZ2V0WChpICsgMik7XG5cdFx0XHRcdFx0XHRwQS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCB2QSk7XG5cdFx0XHRcdFx0XHRwQi5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCB2Qik7XG5cdFx0XHRcdFx0XHRwQy5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCB2Qyk7XG5cdFx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKHBDLCBwQik7XG5cdFx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKHBBLCBwQik7XG5cdFx0XHRcdFx0XHRjYi5jcm9zcyhhYik7XG5cdFx0XHRcdFx0XHRuQS5mcm9tQnVmZmVyQXR0cmlidXRlKG5vcm1hbEF0dHJpYnV0ZSwgdkEpO1xuXHRcdFx0XHRcdFx0bkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBdHRyaWJ1dGUsIHZCKTtcblx0XHRcdFx0XHRcdG5DLmZyb21CdWZmZXJBdHRyaWJ1dGUobm9ybWFsQXR0cmlidXRlLCB2Qyk7XG5cdFx0XHRcdFx0XHRuQS5hZGQoY2IpO1xuXHRcdFx0XHRcdFx0bkIuYWRkKGNiKTtcblx0XHRcdFx0XHRcdG5DLmFkZChjYik7XG5cdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKHZBLCBuQS54LCBuQS55LCBuQS56KTtcblx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVoodkIsIG5CLngsIG5CLnksIG5CLnopO1xuXHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWih2QywgbkMueCwgbkMueSwgbkMueik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKz0gMykge1xuXHRcdFx0XHRcdFx0cEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDApO1xuXHRcdFx0XHRcdFx0cEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDEpO1xuXHRcdFx0XHRcdFx0cEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDIpO1xuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyhwQywgcEIpO1xuXHRcdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyhwQSwgcEIpO1xuXHRcdFx0XHRcdFx0Y2IuY3Jvc3MoYWIpO1xuXHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWihpICsgMCwgY2IueCwgY2IueSwgY2Iueik7XG5cdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKGkgKyAxLCBjYi54LCBjYi55LCBjYi56KTtcblx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooaSArIDIsIGNiLngsIGNiLnksIGNiLnopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lcmdlKGdlb21ldHJ5LCBvZmZzZXQpIHtcblx0XHRcdGlmICghKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9mZnNldCA9IDA7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogT3ZlcndyaXRpbmcgb3JpZ2luYWwgZ2VvbWV0cnksIHN0YXJ0aW5nIGF0IG9mZnNldD0wLiAnICsgJ1VzZSBCdWZmZXJHZW9tZXRyeVV0aWxzLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZvciBsb3NzbGVzcyBtZXJnZS4nKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0XHRpZiAoZ2VvbWV0cnkuYXR0cmlidXRlc1trZXldID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUxID0gYXR0cmlidXRlc1trZXldO1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUyID0gZ2VvbWV0cnkuYXR0cmlidXRlc1trZXldO1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVBcnJheTIgPSBhdHRyaWJ1dGUyLmFycmF5O1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVPZmZzZXQgPSBhdHRyaWJ1dGUyLml0ZW1TaXplICogb2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBsZW5ndGggPSBNYXRoLm1pbihhdHRyaWJ1dGVBcnJheTIubGVuZ3RoLCBhdHRyaWJ1dGVBcnJheTEubGVuZ3RoIC0gYXR0cmlidXRlT2Zmc2V0KTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaiA9IGF0dHJpYnV0ZU9mZnNldDsgaSA8IGxlbmd0aDsgaSsrLCBqKyspIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGVBcnJheTFbal0gPSBhdHRyaWJ1dGVBcnJheTJbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bm9ybWFsaXplTm9ybWFscygpIHtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBub3JtYWxzLmNvdW50OyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDguZnJvbUJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCBpKTtcblxuXHRcdFx0XHRfdmVjdG9yJDgubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0bm9ybWFscy5zZXRYWVooaSwgX3ZlY3RvciQ4LngsIF92ZWN0b3IkOC55LCBfdmVjdG9yJDgueik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG9Ob25JbmRleGVkKCkge1xuXHRcdFx0ZnVuY3Rpb24gY29udmVydEJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGljZXMpIHtcblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuXHRcdFx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlLm5vcm1hbGl6ZWQ7XG5cdFx0XHRcdGNvbnN0IGFycmF5MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplKTtcblx0XHRcdFx0bGV0IGluZGV4ID0gMCxcblx0XHRcdFx0XHRcdGluZGV4MiA9IDA7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmIChhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzW2ldICogYXR0cmlidXRlLmRhdGEuc3RyaWRlICsgYXR0cmlidXRlLm9mZnNldDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzW2ldICogaXRlbVNpemU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaisrKSB7XG5cdFx0XHRcdFx0XHRhcnJheTJbaW5kZXgyKytdID0gYXJyYXlbaW5kZXgrK107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXkyLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0aWYgKHRoaXMuaW5kZXggPT09IG51bGwpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS50b05vbkluZGV4ZWQoKTogQnVmZmVyR2VvbWV0cnkgaXMgYWxyZWFkeSBub24taW5kZXhlZC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IHRoaXMuaW5kZXguYXJyYXk7XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzOyAvLyBhdHRyaWJ1dGVzXG5cblx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cdFx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZSA9IGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRpY2VzKTtcblx0XHRcdFx0Z2VvbWV0cnkyLnNldEF0dHJpYnV0ZShuYW1lLCBuZXdBdHRyaWJ1dGUpO1xuXHRcdFx0fSAvLyBtb3JwaCBhdHRyaWJ1dGVzXG5cblxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0Y29uc3QgbW9ycGhBcnJheSA9IFtdO1xuXHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1tuYW1lXTsgLy8gbW9ycGhBdHRyaWJ1dGU6IGFycmF5IG9mIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVzXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlW2ldO1xuXHRcdFx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZSA9IGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRpY2VzKTtcblx0XHRcdFx0XHRtb3JwaEFycmF5LnB1c2gobmV3QXR0cmlidXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5Mi5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBtb3JwaEFycmF5O1xuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeTIubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlOyAvLyBncm91cHNcblxuXHRcdFx0Y29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdFx0Z2VvbWV0cnkyLmFkZEdyb3VwKGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTI7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdFx0dHlwZTogJ0J1ZmZlckdlb21ldHJ5Jyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXG5cdFx0XHRcdH1cblx0XHRcdH07IC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuXHRcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdFx0aWYgKHRoaXMubmFtZSAhPT0gJycpIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGlmIChPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGggPiAwKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdFx0aWYgKHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gcGFyYW1ldGVycykge1xuXHRcdFx0XHRcdGlmIChwYXJhbWV0ZXJzW2tleV0gIT09IHVuZGVmaW5lZCkgZGF0YVtrZXldID0gcGFyYW1ldGVyc1trZXldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9IC8vIGZvciBzaW1wbGljaXR5IHRoZSBjb2RlIGFzc3VtZXMgYXR0cmlidXRlcyBhcmUgbm90IHNoYXJlZCBhY3Jvc3MgZ2VvbWV0cmllcywgc2VlICMxNTgxMVxuXG5cblx0XHRcdGRhdGEuZGF0YSA9IHtcblx0XHRcdFx0YXR0cmlidXRlczoge31cblx0XHRcdH07XG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG5cblx0XHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRkYXRhLmRhdGEuaW5kZXggPSB7XG5cdFx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0XHRhcnJheTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5kZXguYXJyYXkpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuXHRcdFx0XHRkYXRhLmRhdGEuYXR0cmlidXRlc1trZXldID0gYXR0cmlidXRlLnRvSlNPTihkYXRhLmRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHRcdGxldCBoYXNNb3JwaEF0dHJpYnV0ZXMgPSBmYWxzZTtcblxuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy5tb3JwaEF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkgPSB0aGlzLm1vcnBoQXR0cmlidXRlc1trZXldO1xuXHRcdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZUFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVBcnJheVtpXTtcblx0XHRcdFx0XHRhcnJheS5wdXNoKGF0dHJpYnV0ZS50b0pTT04oZGF0YS5kYXRhKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYXJyYXkubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdG1vcnBoQXR0cmlidXRlc1trZXldID0gYXJyYXk7XG5cdFx0XHRcdFx0aGFzTW9ycGhBdHRyaWJ1dGVzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFzTW9ycGhBdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGRhdGEuZGF0YS5tb3JwaEF0dHJpYnV0ZXMgPSBtb3JwaEF0dHJpYnV0ZXM7XG5cdFx0XHRcdGRhdGEuZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0XHRpZiAoZ3JvdXBzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0ZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZ3JvdXBzKSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdFx0aWYgKGJvdW5kaW5nU3BoZXJlICE9PSBudWxsKSB7XG5cdFx0XHRcdGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcblx0XHRcdFx0XHRjZW50ZXI6IGJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCksXG5cdFx0XHRcdFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHQvKlxuXHRcdFx0IC8vIEhhbmRsZSBwcmltaXRpdmVzXG5cdFx0XHRcdCBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXHRcdFx0XHQgaWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdCBjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRcdFx0IGZvciAoIGNvbnN0IGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXHRcdFx0XHQgdmFsdWVzLnB1c2goIHBhcmFtZXRlcnNbIGtleSBdICk7XG5cdFx0XHRcdCB9XG5cdFx0XHRcdCBjb25zdCBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XG5cdFx0XHQgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSggZ2VvbWV0cnksIHZhbHVlcyApO1xuXHRcdFx0IHJldHVybiBnZW9tZXRyeTtcblx0XHRcdFx0IH1cblx0XHRcdFx0IHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblx0XHRcdCAqL1xuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJHZW9tZXRyeSgpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdC8vIHJlc2V0XG5cdFx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHRcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHRcdHRoaXMuZ3JvdXBzID0gW107XG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsOyAvLyB1c2VkIGZvciBzdG9yaW5nIGNsb25lZCwgc2hhcmVkIGRhdGFcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHt9OyAvLyBuYW1lXG5cblx0XHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lOyAvLyBpbmRleFxuXG5cdFx0XHRjb25zdCBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuXHRcdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2V0SW5kZXgoaW5kZXguY2xvbmUoZGF0YSkpO1xuXHRcdFx0fSAvLyBhdHRyaWJ1dGVzXG5cblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoZGF0YSkpO1xuXHRcdFx0fSAvLyBtb3JwaCBhdHRyaWJ1dGVzXG5cblxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gc291cmNlLm1vcnBoQXR0cmlidXRlcztcblxuXHRcdFx0Zm9yIChjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1tuYW1lXTsgLy8gbW9ycGhBdHRyaWJ1dGU6IGFycmF5IG9mIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVzXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRhcnJheS5wdXNoKG1vcnBoQXR0cmlidXRlW2ldLmNsb25lKGRhdGEpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gYXJyYXk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBzb3VyY2UubW9ycGhUYXJnZXRzUmVsYXRpdmU7IC8vIGdyb3Vwc1xuXG5cdFx0XHRjb25zdCBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG5cdFx0XHRcdHRoaXMuYWRkR3JvdXAoZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4KTtcblx0XHRcdH0gLy8gYm91bmRpbmcgYm94XG5cblxuXHRcdFx0Y29uc3QgYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3g7XG5cblx0XHRcdGlmIChib3VuZGluZ0JveCAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3guY2xvbmUoKTtcblx0XHRcdH0gLy8gYm91bmRpbmcgc3BoZXJlXG5cblxuXHRcdFx0Y29uc3QgYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRcdGlmIChib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblx0XHRcdH0gLy8gZHJhdyByYW5nZVxuXG5cblx0XHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc291cmNlLmRyYXdSYW5nZS5zdGFydDtcblx0XHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDsgLy8gdXNlciBkYXRhXG5cblx0XHRcdHRoaXMudXNlckRhdGEgPSBzb3VyY2UudXNlckRhdGE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0dHlwZTogJ2Rpc3Bvc2UnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0fVxuXG5cdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5pc0J1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcblxuXHRjb25zdCBfaW52ZXJzZU1hdHJpeCQyID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX3JheSQyID0gLypAX19QVVJFX18qL25ldyBSYXkoKTtcblxuXHRjb25zdCBfc3BoZXJlJDMgPSAvKkBfX1BVUkVfXyovbmV3IFNwaGVyZSgpO1xuXG5cdGNvbnN0IF92QSQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3ZCJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdkMkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF90ZW1wQSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF90ZW1wQiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF90ZW1wQyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9tb3JwaEEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfbW9ycGhCID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX21vcnBoQyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF91dkEkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpO1xuXG5cdGNvbnN0IF91dkIkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpO1xuXG5cdGNvbnN0IF91dkMkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpO1xuXG5cdGNvbnN0IF9pbnRlcnNlY3Rpb25Qb2ludCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgTWVzaCBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcihnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCgpKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ01lc2gnO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXHRcdFx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXG5cdFx0XHRpZiAoc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc291cmNlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF0ZXJpYWwgPSBzb3VyY2UubWF0ZXJpYWw7XG5cdFx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dXBkYXRlTW9ycGhUYXJnZXRzKCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cdFx0XHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtb3JwaEF0dHJpYnV0ZXMpO1xuXG5cdFx0XHRcdGlmIChrZXlzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1trZXlzWzBdXTtcblxuXHRcdFx0XHRcdGlmIChtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xuXHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBuYW1lID0gbW9ycGhBdHRyaWJ1dGVbbV0ubmFtZSB8fCBTdHJpbmcobSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goMCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W25hbWVdID0gbTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblxuXHRcdFx0XHRpZiAobW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgbW9ycGhUYXJnZXRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NZXNoLnVwZGF0ZU1vcnBoVGFyZ2V0cygpIG5vIGxvbmdlciBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXHRcdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdFx0aWYgKG1hdGVyaWFsID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cblx0XHRcdGlmIChnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdF9zcGhlcmUkMy5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKTtcblxuXHRcdFx0X3NwaGVyZSQzLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG5cblx0XHRcdGlmIChyYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSQzKSA9PT0gZmFsc2UpIHJldHVybjsgLy9cblxuXHRcdFx0X2ludmVyc2VNYXRyaXgkMi5jb3B5KG1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblxuXHRcdFx0X3JheSQyLmNvcHkocmF5Y2FzdGVyLnJheSkuYXBwbHlNYXRyaXg0KF9pbnZlcnNlTWF0cml4JDIpOyAvLyBDaGVjayBib3VuZGluZ0JveCBiZWZvcmUgY29udGludWluZ1xuXG5cblx0XHRcdGlmIChnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoX3JheSQyLmludGVyc2VjdHNCb3goZ2VvbWV0cnkuYm91bmRpbmdCb3gpID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaW50ZXJzZWN0aW9uO1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IG1vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cdFx0XHRcdGNvbnN0IHV2ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djtcblx0XHRcdFx0Y29uc3QgdXYyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djI7XG5cdFx0XHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRcdFx0Y29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIGluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4LmdldFgoaik7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4LmdldFgoaiArIDEpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGMgPSBpbmRleC5nZXRYKGogKyAyKTtcblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKHRoaXMsIGdyb3VwTWF0ZXJpYWwsIHJheWNhc3RlciwgX3JheSQyLCBwb3NpdGlvbiwgbW9ycGhQb3NpdGlvbiwgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIHV2LCB1djIsIGEsIGIsIGMpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGludGVyc2VjdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoaiAvIDMpOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cblx0XHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlLm1hdGVyaWFsSW5kZXggPSBncm91cC5tYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKGludGVyc2VjdGlvbik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WChpKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4LmdldFgoaSArIDEpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjID0gaW5kZXguZ2V0WChpICsgMik7XG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24odGhpcywgbWF0ZXJpYWwsIHJheWNhc3RlciwgX3JheSQyLCBwb3NpdGlvbiwgbW9ycGhQb3NpdGlvbiwgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIHV2LCB1djIsIGEsIGIsIGMpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpbnRlcnNlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vcihpIC8gMyk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRleGVkIGJ1ZmZlciBzZW1hbnRpY3NcblxuXHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaChpbnRlcnNlY3Rpb24pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBub24taW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG5cblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBhID0gajtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBiID0gaiArIDE7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgYyA9IGogKyAyO1xuXHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24odGhpcywgZ3JvdXBNYXRlcmlhbCwgcmF5Y2FzdGVyLCBfcmF5JDIsIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgYSwgYiwgYyk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoaW50ZXJzZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vcihqIC8gMyk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBub24taW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cblx0XHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlLm1hdGVyaWFsSW5kZXggPSBncm91cC5tYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKGludGVyc2VjdGlvbik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKHBvc2l0aW9uLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhID0gaTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYiA9IGkgKyAxO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjID0gaSArIDI7XG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24odGhpcywgbWF0ZXJpYWwsIHJheWNhc3RlciwgX3JheSQyLCBwb3NpdGlvbiwgbW9ycGhQb3NpdGlvbiwgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIHV2LCB1djIsIGEsIGIsIGMpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpbnRlcnNlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vcihpIC8gMyk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBub24taW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goaW50ZXJzZWN0aW9uKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChnZW9tZXRyeS5pc0dlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk1lc2gucmF5Y2FzdCgpIG5vIGxvbmdlciBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRNZXNoLnByb3RvdHlwZS5pc01lc2ggPSB0cnVlO1xuXG5cdGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCkge1xuXHRcdGxldCBpbnRlcnNlY3Q7XG5cblx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHtcblx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZShwQywgcEIsIHBBLCB0cnVlLCBwb2ludCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZShwQSwgcEIsIHBDLCBtYXRlcmlhbC5zaWRlICE9PSBEb3VibGVTaWRlLCBwb2ludCk7XG5cdFx0fVxuXG5cdFx0aWYgKGludGVyc2VjdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cblx0XHRfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KHBvaW50KTtcblxuXHRcdF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NChvYmplY3QubWF0cml4V29ybGQpO1xuXG5cdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkKTtcblx0XHRpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIHJldHVybiBudWxsO1xuXHRcdHJldHVybiB7XG5cdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRwb2ludDogX2ludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcblx0XHRcdG9iamVjdDogb2JqZWN0XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24ob2JqZWN0LCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgYSwgYiwgYykge1xuXHRcdF92QSQxLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGEpO1xuXG5cdFx0X3ZCJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgYik7XG5cblx0XHRfdkMkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBjKTtcblxuXHRcdGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRpZiAobW9ycGhQb3NpdGlvbiAmJiBtb3JwaEluZmx1ZW5jZXMpIHtcblx0XHRcdF9tb3JwaEEuc2V0KDAsIDAsIDApO1xuXG5cdFx0XHRfbW9ycGhCLnNldCgwLCAwLCAwKTtcblxuXHRcdFx0X21vcnBoQy5zZXQoMCwgMCwgMCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1vcnBoUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbaV07XG5cdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhQb3NpdGlvbltpXTtcblx0XHRcdFx0aWYgKGluZmx1ZW5jZSA9PT0gMCkgY29udGludWU7XG5cblx0XHRcdFx0X3RlbXBBLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGhBdHRyaWJ1dGUsIGEpO1xuXG5cdFx0XHRcdF90ZW1wQi5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoQXR0cmlidXRlLCBiKTtcblxuXHRcdFx0XHRfdGVtcEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaEF0dHJpYnV0ZSwgYyk7XG5cblx0XHRcdFx0aWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG5cdFx0XHRcdFx0X21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLCBpbmZsdWVuY2UpO1xuXG5cdFx0XHRcdFx0X21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLCBpbmZsdWVuY2UpO1xuXG5cdFx0XHRcdFx0X21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLCBpbmZsdWVuY2UpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQS5zdWIoX3ZBJDEpLCBpbmZsdWVuY2UpO1xuXG5cdFx0XHRcdFx0X21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLnN1YihfdkIkMSksIGluZmx1ZW5jZSk7XG5cblx0XHRcdFx0XHRfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyQxKSwgaW5mbHVlbmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRfdkEkMS5hZGQoX21vcnBoQSk7XG5cblx0XHRcdF92QiQxLmFkZChfbW9ycGhCKTtcblxuXHRcdFx0X3ZDJDEuYWRkKF9tb3JwaEMpO1xuXHRcdH1cblxuXHRcdGlmIChvYmplY3QuaXNTa2lubmVkTWVzaCkge1xuXHRcdFx0b2JqZWN0LmJvbmVUcmFuc2Zvcm0oYSwgX3ZBJDEpO1xuXHRcdFx0b2JqZWN0LmJvbmVUcmFuc2Zvcm0oYiwgX3ZCJDEpO1xuXHRcdFx0b2JqZWN0LmJvbmVUcmFuc2Zvcm0oYywgX3ZDJDEpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBfdkEkMSwgX3ZCJDEsIF92QyQxLCBfaW50ZXJzZWN0aW9uUG9pbnQpO1xuXG5cdFx0aWYgKGludGVyc2VjdGlvbikge1xuXHRcdFx0aWYgKHV2KSB7XG5cdFx0XHRcdF91dkEkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2LCBhKTtcblxuXHRcdFx0XHRfdXZCJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh1diwgYik7XG5cblx0XHRcdFx0X3V2QyQxLmZyb21CdWZmZXJBdHRyaWJ1dGUodXYsIGMpO1xuXG5cdFx0XHRcdGludGVyc2VjdGlvbi51diA9IFRyaWFuZ2xlLmdldFVWKF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBJDEsIF92QiQxLCBfdkMkMSwgX3V2QSQxLCBfdXZCJDEsIF91dkMkMSwgbmV3IFZlY3RvcjIoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1djIpIHtcblx0XHRcdFx0X3V2QSQxLmZyb21CdWZmZXJBdHRyaWJ1dGUodXYyLCBhKTtcblxuXHRcdFx0XHRfdXZCJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh1djIsIGIpO1xuXG5cdFx0XHRcdF91dkMkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2MiwgYyk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2MiA9IFRyaWFuZ2xlLmdldFVWKF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBJDEsIF92QiQxLCBfdkMkMSwgX3V2QSQxLCBfdXZCJDEsIF91dkMkMSwgbmV3IFZlY3RvcjIoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZhY2UgPSB7XG5cdFx0XHRcdGE6IGEsXG5cdFx0XHRcdGI6IGIsXG5cdFx0XHRcdGM6IGMsXG5cdFx0XHRcdG5vcm1hbDogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0bWF0ZXJpYWxJbmRleDogMFxuXHRcdFx0fTtcblx0XHRcdFRyaWFuZ2xlLmdldE5vcm1hbChfdkEkMSwgX3ZCJDEsIF92QyQxLCBmYWNlLm5vcm1hbCk7XG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblx0fVxuXG5cdGNsYXNzIEJveEdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxLCB3aWR0aFNlZ21lbnRzID0gMSwgaGVpZ2h0U2VnbWVudHMgPSAxLCBkZXB0aFNlZ21lbnRzID0gMSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdGRlcHRoOiBkZXB0aCxcblx0XHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG5cdFx0XHR9O1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzOyAvLyBzZWdtZW50c1xuXG5cdFx0XHR3aWR0aFNlZ21lbnRzID0gTWF0aC5mbG9vcih3aWR0aFNlZ21lbnRzKTtcblx0XHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vcihoZWlnaHRTZWdtZW50cyk7XG5cdFx0XHRkZXB0aFNlZ21lbnRzID0gTWF0aC5mbG9vcihkZXB0aFNlZ21lbnRzKTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0bGV0IG51bWJlck9mVmVydGljZXMgPSAwO1xuXHRcdFx0bGV0IGdyb3VwU3RhcnQgPSAwOyAvLyBidWlsZCBlYWNoIHNpZGUgb2YgdGhlIGJveCBnZW9tZXRyeVxuXG5cdFx0XHRidWlsZFBsYW5lKCd6JywgJ3knLCAneCcsIC0xLCAtMSwgZGVwdGgsIGhlaWdodCwgd2lkdGgsIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAwKTsgLy8gcHhcblxuXHRcdFx0YnVpbGRQbGFuZSgneicsICd5JywgJ3gnLCAxLCAtMSwgZGVwdGgsIGhlaWdodCwgLXdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMSk7IC8vIG54XG5cblx0XHRcdGJ1aWxkUGxhbmUoJ3gnLCAneicsICd5JywgMSwgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDIpOyAvLyBweVxuXG5cdFx0XHRidWlsZFBsYW5lKCd4JywgJ3onLCAneScsIDEsIC0xLCB3aWR0aCwgZGVwdGgsIC1oZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDMpOyAvLyBueVxuXG5cdFx0XHRidWlsZFBsYW5lKCd4JywgJ3knLCAneicsIDEsIC0xLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDQpOyAvLyBwelxuXG5cdFx0XHRidWlsZFBsYW5lKCd4JywgJ3knLCAneicsIC0xLCAtMSwgd2lkdGgsIGhlaWdodCwgLWRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgNSk7IC8vIG56XG5cdFx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRQbGFuZSh1LCB2LCB3LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ3JpZFgsIGdyaWRZLCBtYXRlcmlhbEluZGV4KSB7XG5cdFx0XHRcdGNvbnN0IHNlZ21lbnRXaWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG5cdFx0XHRcdGNvbnN0IHNlZ21lbnRIZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblx0XHRcdFx0Y29uc3Qgd2lkdGhIYWxmID0gd2lkdGggLyAyO1xuXHRcdFx0XHRjb25zdCBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblx0XHRcdFx0Y29uc3QgZGVwdGhIYWxmID0gZGVwdGggLyAyO1xuXHRcdFx0XHRjb25zdCBncmlkWDEgPSBncmlkWCArIDE7XG5cdFx0XHRcdGNvbnN0IGdyaWRZMSA9IGdyaWRZICsgMTtcblx0XHRcdFx0bGV0IHZlcnRleENvdW50ZXIgPSAwO1xuXHRcdFx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7XG5cdFx0XHRcdGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7IC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0XHRmb3IgKGxldCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgeSA9IGl5ICogc2VnbWVudEhlaWdodCAtIGhlaWdodEhhbGY7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB4ID0gaXggKiBzZWdtZW50V2lkdGggLSB3aWR0aEhhbGY7IC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XG5cblx0XHRcdFx0XHRcdHZlY3Rvclt1XSA9IHggKiB1ZGlyO1xuXHRcdFx0XHRcdFx0dmVjdG9yW3ZdID0geSAqIHZkaXI7XG5cdFx0XHRcdFx0XHR2ZWN0b3Jbd10gPSBkZXB0aEhhbGY7IC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gdmVydGV4IGJ1ZmZlclxuXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnopOyAvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG5cdFx0XHRcdFx0XHR2ZWN0b3JbdV0gPSAwO1xuXHRcdFx0XHRcdFx0dmVjdG9yW3ZdID0gMDtcblx0XHRcdFx0XHRcdHZlY3Rvclt3XSA9IGRlcHRoID4gMCA/IDEgOiAtMTsgLy8gbm93IGFwcGx5IHZlY3RvciB0byBub3JtYWwgYnVmZmVyXG5cblx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaCh2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56KTsgLy8gdXZzXG5cblx0XHRcdFx0XHRcdHV2cy5wdXNoKGl4IC8gZ3JpZFgpO1xuXHRcdFx0XHRcdFx0dXZzLnB1c2goMSAtIGl5IC8gZ3JpZFkpOyAvLyBjb3VudGVyc1xuXG5cdFx0XHRcdFx0XHR2ZXJ0ZXhDb3VudGVyICs9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGluZGljZXNcblx0XHRcdFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2Vcblx0XHRcdFx0Ly8gMi4gYSBzaW5nbGUgc2VnbWVudCBjb25zaXN0cyBvZiB0d28gZmFjZXNcblx0XHRcdFx0Ly8gMy4gc28gd2UgbmVlZCB0byBnZW5lcmF0ZSBzaXggKDIqMykgaW5kaWNlcyBwZXIgc2VnbWVudFxuXG5cblx0XHRcdFx0Zm9yIChsZXQgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSsrKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdFx0XHRjb25zdCBiID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogKGl5ICsgMSk7XG5cdFx0XHRcdFx0XHRjb25zdCBjID0gbnVtYmVyT2ZWZXJ0aWNlcyArIChpeCArIDEpICsgZ3JpZFgxICogKGl5ICsgMSk7XG5cdFx0XHRcdFx0XHRjb25zdCBkID0gbnVtYmVyT2ZWZXJ0aWNlcyArIChpeCArIDEpICsgZ3JpZFgxICogaXk7IC8vIGZhY2VzXG5cblx0XHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRcdGluZGljZXMucHVzaChiLCBjLCBkKTsgLy8gaW5jcmVhc2UgY291bnRlclxuXG5cdFx0XHRcdFx0XHRncm91cENvdW50ICs9IDY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblxuXHRcdFx0XHRzY29wZS5hZGRHcm91cChncm91cFN0YXJ0LCBncm91cENvdW50LCBtYXRlcmlhbEluZGV4KTsgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50OyAvLyB1cGRhdGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzXG5cblx0XHRcdFx0bnVtYmVyT2ZWZXJ0aWNlcyArPSB2ZXJ0ZXhDb3VudGVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEJveEdlb21ldHJ5KGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLmRlcHRoLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEuZGVwdGhTZWdtZW50cyk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogVW5pZm9ybSBVdGlsaXRpZXNcblx0ICovXG5cdGZ1bmN0aW9uIGNsb25lVW5pZm9ybXMoc3JjKSB7XG5cdFx0Y29uc3QgZHN0ID0ge307XG5cblx0XHRmb3IgKGNvbnN0IHUgaW4gc3JjKSB7XG5cdFx0XHRkc3RbdV0gPSB7fTtcblxuXHRcdFx0Zm9yIChjb25zdCBwIGluIHNyY1t1XSkge1xuXHRcdFx0XHRjb25zdCBwcm9wZXJ0eSA9IHNyY1t1XVtwXTtcblxuXHRcdFx0XHRpZiAocHJvcGVydHkgJiYgKHByb3BlcnR5LmlzQ29sb3IgfHwgcHJvcGVydHkuaXNNYXRyaXgzIHx8IHByb3BlcnR5LmlzTWF0cml4NCB8fCBwcm9wZXJ0eS5pc1ZlY3RvcjIgfHwgcHJvcGVydHkuaXNWZWN0b3IzIHx8IHByb3BlcnR5LmlzVmVjdG9yNCB8fCBwcm9wZXJ0eS5pc1RleHR1cmUgfHwgcHJvcGVydHkuaXNRdWF0ZXJuaW9uKSkge1xuXHRcdFx0XHRcdGRzdFt1XVtwXSA9IHByb3BlcnR5LmNsb25lKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRkc3RbdV1bcF0gPSBwcm9wZXJ0eS5zbGljZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRzdFt1XVtwXSA9IHByb3BlcnR5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRzdDtcblx0fVxuXHRmdW5jdGlvbiBtZXJnZVVuaWZvcm1zKHVuaWZvcm1zKSB7XG5cdFx0Y29uc3QgbWVyZ2VkID0ge307XG5cblx0XHRmb3IgKGxldCB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSsrKSB7XG5cdFx0XHRjb25zdCB0bXAgPSBjbG9uZVVuaWZvcm1zKHVuaWZvcm1zW3VdKTtcblxuXHRcdFx0Zm9yIChjb25zdCBwIGluIHRtcCkge1xuXHRcdFx0XHRtZXJnZWRbcF0gPSB0bXBbcF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lcmdlZDtcblx0fSAvLyBMZWdhY3lcblxuXHRjb25zdCBVbmlmb3Jtc1V0aWxzID0ge1xuXHRcdGNsb25lOiBjbG9uZVVuaWZvcm1zLFxuXHRcdG1lcmdlOiBtZXJnZVVuaWZvcm1zXG5cdH07XG5cblx0dmFyIGRlZmF1bHRfdmVydGV4ID0gXCJ2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn1cIjtcblxuXHR2YXIgZGVmYXVsdF9mcmFnbWVudCA9IFwidm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn1cIjtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXG5cdCAqXHR1bmlmb3JtczogeyBcInBhcmFtZXRlcjFcIjogeyB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHZhbHVlMjogMiB9IH0sXG5cdCAqXG5cdCAqXHRmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXG5cdCAqXHR2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxuXHQgKlxuXHQgKlx0d2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqXHR3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRsaWdodHM6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIFNoYWRlck1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU2hhZGVyTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5kZWZpbmVzID0ge307XG5cdFx0XHR0aGlzLnVuaWZvcm1zID0ge307XG5cdFx0XHR0aGlzLnZlcnRleFNoYWRlciA9IGRlZmF1bHRfdmVydGV4O1xuXHRcdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGRlZmF1bHRfZnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdFx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblxuXHRcdFx0dGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcblxuXHRcdFx0dGhpcy5jbGlwcGluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHVzZXItZGVmaW5lZCBjbGlwcGluZyBwbGFuZXNcblxuXHRcdFx0dGhpcy5leHRlbnNpb25zID0ge1xuXHRcdFx0XHRkZXJpdmF0aXZlczogZmFsc2UsXG5cdFx0XHRcdC8vIHNldCB0byB1c2UgZGVyaXZhdGl2ZXNcblx0XHRcdFx0ZnJhZ0RlcHRoOiBmYWxzZSxcblx0XHRcdFx0Ly8gc2V0IHRvIHVzZSBmcmFnbWVudCBkZXB0aCB2YWx1ZXNcblx0XHRcdFx0ZHJhd0J1ZmZlcnM6IGZhbHNlLFxuXHRcdFx0XHQvLyBzZXQgdG8gdXNlIGRyYXcgYnVmZmVyc1xuXHRcdFx0XHRzaGFkZXJUZXh0dXJlTE9EOiBmYWxzZSAvLyBzZXQgdG8gdXNlIHNoYWRlciB0ZXh0dXJlIExPRFxuXG5cdFx0XHR9OyAvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcblx0XHRcdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cblxuXHRcdFx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuXHRcdFx0XHQnY29sb3InOiBbMSwgMSwgMV0sXG5cdFx0XHRcdCd1dic6IFswLCAwXSxcblx0XHRcdFx0J3V2Mic6IFswLCAwXVxuXHRcdFx0fTtcblx0XHRcdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdsc2xWZXJzaW9uID0gbnVsbDtcblxuXHRcdFx0aWYgKHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAocGFyYW1ldGVycy5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xuXHRcdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBzb3VyY2UudmVydGV4U2hhZGVyO1xuXHRcdFx0dGhpcy51bmlmb3JtcyA9IGNsb25lVW5pZm9ybXMoc291cmNlLnVuaWZvcm1zKTtcblx0XHRcdHRoaXMuZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5kZWZpbmVzKTtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcblx0XHRcdHRoaXMuY2xpcHBpbmcgPSBzb3VyY2UuY2xpcHBpbmc7XG5cdFx0XHR0aGlzLmV4dGVuc2lvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuZXh0ZW5zaW9ucyk7XG5cdFx0XHR0aGlzLmdsc2xWZXJzaW9uID0gc291cmNlLmdsc2xWZXJzaW9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04obWV0YSk7XG5cdFx0XHRkYXRhLmdsc2xWZXJzaW9uID0gdGhpcy5nbHNsVmVyc2lvbjtcblx0XHRcdGRhdGEudW5pZm9ybXMgPSB7fTtcblxuXHRcdFx0Zm9yIChjb25zdCBuYW1lIGluIHRoaXMudW5pZm9ybXMpIHtcblx0XHRcdFx0Y29uc3QgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcblxuXHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdFx0ZGF0YS51bmlmb3Jtc1tuYW1lXSA9IHtcblx0XHRcdFx0XHRcdHR5cGU6ICd0Jyxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0pTT04obWV0YSkudXVpZFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuaXNDb2xvcikge1xuXHRcdFx0XHRcdGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnYycsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUuZ2V0SGV4KClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLmlzVmVjdG9yMikge1xuXHRcdFx0XHRcdGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiAndjInLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuaXNWZWN0b3IzKSB7XG5cdFx0XHRcdFx0ZGF0YS51bmlmb3Jtc1tuYW1lXSA9IHtcblx0XHRcdFx0XHRcdHR5cGU6ICd2MycsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUudG9BcnJheSgpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc1ZlY3RvcjQpIHtcblx0XHRcdFx0XHRkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuXHRcdFx0XHRcdFx0dHlwZTogJ3Y0Jyxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLmlzTWF0cml4Mykge1xuXHRcdFx0XHRcdGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnbTMnLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuaXNNYXRyaXg0KSB7XG5cdFx0XHRcdFx0ZGF0YS51bmlmb3Jtc1tuYW1lXSA9IHtcblx0XHRcdFx0XHRcdHR5cGU6ICdtNCcsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUudG9BcnJheSgpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fTsgLy8gbm90ZTogdGhlIGFycmF5IHZhcmlhbnRzIHYydiwgdjN2LCB2NHYsIG00diBhbmQgdHYgYXJlIG5vdCBzdXBwb3J0ZWQgc28gZmFyXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKE9iamVjdC5rZXlzKHRoaXMuZGVmaW5lcykubGVuZ3RoID4gMCkgZGF0YS5kZWZpbmVzID0gdGhpcy5kZWZpbmVzO1xuXHRcdFx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcblx0XHRcdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXHRcdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmV4dGVuc2lvbnMpIHtcblx0XHRcdFx0aWYgKHRoaXMuZXh0ZW5zaW9uc1trZXldID09PSB0cnVlKSBleHRlbnNpb25zW2tleV0gPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoZXh0ZW5zaW9ucykubGVuZ3RoID4gMCkgZGF0YS5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmlzU2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdGNsYXNzIENhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblx0XHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSwgcmVjdXJzaXZlKTtcblx0XHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoc291cmNlLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXguY29weShzb3VyY2UucHJvamVjdGlvbk1hdHJpeCk7XG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoc291cmNlLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldFdvcmxkRGlyZWN0aW9uKHRhcmdldCkge1xuXHRcdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRjb25zdCBlID0gdGhpcy5tYXRyaXhXb3JsZC5lbGVtZW50cztcblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KC1lWzhdLCAtZVs5XSwgLWVbMTBdKS5ub3JtYWxpemUoKTtcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHR9XG5cblx0XHR1cGRhdGVXb3JsZE1hdHJpeCh1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbikge1xuXHRcdFx0c3VwZXIudXBkYXRlV29ybGRNYXRyaXgodXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdH1cblxuXHRDYW1lcmEucHJvdG90eXBlLmlzQ2FtZXJhID0gdHJ1ZTtcblxuXHRjbGFzcyBQZXJzcGVjdGl2ZUNhbWVyYSBleHRlbmRzIENhbWVyYSB7XG5cdFx0Y29uc3RydWN0b3IoZm92ID0gNTAsIGFzcGVjdCA9IDEsIG5lYXIgPSAwLjEsIGZhciA9IDIwMDApIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuXHRcdFx0dGhpcy5mb3YgPSBmb3Y7XG5cdFx0XHR0aGlzLnpvb20gPSAxO1xuXHRcdFx0dGhpcy5uZWFyID0gbmVhcjtcblx0XHRcdHRoaXMuZmFyID0gZmFyO1xuXHRcdFx0dGhpcy5mb2N1cyA9IDEwO1xuXHRcdFx0dGhpcy5hc3BlY3QgPSBhc3BlY3Q7XG5cdFx0XHR0aGlzLnZpZXcgPSBudWxsO1xuXHRcdFx0dGhpcy5maWxtR2F1Z2UgPSAzNTsgLy8gd2lkdGggb2YgdGhlIGZpbG0gKGRlZmF1bHQgaW4gbWlsbGltZXRlcnMpXG5cblx0XHRcdHRoaXMuZmlsbU9mZnNldCA9IDA7IC8vIGhvcml6b250YWwgZmlsbSBvZmZzZXQgKHNhbWUgdW5pdCBhcyBnYXVnZSlcblxuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0XHR0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG5cdFx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblx0XHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuXHRcdFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXHRcdFx0dGhpcy5mb2N1cyA9IHNvdXJjZS5mb2N1cztcblx0XHRcdHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcblx0XHRcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS52aWV3KTtcblx0XHRcdHRoaXMuZmlsbUdhdWdlID0gc291cmNlLmZpbG1HYXVnZTtcblx0XHRcdHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdGhlIEZPViBieSBmb2NhbCBsZW5ndGggaW4gcmVzcGVjdCB0byB0aGUgY3VycmVudCAuZmlsbUdhdWdlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGRlZmF1bHQgZmlsbSBnYXVnZSBpcyAzNSwgc28gdGhhdCB0aGUgZm9jYWwgbGVuZ3RoIGNhbiBiZSBzcGVjaWZpZWQgZm9yXG5cdFx0ICogYSAzNW1tIChmdWxsIGZyYW1lKSBjYW1lcmEuXG5cdFx0ICpcblx0XHQgKiBWYWx1ZXMgZm9yIGZvY2FsIGxlbmd0aCBhbmQgZmlsbSBnYXVnZSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdC5cblx0XHQgKi9cblxuXG5cdFx0c2V0Rm9jYWxMZW5ndGgoZm9jYWxMZW5ndGgpIHtcblx0XHRcdC8qKiBzZWUge0BsaW5rIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sfSAqL1xuXHRcdFx0Y29uc3QgdkV4dGVudFNsb3BlID0gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyBmb2NhbExlbmd0aDtcblx0XHRcdHRoaXMuZm92ID0gUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4odkV4dGVudFNsb3BlKTtcblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBDYWxjdWxhdGVzIHRoZSBmb2NhbCBsZW5ndGggZnJvbSB0aGUgY3VycmVudCAuZm92IGFuZCAuZmlsbUdhdWdlLlxuXHRcdCAqL1xuXG5cblx0XHRnZXRGb2NhbExlbmd0aCgpIHtcblx0XHRcdGNvbnN0IHZFeHRlbnRTbG9wZSA9IE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdik7XG5cdFx0XHRyZXR1cm4gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyB2RXh0ZW50U2xvcGU7XG5cdFx0fVxuXG5cdFx0Z2V0RWZmZWN0aXZlRk9WKCkge1xuXHRcdFx0cmV0dXJuIFJBRDJERUcgKiAyICogTWF0aC5hdGFuKE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdikgLyB0aGlzLnpvb20pO1xuXHRcdH1cblxuXHRcdGdldEZpbG1XaWR0aCgpIHtcblx0XHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBwb3J0cmFpdCBmb3JtYXQgKGFzcGVjdCA8IDEpXG5cdFx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbih0aGlzLmFzcGVjdCwgMSk7XG5cdFx0fVxuXG5cdFx0Z2V0RmlsbUhlaWdodCgpIHtcblx0XHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBsYW5kc2NhcGUgZm9ybWF0IChhc3BlY3QgPiAxKVxuXHRcdFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlIC8gTWF0aC5tYXgodGhpcy5hc3BlY3QsIDEpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG5cdFx0ICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cblx0XHQgKlxuXHRcdCAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXG5cdFx0ICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xuXHRcdCAqXG5cdFx0ICpcdCArLS0tKy0tLSstLS0rXG5cdFx0ICpcdCB8IEEgfCBCIHwgQyB8XG5cdFx0ICpcdCArLS0tKy0tLSstLS0rXG5cdFx0ICpcdCB8IEQgfCBFIHwgRiB8XG5cdFx0ICpcdCArLS0tKy0tLSstLS0rXG5cdFx0ICpcblx0XHQgKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXG5cdFx0ICpcblx0XHQgKlx0IGNvbnN0IHcgPSAxOTIwO1xuXHRcdCAqXHQgY29uc3QgaCA9IDEwODA7XG5cdFx0ICpcdCBjb25zdCBmdWxsV2lkdGggPSB3ICogMztcblx0XHQgKlx0IGNvbnN0IGZ1bGxIZWlnaHQgPSBoICogMjtcblx0XHQgKlxuXHRcdCAqXHQgLS1BLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xuXHRcdCAqXHQgLS1CLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xuXHRcdCAqXHQgLS1DLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xuXHRcdCAqXHQgLS1ELS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xuXHRcdCAqXHQgLS1FLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xuXHRcdCAqXHQgLS1GLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xuXHRcdCAqXG5cdFx0ICpcdCBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxuXHRcdCAqL1xuXG5cblx0XHRzZXRWaWV3T2Zmc2V0KGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdFx0dGhpcy5hc3BlY3QgPSBmdWxsV2lkdGggLyBmdWxsSGVpZ2h0O1xuXG5cdFx0XHRpZiAodGhpcy52aWV3ID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMudmlldyA9IHtcblx0XHRcdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0XHRcdGZ1bGxXaWR0aDogMSxcblx0XHRcdFx0XHRmdWxsSGVpZ2h0OiAxLFxuXHRcdFx0XHRcdG9mZnNldFg6IDAsXG5cdFx0XHRcdFx0b2Zmc2V0WTogMCxcblx0XHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0XHRoZWlnaHQ6IDFcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy52aWV3LmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblx0XHRcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcblx0XHRcdHRoaXMudmlldy5vZmZzZXRYID0geDtcblx0XHRcdHRoaXMudmlldy5vZmZzZXRZID0geTtcblx0XHRcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0dGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdH1cblxuXHRcdGNsZWFyVmlld09mZnNldCgpIHtcblx0XHRcdGlmICh0aGlzLnZpZXcgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0fVxuXG5cdFx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcblx0XHRcdGNvbnN0IG5lYXIgPSB0aGlzLm5lYXI7XG5cdFx0XHRsZXQgdG9wID0gbmVhciAqIE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdikgLyB0aGlzLnpvb207XG5cdFx0XHRsZXQgaGVpZ2h0ID0gMiAqIHRvcDtcblx0XHRcdGxldCB3aWR0aCA9IHRoaXMuYXNwZWN0ICogaGVpZ2h0O1xuXHRcdFx0bGV0IGxlZnQgPSAtMC41ICogd2lkdGg7XG5cdFx0XHRjb25zdCB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0XHRpZiAodGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkKSB7XG5cdFx0XHRcdGNvbnN0IGZ1bGxXaWR0aCA9IHZpZXcuZnVsbFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRmdWxsSGVpZ2h0ID0gdmlldy5mdWxsSGVpZ2h0O1xuXHRcdFx0XHRsZWZ0ICs9IHZpZXcub2Zmc2V0WCAqIHdpZHRoIC8gZnVsbFdpZHRoO1xuXHRcdFx0XHR0b3AgLT0gdmlldy5vZmZzZXRZICogaGVpZ2h0IC8gZnVsbEhlaWdodDtcblx0XHRcdFx0d2lkdGggKj0gdmlldy53aWR0aCAvIGZ1bGxXaWR0aDtcblx0XHRcdFx0aGVpZ2h0ICo9IHZpZXcuaGVpZ2h0IC8gZnVsbEhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2tldyA9IHRoaXMuZmlsbU9mZnNldDtcblx0XHRcdGlmIChza2V3ICE9PSAwKSBsZWZ0ICs9IG5lYXIgKiBza2V3IC8gdGhpcy5nZXRGaWxtV2lkdGgoKTtcblx0XHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUobGVmdCwgbGVmdCArIHdpZHRoLCB0b3AsIHRvcCAtIGhlaWdodCwgbmVhciwgdGhpcy5mYXIpO1xuXHRcdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCk7XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04obWV0YSk7XG5cdFx0XHRkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcblx0XHRcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG5cdFx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuXHRcdFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cdFx0XHRkYXRhLm9iamVjdC5mb2N1cyA9IHRoaXMuZm9jdXM7XG5cdFx0XHRkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcblx0XHRcdGlmICh0aGlzLnZpZXcgIT09IG51bGwpIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXcpO1xuXHRcdFx0ZGF0YS5vYmplY3QuZmlsbUdhdWdlID0gdGhpcy5maWxtR2F1Z2U7XG5cdFx0XHRkYXRhLm9iamVjdC5maWxtT2Zmc2V0ID0gdGhpcy5maWxtT2Zmc2V0O1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdH1cblxuXHRQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuaXNQZXJzcGVjdGl2ZUNhbWVyYSA9IHRydWU7XG5cblx0Y29uc3QgZm92ID0gOTAsXG5cdFx0XHRcdGFzcGVjdCA9IDE7XG5cblx0Y2xhc3MgQ3ViZUNhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcihuZWFyLCBmYXIsIHJlbmRlclRhcmdldCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuXHRcdFx0aWYgKHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5DdWJlQ2FtZXJhOiBUaGUgY29uc3RydWN0b3Igbm93IGV4cGVjdHMgYW4gaW5zdGFuY2Ugb2YgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0IGFzIHRoaXJkIHBhcmFtZXRlci4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblx0XHRcdGNvbnN0IGNhbWVyYVBYID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuXHRcdFx0Y2FtZXJhUFgubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0XHRjYW1lcmFQWC51cC5zZXQoMCwgLTEsIDApO1xuXHRcdFx0Y2FtZXJhUFgubG9va0F0KG5ldyBWZWN0b3IzKDEsIDAsIDApKTtcblx0XHRcdHRoaXMuYWRkKGNhbWVyYVBYKTtcblx0XHRcdGNvbnN0IGNhbWVyYU5YID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuXHRcdFx0Y2FtZXJhTlgubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0XHRjYW1lcmFOWC51cC5zZXQoMCwgLTEsIDApO1xuXHRcdFx0Y2FtZXJhTlgubG9va0F0KG5ldyBWZWN0b3IzKC0xLCAwLCAwKSk7XG5cdFx0XHR0aGlzLmFkZChjYW1lcmFOWCk7XG5cdFx0XHRjb25zdCBjYW1lcmFQWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRcdGNhbWVyYVBZLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdFx0Y2FtZXJhUFkudXAuc2V0KDAsIDAsIDEpO1xuXHRcdFx0Y2FtZXJhUFkubG9va0F0KG5ldyBWZWN0b3IzKDAsIDEsIDApKTtcblx0XHRcdHRoaXMuYWRkKGNhbWVyYVBZKTtcblx0XHRcdGNvbnN0IGNhbWVyYU5ZID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuXHRcdFx0Y2FtZXJhTlkubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0XHRjYW1lcmFOWS51cC5zZXQoMCwgMCwgLTEpO1xuXHRcdFx0Y2FtZXJhTlkubG9va0F0KG5ldyBWZWN0b3IzKDAsIC0xLCAwKSk7XG5cdFx0XHR0aGlzLmFkZChjYW1lcmFOWSk7XG5cdFx0XHRjb25zdCBjYW1lcmFQWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRcdGNhbWVyYVBaLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdFx0Y2FtZXJhUFoudXAuc2V0KDAsIC0xLCAwKTtcblx0XHRcdGNhbWVyYVBaLmxvb2tBdChuZXcgVmVjdG9yMygwLCAwLCAxKSk7XG5cdFx0XHR0aGlzLmFkZChjYW1lcmFQWik7XG5cdFx0XHRjb25zdCBjYW1lcmFOWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRcdGNhbWVyYU5aLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdFx0Y2FtZXJhTloudXAuc2V0KDAsIC0xLCAwKTtcblx0XHRcdGNhbWVyYU5aLmxvb2tBdChuZXcgVmVjdG9yMygwLCAwLCAtMSkpO1xuXHRcdFx0dGhpcy5hZGQoY2FtZXJhTlopO1xuXHRcdH1cblxuXHRcdHVwZGF0ZShyZW5kZXJlciwgc2NlbmUpIHtcblx0XHRcdGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG5cdFx0XHRjb25zdCBbY2FtZXJhUFgsIGNhbWVyYU5YLCBjYW1lcmFQWSwgY2FtZXJhTlksIGNhbWVyYVBaLCBjYW1lcmFOWl0gPSB0aGlzLmNoaWxkcmVuO1xuXHRcdFx0Y29uc3QgY3VycmVudFhyRW5hYmxlZCA9IHJlbmRlcmVyLnhyLmVuYWJsZWQ7XG5cdFx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0XHRyZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG5cdFx0XHRjb25zdCBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQsIDApO1xuXHRcdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFQWCk7XG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0LCAxKTtcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhTlgpO1xuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgMik7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYVBZKTtcblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQsIDMpO1xuXHRcdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFOWSk7XG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0LCA0KTtcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhUFopO1xuXHRcdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgNSk7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYU5aKTtcblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChjdXJyZW50UmVuZGVyVGFyZ2V0KTtcblx0XHRcdHJlbmRlcmVyLnhyLmVuYWJsZWQgPSBjdXJyZW50WHJFbmFibGVkO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQ3ViZVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0XHRjb25zdHJ1Y3RvcihpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcpIHtcblx0XHRcdGltYWdlcyA9IGltYWdlcyAhPT0gdW5kZWZpbmVkID8gaW1hZ2VzIDogW107XG5cdFx0XHRtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcblx0XHRcdGZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogUkdCRm9ybWF0O1xuXHRcdFx0c3VwZXIoaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nKTtcblx0XHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRnZXQgaW1hZ2VzKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW1hZ2U7XG5cdFx0fVxuXG5cdFx0c2V0IGltYWdlcyh2YWx1ZSkge1xuXHRcdFx0dGhpcy5pbWFnZSA9IHZhbHVlO1xuXHRcdH1cblxuXHR9XG5cblx0Q3ViZVRleHR1cmUucHJvdG90eXBlLmlzQ3ViZVRleHR1cmUgPSB0cnVlO1xuXG5cdGNsYXNzIFdlYkdMQ3ViZVJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcblx0XHRjb25zdHJ1Y3RvcihzaXplLCBvcHRpb25zLCBkdW1teSkge1xuXHRcdFx0aWYgKE51bWJlci5pc0ludGVnZXIob3B0aW9ucykpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTEN1YmVSZW5kZXJUYXJnZXQ6IGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBpcyBub3cgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KCBzaXplLCBvcHRpb25zICknKTtcblx0XHRcdFx0b3B0aW9ucyA9IGR1bW15O1xuXHRcdFx0fVxuXG5cdFx0XHRzdXBlcihzaXplLCBzaXplLCBvcHRpb25zKTtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBCeSBjb252ZW50aW9uIC0tIGxpa2VseSBiYXNlZCBvbiB0aGUgUmVuZGVyTWFuIHNwZWMgZnJvbSB0aGUgMTk5MCdzIC0tIGN1YmUgbWFwcyBhcmUgc3BlY2lmaWVkIGJ5IFdlYkdMIChhbmQgdGhyZWUuanMpXG5cdFx0XHQvLyBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtIGluIHdoaWNoIHBvc2l0aXZlLXggaXMgdG8gdGhlIHJpZ2h0IHdoZW4gbG9va2luZyB1cCB0aGUgcG9zaXRpdmUteiBheGlzIC0tIGluIG90aGVyIHdvcmRzLFxuXHRcdFx0Ly8gaW4gYSBsZWZ0LWhhbmRlZCBjb29yZGluYXRlIHN5c3RlbS4gQnkgY29udGludWluZyB0aGlzIGNvbnZlbnRpb24sIHByZWV4aXN0aW5nIGN1YmUgbWFwcyBjb250aW51ZWQgdG8gcmVuZGVyIGNvcnJlY3RseS5cblx0XHRcdC8vIHRocmVlLmpzIHVzZXMgYSByaWdodC1oYW5kZWQgY29vcmRpbmF0ZSBzeXN0ZW0uIFNvIGVudmlyb25tZW50IG1hcHMgdXNlZCBpbiB0aHJlZS5qcyBhcHBlYXIgdG8gaGF2ZSBweCBhbmQgbnggc3dhcHBlZFxuXHRcdFx0Ly8gYW5kIHRoZSBmbGFnIGlzUmVuZGVyVGFyZ2V0VGV4dHVyZSBjb250cm9scyB0aGlzIGNvbnZlcnNpb24uIFRoZSBmbGlwIGlzIG5vdCByZXF1aXJlZCB3aGVuIHVzaW5nIFdlYkdMQ3ViZVJlbmRlclRhcmdldC50ZXh0dXJlXG5cdFx0XHQvLyBhcyBhIGN1YmUgdGV4dHVyZSAodGhpcyBpcyBkZXRlY3RlZCB3aGVuIGlzUmVuZGVyVGFyZ2V0VGV4dHVyZSBpcyBzZXQgdG8gdHJ1ZSBmb3IgY3ViZSB0ZXh0dXJlcykuXG5cblx0XHRcdHRoaXMudGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZSh1bmRlZmluZWQsIG9wdGlvbnMubWFwcGluZywgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuZW5jb2RpbmcpO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cdFx0XHR0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XG5cdFx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gb3B0aW9ucy5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHRcdFx0dGhpcy50ZXh0dXJlLl9uZWVkc0ZsaXBFbnZNYXAgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRmcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZShyZW5kZXJlciwgdGV4dHVyZSkge1xuXHRcdFx0dGhpcy50ZXh0dXJlLnR5cGUgPSB0ZXh0dXJlLnR5cGU7XG5cdFx0XHR0aGlzLnRleHR1cmUuZm9ybWF0ID0gUkdCQUZvcm1hdDsgLy8gc2VlICMxODg1OVxuXG5cdFx0XHR0aGlzLnRleHR1cmUuZW5jb2RpbmcgPSB0ZXh0dXJlLmVuY29kaW5nO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyO1xuXHRcdFx0dGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleHR1cmUubWFnRmlsdGVyO1xuXHRcdFx0Y29uc3Qgc2hhZGVyID0ge1xuXHRcdFx0XHR1bmlmb3Jtczoge1xuXHRcdFx0XHRcdHRFcXVpcmVjdDoge1xuXHRcdFx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZlcnRleFNoYWRlcjpcblx0XHRcdFx0LyogZ2xzbCAqL1xuXHRcdFx0XHRgXG5cblx0XHRcdFx0dmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcblxuXHRcdFx0XHR2ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHRcdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XG5cblx0XHRcdFx0XHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHRcdFx0XHRcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cblxuXHRcdFx0XHR9XG5cdFx0XHRgLFxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjpcblx0XHRcdFx0LyogZ2xzbCAqL1xuXHRcdFx0XHRgXG5cblx0XHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1xuXG5cdFx0XHRcdHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XG5cblx0XHRcdFx0I2luY2x1ZGUgPGNvbW1vbj5cblxuXHRcdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0XHR2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkRGlyZWN0aW9uICk7XG5cblx0XHRcdFx0XHR2ZWMyIHNhbXBsZVVWID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7XG5cblx0XHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcblxuXHRcdFx0XHR9XG5cdFx0XHRgXG5cdFx0XHR9O1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQm94R2VvbWV0cnkoNSwgNSwgNSk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbCh7XG5cdFx0XHRcdG5hbWU6ICdDdWJlbWFwRnJvbUVxdWlyZWN0Jyxcblx0XHRcdFx0dW5pZm9ybXM6IGNsb25lVW5pZm9ybXMoc2hhZGVyLnVuaWZvcm1zKSxcblx0XHRcdFx0dmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuXHRcdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdFx0YmxlbmRpbmc6IE5vQmxlbmRpbmdcblx0XHRcdH0pO1xuXHRcdFx0bWF0ZXJpYWwudW5pZm9ybXMudEVxdWlyZWN0LnZhbHVlID0gdGV4dHVyZTtcblx0XHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0Y29uc3QgY3VycmVudE1pbkZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyOyAvLyBBdm9pZCBibHVycmVkIHBvbGVzXG5cblx0XHRcdGlmICh0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyKSB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblx0XHRcdGNvbnN0IGNhbWVyYSA9IG5ldyBDdWJlQ2FtZXJhKDEsIDEwLCB0aGlzKTtcblx0XHRcdGNhbWVyYS51cGRhdGUocmVuZGVyZXIsIG1lc2gpO1xuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBjdXJyZW50TWluRmlsdGVyO1xuXHRcdFx0bWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHRtZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsZWFyKHJlbmRlcmVyLCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwpIHtcblx0XHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMsIGkpO1xuXHRcdFx0XHRyZW5kZXJlci5jbGVhcihjb2xvciwgZGVwdGgsIHN0ZW5jaWwpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoY3VycmVudFJlbmRlclRhcmdldCk7XG5cdFx0fVxuXG5cdH1cblxuXHRXZWJHTEN1YmVSZW5kZXJUYXJnZXQucHJvdG90eXBlLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcblxuXHRjb25zdCBfdmVjdG9yMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92ZWN0b3IyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX25vcm1hbE1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4MygpO1xuXG5cdGNsYXNzIFBsYW5lIHtcblx0XHRjb25zdHJ1Y3Rvcihub3JtYWwgPSBuZXcgVmVjdG9yMygxLCAwLCAwKSwgY29uc3RhbnQgPSAwKSB7XG5cdFx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cdFx0XHR0aGlzLm5vcm1hbCA9IG5vcm1hbDtcblx0XHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblx0XHR9XG5cblx0XHRzZXQobm9ybWFsLCBjb25zdGFudCkge1xuXHRcdFx0dGhpcy5ub3JtYWwuY29weShub3JtYWwpO1xuXHRcdFx0dGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0Q29tcG9uZW50cyh4LCB5LCB6LCB3KSB7XG5cdFx0XHR0aGlzLm5vcm1hbC5zZXQoeCwgeSwgeik7XG5cdFx0XHR0aGlzLmNvbnN0YW50ID0gdztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KG5vcm1hbCwgcG9pbnQpIHtcblx0XHRcdHRoaXMubm9ybWFsLmNvcHkobm9ybWFsKTtcblx0XHRcdHRoaXMuY29uc3RhbnQgPSAtcG9pbnQuZG90KHRoaXMubm9ybWFsKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21Db3BsYW5hclBvaW50cyhhLCBiLCBjKSB7XG5cdFx0XHRjb25zdCBub3JtYWwgPSBfdmVjdG9yMS5zdWJWZWN0b3JzKGMsIGIpLmNyb3NzKF92ZWN0b3IyLnN1YlZlY3RvcnMoYSwgYikpLm5vcm1hbGl6ZSgpOyAvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xuXG5cblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQobm9ybWFsLCBhKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHkocGxhbmUpIHtcblx0XHRcdHRoaXMubm9ybWFsLmNvcHkocGxhbmUubm9ybWFsKTtcblx0XHRcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG5vcm1hbGl6ZSgpIHtcblx0XHRcdC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxuXHRcdFx0Y29uc3QgaW52ZXJzZU5vcm1hbExlbmd0aCA9IDEuMCAvIHRoaXMubm9ybWFsLmxlbmd0aCgpO1xuXHRcdFx0dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoaW52ZXJzZU5vcm1hbExlbmd0aCk7XG5cdFx0XHR0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRuZWdhdGUoKSB7XG5cdFx0XHR0aGlzLmNvbnN0YW50ICo9IC0xO1xuXHRcdFx0dGhpcy5ub3JtYWwubmVnYXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbC5kb3QocG9pbnQpICsgdGhpcy5jb25zdGFudDtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVRvU3BoZXJlKHNwaGVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KHNwaGVyZS5jZW50ZXIpIC0gc3BoZXJlLnJhZGl1cztcblx0XHR9XG5cblx0XHRwcm9qZWN0UG9pbnQocG9pbnQsIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcigtdGhpcy5kaXN0YW5jZVRvUG9pbnQocG9pbnQpKS5hZGQocG9pbnQpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdExpbmUobGluZSwgdGFyZ2V0KSB7XG5cdFx0XHRjb25zdCBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKF92ZWN0b3IxKTtcblx0XHRcdGNvbnN0IGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KGRpcmVjdGlvbik7XG5cblx0XHRcdGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuXHRcdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXG5cdFx0XHRcdGlmICh0aGlzLmRpc3RhbmNlVG9Qb2ludChsaW5lLnN0YXJ0KSA9PT0gMCkge1xuXHRcdFx0XHRcdHJldHVybiB0YXJnZXQuY29weShsaW5lLnN0YXJ0KTtcblx0XHRcdFx0fSAvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cblxuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0ID0gLShsaW5lLnN0YXJ0LmRvdCh0aGlzLm5vcm1hbCkgKyB0aGlzLmNvbnN0YW50KSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0XHRpZiAodCA8IDAgfHwgdCA+IDEpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0YXJnZXQuY29weShkaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKHQpLmFkZChsaW5lLnN0YXJ0KTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzTGluZShsaW5lKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cblx0XHRcdGNvbnN0IHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KGxpbmUuc3RhcnQpO1xuXHRcdFx0Y29uc3QgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KGxpbmUuZW5kKTtcblx0XHRcdHJldHVybiBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwIHx8IGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDA7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c0JveChib3gpIHtcblx0XHRcdHJldHVybiBib3guaW50ZXJzZWN0c1BsYW5lKHRoaXMpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSB7XG5cdFx0XHRyZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSh0aGlzKTtcblx0XHR9XG5cblx0XHRjb3BsYW5hclBvaW50KHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcigtdGhpcy5jb25zdGFudCk7XG5cdFx0fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXgpIHtcblx0XHRcdGNvbnN0IG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IF9ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KG1hdHJpeCk7XG5cblx0XHRcdGNvbnN0IHJlZmVyZW5jZVBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KF92ZWN0b3IxKS5hcHBseU1hdHJpeDQobWF0cml4KTtcblx0XHRcdGNvbnN0IG5vcm1hbCA9IHRoaXMubm9ybWFsLmFwcGx5TWF0cml4Myhub3JtYWxNYXRyaXgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5jb25zdGFudCA9IC1yZWZlcmVuY2VQb2ludC5kb3Qobm9ybWFsKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRyYW5zbGF0ZShvZmZzZXQpIHtcblx0XHRcdHRoaXMuY29uc3RhbnQgLT0gb2Zmc2V0LmRvdCh0aGlzLm5vcm1hbCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlcXVhbHMocGxhbmUpIHtcblx0XHRcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKHRoaXMubm9ybWFsKSAmJiBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudDtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdH1cblxuXHRQbGFuZS5wcm90b3R5cGUuaXNQbGFuZSA9IHRydWU7XG5cblx0Y29uc3QgX3NwaGVyZSQyID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcblxuXHRjb25zdCBfdmVjdG9yJDcgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBGcnVzdHVtIHtcblx0XHRjb25zdHJ1Y3RvcihwMCA9IG5ldyBQbGFuZSgpLCBwMSA9IG5ldyBQbGFuZSgpLCBwMiA9IG5ldyBQbGFuZSgpLCBwMyA9IG5ldyBQbGFuZSgpLCBwNCA9IG5ldyBQbGFuZSgpLCBwNSA9IG5ldyBQbGFuZSgpKSB7XG5cdFx0XHR0aGlzLnBsYW5lcyA9IFtwMCwgcDEsIHAyLCBwMywgcDQsIHA1XTtcblx0XHR9XG5cblx0XHRzZXQocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSkge1xuXHRcdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cdFx0XHRwbGFuZXNbMF0uY29weShwMCk7XG5cdFx0XHRwbGFuZXNbMV0uY29weShwMSk7XG5cdFx0XHRwbGFuZXNbMl0uY29weShwMik7XG5cdFx0XHRwbGFuZXNbM10uY29weShwMyk7XG5cdFx0XHRwbGFuZXNbNF0uY29weShwNCk7XG5cdFx0XHRwbGFuZXNbNV0uY29weShwNSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KGZydXN0dW0pIHtcblx0XHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRwbGFuZXNbaV0uY29weShmcnVzdHVtLnBsYW5lc1tpXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21Qcm9qZWN0aW9uTWF0cml4KG0pIHtcblx0XHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgbWUwID0gbWVbMF0sXG5cdFx0XHRcdFx0XHRtZTEgPSBtZVsxXSxcblx0XHRcdFx0XHRcdG1lMiA9IG1lWzJdLFxuXHRcdFx0XHRcdFx0bWUzID0gbWVbM107XG5cdFx0XHRjb25zdCBtZTQgPSBtZVs0XSxcblx0XHRcdFx0XHRcdG1lNSA9IG1lWzVdLFxuXHRcdFx0XHRcdFx0bWU2ID0gbWVbNl0sXG5cdFx0XHRcdFx0XHRtZTcgPSBtZVs3XTtcblx0XHRcdGNvbnN0IG1lOCA9IG1lWzhdLFxuXHRcdFx0XHRcdFx0bWU5ID0gbWVbOV0sXG5cdFx0XHRcdFx0XHRtZTEwID0gbWVbMTBdLFxuXHRcdFx0XHRcdFx0bWUxMSA9IG1lWzExXTtcblx0XHRcdGNvbnN0IG1lMTIgPSBtZVsxMl0sXG5cdFx0XHRcdFx0XHRtZTEzID0gbWVbMTNdLFxuXHRcdFx0XHRcdFx0bWUxNCA9IG1lWzE0XSxcblx0XHRcdFx0XHRcdG1lMTUgPSBtZVsxNV07XG5cdFx0XHRwbGFuZXNbMF0uc2V0Q29tcG9uZW50cyhtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cGxhbmVzWzFdLnNldENvbXBvbmVudHMobWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyKS5ub3JtYWxpemUoKTtcblx0XHRcdHBsYW5lc1syXS5zZXRDb21wb25lbnRzKG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMykubm9ybWFsaXplKCk7XG5cdFx0XHRwbGFuZXNbM10uc2V0Q29tcG9uZW50cyhtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cGxhbmVzWzRdLnNldENvbXBvbmVudHMobWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCkubm9ybWFsaXplKCk7XG5cdFx0XHRwbGFuZXNbNV0uc2V0Q29tcG9uZW50cyhtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0KS5ub3JtYWxpemUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNPYmplY3Qob2JqZWN0KSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHRcdGlmIChnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdF9zcGhlcmUkMi5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKS5hcHBseU1hdHJpeDQob2JqZWN0Lm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZShfc3BoZXJlJDIpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNTcHJpdGUoc3ByaXRlKSB7XG5cdFx0XHRfc3BoZXJlJDIuY2VudGVyLnNldCgwLCAwLCAwKTtcblxuXHRcdFx0X3NwaGVyZSQyLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3NjtcblxuXHRcdFx0X3NwaGVyZSQyLmFwcGx5TWF0cml4NChzcHJpdGUubWF0cml4V29ybGQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKF9zcGhlcmUkMik7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c1NwaGVyZShzcGhlcmUpIHtcblx0XHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdFx0Y29uc3QgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcblx0XHRcdGNvbnN0IG5lZ1JhZGl1cyA9IC1zcGhlcmUucmFkaXVzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRjb25zdCBkaXN0YW5jZSA9IHBsYW5lc1tpXS5kaXN0YW5jZVRvUG9pbnQoY2VudGVyKTtcblxuXHRcdFx0XHRpZiAoZGlzdGFuY2UgPCBuZWdSYWRpdXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c0JveChib3gpIHtcblx0XHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRjb25zdCBwbGFuZSA9IHBsYW5lc1tpXTsgLy8gY29ybmVyIGF0IG1heCBkaXN0YW5jZVxuXG5cdFx0XHRcdF92ZWN0b3IkNy54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xuXHRcdFx0XHRfdmVjdG9yJDcueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcblx0XHRcdFx0X3ZlY3RvciQ3LnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XG5cblx0XHRcdFx0aWYgKHBsYW5lLmRpc3RhbmNlVG9Qb2ludChfdmVjdG9yJDcpIDwgMCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRjb250YWluc1BvaW50KHBvaW50KSB7XG5cdFx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0aWYgKHBsYW5lc1tpXS5kaXN0YW5jZVRvUG9pbnQocG9pbnQpIDwgMCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEFuaW1hdGlvbigpIHtcblx0XHRsZXQgY29udGV4dCA9IG51bGw7XG5cdFx0bGV0IGlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0bGV0IGFuaW1hdGlvbkxvb3AgPSBudWxsO1xuXHRcdGxldCByZXF1ZXN0SWQgPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gb25BbmltYXRpb25GcmFtZSh0aW1lLCBmcmFtZSkge1xuXHRcdFx0YW5pbWF0aW9uTG9vcCh0aW1lLCBmcmFtZSk7XG5cdFx0XHRyZXF1ZXN0SWQgPSBjb250ZXh0LnJlcXVlc3RBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKGlzQW5pbWF0aW5nID09PSB0cnVlKSByZXR1cm47XG5cdFx0XHRcdGlmIChhbmltYXRpb25Mb29wID09PSBudWxsKSByZXR1cm47XG5cdFx0XHRcdHJlcXVlc3RJZCA9IGNvbnRleHQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uQW5pbWF0aW9uRnJhbWUpO1xuXHRcdFx0XHRpc0FuaW1hdGluZyA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb250ZXh0LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZCk7XG5cdFx0XHRcdGlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0c2V0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGFuaW1hdGlvbkxvb3AgPSBjYWxsYmFjaztcblx0XHRcdH0sXG5cdFx0XHRzZXRDb250ZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29udGV4dCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEF0dHJpYnV0ZXMoZ2wsIGNhcGFiaWxpdGllcykge1xuXHRcdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xuXHRcdGNvbnN0IGJ1ZmZlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSkge1xuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRjb25zdCB1c2FnZSA9IGF0dHJpYnV0ZS51c2FnZTtcblx0XHRcdGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0Z2wuYmluZEJ1ZmZlcihidWZmZXJUeXBlLCBidWZmZXIpO1xuXHRcdFx0Z2wuYnVmZmVyRGF0YShidWZmZXJUeXBlLCBhcnJheSwgdXNhZ2UpO1xuXHRcdFx0YXR0cmlidXRlLm9uVXBsb2FkQ2FsbGJhY2soKTtcblx0XHRcdGxldCB0eXBlID0gZ2wuRkxPQVQ7XG5cblx0XHRcdGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuXHRcdFx0XHR0eXBlID0gZ2wuRkxPQVQ7XG5cdFx0XHR9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVbnN1cHBvcnRlZCBkYXRhIGJ1ZmZlciBmb3JtYXQ6IEZsb2F0NjRBcnJheS4nKTtcblx0XHRcdH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuXHRcdFx0XHRpZiAoYXR0cmlidXRlLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdGlmIChpc1dlYkdMMikge1xuXHRcdFx0XHRcdFx0dHlwZSA9IGdsLkhBTEZfRkxPQVQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVc2FnZSBvZiBGbG9hdDE2QnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIFdlYkdMMi4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX1NIT1JUO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSkge1xuXHRcdFx0XHR0eXBlID0gZ2wuU0hPUlQ7XG5cdFx0XHR9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcblx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0lOVDtcblx0XHRcdH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XG5cdFx0XHRcdHR5cGUgPSBnbC5JTlQ7XG5cdFx0XHR9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5KSB7XG5cdFx0XHRcdHR5cGUgPSBnbC5CWVRFO1xuXHRcdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHR9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcblx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGJ1ZmZlcjogYnVmZmVyLFxuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRieXRlc1BlckVsZW1lbnQ6IGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuXHRcdFx0XHR2ZXJzaW9uOiBhdHRyaWJ1dGUudmVyc2lvblxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVCdWZmZXIoYnVmZmVyLCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUpIHtcblx0XHRcdGNvbnN0IGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xuXHRcdFx0Y29uc3QgdXBkYXRlUmFuZ2UgPSBhdHRyaWJ1dGUudXBkYXRlUmFuZ2U7XG5cdFx0XHRnbC5iaW5kQnVmZmVyKGJ1ZmZlclR5cGUsIGJ1ZmZlcik7XG5cblx0XHRcdGlmICh1cGRhdGVSYW5nZS5jb3VudCA9PT0gLTEpIHtcblx0XHRcdFx0Ly8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcblx0XHRcdFx0Z2wuYnVmZmVyU3ViRGF0YShidWZmZXJUeXBlLCAwLCBhcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaXNXZWJHTDIpIHtcblx0XHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKGJ1ZmZlclR5cGUsIHVwZGF0ZVJhbmdlLm9mZnNldCAqIGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCBhcnJheSwgdXBkYXRlUmFuZ2Uub2Zmc2V0LCB1cGRhdGVSYW5nZS5jb3VudCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2wuYnVmZmVyU3ViRGF0YShidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgYXJyYXkuc3ViYXJyYXkodXBkYXRlUmFuZ2Uub2Zmc2V0LCB1cGRhdGVSYW5nZS5vZmZzZXQgKyB1cGRhdGVSYW5nZS5jb3VudCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dXBkYXRlUmFuZ2UuY291bnQgPSAtMTsgLy8gcmVzZXQgcmFuZ2Vcblx0XHRcdH1cblx0XHR9IC8vXG5cblxuXHRcdGZ1bmN0aW9uIGdldChhdHRyaWJ1dGUpIHtcblx0XHRcdGlmIChhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XG5cdFx0XHRyZXR1cm4gYnVmZmVycy5nZXQoYXR0cmlidXRlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmUoYXR0cmlidXRlKSB7XG5cdFx0XHRpZiAoYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUpIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xuXHRcdFx0Y29uc3QgZGF0YSA9IGJ1ZmZlcnMuZ2V0KGF0dHJpYnV0ZSk7XG5cblx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdGdsLmRlbGV0ZUJ1ZmZlcihkYXRhLmJ1ZmZlcik7XG5cdFx0XHRcdGJ1ZmZlcnMuZGVsZXRlKGF0dHJpYnV0ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlKGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSkge1xuXHRcdFx0aWYgKGF0dHJpYnV0ZS5pc0dMQnVmZmVyQXR0cmlidXRlKSB7XG5cdFx0XHRcdGNvbnN0IGNhY2hlZCA9IGJ1ZmZlcnMuZ2V0KGF0dHJpYnV0ZSk7XG5cblx0XHRcdFx0aWYgKCFjYWNoZWQgfHwgY2FjaGVkLnZlcnNpb24gPCBhdHRyaWJ1dGUudmVyc2lvbikge1xuXHRcdFx0XHRcdGJ1ZmZlcnMuc2V0KGF0dHJpYnV0ZSwge1xuXHRcdFx0XHRcdFx0YnVmZmVyOiBhdHRyaWJ1dGUuYnVmZmVyLFxuXHRcdFx0XHRcdFx0dHlwZTogYXR0cmlidXRlLnR5cGUsXG5cdFx0XHRcdFx0XHRieXRlc1BlckVsZW1lbnQ6IGF0dHJpYnV0ZS5lbGVtZW50U2l6ZSxcblx0XHRcdFx0XHRcdHZlcnNpb246IGF0dHJpYnV0ZS52ZXJzaW9uXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XG5cdFx0XHRjb25zdCBkYXRhID0gYnVmZmVycy5nZXQoYXR0cmlidXRlKTtcblxuXHRcdFx0aWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRidWZmZXJzLnNldChhdHRyaWJ1dGUsIGNyZWF0ZUJ1ZmZlcihhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUpKTtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YS52ZXJzaW9uIDwgYXR0cmlidXRlLnZlcnNpb24pIHtcblx0XHRcdFx0dXBkYXRlQnVmZmVyKGRhdGEuYnVmZmVyLCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUpO1xuXHRcdFx0XHRkYXRhLnZlcnNpb24gPSBhdHRyaWJ1dGUudmVyc2lvbjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRyZW1vdmU6IHJlbW92ZSxcblx0XHRcdHVwZGF0ZTogdXBkYXRlXG5cdFx0fTtcblx0fVxuXG5cdGNsYXNzIFBsYW5lR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3Iod2lkdGggPSAxLCBoZWlnaHQgPSAxLCB3aWR0aFNlZ21lbnRzID0gMSwgaGVpZ2h0U2VnbWVudHMgPSAxKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcblx0XHRcdH07XG5cdFx0XHRjb25zdCB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuXHRcdFx0Y29uc3QgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuXHRcdFx0Y29uc3QgZ3JpZFggPSBNYXRoLmZsb29yKHdpZHRoU2VnbWVudHMpO1xuXHRcdFx0Y29uc3QgZ3JpZFkgPSBNYXRoLmZsb29yKGhlaWdodFNlZ21lbnRzKTtcblx0XHRcdGNvbnN0IGdyaWRYMSA9IGdyaWRYICsgMTtcblx0XHRcdGNvbnN0IGdyaWRZMSA9IGdyaWRZICsgMTtcblx0XHRcdGNvbnN0IHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuXHRcdFx0Y29uc3Qgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTsgLy9cblxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSsrKSB7XG5cdFx0XHRcdGNvbnN0IHkgPSBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGY7XG5cblx0XHRcdFx0Zm9yIChsZXQgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXgrKykge1xuXHRcdFx0XHRcdGNvbnN0IHggPSBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goeCwgLXksIDApO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCgwLCAwLCAxKTtcblx0XHRcdFx0XHR1dnMucHVzaChpeCAvIGdyaWRYKTtcblx0XHRcdFx0XHR1dnMucHVzaCgxIC0gaXkgLyBncmlkWSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSsrKSB7XG5cdFx0XHRcdGZvciAobGV0IGl4ID0gMDsgaXggPCBncmlkWDsgaXgrKykge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBpeCArIGdyaWRYMSAqIChpeSArIDEpO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBpeCArIDEgKyBncmlkWDEgKiAoaXkgKyAxKTtcblx0XHRcdFx0XHRjb25zdCBkID0gaXggKyAxICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaChiLCBjLCBkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQbGFuZUdlb21ldHJ5KGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMpO1xuXHRcdH1cblxuXHR9XG5cblx0dmFyIGFscGhhbWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0ZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdlV2ICkuZztcXG4jZW5kaWZcIjtcblxuXHR2YXIgYWxwaGFtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBhbHBoYXRlc3RfZnJhZ21lbnQgPSBcIiNpZmRlZiBBTFBIQVRFU1RcXG5cXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgQUxQSEFURVNUICkgZGlzY2FyZDtcXG4jZW5kaWZcIjtcblxuXHR2YXIgYW9tYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXHRmbG9hdCBhbWJpZW50T2NjbHVzaW9uID0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGFtYmllbnRPY2NsdXNpb247XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBTVEFOREFSRCApXFxuXFx0XFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKj0gY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBkb3ROViwgYW1iaWVudE9jY2x1c2lvbiwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgYW9tYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGJlZ2luX3ZlcnRleCA9IFwidmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIHBvc2l0aW9uICk7XCI7XG5cblx0dmFyIGJlZ2lubm9ybWFsX3ZlcnRleCA9IFwidmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXG4jaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHR2ZWMzIG9iamVjdFRhbmdlbnQgPSB2ZWMzKCB0YW5nZW50Lnh5eiApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBic2RmcyA9IFwidmVjMiBpbnRlZ3JhdGVTcGVjdWxhckJSREYoIGNvbnN0IGluIGZsb2F0IGRvdE5WLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0Y29uc3QgdmVjNCBjMCA9IHZlYzQoIC0gMSwgLSAwLjAyNzUsIC0gMC41NzIsIDAuMDIyICk7XFxuXFx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XFxuXFx0dmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcXG5cXHRmbG9hdCBhMDA0ID0gbWluKCByLnggKiByLngsIGV4cDIoIC0gOS4yOCAqIGRvdE5WICkgKSAqIHIueCArIHIueTtcXG5cXHRyZXR1cm4gdmVjMiggLTEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcbn1cXG5mbG9hdCBwdW5jdHVhbExpZ2h0SW50ZW5zaXR5VG9JcnJhZGlhbmNlRmFjdG9yKCBjb25zdCBpbiBmbG9hdCBsaWdodERpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXG4jaWYgZGVmaW5lZCAoIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFMgKVxcblxcdGZsb2F0IGRpc3RhbmNlRmFsbG9mZiA9IDEuMCAvIG1heCggcG93KCBsaWdodERpc3RhbmNlLCBkZWNheUV4cG9uZW50ICksIDAuMDEgKTtcXG5cXHRpZiggY3V0b2ZmRGlzdGFuY2UgPiAwLjAgKSB7XFxuXFx0XFx0ZGlzdGFuY2VGYWxsb2ZmICo9IHBvdzIoIHNhdHVyYXRlKCAxLjAgLSBwb3c0KCBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSApICk7XFxuXFx0fVxcblxcdHJldHVybiBkaXN0YW5jZUZhbGxvZmY7XFxuI2Vsc2VcXG5cXHRpZiggY3V0b2ZmRGlzdGFuY2UgPiAwLjAgJiYgZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXG5cXHRcXHRyZXR1cm4gcG93KCBzYXR1cmF0ZSggLWxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XFxuXFx0fVxcblxcdHJldHVybiAxLjA7XFxuI2VuZGlmXFxufVxcbnZlYzMgQlJERl9EaWZmdXNlX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkge1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yO1xcbn1cXG52ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gdmVjMyBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkge1xcblxcdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC01LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApO1xcblxcdHJldHVybiAoIGY5MCAtIGYwICkgKiBmcmVzbmVsICsgZjA7XFxufVxcbnZlYzMgRl9TY2hsaWNrX1JvdWdobmVzc0RlcGVuZGVudCggY29uc3QgaW4gdmVjMyBGMCwgY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtNS41NTQ3MyAqIGRvdE5WIC0gNi45ODMxNiApICogZG90TlYgKTtcXG5cXHR2ZWMzIEZyID0gbWF4KCB2ZWMzKCAxLjAgLSByb3VnaG5lc3MgKSwgRjAgKSAtIEYwO1xcblxcdHJldHVybiBGciAqIGZyZXNuZWwgKyBGMDtcXG59XFxuZmxvYXQgR19HR1hfU21pdGgoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGdsID0gZG90TkwgKyBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXG5cXHRmbG9hdCBndiA9IGRvdE5WICsgc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxuXFx0cmV0dXJuIDEuMCAvICggZ2wgKiBndiApO1xcbn1cXG5mbG9hdCBHX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGd2ID0gZG90TkwgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTtcXG5cXHRmbG9hdCBnbCA9IGRvdE5WICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7XFxuXFx0cmV0dXJuIDAuNSAvIG1heCggZ3YgKyBnbCwgRVBTSUxPTiApO1xcbn1cXG5mbG9hdCBEX0dHWCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXG5cXHRmbG9hdCBkZW5vbSA9IHBvdzIoIGRvdE5IICkgKiAoIGEyIC0gMS4wICkgKyAxLjA7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAvIHBvdzIoIGRlbm9tICk7XFxufVxcbnZlYzMgQlJERl9TcGVjdWxhcl9HR1goIGNvbnN0IGluIEluY2lkZW50TGlnaHQgaW5jaWRlbnRMaWdodCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gdmVjMyBmOTAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24sIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggZjAsIGY5MCwgZG90TEggKTtcXG5cXHRmbG9hdCBHID0gR19HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XFxuXFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cXHRyZXR1cm4gRiAqICggRyAqIEQgKTtcXG59XFxudmVjMiBMVENfVXYoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NJWkUgPSA2NC4wO1xcblxcdGNvbnN0IGZsb2F0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xcblxcdGNvbnN0IGZsb2F0IExVVF9CSUFTID0gMC41IC8gTFVUX1NJWkU7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBOLCBWICkgKTtcXG5cXHR2ZWMyIHV2ID0gdmVjMiggcm91Z2huZXNzLCBzcXJ0KCAxLjAgLSBkb3ROViApICk7XFxuXFx0dXYgPSB1diAqIExVVF9TQ0FMRSArIExVVF9CSUFTO1xcblxcdHJldHVybiB1djtcXG59XFxuZmxvYXQgTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIGYgKSB7XFxuXFx0ZmxvYXQgbCA9IGxlbmd0aCggZiApO1xcblxcdHJldHVybiBtYXgoICggbCAqIGwgKyBmLnogKSAvICggbCArIDEuMCApLCAwLjAgKTtcXG59XFxudmVjMyBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgdjEsIGNvbnN0IGluIHZlYzMgdjIgKSB7XFxuXFx0ZmxvYXQgeCA9IGRvdCggdjEsIHYyICk7XFxuXFx0ZmxvYXQgeSA9IGFicyggeCApO1xcblxcdGZsb2F0IGEgPSAwLjg1NDM5ODUgKyAoIDAuNDk2NTE1NSArIDAuMDE0NTIwNiAqIHkgKSAqIHk7XFxuXFx0ZmxvYXQgYiA9IDMuNDE3NTk0MCArICggNC4xNjE2NzI0ICsgeSApICogeTtcXG5cXHRmbG9hdCB2ID0gYSAvIGI7XFxuXFx0ZmxvYXQgdGhldGFfc2ludGhldGEgPSAoIHggPiAwLjAgKSA/IHYgOiAwLjUgKiBpbnZlcnNlc3FydCggbWF4KCAxLjAgLSB4ICogeCwgMWUtNyApICkgLSB2O1xcblxcdHJldHVybiBjcm9zcyggdjEsIHYyICkgKiB0aGV0YV9zaW50aGV0YTtcXG59XFxudmVjMyBMVENfRXZhbHVhdGUoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiB2ZWMzIFAsIGNvbnN0IGluIG1hdDMgbUludiwgY29uc3QgaW4gdmVjMyByZWN0Q29vcmRzWyA0IF0gKSB7XFxuXFx0dmVjMyB2MSA9IHJlY3RDb29yZHNbIDEgXSAtIHJlY3RDb29yZHNbIDAgXTtcXG5cXHR2ZWMzIHYyID0gcmVjdENvb3Jkc1sgMyBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcblxcdHZlYzMgbGlnaHROb3JtYWwgPSBjcm9zcyggdjEsIHYyICk7XFxuXFx0aWYoIGRvdCggbGlnaHROb3JtYWwsIFAgLSByZWN0Q29vcmRzWyAwIF0gKSA8IDAuMCApIHJldHVybiB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIFQxLCBUMjtcXG5cXHRUMSA9IG5vcm1hbGl6ZSggViAtIE4gKiBkb3QoIFYsIE4gKSApO1xcblxcdFQyID0gLSBjcm9zcyggTiwgVDEgKTtcXG5cXHRtYXQzIG1hdCA9IG1JbnYgKiB0cmFuc3Bvc2VNYXQzKCBtYXQzKCBUMSwgVDIsIE4gKSApO1xcblxcdHZlYzMgY29vcmRzWyA0IF07XFxuXFx0Y29vcmRzWyAwIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDAgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDEgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMSBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMiBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAyIF0gLSBQICk7XFxuXFx0Y29vcmRzWyAzIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDMgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDAgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAwIF0gKTtcXG5cXHRjb29yZHNbIDEgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAxIF0gKTtcXG5cXHRjb29yZHNbIDIgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAyIF0gKTtcXG5cXHRjb29yZHNbIDMgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAzIF0gKTtcXG5cXHR2ZWMzIHZlY3RvckZvcm1GYWN0b3IgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAwIF0sIGNvb3Jkc1sgMSBdICk7XFxuXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMSBdLCBjb29yZHNbIDIgXSApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDIgXSwgY29vcmRzWyAzIF0gKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAzIF0sIGNvb3Jkc1sgMCBdICk7XFxuXFx0ZmxvYXQgcmVzdWx0ID0gTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCB2ZWN0b3JGb3JtRmFjdG9yICk7XFxuXFx0cmV0dXJuIHZlYzMoIHJlc3VsdCApO1xcbn1cXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0dmVjMiBicmRmID0gaW50ZWdyYXRlU3BlY3VsYXJCUkRGKCBkb3ROViwgcm91Z2huZXNzICk7XFxuXFx0cmV0dXJuIHNwZWN1bGFyQ29sb3IgKiBicmRmLnggKyBicmRmLnk7XFxufVxcbnZvaWQgQlJERl9TcGVjdWxhcl9NdWx0aXNjYXR0ZXJpbmdfRW52aXJvbm1lbnQoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBpbm91dCB2ZWMzIHNpbmdsZVNjYXR0ZXIsIGlub3V0IHZlYzMgbXVsdGlTY2F0dGVyICkge1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cXHR2ZWMzIEYgPSBGX1NjaGxpY2tfUm91Z2huZXNzRGVwZW5kZW50KCBzcGVjdWxhckNvbG9yLCBkb3ROViwgcm91Z2huZXNzICk7XFxuXFx0dmVjMiBicmRmID0gaW50ZWdyYXRlU3BlY3VsYXJCUkRGKCBkb3ROViwgcm91Z2huZXNzICk7XFxuXFx0dmVjMyBGc3NFc3MgPSBGICogYnJkZi54ICsgYnJkZi55O1xcblxcdGZsb2F0IEVzcyA9IGJyZGYueCArIGJyZGYueTtcXG5cXHRmbG9hdCBFbXMgPSAxLjAgLSBFc3M7XFxuXFx0dmVjMyBGYXZnID0gc3BlY3VsYXJDb2xvciArICggMS4wIC0gc3BlY3VsYXJDb2xvciApICogMC4wNDc2MTk7XFx0dmVjMyBGbXMgPSBGc3NFc3MgKiBGYXZnIC8gKCAxLjAgLSBFbXMgKiBGYXZnICk7XFxuXFx0c2luZ2xlU2NhdHRlciArPSBGc3NFc3M7XFxuXFx0bXVsdGlTY2F0dGVyICs9IEZtcyAqIEVtcztcXG59XFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCApIHtcXG5cXHRyZXR1cm4gMC4yNTtcXG59XFxuZmxvYXQgRF9CbGlublBob25nKCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApO1xcbn1cXG52ZWMzIEJSREZfU3BlY3VsYXJfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXG5cXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIHZlYzMoIDEuMCApLCBkb3RMSCApO1xcblxcdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICk7XFxuXFx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBHICogRCApO1xcbn1cXG5mbG9hdCBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIGNvbnN0IGluIGZsb2F0IGdneFJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gKCAyLjAgLyBwb3cyKCBnZ3hSb3VnaG5lc3MgKyAwLjAwMDEgKSAtIDIuMCApO1xcbn1cXG5mbG9hdCBCbGlubkV4cG9uZW50VG9HR1hSb3VnaG5lc3MoIGNvbnN0IGluIGZsb2F0IGJsaW5uRXhwb25lbnQgKSB7XFxuXFx0cmV0dXJuIHNxcnQoIDIuMCAvICggYmxpbm5FeHBvbmVudCArIDIuMCApICk7XFxufVxcbiNpZiBkZWZpbmVkKCBVU0VfU0hFRU4gKVxcbmZsb2F0IERfQ2hhcmxpZShmbG9hdCByb3VnaG5lc3MsIGZsb2F0IE5vSCkge1xcblxcdGZsb2F0IGludkFscGhhID0gMS4wIC8gcm91Z2huZXNzO1xcblxcdGZsb2F0IGNvczJoID0gTm9IICogTm9IO1xcblxcdGZsb2F0IHNpbjJoID0gbWF4KDEuMCAtIGNvczJoLCAwLjAwNzgxMjUpO1xcdHJldHVybiAoMi4wICsgaW52QWxwaGEpICogcG93KHNpbjJoLCBpbnZBbHBoYSAqIDAuNSkgLyAoMi4wICogUEkpO1xcbn1cXG5mbG9hdCBWX05ldWJlbHQoZmxvYXQgTm9WLCBmbG9hdCBOb0wpIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoMS4wIC8gKDQuMCAqIChOb0wgKyBOb1YgLSBOb0wgKiBOb1YpKSk7XFxufVxcbnZlYzMgQlJERl9TcGVjdWxhcl9TaGVlbiggY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiB2ZWMzIEwsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIHZlYzMgc3BlY3VsYXJDb2xvciApIHtcXG5cXHR2ZWMzIE4gPSBnZW9tZXRyeS5ub3JtYWw7XFxuXFx0dmVjMyBWID0gZ2VvbWV0cnkudmlld0RpcjtcXG5cXHR2ZWMzIEggPSBub3JtYWxpemUoIFYgKyBMICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBOLCBIICkgKTtcXG5cXHRyZXR1cm4gc3BlY3VsYXJDb2xvciAqIERfQ2hhcmxpZSggcm91Z2huZXNzLCBkb3ROSCApICogVl9OZXViZWx0KCBkb3QoTiwgViksIGRvdChOLCBMKSApO1xcbn1cXG4jZW5kaWZcIjtcblxuXHR2YXIgYnVtcG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0JVTVBNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcdHZlYzIgZEhkeHlfZndkKCkge1xcblxcdFxcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXG5cXHRcXHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXFx0XFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1xcblxcdFxcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcblxcdFxcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcdFxcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcblxcdH1cXG5cXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5LCBmbG9hdCBmYWNlRGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgdlNpZ21hWCA9IHZlYzMoIGRGZHgoIHN1cmZfcG9zLnggKSwgZEZkeCggc3VyZl9wb3MueSApLCBkRmR4KCBzdXJmX3Bvcy56ICkgKTtcXG5cXHRcXHR2ZWMzIHZTaWdtYVkgPSB2ZWMzKCBkRmR5KCBzdXJmX3Bvcy54ICksIGRGZHkoIHN1cmZfcG9zLnkgKSwgZEZkeSggc3VyZl9wb3MueiApICk7XFxuXFx0XFx0dmVjMyB2TiA9IHN1cmZfbm9ybTtcXG5cXHRcXHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxuXFx0XFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblxcdFxcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICkgKiBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cblx0dmFyIGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dmVjNCBwbGFuZTtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkge1xcblxcdFxcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRpZiAoIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgZGlzY2FyZDtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjaWYgVU5JT05fQ0xJUFBJTkdfUExBTkVTIDwgTlVNX0NMSVBQSU5HX1BMQU5FU1xcblxcdFxcdGJvb2wgY2xpcHBlZCA9IHRydWU7XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdFxcdGZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHtcXG5cXHRcXHRcXHRwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxuXFx0XFx0XFx0Y2xpcHBlZCA9ICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdFxcdGlmICggY2xpcHBlZCApIGRpc2NhcmQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjtcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjtcXG4jZW5kaWZcIjtcblxuXHR2YXIgY2xpcHBpbmdfcGxhbmVzX3ZlcnRleCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dkNsaXBQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGNvbG9yX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHRkaWZmdXNlQ29sb3IgKj0gdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXFxuXFx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGNvbG9yX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdHZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SIClcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBjb2xvcl9wYXJzX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXFxuXFx0dmFyeWluZyB2ZWM0IHZDb2xvcjtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApXFxuXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcIjtcblxuXHR2YXIgY29sb3JfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2Q29sb3IgPSB2ZWM0KCAxLjAgKTtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApXFxuXFx0dkNvbG9yID0gdmVjMyggMS4wICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZDb2xvciAqPSBjb2xvcjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdfQ09MT1JcXG5cXHR2Q29sb3IueHl6ICo9IGluc3RhbmNlQ29sb3IueHl6O1xcbiNlbmRpZlwiO1xuXG5cdHZhciBjb21tb24gPSBcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTNcXG4jZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE3OTU4NlxcbiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDg5NjZcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkgMC4zMTgzMDk4ODYxODM3OTA3XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0MzA5MTg5NTM1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG4jaWZuZGVmIHNhdHVyYXRlXFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNlbmRpZlxcbiNkZWZpbmUgd2hpdGVDb21wbGVtZW50KGEpICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXFxuZmxvYXQgcG93MiggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeDsgfVxcbmZsb2F0IHBvdzMoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4KngqeDsgfVxcbmZsb2F0IHBvdzQoIGNvbnN0IGluIGZsb2F0IHggKSB7IGZsb2F0IHgyID0geCp4OyByZXR1cm4geDIqeDI7IH1cXG5mbG9hdCBhdmVyYWdlKCBjb25zdCBpbiB2ZWMzIGNvbG9yICkgeyByZXR1cm4gZG90KCBjb2xvciwgdmVjMyggMC4zMzMzICkgKTsgfVxcbmhpZ2hwIGZsb2F0IHJhbmQoIGNvbnN0IGluIHZlYzIgdXYgKSB7XFxuXFx0Y29uc3QgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzO1xcblxcdGhpZ2hwIGZsb2F0IGR0ID0gZG90KCB1di54eSwgdmVjMiggYSxiICkgKSwgc24gPSBtb2QoIGR0LCBQSSApO1xcblxcdHJldHVybiBmcmFjdChzaW4oc24pICogYyk7XFxufVxcbiNpZmRlZiBISUdIX1BSRUNJU0lPTlxcblxcdGZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHsgcmV0dXJuIGxlbmd0aCggdiApOyB9XFxuI2Vsc2VcXG5cXHRmbG9hdCBtYXgzKCB2ZWMzIHYgKSB7IHJldHVybiBtYXgoIG1heCggdi54LCB2LnkgKSwgdi56ICk7IH1cXG5cXHRmbG9hdCBwcmVjaXNpb25TYWZlTGVuZ3RoKCB2ZWMzIHYgKSB7XFxuXFx0XFx0ZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4MyggYWJzKCB2ICkgKTtcXG5cXHRcXHRyZXR1cm4gbGVuZ3RoKCB2IC8gbWF4Q29tcG9uZW50ICkgKiBtYXhDb21wb25lbnQ7XFxuXFx0fVxcbiNlbmRpZlxcbnN0cnVjdCBJbmNpZGVudExpZ2h0IHtcXG5cXHR2ZWMzIGNvbG9yO1xcblxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdGJvb2wgdmlzaWJsZTtcXG59O1xcbnN0cnVjdCBSZWZsZWN0ZWRMaWdodCB7XFxuXFx0dmVjMyBkaXJlY3REaWZmdXNlO1xcblxcdHZlYzMgZGlyZWN0U3BlY3VsYXI7XFxuXFx0dmVjMyBpbmRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBpbmRpcmVjdFNwZWN1bGFyO1xcbn07XFxuc3RydWN0IEdlb21ldHJpY0NvbnRleHQge1xcblxcdHZlYzMgcG9zaXRpb247XFxuXFx0dmVjMyBub3JtYWw7XFxuXFx0dmVjMyB2aWV3RGlyO1xcbiNpZmRlZiBDTEVBUkNPQVRcXG5cXHR2ZWMzIGNsZWFyY29hdE5vcm1hbDtcXG4jZW5kaWZcXG59O1xcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxufVxcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcbn1cXG52ZWMzIHByb2plY3RPblBsYW5lKGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcdGZsb2F0IGRpc3RhbmNlID0gZG90KCBwbGFuZU5vcm1hbCwgcG9pbnQgLSBwb2ludE9uUGxhbmUgKTtcXG5cXHRyZXR1cm4gLSBkaXN0YW5jZSAqIHBsYW5lTm9ybWFsICsgcG9pbnQ7XFxufVxcbmZsb2F0IHNpZGVPZlBsYW5lKCBpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXHRyZXR1cm4gc2lnbiggZG90KCBwb2ludCAtIHBvaW50T25QbGFuZSwgcGxhbmVOb3JtYWwgKSApO1xcbn1cXG52ZWMzIGxpbmVQbGFuZUludGVyc2VjdCggaW4gdmVjMyBwb2ludE9uTGluZSwgaW4gdmVjMyBsaW5lRGlyZWN0aW9uLCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXHRyZXR1cm4gbGluZURpcmVjdGlvbiAqICggZG90KCBwbGFuZU5vcm1hbCwgcG9pbnRPblBsYW5lIC0gcG9pbnRPbkxpbmUgKSAvIGRvdCggcGxhbmVOb3JtYWwsIGxpbmVEaXJlY3Rpb24gKSApICsgcG9pbnRPbkxpbmU7XFxufVxcbm1hdDMgdHJhbnNwb3NlTWF0MyggY29uc3QgaW4gbWF0MyBtICkge1xcblxcdG1hdDMgdG1wO1xcblxcdHRtcFsgMCBdID0gdmVjMyggbVsgMCBdLngsIG1bIDEgXS54LCBtWyAyIF0ueCApO1xcblxcdHRtcFsgMSBdID0gdmVjMyggbVsgMCBdLnksIG1bIDEgXS55LCBtWyAyIF0ueSApO1xcblxcdHRtcFsgMiBdID0gdmVjMyggbVsgMCBdLnosIG1bIDEgXS56LCBtWyAyIF0ueiApO1xcblxcdHJldHVybiB0bXA7XFxufVxcbmZsb2F0IGxpbmVhclRvUmVsYXRpdmVMdW1pbmFuY2UoIGNvbnN0IGluIHZlYzMgY29sb3IgKSB7XFxuXFx0dmVjMyB3ZWlnaHRzID0gdmVjMyggMC4yMTI2LCAwLjcxNTIsIDAuMDcyMiApO1xcblxcdHJldHVybiBkb3QoIHdlaWdodHMsIGNvbG9yLnJnYiApO1xcbn1cXG5ib29sIGlzUGVyc3BlY3RpdmVNYXRyaXgoIG1hdDQgbSApIHtcXG5cXHRyZXR1cm4gbVsgMiBdWyAzIF0gPT0gLSAxLjA7XFxufVxcbnZlYzIgZXF1aXJlY3RVdiggaW4gdmVjMyBkaXIgKSB7XFxuXFx0ZmxvYXQgdSA9IGF0YW4oIGRpci56LCBkaXIueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXFx0ZmxvYXQgdiA9IGFzaW4oIGNsYW1wKCBkaXIueSwgLSAxLjAsIDEuMCApICkgKiBSRUNJUFJPQ0FMX1BJICsgMC41O1xcblxcdHJldHVybiB2ZWMyKCB1LCB2ICk7XFxufVwiO1xuXG5cdHZhciBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQgPSBcIiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuXFx0I2RlZmluZSBjdWJlVVZfbWF4TWlwTGV2ZWwgOC4wXFxuXFx0I2RlZmluZSBjdWJlVVZfbWluTWlwTGV2ZWwgNC4wXFxuXFx0I2RlZmluZSBjdWJlVVZfbWF4VGlsZVNpemUgMjU2LjBcXG5cXHQjZGVmaW5lIGN1YmVVVl9taW5UaWxlU2l6ZSAxNi4wXFxuXFx0ZmxvYXQgZ2V0RmFjZSggdmVjMyBkaXJlY3Rpb24gKSB7XFxuXFx0XFx0dmVjMyBhYnNEaXJlY3Rpb24gPSBhYnMoIGRpcmVjdGlvbiApO1xcblxcdFxcdGZsb2F0IGZhY2UgPSAtIDEuMDtcXG5cXHRcXHRpZiAoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnogKSB7XFxuXFx0XFx0XFx0aWYgKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi55IClcXG5cXHRcXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnggPiAwLjAgPyAwLjAgOiAzLjA7XFxuXFx0XFx0XFx0ZWxzZVxcblxcdFxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEuMCA6IDQuMDtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGlmICggYWJzRGlyZWN0aW9uLnogPiBhYnNEaXJlY3Rpb24ueSApXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi56ID4gMC4wID8gMi4wIDogNS4wO1xcblxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxLjAgOiA0LjA7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBmYWNlO1xcblxcdH1cXG5cXHR2ZWMyIGdldFVWKCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgZmFjZSApIHtcXG5cXHRcXHR2ZWMyIHV2O1xcblxcdFxcdGlmICggZmFjZSA9PSAwLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDEuMCApIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIC0gZGlyZWN0aW9uLnogKSAvIGFicyggZGlyZWN0aW9uLnkgKTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDIuMCApIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi56ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAzLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueCApO1xcblxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gNC4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnogKSAvIGFicyggZGlyZWN0aW9uLnkgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi56ICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAwLjUgKiAoIHV2ICsgMS4wICk7XFxuXFx0fVxcblxcdHZlYzMgYmlsaW5lYXJDdWJlVVYoIHNhbXBsZXIyRCBlbnZNYXAsIHZlYzMgZGlyZWN0aW9uLCBmbG9hdCBtaXBJbnQgKSB7XFxuXFx0XFx0ZmxvYXQgZmFjZSA9IGdldEZhY2UoIGRpcmVjdGlvbiApO1xcblxcdFxcdGZsb2F0IGZpbHRlckludCA9IG1heCggY3ViZVVWX21pbk1pcExldmVsIC0gbWlwSW50LCAwLjAgKTtcXG5cXHRcXHRtaXBJbnQgPSBtYXgoIG1pcEludCwgY3ViZVVWX21pbk1pcExldmVsICk7XFxuXFx0XFx0ZmxvYXQgZmFjZVNpemUgPSBleHAyKCBtaXBJbnQgKTtcXG5cXHRcXHRmbG9hdCB0ZXhlbFNpemUgPSAxLjAgLyAoIDMuMCAqIGN1YmVVVl9tYXhUaWxlU2l6ZSApO1xcblxcdFxcdHZlYzIgdXYgPSBnZXRVViggZGlyZWN0aW9uLCBmYWNlICkgKiAoIGZhY2VTaXplIC0gMS4wICk7XFxuXFx0XFx0dmVjMiBmID0gZnJhY3QoIHV2ICk7XFxuXFx0XFx0dXYgKz0gMC41IC0gZjtcXG5cXHRcXHRpZiAoIGZhY2UgPiAyLjAgKSB7XFxuXFx0XFx0XFx0dXYueSArPSBmYWNlU2l6ZTtcXG5cXHRcXHRcXHRmYWNlIC09IDMuMDtcXG5cXHRcXHR9XFxuXFx0XFx0dXYueCArPSBmYWNlICogZmFjZVNpemU7XFxuXFx0XFx0aWYgKCBtaXBJbnQgPCBjdWJlVVZfbWF4TWlwTGV2ZWwgKSB7XFxuXFx0XFx0XFx0dXYueSArPSAyLjAgKiBjdWJlVVZfbWF4VGlsZVNpemU7XFxuXFx0XFx0fVxcblxcdFxcdHV2LnkgKz0gZmlsdGVySW50ICogMi4wICogY3ViZVVWX21pblRpbGVTaXplO1xcblxcdFxcdHV2LnggKz0gMy4wICogbWF4KCAwLjAsIGN1YmVVVl9tYXhUaWxlU2l6ZSAtIDIuMCAqIGZhY2VTaXplICk7XFxuXFx0XFx0dXYgKj0gdGV4ZWxTaXplO1xcblxcdFxcdHZlYzMgdGwgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQoIGVudk1hcCwgdXYgKSApLnJnYjtcXG5cXHRcXHR1di54ICs9IHRleGVsU2l6ZTtcXG5cXHRcXHR2ZWMzIHRyID0gZW52TWFwVGV4ZWxUb0xpbmVhciggdGV4dHVyZTJEKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XFxuXFx0XFx0dXYueSArPSB0ZXhlbFNpemU7XFxuXFx0XFx0dmVjMyBiciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmUyRCggZW52TWFwLCB1diApICkucmdiO1xcblxcdFxcdHV2LnggLT0gdGV4ZWxTaXplO1xcblxcdFxcdHZlYzMgYmwgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQoIGVudk1hcCwgdXYgKSApLnJnYjtcXG5cXHRcXHR2ZWMzIHRtID0gbWl4KCB0bCwgdHIsIGYueCApO1xcblxcdFxcdHZlYzMgYm0gPSBtaXgoIGJsLCBiciwgZi54ICk7XFxuXFx0XFx0cmV0dXJuIG1peCggdG0sIGJtLCBmLnkgKTtcXG5cXHR9XFxuXFx0I2RlZmluZSByMCAxLjBcXG5cXHQjZGVmaW5lIHYwIDAuMzM5XFxuXFx0I2RlZmluZSBtMCAtIDIuMFxcblxcdCNkZWZpbmUgcjEgMC44XFxuXFx0I2RlZmluZSB2MSAwLjI3NlxcblxcdCNkZWZpbmUgbTEgLSAxLjBcXG5cXHQjZGVmaW5lIHI0IDAuNFxcblxcdCNkZWZpbmUgdjQgMC4wNDZcXG5cXHQjZGVmaW5lIG00IDIuMFxcblxcdCNkZWZpbmUgcjUgMC4zMDVcXG5cXHQjZGVmaW5lIHY1IDAuMDE2XFxuXFx0I2RlZmluZSBtNSAzLjBcXG5cXHQjZGVmaW5lIHI2IDAuMjFcXG5cXHQjZGVmaW5lIHY2IDAuMDAzOFxcblxcdCNkZWZpbmUgbTYgNC4wXFxuXFx0ZmxvYXQgcm91Z2huZXNzVG9NaXAoIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRcXHRmbG9hdCBtaXAgPSAwLjA7XFxuXFx0XFx0aWYgKCByb3VnaG5lc3MgPj0gcjEgKSB7XFxuXFx0XFx0XFx0bWlwID0gKCByMCAtIHJvdWdobmVzcyApICogKCBtMSAtIG0wICkgLyAoIHIwIC0gcjEgKSArIG0wO1xcblxcdFxcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSByNCApIHtcXG5cXHRcXHRcXHRtaXAgPSAoIHIxIC0gcm91Z2huZXNzICkgKiAoIG00IC0gbTEgKSAvICggcjEgLSByNCApICsgbTE7XFxuXFx0XFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IHI1ICkge1xcblxcdFxcdFxcdG1pcCA9ICggcjQgLSByb3VnaG5lc3MgKSAqICggbTUgLSBtNCApIC8gKCByNCAtIHI1ICkgKyBtNDtcXG5cXHRcXHR9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gcjYgKSB7XFxuXFx0XFx0XFx0bWlwID0gKCByNSAtIHJvdWdobmVzcyApICogKCBtNiAtIG01ICkgLyAoIHI1IC0gcjYgKSArIG01O1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bWlwID0gLSAyLjAgKiBsb2cyKCAxLjE2ICogcm91Z2huZXNzICk7XFx0XFx0fVxcblxcdFxcdHJldHVybiBtaXA7XFxuXFx0fVxcblxcdHZlYzQgdGV4dHVyZUN1YmVVViggc2FtcGxlcjJEIGVudk1hcCwgdmVjMyBzYW1wbGVEaXIsIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRcXHRmbG9hdCBtaXAgPSBjbGFtcCggcm91Z2huZXNzVG9NaXAoIHJvdWdobmVzcyApLCBtMCwgY3ViZVVWX21heE1pcExldmVsICk7XFxuXFx0XFx0ZmxvYXQgbWlwRiA9IGZyYWN0KCBtaXAgKTtcXG5cXHRcXHRmbG9hdCBtaXBJbnQgPSBmbG9vciggbWlwICk7XFxuXFx0XFx0dmVjMyBjb2xvcjAgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCApO1xcblxcdFxcdGlmICggbWlwRiA9PSAwLjAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZlYzQoIGNvbG9yMCwgMS4wICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR2ZWMzIGNvbG9yMSA9IGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpciwgbWlwSW50ICsgMS4wICk7XFxuXFx0XFx0XFx0cmV0dXJuIHZlYzQoIG1peCggY29sb3IwLCBjb2xvcjEsIG1pcEYgKSwgMS4wICk7XFxuXFx0XFx0fVxcblxcdH1cXG4jZW5kaWZcIjtcblxuXHR2YXIgZGVmYXVsdG5vcm1hbF92ZXJ0ZXggPSBcInZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBvYmplY3ROb3JtYWw7XFxuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuXFx0bWF0MyBtID0gbWF0MyggaW5zdGFuY2VNYXRyaXggKTtcXG5cXHR0cmFuc2Zvcm1lZE5vcm1hbCAvPSB2ZWMzKCBkb3QoIG1bIDAgXSwgbVsgMCBdICksIGRvdCggbVsgMSBdLCBtWyAxIF0gKSwgZG90KCBtWyAyIF0sIG1bIDIgXSApICk7XFxuXFx0dHJhbnNmb3JtZWROb3JtYWwgPSBtICogdHJhbnNmb3JtZWROb3JtYWw7XFxuI2VuZGlmXFxudHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiB0cmFuc2Zvcm1lZE5vcm1hbDtcXG4jaWZkZWYgRkxJUF9TSURFRFxcblxcdHRyYW5zZm9ybWVkTm9ybWFsID0gLSB0cmFuc2Zvcm1lZE5vcm1hbDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHR2ZWMzIHRyYW5zZm9ybWVkVGFuZ2VudCA9ICggbW9kZWxWaWV3TWF0cml4ICogdmVjNCggb2JqZWN0VGFuZ2VudCwgMC4wICkgKS54eXo7XFxuXFx0I2lmZGVmIEZMSVBfU0lERURcXG5cXHRcXHR0cmFuc2Zvcm1lZFRhbmdlbnQgPSAtIHRyYW5zZm9ybWVkVGFuZ2VudDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcblxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhcztcXG4jZW5kaWZcIjtcblxuXHR2YXIgZGlzcGxhY2VtZW50bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR0cmFuc2Zvcm1lZCArPSBub3JtYWxpemUoIG9iamVjdE5vcm1hbCApICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdlV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBlbWlzc2l2ZW1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcdHZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZVdiApO1xcblxcdGVtaXNzaXZlQ29sb3IucmdiID0gZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyKCBlbWlzc2l2ZUNvbG9yICkucmdiO1xcblxcdHRvdGFsRW1pc3NpdmVSYWRpYW5jZSAqPSBlbWlzc2l2ZUNvbG9yLnJnYjtcXG4jZW5kaWZcIjtcblxuXHR2YXIgZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBlbmNvZGluZ3NfZnJhZ21lbnQgPSBcImdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1wiO1xuXG5cdHZhciBlbmNvZGluZ3NfcGFyc19mcmFnbWVudCA9IFwiXFxudmVjNCBMaW5lYXJUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmFsdWU7XFxufVxcbnZlYzQgR2FtbWFUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCBnYW1tYUZhY3RvciApICksIHZhbHVlLmEgKTtcXG59XFxudmVjNCBMaW5lYXJUb0dhbW1hKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBnYW1tYUZhY3RvciApIHtcXG5cXHRyZXR1cm4gdmVjNCggcG93KCB2YWx1ZS5yZ2IsIHZlYzMoIDEuMCAvIGdhbW1hRmFjdG9yICkgKSwgdmFsdWUuYSApO1xcbn1cXG52ZWM0IHNSR0JUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiAqIDAuOTQ3ODY3Mjk4NiArIHZlYzMoIDAuMDUyMTMyNzAxNCApLCB2ZWMzKCAyLjQgKSApLCB2YWx1ZS5yZ2IgKiAwLjA3NzM5OTM4MDgsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wNDA0NSApICkgKSApLCB2YWx1ZS5hICk7XFxufVxcbnZlYzQgTGluZWFyVG9zUkdCKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAwLjQxNjY2ICkgKSAqIDEuMDU1IC0gdmVjMyggMC4wNTUgKSwgdmFsdWUucmdiICogMTIuOTIsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wMDMxMzA4ICkgKSApICksIHZhbHVlLmEgKTtcXG59XFxudmVjNCBSR0JFVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqIGV4cDIoIHZhbHVlLmEgKiAyNTUuMCAtIDEyOC4wICksIDEuMCApO1xcbn1cXG52ZWM0IExpbmVhclRvUkdCRSggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgoIG1heCggdmFsdWUuciwgdmFsdWUuZyApLCB2YWx1ZS5iICk7XFxuXFx0ZmxvYXQgZkV4cCA9IGNsYW1wKCBjZWlsKCBsb2cyKCBtYXhDb21wb25lbnQgKSApLCAtMTI4LjAsIDEyNy4wICk7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAvIGV4cDIoIGZFeHAgKSwgKCBmRXhwICsgMTI4LjAgKSAvIDI1NS4wICk7XFxufVxcbnZlYzQgUkdCTVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogdmFsdWUuYSAqIG1heFJhbmdlLCAxLjAgKTtcXG59XFxudmVjNCBMaW5lYXJUb1JHQk0oIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcblxcdGZsb2F0IG1heFJHQiA9IG1heCggdmFsdWUuciwgbWF4KCB2YWx1ZS5nLCB2YWx1ZS5iICkgKTtcXG5cXHRmbG9hdCBNID0gY2xhbXAoIG1heFJHQiAvIG1heFJhbmdlLCAwLjAsIDEuMCApO1xcblxcdE0gPSBjZWlsKCBNICogMjU1LjAgKSAvIDI1NS4wO1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyAoIE0gKiBtYXhSYW5nZSApLCBNICk7XFxufVxcbnZlYzQgUkdCRFRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogKCAoIG1heFJhbmdlIC8gMjU1LjAgKSAvIHZhbHVlLmEgKSwgMS4wICk7XFxufVxcbnZlYzQgTGluZWFyVG9SR0JEKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG5cXHRmbG9hdCBtYXhSR0IgPSBtYXgoIHZhbHVlLnIsIG1heCggdmFsdWUuZywgdmFsdWUuYiApICk7XFxuXFx0ZmxvYXQgRCA9IG1heCggbWF4UmFuZ2UgLyBtYXhSR0IsIDEuMCApO1xcblxcdEQgPSBjbGFtcCggZmxvb3IoIEQgKSAvIDI1NS4wLCAwLjAsIDEuMCApO1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiAoIEQgKiAoIDI1NS4wIC8gbWF4UmFuZ2UgKSApLCBEICk7XFxufVxcbmNvbnN0IG1hdDMgY0xvZ0x1dk0gPSBtYXQzKCAwLjIyMDksIDAuMzM5MCwgMC40MTg0LCAwLjExMzgsIDAuNjc4MCwgMC43MzE5LCAwLjAxMDIsIDAuMTEzMCwgMC4yOTY5ICk7XFxudmVjNCBMaW5lYXJUb0xvZ0x1diggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHR2ZWMzIFhwX1lfWFlacCA9IGNMb2dMdXZNICogdmFsdWUucmdiO1xcblxcdFhwX1lfWFlacCA9IG1heCggWHBfWV9YWVpwLCB2ZWMzKCAxZS02LCAxZS02LCAxZS02ICkgKTtcXG5cXHR2ZWM0IHZSZXN1bHQ7XFxuXFx0dlJlc3VsdC54eSA9IFhwX1lfWFlacC54eSAvIFhwX1lfWFlacC56O1xcblxcdGZsb2F0IExlID0gMi4wICogbG9nMihYcF9ZX1hZWnAueSkgKyAxMjcuMDtcXG5cXHR2UmVzdWx0LncgPSBmcmFjdCggTGUgKTtcXG5cXHR2UmVzdWx0LnogPSAoIExlIC0gKCBmbG9vciggdlJlc3VsdC53ICogMjU1LjAgKSApIC8gMjU1LjAgKSAvIDI1NS4wO1xcblxcdHJldHVybiB2UmVzdWx0O1xcbn1cXG5jb25zdCBtYXQzIGNMb2dMdXZJbnZlcnNlTSA9IG1hdDMoIDYuMDAxNCwgLTIuNzAwOCwgLTEuNzk5NiwgLTEuMzMyMCwgMy4xMDI5LCAtNS43NzIxLCAwLjMwMDgsIC0xLjA4ODIsIDUuNjI2OCApO1xcbnZlYzQgTG9nTHV2VG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0ZmxvYXQgTGUgPSB2YWx1ZS56ICogMjU1LjAgKyB2YWx1ZS53O1xcblxcdHZlYzMgWHBfWV9YWVpwO1xcblxcdFhwX1lfWFlacC55ID0gZXhwMiggKCBMZSAtIDEyNy4wICkgLyAyLjAgKTtcXG5cXHRYcF9ZX1hZWnAueiA9IFhwX1lfWFlacC55IC8gdmFsdWUueTtcXG5cXHRYcF9ZX1hZWnAueCA9IHZhbHVlLnggKiBYcF9ZX1hZWnAuejtcXG5cXHR2ZWMzIHZSR0IgPSBjTG9nTHV2SW52ZXJzZU0gKiBYcF9ZX1hZWnAucmdiO1xcblxcdHJldHVybiB2ZWM0KCBtYXgoIHZSR0IsIDAuMCApLCAxLjAgKTtcXG59XCI7XG5cblx0dmFyIGVudm1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWZkZWYgRU5WX1dPUkxEUE9TXFxuXFx0XFx0dmVjMyBjYW1lcmFUb0ZyYWc7XFxuXFx0XFx0aWYgKCBpc09ydGhvZ3JhcGhpYyApIHtcXG5cXHRcXHRcXHRjYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZlYzMoIC0gdmlld01hdHJpeFsgMCBdWyAyIF0sIC0gdmlld01hdHJpeFsgMSBdWyAyIF0sIC0gdmlld01hdHJpeFsgMiBdWyAyIF0gKSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y2FtZXJhVG9GcmFnID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFx0XFx0fVxcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvRnJhZywgd29ybGROb3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvRnJhZywgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgcmVmbGVjdFZlYywgMC4wICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdmVjNCggMC4wICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmbmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuXFx0XFx0ZW52Q29sb3IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZDb2xvciApO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApXFxuXFx0XFx0b3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0dW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcdHVuaWZvcm0gaW50IG1heE1pcExldmVsO1xcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuXFx0I2VuZGlmXFxuXFx0XFxuI2VuZGlmXCI7XG5cblx0dmFyIGVudm1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdHVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFx0XFx0I2RlZmluZSBFTlZfV09STERQT1NcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WX1dPUkxEUE9TXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcdCNlbHNlXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBlbnZtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8ZGVmaW5lZCggUEhPTkcgKVxcblxcdFxcdCNkZWZpbmUgRU5WX1dPUkxEUE9TXFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVl9XT1JMRFBPU1xcblxcdFxcdFxcblxcdFxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgZW52bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWZkZWYgRU5WX1dPUkxEUE9TXFxuXFx0XFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXg7XFxuXFx0XFx0aWYgKCBpc09ydGhvZ3JhcGhpYyApIHtcXG5cXHRcXHRcXHRjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcdFxcdH1cXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIGZvZ192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0Zm9nRGVwdGggPSAtIG12UG9zaXRpb24uejtcXG4jZW5kaWZcIjtcblxuXHR2YXIgZm9nX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdHZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGZvZ19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSAxLjAgLSBleHAoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBmb2dEZXB0aCAqIGZvZ0RlcHRoICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGZvZ0RlcHRoICk7XFxuXFx0I2VuZGlmXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBmb2dfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxuXFx0dmFyeWluZyBmbG9hdCBmb2dEZXB0aDtcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfR1JBRElFTlRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBncmFkaWVudE1hcDtcXG4jZW5kaWZcXG52ZWMzIGdldEdyYWRpZW50SXJyYWRpYW5jZSggdmVjMyBub3JtYWwsIHZlYzMgbGlnaHREaXJlY3Rpb24gKSB7XFxuXFx0ZmxvYXQgZG90TkwgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXJlY3Rpb24gKTtcXG5cXHR2ZWMyIGNvb3JkID0gdmVjMiggZG90TkwgKiAwLjUgKyAwLjUsIDAuMCApO1xcblxcdCNpZmRlZiBVU0VfR1JBRElFTlRNQVBcXG5cXHRcXHRyZXR1cm4gdGV4dHVyZTJEKCBncmFkaWVudE1hcCwgY29vcmQgKS5yZ2I7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZXR1cm4gKCBjb29yZC54IDwgMC43ICkgPyB2ZWMzKCAwLjcgKSA6IHZlYzMoIDEuMCApO1xcblxcdCNlbmRpZlxcbn1cIjtcblxuXHR2YXIgbGlnaHRtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHR2ZWM0IGxpZ2h0TWFwVGV4ZWw9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gUEkgKiBsaWdodE1hcFRleGVsVG9MaW5lYXIoIGxpZ2h0TWFwVGV4ZWwgKS5yZ2IgKiBsaWdodE1hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgbGlnaHRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCA9IFwidmVjMyBkaWZmdXNlID0gdmVjMyggMS4wICk7XFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IG12UG9zaXRpb24ueHl6O1xcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5nZW9tZXRyeS52aWV3RGlyID0gKCBpc09ydGhvZ3JhcGhpYyApID8gdmVjMyggMCwgMCwgMSApIDogbm9ybWFsaXplKCAtbXZQb3NpdGlvbi54eXogKTtcXG5HZW9tZXRyaWNDb250ZXh0IGJhY2tHZW9tZXRyeTtcXG5iYWNrR2VvbWV0cnkucG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5iYWNrR2VvbWV0cnkubm9ybWFsID0gLWdlb21ldHJ5Lm5vcm1hbDtcXG5iYWNrR2VvbWV0cnkudmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XFxudkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcXG52SW5kaXJlY3RGcm9udCA9IHZlYzMoIDAuMCApO1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXHR2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxuXFx0dkluZGlyZWN0QmFjayA9IHZlYzMoIDAuMCApO1xcbiNlbmRpZlxcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuZmxvYXQgZG90Tkw7XFxudmVjMyBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxudkluZGlyZWN0RnJvbnQgKz0gZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggYW1iaWVudExpZ2h0Q29sb3IgKTtcXG52SW5kaXJlY3RGcm9udCArPSBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggbGlnaHRQcm9iZSwgZ2VvbWV0cnkgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dkluZGlyZWN0QmFjayArPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdHZJbmRpcmVjdEJhY2sgKz0gZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGxpZ2h0UHJvYmUsIGJhY2tHZW9tZXRyeSApO1xcbiNlbmRpZlxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBwb2ludExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0U3BvdERpcmVjdExpZ2h0SXJyYWRpYW5jZSggc3BvdExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0dkluZGlyZWN0RnJvbnQgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2SW5kaXJlY3RCYWNrICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgYmFja0dlb21ldHJ5ICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXCI7XG5cblx0dmFyIGxpZ2h0c19wYXJzX2JlZ2luID0gXCJ1bmlmb3JtIGJvb2wgcmVjZWl2ZVNoYWRvdztcXG51bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxudW5pZm9ybSB2ZWMzIGxpZ2h0UHJvYmVbIDkgXTtcXG52ZWMzIHNoR2V0SXJyYWRpYW5jZUF0KCBpbiB2ZWMzIG5vcm1hbCwgaW4gdmVjMyBzaENvZWZmaWNpZW50c1sgOSBdICkge1xcblxcdGZsb2F0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XFxuXFx0dmVjMyByZXN1bHQgPSBzaENvZWZmaWNpZW50c1sgMCBdICogMC44ODYyMjc7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAxIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHk7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAyIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHo7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAzIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHg7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA0IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB5O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNSBdICogMi4wICogMC40MjkwNDMgKiB5ICogejtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDYgXSAqICggMC43NDMxMjUgKiB6ICogeiAtIDAuMjQ3NzA4ICk7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA3IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB6O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgOCBdICogMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKTtcXG5cXHRyZXR1cm4gcmVzdWx0O1xcbn1cXG52ZWMzIGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGxpZ2h0UHJvYmVbIDkgXSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSApIHtcXG5cXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggZ2VvbWV0cnkubm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gc2hHZXRJcnJhZGlhbmNlQXQoIHdvcmxkTm9ybWFsLCBsaWdodFByb2JlICk7XFxuXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxufVxcbnZlYzMgZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBhbWJpZW50TGlnaHRDb2xvciApIHtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRpcnJhZGlhbmNlICo9IFBJO1xcblxcdCNlbmRpZlxcblxcdHJldHVybiBpcnJhZGlhbmNlO1xcbn1cXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0dm9pZCBnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCApIHtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7XFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxuXFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IHRydWU7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdHN0cnVjdCBQb2ludExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICkge1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGxpZ2h0RGlzdGFuY2UsIHBvaW50TGlnaHQuZGlzdGFuY2UsIHBvaW50TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gKCBkaXJlY3RMaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdHN0cnVjdCBTcG90TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHRcXHRmbG9hdCBjb25lQ29zO1xcblxcdFxcdGZsb2F0IHBlbnVtYnJhQ29zO1xcblxcdH07XFxuXFx0dW5pZm9ybSBTcG90TGlnaHQgc3BvdExpZ2h0c1sgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0dm9pZCBnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBTcG90TGlnaHQgc3BvdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCApIHtcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBzcG90TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgYW5nbGVDb3MgPSBkb3QoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgc3BvdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGlmICggYW5nbGVDb3MgPiBzcG90TGlnaHQuY29uZUNvcyApIHtcXG5cXHRcXHRcXHRmbG9hdCBzcG90RWZmZWN0ID0gc21vb3Roc3RlcCggc3BvdExpZ2h0LmNvbmVDb3MsIHNwb3RMaWdodC5wZW51bWJyYUNvcywgYW5nbGVDb3MgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvcjtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBzcG90RWZmZWN0ICogcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggbGlnaHREaXN0YW5jZSwgc3BvdExpZ2h0LmRpc3RhbmNlLCBzcG90TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gdHJ1ZTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gdmVjMyggMC4wICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcblxcdHN0cnVjdCBSZWN0QXJlYUxpZ2h0IHtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBoYWxmV2lkdGg7XFxuXFx0XFx0dmVjMyBoYWxmSGVpZ2h0O1xcblxcdH07XFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjXzE7XFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjXzI7XFxuXFx0dW5pZm9ybSBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHRzWyBOVU1fUkVDVF9BUkVBX0xJR0hUUyBdO1xcbiNlbmRpZlxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IEhlbWlzcGhlcmVMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBza3lDb2xvcjtcXG5cXHRcXHR2ZWMzIGdyb3VuZENvbG9yO1xcblxcdH07XFxuXFx0dW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07XFxuXFx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5ICkge1xcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhlbWlMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41O1xcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFx0XFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRyZXR1cm4gaXJyYWRpYW5jZTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cblx0dmFyIGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRlJBQ1RJT05cXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZW5kaWZcXG5cXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdElycmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggZ2VvbWV0cnkubm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHRcXHR2ZWMzIHF1ZXJ5VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHdvcmxkTm9ybWFsLngsIHdvcmxkTm9ybWFsLnl6ICk7XFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXG5cXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCB3b3JsZE5vcm1hbCwgMS4wICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdmVjNCggMC4wICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0cmV0dXJuIFBJICogZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcblxcdH1cXG5cXHRmbG9hdCBnZXRTcGVjdWxhck1JUExldmVsKCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXHRcXHRmbG9hdCBtYXhNSVBMZXZlbFNjYWxhciA9IGZsb2F0KCBtYXhNSVBMZXZlbCApO1xcblxcdFxcdGZsb2F0IHNpZ21hID0gUEkgKiByb3VnaG5lc3MgKiByb3VnaG5lc3MgLyAoIDEuMCArIHJvdWdobmVzcyApO1xcblxcdFxcdGZsb2F0IGRlc2lyZWRNSVBMZXZlbCA9IG1heE1JUExldmVsU2NhbGFyICsgbG9nMiggc2lnbWEgKTtcXG5cXHRcXHRyZXR1cm4gY2xhbXAoIGRlc2lyZWRNSVBMZXZlbCwgMC4wLCBtYXhNSVBMZXZlbFNjYWxhciApO1xcblxcdH1cXG5cXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIC12aWV3RGlyLCBub3JtYWwgKTtcXG5cXHRcXHRcXHRyZWZsZWN0VmVjID0gbm9ybWFsaXplKCBtaXgoIHJlZmxlY3RWZWMsIG5vcm1hbCwgcm91Z2huZXNzICogcm91Z2huZXNzKSApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggLXZpZXdEaXIsIG5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0cmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHRmbG9hdCBzcGVjdWxhck1JUExldmVsID0gZ2V0U3BlY3VsYXJNSVBMZXZlbCggcm91Z2huZXNzLCBtYXhNSVBMZXZlbCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVJlZmxlY3RWZWMgPSB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICk7XFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCByZWZsZWN0VmVjLCByb3VnaG5lc3MgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRyZXR1cm4gZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcblxcdH1cXG4jZW5kaWZcIjtcblxuXHR2YXIgbGlnaHRzX3Rvb25fZnJhZ21lbnQgPSBcIlRvb25NYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1wiO1xuXG5cdHZhciBsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuc3RydWN0IFRvb25NYXRlcmlhbCB7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9Ub29uKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEdyYWRpZW50SXJyYWRpYW5jZSggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdGlycmFkaWFuY2UgKj0gUEk7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9Ub29uKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFRvb25NYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X1Rvb25cXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9Ub29uXFxuI2RlZmluZSBNYXRlcmlhbF9MaWdodFByb2JlTE9EKCBtYXRlcmlhbCApXFx0KDApXCI7XG5cblx0dmFyIGxpZ2h0c19waG9uZ19mcmFnbWVudCA9IFwiQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyO1xcbm1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzID0gc2hpbmluZXNzO1xcbm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO1wiO1xuXG5cdHZhciBsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudCA9IFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbnN0cnVjdCBCbGlublBob25nTWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcblxcdHZlYzMgc3BlY3VsYXJDb2xvcjtcXG5cXHRmbG9hdCBzcGVjdWxhclNoaW5pbmVzcztcXG5cXHRmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbn07XFxudm9pZCBSRV9EaXJlY3RfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdGlycmFkaWFuY2UgKj0gUEk7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0JsaW5uUGhvbmcoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgKSAqIG1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGg7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfQmxpbm5QaG9uZ1xcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmdcXG4jZGVmaW5lIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QoIG1hdGVyaWFsIClcXHQoMClcIjtcblxuXHR2YXIgbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50ID0gXCJQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcbnZlYzMgZHh5ID0gbWF4KCBhYnMoIGRGZHgoIGdlb21ldHJ5Tm9ybWFsICkgKSwgYWJzKCBkRmR5KCBnZW9tZXRyeU5vcm1hbCApICkgKTtcXG5mbG9hdCBnZW9tZXRyeVJvdWdobmVzcyA9IG1heCggbWF4KCBkeHkueCwgZHh5LnkgKSwgZHh5LnogKTtcXG5tYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyA9IG1heCggcm91Z2huZXNzRmFjdG9yLCAwLjA1MjUgKTttYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcXG5tYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyA9IG1pbiggbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MsIDEuMCApO1xcbiNpZmRlZiBSRUZMRUNUSVZJVFlcXG5cXHQjaWZkZWYgU1BFQ1VMQVJcXG5cXHRcXHR2ZWMzIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yID0gdmVjMyggc3BlY3VsYXJJbnRlbnNpdHkgKTtcXG5cXHRcXHR2ZWMzIHNwZWN1bGFyVGludEZhY3RvciA9IHNwZWN1bGFyVGludDtcXG5cXHRcXHQjaWZkZWYgVVNFX1NQRUNVTEFSSU5URU5TSVRZTUFQXFxuXFx0XFx0XFx0c3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgKj0gdGV4dHVyZTJEKCBzcGVjdWxhckludGVuc2l0eU1hcCwgdlV2ICkuYTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHQjaWZkZWYgVVNFX1NQRUNVTEFSVElOVE1BUFxcblxcdFxcdFxcdHNwZWN1bGFyVGludEZhY3RvciAqPSBzcGVjdWxhclRpbnRNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQoIHNwZWN1bGFyVGludE1hcCwgdlV2ICkgKS5yZ2I7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvckY5MCA9IG1peCggc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IsIHZlYzMoIDEuMCApLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSB2ZWMzKCAxLjAgKTtcXG5cXHRcXHR2ZWMzIHNwZWN1bGFyVGludEZhY3RvciA9IHZlYzMoIDEuMCApO1xcblxcdFxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JGOTAgPSB2ZWMzKCAxLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCBtaW4oIHZlYzMoIE1BWElNVU1fU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKiBwb3cyKCByZWZsZWN0aXZpdHkgKSApICogc3BlY3VsYXJUaW50RmFjdG9yLCB2ZWMzKCAxLjAgKSApICogc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IsIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcbiNlbHNlXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yRjkwID0gdmVjMyggMS4wICk7XFxuI2VuZGlmXFxuI2lmZGVmIENMRUFSQ09BVFxcblxcdG1hdGVyaWFsLmNsZWFyY29hdCA9IGNsZWFyY29hdDtcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBjbGVhcmNvYXRSb3VnaG5lc3M7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRNQVBcXG5cXHRcXHRtYXRlcmlhbC5jbGVhcmNvYXQgKj0gdGV4dHVyZTJEKCBjbGVhcmNvYXRNYXAsIHZVdiApLng7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQXFxuXFx0XFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICo9IHRleHR1cmUyRCggY2xlYXJjb2F0Um91Z2huZXNzTWFwLCB2VXYgKS55O1xcblxcdCNlbmRpZlxcblxcdG1hdGVyaWFsLmNsZWFyY29hdCA9IHNhdHVyYXRlKCBtYXRlcmlhbC5jbGVhcmNvYXQgKTtcXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBtYXgoIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcywgMC4wNTI1ICk7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICs9IGdlb21ldHJ5Um91Z2huZXNzO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IG1pbiggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCAxLjAgKTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIRUVOXFxuXFx0bWF0ZXJpYWwuc2hlZW5Db2xvciA9IHNoZWVuO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCA9IFwic3RydWN0IFBoeXNpY2FsTWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcblxcdGZsb2F0IHNwZWN1bGFyUm91Z2huZXNzO1xcblxcdHZlYzMgc3BlY3VsYXJDb2xvcjtcXG5cXHR2ZWMzIHNwZWN1bGFyQ29sb3JGOTA7XFxuI2lmZGVmIENMRUFSQ09BVFxcblxcdGZsb2F0IGNsZWFyY29hdDtcXG5cXHRmbG9hdCBjbGVhcmNvYXRSb3VnaG5lc3M7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TSEVFTlxcblxcdHZlYzMgc2hlZW5Db2xvcjtcXG4jZW5kaWZcXG59O1xcbiNkZWZpbmUgTUFYSU1VTV9TUEVDVUxBUl9DT0VGRklDSUVOVCAwLjE2XFxuI2RlZmluZSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UIDAuMDRcXG5mbG9hdCBjbGVhcmNvYXRESFJBcHByb3goIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkwgKSB7XFxuXFx0cmV0dXJuIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKyAoIDEuMCAtIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSAqICggcG93KCAxLjAgLSBkb3ROTCwgNS4wICkgKiBwb3coIDEuMCAtIHJvdWdobmVzcywgMi4wICkgKTtcXG59XFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcblxcdHZvaWQgUkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsKCBjb25zdCBpbiBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdFxcdHZlYzMgbm9ybWFsID0gZ2VvbWV0cnkubm9ybWFsO1xcblxcdFxcdHZlYzMgdmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdFxcdHZlYzMgbGlnaHRQb3MgPSByZWN0QXJlYUxpZ2h0LnBvc2l0aW9uO1xcblxcdFxcdHZlYzMgaGFsZldpZHRoID0gcmVjdEFyZWFMaWdodC5oYWxmV2lkdGg7XFxuXFx0XFx0dmVjMyBoYWxmSGVpZ2h0ID0gcmVjdEFyZWFMaWdodC5oYWxmSGVpZ2h0O1xcblxcdFxcdHZlYzMgbGlnaHRDb2xvciA9IHJlY3RBcmVhTGlnaHQuY29sb3I7XFxuXFx0XFx0ZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3M7XFxuXFx0XFx0dmVjMyByZWN0Q29vcmRzWyA0IF07XFxuXFx0XFx0cmVjdENvb3Jkc1sgMCBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcdFxcdHJlY3RDb29yZHNbIDEgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcXG5cXHRcXHRyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxuXFx0XFx0cmVjdENvb3Jkc1sgMyBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0O1xcblxcdFxcdHZlYzIgdXYgPSBMVENfVXYoIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XFxuXFx0XFx0dmVjNCB0MSA9IHRleHR1cmUyRCggbHRjXzEsIHV2ICk7XFxuXFx0XFx0dmVjNCB0MiA9IHRleHR1cmUyRCggbHRjXzIsIHV2ICk7XFxuXFx0XFx0bWF0MyBtSW52ID0gbWF0MyhcXG5cXHRcXHRcXHR2ZWMzKCB0MS54LCAwLCB0MS55ICksXFxuXFx0XFx0XFx0dmVjMyhcdFx0MCwgMSxcdFx0MCApLFxcblxcdFxcdFxcdHZlYzMoIHQxLnosIDAsIHQxLncgKVxcblxcdFxcdCk7XFxuXFx0XFx0dmVjMyBmcmVzbmVsID0gKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICogdDIueCArICggdmVjMyggMS4wICkgLSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICkgKiB0Mi55ICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIGZyZXNuZWwgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1JbnYsIHJlY3RDb29yZHMgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGxpZ2h0Q29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1hdDMoIDEuMCApLCByZWN0Q29vcmRzICk7XFxuXFx0fVxcbiNlbmRpZlxcbnZvaWQgUkVfRGlyZWN0X1BoeXNpY2FsKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdGlycmFkaWFuY2UgKj0gUEk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIENMRUFSQ09BVFxcblxcdFxcdGZsb2F0IGNjRG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0XFx0dmVjMyBjY0lycmFkaWFuY2UgPSBjY0RvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0XFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0XFx0Y2NJcnJhZGlhbmNlICo9IFBJO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdGZsb2F0IGNsZWFyY29hdERIUiA9IG1hdGVyaWFsLmNsZWFyY29hdCAqIGNsZWFyY29hdERIUkFwcHJveCggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCBjY0RvdE5MICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gY2NJcnJhZGlhbmNlICogbWF0ZXJpYWwuY2xlYXJjb2F0ICogQlJERl9TcGVjdWxhcl9HR1goIGRpcmVjdExpZ2h0LCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgdmVjMyggMS4wICksIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgY2xlYXJjb2F0REhSID0gMC4wO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU0hFRU5cXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSAoIDEuMCAtIGNsZWFyY29hdERIUiApICogaXJyYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfU2hlZW4oXFxuXFx0XFx0XFx0bWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MsXFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uLFxcblxcdFxcdFxcdGdlb21ldHJ5LFxcblxcdFxcdFxcdG1hdGVyaWFsLnNoZWVuQ29sb3JcXG5cXHRcXHQpO1xcblxcdCNlbHNlXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gKCAxLjAgLSBjbGVhcmNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvckY5MCwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MpO1xcblxcdCNlbmRpZlxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gKCAxLjAgLSBjbGVhcmNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBjbGVhcmNvYXRSYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQpIHtcXG5cXHQjaWZkZWYgQ0xFQVJDT0FUXFxuXFx0XFx0ZmxvYXQgY2NEb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSBjbGVhcmNvYXRSYWRpYW5jZSAqIG1hdGVyaWFsLmNsZWFyY29hdCAqIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XFxuXFx0XFx0ZmxvYXQgY2NEb3ROTCA9IGNjRG90TlY7XFxuXFx0XFx0ZmxvYXQgY2xlYXJjb2F0REhSID0gbWF0ZXJpYWwuY2xlYXJjb2F0ICogY2xlYXJjb2F0REhSQXBwcm94KCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIGNjRG90TkwgKTtcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IGNsZWFyY29hdERIUiA9IDAuMDtcXG5cXHQjZW5kaWZcXG5cXHRmbG9hdCBjbGVhcmNvYXRJbnYgPSAxLjAgLSBjbGVhcmNvYXRESFI7XFxuXFx0dmVjMyBzaW5nbGVTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBtdWx0aVNjYXR0ZXJpbmcgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZSA9IGlycmFkaWFuY2UgKiBSRUNJUFJPQ0FMX1BJO1xcblxcdEJSREZfU3BlY3VsYXJfTXVsdGlzY2F0dGVyaW5nX0Vudmlyb25tZW50KCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApO1xcblxcdHZlYzMgZGlmZnVzZSA9IG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqICggMS4wIC0gKCBzaW5nbGVTY2F0dGVyaW5nICsgbXVsdGlTY2F0dGVyaW5nICkgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IGNsZWFyY29hdEludiAqIHJhZGlhbmNlICogc2luZ2xlU2NhdHRlcmluZztcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IG11bHRpU2NhdHRlcmluZyAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gZGlmZnVzZSAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0RpcmVjdF9SZWN0QXJlYVxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdFNwZWN1bGFyXFx0XFx0UkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbFxcbmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIHBvdyggZG90TlYgKyBhbWJpZW50T2NjbHVzaW9uLCBleHAyKCAtIDE2LjAgKiByb3VnaG5lc3MgLSAxLjAgKSApIC0gMS4wICsgYW1iaWVudE9jY2x1c2lvbiApO1xcbn1cIjtcblxuXHR2YXIgbGlnaHRzX2ZyYWdtZW50X2JlZ2luID0gXCJcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbDtcXG5nZW9tZXRyeS52aWV3RGlyID0gKCBpc09ydGhvZ3JhcGhpYyApID8gdmVjMyggMCwgMCwgMSApIDogbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuI2lmZGVmIENMRUFSQ09BVFxcblxcdGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCA9IGNsZWFyY29hdE5vcm1hbDtcXG4jZW5kaWZcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcbiNpZiAoIE5VTV9QT0lOVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXHRQb2ludExpZ2h0IHBvaW50TGlnaHQ7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3c7XFxuXFx0I2VuZGlmXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIHBvaW50TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgKVxcblxcdFxcdHBvaW50TGlnaHRTaGFkb3cgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdExpZ2h0LnZpc2libGUsIHJlY2VpdmVTaGFkb3cgKSApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgKCBOVU1fU1BPVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXHRTcG90TGlnaHQgc3BvdExpZ2h0O1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93O1xcblxcdCNlbmRpZlxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIHNwb3RMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRzcG90TGlnaHRTaGFkb3cgPSBzcG90TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggZGlyZWN0TGlnaHQudmlzaWJsZSwgcmVjZWl2ZVNoYWRvdyApICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmICggTlVNX0RJUl9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0RGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93O1xcblxcdCNlbmRpZlxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTtcXG5cXHRcXHRnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggZGlyZWN0aW9uYWxMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fRElSX0xJR0hUX1NIQURPV1MgKVxcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdExpZ2h0LnZpc2libGUsIHJlY2VpdmVTaGFkb3cgKSApID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmICggTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0X1JlY3RBcmVhIClcXG5cXHRSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9SRUNUX0FSRUFfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHJlY3RBcmVhTGlnaHQgPSByZWN0QXJlYUxpZ2h0c1sgaSBdO1xcblxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYSggcmVjdEFyZWFMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcblxcdHZlYzMgaWJsSXJyYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxuXFx0aXJyYWRpYW5jZSArPSBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggbGlnaHRQcm9iZSwgZ2VvbWV0cnkgKTtcXG5cXHQjaWYgKCBOVU1fSEVNSV9MSUdIVFMgPiAwIClcXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcdFxcdFxcdGlycmFkaWFuY2UgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcXG5cXHR2ZWMzIHJhZGlhbmNlID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBjbGVhcmNvYXRSYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBsaWdodHNfZnJhZ21lbnRfbWFwcyA9IFwiI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdFxcdHZlYzQgbGlnaHRNYXBUZXhlbD0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApO1xcblxcdFxcdHZlYzMgbGlnaHRNYXBJcnJhZGlhbmNlID0gbGlnaHRNYXBUZXhlbFRvTGluZWFyKCBsaWdodE1hcFRleGVsICkucmdiICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFx0XFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0XFx0bGlnaHRNYXBJcnJhZGlhbmNlICo9IFBJO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdGlycmFkaWFuY2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xcblxcdCNlbmRpZlxcblxcdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggU1RBTkRBUkQgKSAmJiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRpYmxJcnJhZGlhbmNlICs9IGdldExpZ2h0UHJvYmVJbmRpcmVjdElycmFkaWFuY2UoIGdlb21ldHJ5LCBtYXhNaXBMZXZlbCApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXFx0cmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MsIG1heE1pcExldmVsICk7XFxuXFx0I2lmZGVmIENMRUFSQ09BVFxcblxcdFxcdGNsZWFyY29hdFJhZGlhbmNlICs9IGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcywgbWF4TWlwTGV2ZWwgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgbGlnaHRzX2ZyYWdtZW50X2VuZCA9IFwiI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFx0UkVfSW5kaXJlY3REaWZmdXNlKCBpcnJhZGlhbmNlLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdFJFX0luZGlyZWN0U3BlY3VsYXIoIHJhZGlhbmNlLCBpYmxJcnJhZGlhbmNlLCBjbGVhcmNvYXRSYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBsb2dkZXB0aGJ1Zl9mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRiApICYmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRl9FWFQgKVxcblxcdGdsX0ZyYWdEZXB0aEVYVCA9IHZJc1BlcnNwZWN0aXZlID09IDAuMCA/IGdsX0ZyYWdDb29yZC56IDogbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRiApICYmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRl9FWFQgKVxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFx0dmFyeWluZyBmbG9hdCB2SXNQZXJzcGVjdGl2ZTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcdFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXHRcXHR2YXJ5aW5nIGZsb2F0IHZJc1BlcnNwZWN0aXZlO1xcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBsb2dkZXB0aGJ1Zl92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcdFxcdHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xcblxcdFxcdHZJc1BlcnNwZWN0aXZlID0gZmxvYXQoIGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKSApO1xcblxcdCNlbHNlXFxuXFx0XFx0aWYgKCBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICkgKSB7XFxuXFx0XFx0XFx0Z2xfUG9zaXRpb24ueiA9IGxvZzIoIG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApICkgKiBsb2dEZXB0aEJ1ZkZDIC0gMS4wO1xcblxcdFxcdFxcdGdsX1Bvc2l0aW9uLnogKj0gZ2xfUG9zaXRpb24udztcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIG1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XFxuXFx0dGV4ZWxDb2xvciA9IG1hcFRleGVsVG9MaW5lYXIoIHRleGVsQ29sb3IgKTtcXG5cXHRkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcXG4jZW5kaWZcIjtcblxuXHR2YXIgbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBtYXBfcGFydGljbGVfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXHR2ZWMyIHV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55LCAxICkgKS54eTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX01BUFxcblxcdHZlYzQgbWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIG1hcCwgdXYgKTtcXG5cXHRkaWZmdXNlQ29sb3IgKj0gbWFwVGV4ZWxUb0xpbmVhciggbWFwVGV4ZWwgKTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0ZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdXYgKS5nO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKVxcblxcdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuI2VuZGlmXCI7XG5cblx0dmFyIG1ldGFsbmVzc21hcF9mcmFnbWVudCA9IFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2VXYgKTtcXG5cXHRtZXRhbG5lc3NGYWN0b3IgKj0gdGV4ZWxNZXRhbG5lc3MuYjtcXG4jZW5kaWZcIjtcblxuXHR2YXIgbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxuZXNzTWFwO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBtb3JwaG5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0b2JqZWN0Tm9ybWFsICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHRvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwwICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXFx0b2JqZWN0Tm9ybWFsICs9IG1vcnBoTm9ybWFsMSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDIgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cXHRvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwzICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuI2VuZGlmXCI7XG5cblx0dmFyIG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xcblxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBtb3JwaHRhcmdldF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFx0dHJhbnNmb3JtZWQgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xcblxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0MCAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0MSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0MiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0MyAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NCAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcblxcdFxcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NyAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBub3JtYWxfZnJhZ21lbnRfYmVnaW4gPSBcImZsb2F0IGZhY2VEaXJlY3Rpb24gPSBnbF9Gcm9udEZhY2luZyA/IDEuMCA6IC0gMS4wO1xcbiNpZmRlZiBGTEFUX1NIQURFRFxcblxcdHZlYzMgZmR4ID0gdmVjMyggZEZkeCggdlZpZXdQb3NpdGlvbi54ICksIGRGZHgoIHZWaWV3UG9zaXRpb24ueSApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnogKSApO1xcblxcdHZlYzMgZmR5ID0gdmVjMyggZEZkeSggdlZpZXdQb3NpdGlvbi54ICksIGRGZHkoIHZWaWV3UG9zaXRpb24ueSApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnogKSApO1xcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcbiNlbHNlXFxuXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTtcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0bm9ybWFsID0gbm9ybWFsICogZmFjZURpcmVjdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2ZWMzIHRhbmdlbnQgPSBub3JtYWxpemUoIHZUYW5nZW50ICk7XFxuXFx0XFx0dmVjMyBiaXRhbmdlbnQgPSBub3JtYWxpemUoIHZCaXRhbmdlbnQgKTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dGFuZ2VudCA9IHRhbmdlbnQgKiBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdFxcdGJpdGFuZ2VudCA9IGJpdGFuZ2VudCAqIGZhY2VEaXJlY3Rpb247XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0I2lmIGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCApXFxuXFx0XFx0XFx0bWF0MyB2VEJOID0gbWF0MyggdGFuZ2VudCwgYml0YW5nZW50LCBub3JtYWwgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG52ZWMzIGdlb21ldHJ5Tm9ybWFsID0gbm9ybWFsO1wiO1xuXG5cdHZhciBub3JtYWxfZnJhZ21lbnRfbWFwcyA9IFwiI2lmZGVmIE9CSkVDVFNQQUNFX05PUk1BTE1BUFxcblxcdG5vcm1hbCA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXFx0I2lmZGVmIEZMSVBfU0lERURcXG5cXHRcXHRub3JtYWwgPSAtIG5vcm1hbDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0bm9ybWFsID0gbm9ybWFsICogZmFjZURpcmVjdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHRub3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1xcbiNlbGlmIGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKVxcblxcdHZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXFx0bWFwTi54eSAqPSBub3JtYWxTY2FsZTtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHRub3JtYWwgPSBub3JtYWxpemUoIHZUQk4gKiBtYXBOICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgbWFwTiwgZmFjZURpcmVjdGlvbiApO1xcblxcdCNlbmRpZlxcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXG5cXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSwgZmFjZURpcmVjdGlvbiApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBub3JtYWxtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcbiNlbmRpZlxcbiNpZmRlZiBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4O1xcbiNlbmRpZlxcbiNpZiAhIGRlZmluZWQgKCBVU0VfVEFOR0VOVCApICYmICggZGVmaW5lZCAoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkICggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKSApXFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMyBtYXBOLCBmbG9hdCBmYWNlRGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgcTAgPSB2ZWMzKCBkRmR4KCBleWVfcG9zLnggKSwgZEZkeCggZXllX3Bvcy55ICksIGRGZHgoIGV5ZV9wb3MueiApICk7XFxuXFx0XFx0dmVjMyBxMSA9IHZlYzMoIGRGZHkoIGV5ZV9wb3MueCApLCBkRmR5KCBleWVfcG9zLnkgKSwgZEZkeSggZXllX3Bvcy56ICkgKTtcXG5cXHRcXHR2ZWMyIHN0MCA9IGRGZHgoIHZVdi5zdCApO1xcblxcdFxcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFx0XFx0dmVjMyBOID0gc3VyZl9ub3JtO1xcblxcdFxcdHZlYzMgcTFwZXJwID0gY3Jvc3MoIHExLCBOICk7XFxuXFx0XFx0dmVjMyBxMHBlcnAgPSBjcm9zcyggTiwgcTAgKTtcXG5cXHRcXHR2ZWMzIFQgPSBxMXBlcnAgKiBzdDAueCArIHEwcGVycCAqIHN0MS54O1xcblxcdFxcdHZlYzMgQiA9IHExcGVycCAqIHN0MC55ICsgcTBwZXJwICogc3QxLnk7XFxuXFx0XFx0ZmxvYXQgZGV0ID0gbWF4KCBkb3QoIFQsIFQgKSwgZG90KCBCLCBCICkgKTtcXG5cXHRcXHRmbG9hdCBzY2FsZSA9ICggZGV0ID09IDAuMCApID8gMC4wIDogZmFjZURpcmVjdGlvbiAqIGludmVyc2VzcXJ0KCBkZXQgKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCBUICogKCBtYXBOLnggKiBzY2FsZSApICsgQiAqICggbWFwTi55ICogc2NhbGUgKSArIE4gKiBtYXBOLnogKTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cblx0dmFyIGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW4gPSBcIiNpZmRlZiBDTEVBUkNPQVRcXG5cXHR2ZWMzIGNsZWFyY29hdE5vcm1hbCA9IGdlb21ldHJ5Tm9ybWFsO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHMgPSBcIiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFxcblxcdHZlYzMgY2xlYXJjb2F0TWFwTiA9IHRleHR1cmUyRCggY2xlYXJjb2F0Tm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXFx0Y2xlYXJjb2F0TWFwTi54eSAqPSBjbGVhcmNvYXROb3JtYWxTY2FsZTtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHRjbGVhcmNvYXROb3JtYWwgPSBub3JtYWxpemUoIHZUQk4gKiBjbGVhcmNvYXRNYXBOICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRjbGVhcmNvYXROb3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLSB2Vmlld1Bvc2l0aW9uLCBjbGVhcmNvYXROb3JtYWwsIGNsZWFyY29hdE1hcE4sIGZhY2VEaXJlY3Rpb24gKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgY2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJjb2F0TWFwO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdFJvdWdobmVzc01hcDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXROb3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBwYWNraW5nID0gXCJ2ZWMzIHBhY2tOb3JtYWxUb1JHQiggY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggbm9ybWFsICkgKiAwLjUgKyAwLjU7XFxufVxcbnZlYzMgdW5wYWNrUkdCVG9Ob3JtYWwoIGNvbnN0IGluIHZlYzMgcmdiICkge1xcblxcdHJldHVybiAyLjAgKiByZ2IueHl6IC0gMS4wO1xcbn1cXG5jb25zdCBmbG9hdCBQYWNrVXBzY2FsZSA9IDI1Ni4gLyAyNTUuO2NvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuO1xcbmNvbnN0IHZlYzMgUGFja0ZhY3RvcnMgPSB2ZWMzKCAyNTYuICogMjU2LiAqIDI1Ni4sIDI1Ni4gKiAyNTYuLCAyNTYuICk7XFxuY29uc3QgdmVjNCBVbnBhY2tGYWN0b3JzID0gVW5wYWNrRG93bnNjYWxlIC8gdmVjNCggUGFja0ZhY3RvcnMsIDEuICk7XFxuY29uc3QgZmxvYXQgU2hpZnRSaWdodDggPSAxLiAvIDI1Ni47XFxudmVjNCBwYWNrRGVwdGhUb1JHQkEoIGNvbnN0IGluIGZsb2F0IHYgKSB7XFxuXFx0dmVjNCByID0gdmVjNCggZnJhY3QoIHYgKiBQYWNrRmFjdG9ycyApLCB2ICk7XFxuXFx0ci55encgLT0gci54eXogKiBTaGlmdFJpZ2h0ODtcXHRyZXR1cm4gciAqIFBhY2tVcHNjYWxlO1xcbn1cXG5mbG9hdCB1bnBhY2tSR0JBVG9EZXB0aCggY29uc3QgaW4gdmVjNCB2ICkge1xcblxcdHJldHVybiBkb3QoIHYsIFVucGFja0ZhY3RvcnMgKTtcXG59XFxudmVjNCBwYWNrMkhhbGZUb1JHQkEoIHZlYzIgdiApIHtcXG5cXHR2ZWM0IHIgPSB2ZWM0KCB2LngsIGZyYWN0KCB2LnggKiAyNTUuMCApLCB2LnksIGZyYWN0KCB2LnkgKiAyNTUuMCApKTtcXG5cXHRyZXR1cm4gdmVjNCggci54IC0gci55IC8gMjU1LjAsIHIueSwgci56IC0gci53IC8gMjU1LjAsIHIudyk7XFxufVxcbnZlYzIgdW5wYWNrUkdCQVRvMkhhbGYoIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gdmVjMiggdi54ICsgKCB2LnkgLyAyNTUuMCApLCB2LnogKyAoIHYudyAvIDI1NS4wICkgKTtcXG59XFxuZmxvYXQgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XFxufVxcbmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgbGluZWFyQ2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gbGluZWFyQ2xpcFogKiAoIG5lYXIgLSBmYXIgKSAtIG5lYXI7XFxufVxcbmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoKCBuZWFyICsgdmlld1ogKSAqIGZhciApIC8gKCggZmFyIC0gbmVhciApICogdmlld1ogKTtcXG59XFxuZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGludkNsaXBaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuICggbmVhciAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIGludkNsaXBaIC0gZmFyICk7XFxufVwiO1xuXG5cdHZhciBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50ID0gXCIjaWZkZWYgUFJFTVVMVElQTElFRF9BTFBIQVxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgKj0gZ2xfRnJhZ0NvbG9yLmE7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHByb2plY3RfdmVydGV4ID0gXCJ2ZWM0IG12UG9zaXRpb24gPSB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuXFx0bXZQb3NpdGlvbiA9IGluc3RhbmNlTWF0cml4ICogbXZQb3NpdGlvbjtcXG4jZW5kaWZcXG5tdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogbXZQb3NpdGlvbjtcXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiO1xuXG5cdHZhciBkaXRoZXJpbmdfZnJhZ21lbnQgPSBcIiNpZmRlZiBESVRIRVJJTkdcXG5cXHRnbF9GcmFnQ29sb3IucmdiID0gZGl0aGVyaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgRElUSEVSSU5HXFxuXFx0dmVjMyBkaXRoZXJpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0XFx0ZmxvYXQgZ3JpZF9wb3NpdGlvbiA9IHJhbmQoIGdsX0ZyYWdDb29yZC54eSApO1xcblxcdFxcdHZlYzMgZGl0aGVyX3NoaWZ0X1JHQiA9IHZlYzMoIDAuMjUgLyAyNTUuMCwgLTAuMjUgLyAyNTUuMCwgMC4yNSAvIDI1NS4wICk7XFxuXFx0XFx0ZGl0aGVyX3NoaWZ0X1JHQiA9IG1peCggMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgLTIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIGdyaWRfcG9zaXRpb24gKTtcXG5cXHRcXHRyZXR1cm4gY29sb3IgKyBkaXRoZXJfc2hpZnRfUkdCO1xcblxcdH1cXG4jZW5kaWZcIjtcblxuXHR2YXIgcm91Z2huZXNzbWFwX2ZyYWdtZW50ID0gXCJmbG9hdCByb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3M7XFxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cXHR2ZWM0IHRleGVsUm91Z2huZXNzID0gdGV4dHVyZTJEKCByb3VnaG5lc3NNYXAsIHZVdiApO1xcblxcdHJvdWdobmVzc0ZhY3RvciAqPSB0ZXhlbFJvdWdobmVzcy5nO1xcbiNlbmRpZlwiO1xuXG5cdHZhciByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90U2hhZG93TWFwWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHRzdHJ1Y3QgU3BvdExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gU3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvd3NbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRTaGFkb3dNYXBbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFOZWFyO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYUZhcjtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gUG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93c1sgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHRmbG9hdCB0ZXh0dXJlMkRDb21wYXJlKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkge1xcblxcdFxcdHJldHVybiBzdGVwKCBjb21wYXJlLCB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBkZXB0aHMsIHV2ICkgKSApO1xcblxcdH1cXG5cXHR2ZWMyIHRleHR1cmUyRERpc3RyaWJ1dGlvbiggc2FtcGxlcjJEIHNoYWRvdywgdmVjMiB1diApIHtcXG5cXHRcXHRyZXR1cm4gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93LCB1diApICk7XFxuXFx0fVxcblxcdGZsb2F0IFZTTVNoYWRvdyAoc2FtcGxlcjJEIHNoYWRvdywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApe1xcblxcdFxcdGZsb2F0IG9jY2x1c2lvbiA9IDEuMDtcXG5cXHRcXHR2ZWMyIGRpc3RyaWJ1dGlvbiA9IHRleHR1cmUyRERpc3RyaWJ1dGlvbiggc2hhZG93LCB1diApO1xcblxcdFxcdGZsb2F0IGhhcmRfc2hhZG93ID0gc3RlcCggY29tcGFyZSAsIGRpc3RyaWJ1dGlvbi54ICk7XFxuXFx0XFx0aWYgKGhhcmRfc2hhZG93ICE9IDEuMCApIHtcXG5cXHRcXHRcXHRmbG9hdCBkaXN0YW5jZSA9IGNvbXBhcmUgLSBkaXN0cmlidXRpb24ueCA7XFxuXFx0XFx0XFx0ZmxvYXQgdmFyaWFuY2UgPSBtYXgoIDAuMDAwMDAsIGRpc3RyaWJ1dGlvbi55ICogZGlzdHJpYnV0aW9uLnkgKTtcXG5cXHRcXHRcXHRmbG9hdCBzb2Z0bmVzc19wcm9iYWJpbGl0eSA9IHZhcmlhbmNlIC8gKHZhcmlhbmNlICsgZGlzdGFuY2UgKiBkaXN0YW5jZSApO1xcdFxcdFxcdHNvZnRuZXNzX3Byb2JhYmlsaXR5ID0gY2xhbXAoICggc29mdG5lc3NfcHJvYmFiaWxpdHkgLSAwLjMgKSAvICggMC45NSAtIDAuMyApLCAwLjAsIDEuMCApO1xcdFxcdFxcdG9jY2x1c2lvbiA9IGNsYW1wKCBtYXgoIGhhcmRfc2hhZG93LCBzb2Z0bmVzc19wcm9iYWJpbGl0eSApLCAwLjAsIDEuMCApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gb2NjbHVzaW9uO1xcblxcdH1cXG5cXHRmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblxcdFxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHRcXHRzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudztcXG5cXHRcXHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXM7XFxuXFx0XFx0YnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcblxcdFxcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXHRcXHRidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxuXFx0XFx0Ym9vbCBmcnVzdHVtVGVzdCA9IGFsbCggZnJ1c3R1bVRlc3RWZWMgKTtcXG5cXHRcXHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkwID0gLSB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHgyID0gZHgwIC8gMi4wO1xcblxcdFxcdFxcdGZsb2F0IGR5MiA9IGR5MCAvIDIuMDtcXG5cXHRcXHRcXHRmbG9hdCBkeDMgPSBkeDEgLyAyLjA7XFxuXFx0XFx0XFx0ZmxvYXQgZHkzID0gZHkxIC8gMi4wO1xcblxcdFxcdFxcdHNoYWRvdyA9IChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyAxNy4wICk7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IGR4ID0gdGV4ZWxTaXplLng7XFxuXFx0XFx0XFx0ZmxvYXQgZHkgPSB0ZXhlbFNpemUueTtcXG5cXHRcXHRcXHR2ZWMyIHV2ID0gc2hhZG93Q29vcmQueHk7XFxuXFx0XFx0XFx0dmVjMiBmID0gZnJhY3QoIHV2ICogc2hhZG93TWFwU2l6ZSArIDAuNSApO1xcblxcdFxcdFxcdHV2IC09IGYgKiB0ZXhlbFNpemU7XFxuXFx0XFx0XFx0c2hhZG93ID0gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYsIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCBkeSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB0ZXhlbFNpemUsIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLCBcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnggKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCBkeSApLCBzaGFkb3dDb29yZC56ICksIFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi54ICkgK1xcblxcdFxcdFxcdFxcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwgXFxuXFx0XFx0XFx0XFx0XFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi55ICkgK1xcblxcdFxcdFxcdFxcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLCBcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IGYueSApICtcXG5cXHRcXHRcXHRcXHRtaXgoIG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwgXFxuXFx0XFx0XFx0XFx0XFx0XFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XHRmLnggKSxcXG5cXHRcXHRcXHRcXHRcXHQgbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksIFxcblxcdFxcdFxcdFxcdFxcdFxcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XHRmLnggKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi55IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9WU00gKVxcblxcdFxcdFxcdHNoYWRvdyA9IFZTTVNoYWRvdyggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0c2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gc2hhZG93O1xcblxcdH1cXG5cXHR2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7XFxuXFx0XFx0dmVjMyBhYnNWID0gYWJzKCB2ICk7XFxuXFx0XFx0ZmxvYXQgc2NhbGVUb0N1YmUgPSAxLjAgLyBtYXgoIGFic1YueCwgbWF4KCBhYnNWLnksIGFic1YueiApICk7XFxuXFx0XFx0YWJzViAqPSBzY2FsZVRvQ3ViZTtcXG5cXHRcXHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XFxuXFx0XFx0dmVjMiBwbGFuYXIgPSB2Lnh5O1xcblxcdFxcdGZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7XFxuXFx0XFx0ZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsO1xcblxcdFxcdGlmICggYWJzVi56ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRpZiAoIHYueiA+IDAuMCApXFxuXFx0XFx0XFx0XFx0cGxhbmFyLnggPSA0LjAgLSB2Lng7XFxuXFx0XFx0fSBlbHNlIGlmICggYWJzVi54ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApO1xcblxcdFxcdFxcdHBsYW5hci54ID0gdi56ICogc2lnblggKyAyLjAgKiBzaWduWDtcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnkgPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7XFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnggKyAyLjAgKiBzaWduWSArIDIuMDtcXG5cXHRcXHRcXHRwbGFuYXIueSA9IHYueiAqIHNpZ25ZIC0gMi4wO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdmVjMiggMC4xMjUsIDAuMjUgKSAqIHBsYW5hciArIHZlYzIoIDAuMzc1LCAwLjc1ICk7XFxuXFx0fVxcblxcdGZsb2F0IGdldFBvaW50U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCwgZmxvYXQgc2hhZG93Q2FtZXJhTmVhciwgZmxvYXQgc2hhZG93Q2FtZXJhRmFyICkge1xcblxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyAoIHNoYWRvd01hcFNpemUgKiB2ZWMyKCA0LjAsIDIuMCApICk7XFxuXFx0XFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSBzaGFkb3dDb29yZC54eXo7XFxuXFx0XFx0ZmxvYXQgZHAgPSAoIGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICkgLSBzaGFkb3dDYW1lcmFOZWFyICkgLyAoIHNoYWRvd0NhbWVyYUZhciAtIHNoYWRvd0NhbWVyYU5lYXIgKTtcXHRcXHRkcCArPSBzaGFkb3dCaWFzO1xcblxcdFxcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNIClcXG5cXHRcXHRcXHR2ZWMyIG9mZnNldCA9IHZlYzIoIC0gMSwgMSApICogc2hhZG93UmFkaXVzICogdGV4ZWxTaXplLnk7XFxuXFx0XFx0XFx0cmV0dXJuIChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHgsIHRleGVsU2l6ZS55ICksIGRwIClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcIjtcblxuXHR2YXIgc2hhZG93bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IHNwb3RTaGFkb3dNYXRyaXhbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlNwb3RTaGFkb3dDb29yZFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBTcG90TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93c1sgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgcG9pbnRTaGFkb3dNYXRyaXhbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFOZWFyO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYUZhcjtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gUG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93c1sgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgc2hhZG93bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMCB8fCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMCB8fCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR2ZWMzIHNoYWRvd1dvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHR2ZWM0IHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uICsgdmVjNCggc2hhZG93V29ybGROb3JtYWwgKiBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTtcXG5cXHRcXHR2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdID0gZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIHNwb3RMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzLCAwICk7XFxuXFx0XFx0dlNwb3RTaGFkb3dDb29yZFsgaSBdID0gc3BvdFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uICsgdmVjNCggc2hhZG93V29ybGROb3JtYWwgKiBwb2ludExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTtcXG5cXHRcXHR2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCA9IFwiZmxvYXQgZ2V0U2hhZG93TWFzaygpIHtcXG5cXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxuXFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodDtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0O1xcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNlbmRpZlxcblxcdHJldHVybiBzaGFkb3c7XFxufVwiO1xuXG5cdHZhciBza2luYmFzZV92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXG5cXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG5cXHRtYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTtcXG5cXHRtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgc2tpbm5pbmdfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxuXFx0I2lmZGVmIEJPTkVfVEVYVFVSRVxcblxcdFxcdHVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcblxcdFxcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlU2l6ZTtcXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXFx0XFx0XFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XFxuXFx0XFx0XFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XFxuXFx0XFx0XFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XFxuXFx0XFx0XFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcblxcdFxcdFxcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFx0XFx0fVxcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IGJvbmVNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFx0XFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdFxcdG1hdDQgYm9uZSA9IGJvbmVNYXRyaWNlc1sgaW50KGkpIF07XFxuXFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBza2lubmluZ192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xcblxcdHRyYW5zZm9ybWVkID0gKCBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQgKS54eXo7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHNraW5ub3JtYWxfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0bWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXG5cXHRza2luTWF0cml4ID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXHRvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHRvYmplY3RUYW5nZW50ID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdFRhbmdlbnQsIDAuMCApICkueHl6O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBzcGVjdWxhcm1hcF9mcmFnbWVudCA9IFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG4jZWxzZVxcblxcdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG4jZW5kaWZcIjtcblxuXHR2YXIgdG9uZW1hcHBpbmdfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBUT05FX01BUFBJTkcgKVxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSB0b25lTWFwcGluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50ID0gXCIjaWZuZGVmIHNhdHVyYXRlXFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNlbmRpZlxcbnVuaWZvcm0gZmxvYXQgdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG52ZWMzIExpbmVhclRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdHJldHVybiB0b25lTWFwcGluZ0V4cG9zdXJlICogY29sb3I7XFxufVxcbnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcblxcdHJldHVybiBzYXR1cmF0ZSggY29sb3IgLyAoIHZlYzMoIDEuMCApICsgY29sb3IgKSApO1xcbn1cXG52ZWMzIE9wdGltaXplZENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuXFx0Y29sb3IgPSBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciAtIDAuMDA0ICk7XFxuXFx0cmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTtcXG59XFxudmVjMyBSUlRBbmRPRFRGaXQoIHZlYzMgdiApIHtcXG5cXHR2ZWMzIGEgPSB2ICogKCB2ICsgMC4wMjQ1Nzg2ICkgLSAwLjAwMDA5MDUzNztcXG5cXHR2ZWMzIGIgPSB2ICogKCAwLjk4MzcyOSAqIHYgKyAwLjQzMjk1MTAgKSArIDAuMjM4MDgxO1xcblxcdHJldHVybiBhIC8gYjtcXG59XFxudmVjMyBBQ0VTRmlsbWljVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29uc3QgbWF0MyBBQ0VTSW5wdXRNYXQgPSBtYXQzKFxcblxcdFxcdHZlYzMoIDAuNTk3MTksIDAuMDc2MDAsIDAuMDI4NDAgKSxcXHRcXHR2ZWMzKCAwLjM1NDU4LCAwLjkwODM0LCAwLjEzMzgzICksXFxuXFx0XFx0dmVjMyggMC4wNDgyMywgMC4wMTU2NiwgMC44Mzc3NyApXFxuXFx0KTtcXG5cXHRjb25zdCBtYXQzIEFDRVNPdXRwdXRNYXQgPSBtYXQzKFxcblxcdFxcdHZlYzMoXHQxLjYwNDc1LCAtMC4xMDIwOCwgLTAuMDAzMjcgKSxcXHRcXHR2ZWMzKCAtMC41MzEwOCxcdDEuMTA4MTMsIC0wLjA3Mjc2ICksXFxuXFx0XFx0dmVjMyggLTAuMDczNjcsIC0wLjAwNjA1LFx0MS4wNzYwMiApXFxuXFx0KTtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlIC8gMC42O1xcblxcdGNvbG9yID0gQUNFU0lucHV0TWF0ICogY29sb3I7XFxuXFx0Y29sb3IgPSBSUlRBbmRPRFRGaXQoIGNvbG9yICk7XFxuXFx0Y29sb3IgPSBBQ0VTT3V0cHV0TWF0ICogY29sb3I7XFxuXFx0cmV0dXJuIHNhdHVyYXRlKCBjb2xvciApO1xcbn1cXG52ZWMzIEN1c3RvbVRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gY29sb3I7IH1cIjtcblxuXHR2YXIgdHJhbnNtaXNzaW9uX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTlxcblxcdGZsb2F0IHRyYW5zbWlzc2lvbkZhY3RvciA9IHRyYW5zbWlzc2lvbjtcXG5cXHRmbG9hdCB0aGlja25lc3NGYWN0b3IgPSB0aGlja25lc3M7XFxuXFx0I2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcXG5cXHRcXHR0cmFuc21pc3Npb25GYWN0b3IgKj0gdGV4dHVyZTJEKCB0cmFuc21pc3Npb25NYXAsIHZVdiApLnI7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9USElDS05FU1NNQVBcXG5cXHRcXHR0aGlja25lc3NGYWN0b3IgKj0gdGV4dHVyZTJEKCB0aGlja25lc3NNYXAsIHZVdiApLmc7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMyBwb3MgPSB2V29ybGRQb3NpdGlvbi54eXogLyB2V29ybGRQb3NpdGlvbi53O1xcblxcdHZlYzMgdiA9IG5vcm1hbGl6ZSggY2FtZXJhUG9zaXRpb24gLSBwb3MgKTtcXG5cXHR2ZWMzIG4gPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRmbG9hdCBpb3IgPSAoIDEuMCArIDAuNCAqIHJlZmxlY3Rpdml0eSApIC8gKCAxLjAgLSAwLjQgKiByZWZsZWN0aXZpdHkgKTtcXG5cXHR2ZWMzIHRyYW5zbWlzc2lvbiA9IHRyYW5zbWlzc2lvbkZhY3RvciAqIGdldElCTFZvbHVtZVJlZnJhY3Rpb24oXFxuXFx0XFx0biwgdiwgcm91Z2huZXNzRmFjdG9yLCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsXFxuXFx0XFx0cG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgaW9yLCB0aGlja25lc3NGYWN0b3IsXFxuXFx0XFx0YXR0ZW51YXRpb25UaW50LCBhdHRlbnVhdGlvbkRpc3RhbmNlICk7XFxuXFx0dG90YWxEaWZmdXNlID0gbWl4KCB0b3RhbERpZmZ1c2UsIHRyYW5zbWlzc2lvbiwgdHJhbnNtaXNzaW9uRmFjdG9yICk7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTlxcblxcdCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgdHJhbnNtaXNzaW9uTWFwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgdGhpY2tuZXNzTWFwO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gdmVjMiB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZTtcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25TYW1wbGVyTWFwO1xcblxcdHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcXG5cXHR1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcXG5cXHR2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XFxuXFx0dmVjMyBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkodmVjMyBuLCB2ZWMzIHYsIGZsb2F0IHRoaWNrbmVzcywgZmxvYXQgaW9yLCBtYXQ0IG1vZGVsTWF0cml4KSB7XFxuXFx0XFx0dmVjMyByZWZyYWN0aW9uVmVjdG9yID0gcmVmcmFjdCgtdiwgbm9ybWFsaXplKG4pLCAxLjAgLyBpb3IpO1xcblxcdFxcdHZlYzMgbW9kZWxTY2FsZTtcXG5cXHRcXHRtb2RlbFNjYWxlLnggPSBsZW5ndGgodmVjMyhtb2RlbE1hdHJpeFswXS54eXopKTtcXG5cXHRcXHRtb2RlbFNjYWxlLnkgPSBsZW5ndGgodmVjMyhtb2RlbE1hdHJpeFsxXS54eXopKTtcXG5cXHRcXHRtb2RlbFNjYWxlLnogPSBsZW5ndGgodmVjMyhtb2RlbE1hdHJpeFsyXS54eXopKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKHJlZnJhY3Rpb25WZWN0b3IpICogdGhpY2tuZXNzICogbW9kZWxTY2FsZTtcXG5cXHR9XFxuXFx0ZmxvYXQgYXBwbHlJb3JUb1JvdWdobmVzcyhmbG9hdCByb3VnaG5lc3MsIGZsb2F0IGlvcikge1xcblxcdFxcdHJldHVybiByb3VnaG5lc3MgKiBjbGFtcChpb3IgKiAyLjAgLSAyLjAsIDAuMCwgMS4wKTtcXG5cXHR9XFxuXFx0dmVjMyBnZXRUcmFuc21pc3Npb25TYW1wbGUodmVjMiBmcmFnQ29vcmQsIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgaW9yKSB7XFxuXFx0XFx0ZmxvYXQgZnJhbWVidWZmZXJMb2QgPSBsb2cyKHRyYW5zbWlzc2lvblNhbXBsZXJTaXplLngpICogYXBwbHlJb3JUb1JvdWdobmVzcyhyb3VnaG5lc3MsIGlvcik7XFxuXFx0XFx0cmV0dXJuIHRleHR1cmUyRExvZEVYVCh0cmFuc21pc3Npb25TYW1wbGVyTWFwLCBmcmFnQ29vcmQueHksIGZyYW1lYnVmZmVyTG9kKS5yZ2I7XFxuXFx0fVxcblxcdHZlYzMgYXBwbHlWb2x1bWVBdHRlbnVhdGlvbih2ZWMzIHJhZGlhbmNlLCBmbG9hdCB0cmFuc21pc3Npb25EaXN0YW5jZSwgdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlKSB7XFxuXFx0XFx0aWYgKGF0dGVudWF0aW9uRGlzdGFuY2UgPT0gMC4wKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJhZGlhbmNlO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dmVjMyBhdHRlbnVhdGlvbkNvZWZmaWNpZW50ID0gLWxvZyhhdHRlbnVhdGlvbkNvbG9yKSAvIGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuXFx0XFx0XFx0dmVjMyB0cmFuc21pdHRhbmNlID0gZXhwKC1hdHRlbnVhdGlvbkNvZWZmaWNpZW50ICogdHJhbnNtaXNzaW9uRGlzdGFuY2UpO1xcdFxcdFxcdHJldHVybiB0cmFuc21pdHRhbmNlICogcmFkaWFuY2U7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHR2ZWMzIGdldElCTFZvbHVtZVJlZnJhY3Rpb24odmVjMyBuLCB2ZWMzIHYsIGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3MsIHZlYzMgYmFzZUNvbG9yLCB2ZWMzIHNwZWN1bGFyQ29sb3IsXFxuXFx0XFx0dmVjMyBwb3NpdGlvbiwgbWF0NCBtb2RlbE1hdHJpeCwgbWF0NCB2aWV3TWF0cml4LCBtYXQ0IHByb2pNYXRyaXgsIGZsb2F0IGlvciwgZmxvYXQgdGhpY2tuZXNzLFxcblxcdFxcdHZlYzMgYXR0ZW51YXRpb25Db2xvciwgZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSkge1xcblxcdFxcdHZlYzMgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KG4sIHYsIHRoaWNrbmVzcywgaW9yLCBtb2RlbE1hdHJpeCk7XFxuXFx0XFx0dmVjMyByZWZyYWN0ZWRSYXlFeGl0ID0gcG9zaXRpb24gKyB0cmFuc21pc3Npb25SYXk7XFxuXFx0XFx0dmVjNCBuZGNQb3MgPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIHZlYzQocmVmcmFjdGVkUmF5RXhpdCwgMS4wKTtcXG5cXHRcXHR2ZWMyIHJlZnJhY3Rpb25Db29yZHMgPSBuZGNQb3MueHkgLyBuZGNQb3MudztcXG5cXHRcXHRyZWZyYWN0aW9uQ29vcmRzICs9IDEuMDtcXG5cXHRcXHRyZWZyYWN0aW9uQ29vcmRzIC89IDIuMDtcXG5cXHRcXHR2ZWMzIHRyYW5zbWl0dGVkTGlnaHQgPSBnZXRUcmFuc21pc3Npb25TYW1wbGUocmVmcmFjdGlvbkNvb3JkcywgcGVyY2VwdHVhbFJvdWdobmVzcywgaW9yKTtcXG5cXHRcXHR2ZWMzIGF0dGVudWF0ZWRDb2xvciA9IGFwcGx5Vm9sdW1lQXR0ZW51YXRpb24odHJhbnNtaXR0ZWRMaWdodCwgbGVuZ3RoKHRyYW5zbWlzc2lvblJheSksIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UpO1xcblxcdFxcdHJldHVybiAoMS4wIC0gc3BlY3VsYXJDb2xvcikgKiBhdHRlbnVhdGVkQ29sb3IgKiBiYXNlQ29sb3I7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG5cdHZhciB1dl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgKCBkZWZpbmVkKCBVU0VfVVYgKSAmJiAhIGRlZmluZWQoIFVWU19WRVJURVhfT05MWSApIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlwiO1xuXG5cdHZhciB1dl9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9VVlxcblxcdCNpZmRlZiBVVlNfVkVSVEVYX09OTFlcXG5cXHRcXHR2ZWMyIHZVdjtcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbiNlbmRpZlwiO1xuXG5cdHZhciB1dl92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfVVZcXG5cXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcbiNlbmRpZlwiO1xuXG5cdHZhciB1djJfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHV2Ml9wYXJzX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0YXR0cmlidXRlIHZlYzIgdXYyO1xcblxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcblxcdHVuaWZvcm0gbWF0MyB1djJUcmFuc2Zvcm07XFxuI2VuZGlmXCI7XG5cblx0dmFyIHV2Ml92ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdHZVdjIgPSAoIHV2MlRyYW5zZm9ybSAqIHZlYzMoIHV2MiwgMSApICkueHk7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHdvcmxkcG9zX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBESVNUQU5DRSApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9UUkFOU01JU1NJT04gKVxcblxcdHZlYzQgd29ybGRQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXHQjaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXHRcXHR3b3JsZFBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xcblxcdCNlbmRpZlxcblxcdHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHdvcmxkUG9zaXRpb247XFxuI2VuZGlmXCI7XG5cblx0dmFyIGJhY2tncm91bmRfZnJhZyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdDJEO1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQoIHQyRCwgdlV2ICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gbWFwVGV4ZWxUb0xpbmVhciggdGV4Q29sb3IgKTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG59XCI7XG5cblx0dmFyIGJhY2tncm91bmRfdmVydCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXG51bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07XFxudm9pZCBtYWluKCkge1xcblxcdHZVdiA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCB1diwgMSApICkueHk7XFxuXFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbi54eSwgMS4wLCAxLjAgKTtcXG59XCI7XG5cblx0dmFyIGN1YmVfZnJhZyA9IFwiI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIHZSZWZsZWN0ID0gdldvcmxkRGlyZWN0aW9uO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gZW52Q29sb3I7XFxuXFx0Z2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG59XCI7XG5cblx0dmFyIGN1YmVfdmVydCA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdGdsX1Bvc2l0aW9uLnogPSBnbF9Qb3NpdGlvbi53O1xcbn1cIjtcblxuXHR2YXIgZGVwdGhfZnJhZyA9IFwiI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdGZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggMS4wIC0gZnJhZ0Nvb3JkWiApLCBvcGFjaXR5ICk7XFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBmcmFnQ29vcmRaICk7XFxuXFx0I2VuZGlmXFxufVwiO1xuXG5cdHZhciBkZXB0aF92ZXJ0ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dkhpZ2hQcmVjaXNpb25aVyA9IGdsX1Bvc2l0aW9uLnp3O1xcbn1cIjtcblxuXHR2YXIgZGlzdGFuY2VSR0JBX2ZyYWcgPSBcIiNkZWZpbmUgRElTVEFOQ0VcXG51bmlmb3JtIHZlYzMgcmVmZXJlbmNlUG9zaXRpb247XFxudW5pZm9ybSBmbG9hdCBuZWFyRGlzdGFuY2U7XFxudW5pZm9ybSBmbG9hdCBmYXJEaXN0YW5jZTtcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbiAoKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApO1xcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0ZmxvYXQgZGlzdCA9IGxlbmd0aCggdldvcmxkUG9zaXRpb24gLSByZWZlcmVuY2VQb3NpdGlvbiApO1xcblxcdGRpc3QgPSAoIGRpc3QgLSBuZWFyRGlzdGFuY2UgKSAvICggZmFyRGlzdGFuY2UgLSBuZWFyRGlzdGFuY2UgKTtcXG5cXHRkaXN0ID0gc2F0dXJhdGUoIGRpc3QgKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGRpc3QgKTtcXG59XCI7XG5cblx0dmFyIGRpc3RhbmNlUkdCQV92ZXJ0ID0gXCIjZGVmaW5lIERJU1RBTkNFXFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxufVwiO1xuXG5cdHZhciBlcXVpcmVjdF9mcmFnID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkRGlyZWN0aW9uICk7XFxuXFx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xcblxcdHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSBtYXBUZXhlbFRvTGluZWFyKCB0ZXhDb2xvciApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50Plxcbn1cIjtcblxuXHR2YXIgZXF1aXJlY3RfdmVydCA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4Plxcbn1cIjtcblxuXHR2YXIgbGluZWRhc2hlZF9mcmFnID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcXG51bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcXG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1xcblxcdFxcdGRpc2NhcmQ7XFxuXFx0fVxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50Plxcbn1cIjtcblxuXHR2YXIgbGluZWRhc2hlZF92ZXJ0ID0gXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1xcbmF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuXG5cdHZhciBtZXNoYmFzaWNfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdFxcblxcdFxcdHZlYzQgbGlnaHRNYXBUZXhlbD0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBsaWdodE1hcFRleGVsVG9MaW5lYXIoIGxpZ2h0TWFwVGV4ZWwgKS5yZ2IgKiBsaWdodE1hcEludGVuc2l0eTtcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB2ZWMzKCAxLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5cdHZhciBtZXNoYmFzaWNfdmVydCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaWYgZGVmaW5lZCAoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkICggVVNFX1NLSU5OSU5HIClcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuXG5cdHZhciBtZXNobGFtYmVydF9mcmFnID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG52YXJ5aW5nIHZlYzMgdkluZGlyZWN0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcblxcdHZhcnlpbmcgdmVjMyB2SW5kaXJlY3RCYWNrO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gKCBnbF9Gcm9udEZhY2luZyApID8gdkluZGlyZWN0RnJvbnQgOiB2SW5kaXJlY3RCYWNrO1xcblxcdCNlbHNlXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHZJbmRpcmVjdEZyb250O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxsaWdodG1hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKTtcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgPSB2TGlnaHRGcm9udDtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICo9IEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICkgKiBnZXRTaGFkb3dNYXNrKCk7XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG5cblx0dmFyIG1lc2hsYW1iZXJ0X3ZlcnQgPSBcIiNkZWZpbmUgTEFNQkVSVFxcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG52YXJ5aW5nIHZlYzMgdkluZGlyZWN0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcblxcdHZhcnlpbmcgdmVjMyB2SW5kaXJlY3RCYWNrO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuXHR2YXIgbWVzaG1hdGNhcF9mcmFnID0gXCIjZGVmaW5lIE1BVENBUFxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXRjYXA7XFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdHZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdkJpdGFuZ2VudDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0dmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuXFx0dmVjMyB4ID0gbm9ybWFsaXplKCB2ZWMzKCB2aWV3RGlyLnosIDAuMCwgLSB2aWV3RGlyLnggKSApO1xcblxcdHZlYzMgeSA9IGNyb3NzKCB2aWV3RGlyLCB4ICk7XFxuXFx0dmVjMiB1diA9IHZlYzIoIGRvdCggeCwgbm9ybWFsICksIGRvdCggeSwgbm9ybWFsICkgKSAqIDAuNDk1ICsgMC41O1xcblxcdCNpZmRlZiBVU0VfTUFUQ0FQXFxuXFx0XFx0dmVjNCBtYXRjYXBDb2xvciA9IHRleHR1cmUyRCggbWF0Y2FwLCB1diApO1xcblxcdFxcdG1hdGNhcENvbG9yID0gbWF0Y2FwVGV4ZWxUb0xpbmVhciggbWF0Y2FwQ29sb3IgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzQgbWF0Y2FwQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiICogbWF0Y2FwQ29sb3IucmdiO1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuXHR2YXIgbWVzaG1hdGNhcF92ZXJ0ID0gXCIjZGVmaW5lIE1BVENBUFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0XFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5cXHRcXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHRcXHR2VGFuZ2VudCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWRUYW5nZW50ICk7XFxuXFx0XFx0XFx0dkJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG59XCI7XG5cblx0dmFyIG1lc2h0b29uX2ZyYWcgPSBcIiNkZWZpbmUgVE9PTlxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfdG9vbl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG5cblx0dmFyIG1lc2h0b29uX3ZlcnQgPSBcIiNkZWZpbmUgVE9PTlxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG4jZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuXHR2YXIgbWVzaHBob25nX2ZyYWcgPSBcIiNkZWZpbmUgUEhPTkdcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1xcbnVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG5cblx0dmFyIG1lc2hwaG9uZ192ZXJ0ID0gXCIjZGVmaW5lIFBIT05HXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuI2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cblx0dmFyIG1lc2hwaHlzaWNhbF9mcmFnID0gXCIjZGVmaW5lIFNUQU5EQVJEXFxuI2lmZGVmIFBIWVNJQ0FMXFxuXFx0I2RlZmluZSBSRUZMRUNUSVZJVFlcXG5cXHQjZGVmaW5lIENMRUFSQ09BVFxcblxcdCNkZWZpbmUgU1BFQ1VMQVJcXG4jZW5kaWZcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7XFxudW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0dW5pZm9ybSBmbG9hdCB0cmFuc21pc3Npb247XFxuXFx0dW5pZm9ybSBmbG9hdCB0aGlja25lc3M7XFxuXFx0dW5pZm9ybSBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlO1xcblxcdHVuaWZvcm0gdmVjMyBhdHRlbnVhdGlvblRpbnQ7XFxuI2VuZGlmXFxuI2lmZGVmIFJFRkxFQ1RJVklUWVxcblxcdHVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1xcbiNlbmRpZlxcbiNpZmRlZiBTUEVDVUxBUlxcblxcdHVuaWZvcm0gZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHk7XFxuXFx0dW5pZm9ybSB2ZWMzIHNwZWN1bGFyVGludDtcXG5cXHQjaWZkZWYgVVNFX1NQRUNVTEFSSU5URU5TSVRZTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJJbnRlbnNpdHlNYXA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TUEVDVUxBUlRJTlRNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhclRpbnRNYXA7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIENMRUFSQ09BVFxcblxcdHVuaWZvcm0gZmxvYXQgY2xlYXJjb2F0O1xcblxcdHVuaWZvcm0gZmxvYXQgY2xlYXJjb2F0Um91Z2huZXNzO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5cXG5cXHR1bmlmb3JtIHZlYzMgc2hlZW47XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdHZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdkJpdGFuZ2VudDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8dHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgdG90YWxEaWZmdXNlID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIHRvdGFsU3BlY3VsYXIgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXI7XFxuXFx0I2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB0b3RhbERpZmZ1c2UgKyB0b3RhbFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuXHR2YXIgbWVzaHBoeXNpY2FsX3ZlcnQgPSBcIiNkZWZpbmUgU1RBTkRBUkRcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0dmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdHZUYW5nZW50ID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZFRhbmdlbnQgKTtcXG5cXHRcXHR2Qml0YW5nZW50ID0gbm9ybWFsaXplKCBjcm9zcyggdk5vcm1hbCwgdlRhbmdlbnQgKSAqIHRhbmdlbnQudyApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XFxuI2VuZGlmXFxufVwiO1xuXG5cdHZhciBub3JtYWxfZnJhZyA9IFwiI2RlZmluZSBOT1JNQUxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja05vcm1hbFRvUkdCKCBub3JtYWwgKSwgb3BhY2l0eSApO1xcbn1cIjtcblxuXHR2YXIgbm9ybWFsX3ZlcnQgPSBcIiNkZWZpbmUgTk9STUFMXFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdHZUYW5nZW50ID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZFRhbmdlbnQgKTtcXG5cXHRcXHR2Qml0YW5nZW50ID0gbm9ybWFsaXplKCBjcm9zcyggdk5vcm1hbCwgdlRhbmdlbnQgKSAqIHRhbmdlbnQudyApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVEFOR0VOVFNQQUNFX05PUk1BTE1BUCApXFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXFxufVwiO1xuXG5cdHZhciBwb2ludHNfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfcGFydGljbGVfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50Plxcbn1cIjtcblxuXHR2YXIgcG9pbnRzX3ZlcnQgPSBcInVuaWZvcm0gZmxvYXQgc2l6ZTtcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcXG5cXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxcblxcdFxcdGJvb2wgaXNQZXJzcGVjdGl2ZSA9IGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKTtcXG5cXHRcXHRpZiAoIGlzUGVyc3BlY3RpdmUgKSBnbF9Qb2ludFNpemUgKj0gKCBzY2FsZSAvIC0gbXZQb3NpdGlvbi56ICk7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuXHR2YXIgc2hhZG93X2ZyYWcgPSBcInVuaWZvcm0gdmVjMyBjb2xvcjtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IsIG9wYWNpdHkgKiAoIDEuMCAtIGdldFNoYWRvd01hc2soKSApICk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XCI7XG5cblx0dmFyIHNoYWRvd192ZXJ0ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuXHR2YXIgc3ByaXRlX2ZyYWcgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XCI7XG5cblx0dmFyIHNwcml0ZV92ZXJ0ID0gXCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1xcbnVuaWZvcm0gdmVjMiBjZW50ZXI7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG5cXHR2ZWMyIHNjYWxlO1xcblxcdHNjYWxlLnggPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAwIF0ueCwgbW9kZWxNYXRyaXhbIDAgXS55LCBtb2RlbE1hdHJpeFsgMCBdLnogKSApO1xcblxcdHNjYWxlLnkgPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAxIF0ueCwgbW9kZWxNYXRyaXhbIDEgXS55LCBtb2RlbE1hdHJpeFsgMSBdLnogKSApO1xcblxcdCNpZm5kZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxcblxcdFxcdGJvb2wgaXNQZXJzcGVjdGl2ZSA9IGlzUGVyc3BlY3RpdmVNYXRyaXgoIHByb2plY3Rpb25NYXRyaXggKTtcXG5cXHRcXHRpZiAoIGlzUGVyc3BlY3RpdmUgKSBzY2FsZSAqPSAtIG12UG9zaXRpb24uejtcXG5cXHQjZW5kaWZcXG5cXHR2ZWMyIGFsaWduZWRQb3NpdGlvbiA9ICggcG9zaXRpb24ueHkgLSAoIGNlbnRlciAtIHZlYzIoIDAuNSApICkgKSAqIHNjYWxlO1xcblxcdHZlYzIgcm90YXRlZFBvc2l0aW9uO1xcblxcdHJvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcXG5cXHRyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XFxuXFx0bXZQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblxuXHRjb25zdCBTaGFkZXJDaHVuayA9IHtcblx0XHRhbHBoYW1hcF9mcmFnbWVudDogYWxwaGFtYXBfZnJhZ21lbnQsXG5cdFx0YWxwaGFtYXBfcGFyc19mcmFnbWVudDogYWxwaGFtYXBfcGFyc19mcmFnbWVudCxcblx0XHRhbHBoYXRlc3RfZnJhZ21lbnQ6IGFscGhhdGVzdF9mcmFnbWVudCxcblx0XHRhb21hcF9mcmFnbWVudDogYW9tYXBfZnJhZ21lbnQsXG5cdFx0YW9tYXBfcGFyc19mcmFnbWVudDogYW9tYXBfcGFyc19mcmFnbWVudCxcblx0XHRiZWdpbl92ZXJ0ZXg6IGJlZ2luX3ZlcnRleCxcblx0XHRiZWdpbm5vcm1hbF92ZXJ0ZXg6IGJlZ2lubm9ybWFsX3ZlcnRleCxcblx0XHRic2RmczogYnNkZnMsXG5cdFx0YnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBidW1wbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQsXG5cdFx0Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ6IGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50LFxuXHRcdGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4LFxuXHRcdGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXgsXG5cdFx0Y29sb3JfZnJhZ21lbnQ6IGNvbG9yX2ZyYWdtZW50LFxuXHRcdGNvbG9yX3BhcnNfZnJhZ21lbnQ6IGNvbG9yX3BhcnNfZnJhZ21lbnQsXG5cdFx0Y29sb3JfcGFyc192ZXJ0ZXg6IGNvbG9yX3BhcnNfdmVydGV4LFxuXHRcdGNvbG9yX3ZlcnRleDogY29sb3JfdmVydGV4LFxuXHRcdGNvbW1vbjogY29tbW9uLFxuXHRcdGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudDogY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50LFxuXHRcdGRlZmF1bHRub3JtYWxfdmVydGV4OiBkZWZhdWx0bm9ybWFsX3ZlcnRleCxcblx0XHRkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCxcblx0XHRkaXNwbGFjZW1lbnRtYXBfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfdmVydGV4LFxuXHRcdGVtaXNzaXZlbWFwX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9mcmFnbWVudCxcblx0XHRlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdGVuY29kaW5nc19mcmFnbWVudDogZW5jb2RpbmdzX2ZyYWdtZW50LFxuXHRcdGVuY29kaW5nc19wYXJzX2ZyYWdtZW50OiBlbmNvZGluZ3NfcGFyc19mcmFnbWVudCxcblx0XHRlbnZtYXBfZnJhZ21lbnQ6IGVudm1hcF9mcmFnbWVudCxcblx0XHRlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ6IGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudCxcblx0XHRlbnZtYXBfcGFyc19mcmFnbWVudDogZW52bWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0ZW52bWFwX3BhcnNfdmVydGV4OiBlbnZtYXBfcGFyc192ZXJ0ZXgsXG5cdFx0ZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxuXHRcdGVudm1hcF92ZXJ0ZXg6IGVudm1hcF92ZXJ0ZXgsXG5cdFx0Zm9nX3ZlcnRleDogZm9nX3ZlcnRleCxcblx0XHRmb2dfcGFyc192ZXJ0ZXg6IGZvZ19wYXJzX3ZlcnRleCxcblx0XHRmb2dfZnJhZ21lbnQ6IGZvZ19mcmFnbWVudCxcblx0XHRmb2dfcGFyc19mcmFnbWVudDogZm9nX3BhcnNfZnJhZ21lbnQsXG5cdFx0Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudDogZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCxcblx0XHRsaWdodG1hcF9mcmFnbWVudDogbGlnaHRtYXBfZnJhZ21lbnQsXG5cdFx0bGlnaHRtYXBfcGFyc19mcmFnbWVudDogbGlnaHRtYXBfcGFyc19mcmFnbWVudCxcblx0XHRsaWdodHNfbGFtYmVydF92ZXJ0ZXg6IGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCxcblx0XHRsaWdodHNfcGFyc19iZWdpbjogbGlnaHRzX3BhcnNfYmVnaW4sXG5cdFx0bGlnaHRzX3Rvb25fZnJhZ21lbnQ6IGxpZ2h0c190b29uX2ZyYWdtZW50LFxuXHRcdGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQsXG5cdFx0bGlnaHRzX3Bob25nX2ZyYWdtZW50OiBsaWdodHNfcGhvbmdfZnJhZ21lbnQsXG5cdFx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxuXHRcdGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudDogbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50LFxuXHRcdGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50OiBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCxcblx0XHRsaWdodHNfZnJhZ21lbnRfYmVnaW46IGxpZ2h0c19mcmFnbWVudF9iZWdpbixcblx0XHRsaWdodHNfZnJhZ21lbnRfbWFwczogbGlnaHRzX2ZyYWdtZW50X21hcHMsXG5cdFx0bGlnaHRzX2ZyYWdtZW50X2VuZDogbGlnaHRzX2ZyYWdtZW50X2VuZCxcblx0XHRsb2dkZXB0aGJ1Zl9mcmFnbWVudDogbG9nZGVwdGhidWZfZnJhZ21lbnQsXG5cdFx0bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudDogbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCxcblx0XHRsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDogbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXG5cdFx0bG9nZGVwdGhidWZfdmVydGV4OiBsb2dkZXB0aGJ1Zl92ZXJ0ZXgsXG5cdFx0bWFwX2ZyYWdtZW50OiBtYXBfZnJhZ21lbnQsXG5cdFx0bWFwX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdG1hcF9wYXJ0aWNsZV9mcmFnbWVudDogbWFwX3BhcnRpY2xlX2ZyYWdtZW50LFxuXHRcdG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OiBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCxcblx0XHRtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9mcmFnbWVudCxcblx0XHRtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0bW9ycGhub3JtYWxfdmVydGV4OiBtb3JwaG5vcm1hbF92ZXJ0ZXgsXG5cdFx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxuXHRcdG1vcnBodGFyZ2V0X3ZlcnRleDogbW9ycGh0YXJnZXRfdmVydGV4LFxuXHRcdG5vcm1hbF9mcmFnbWVudF9iZWdpbjogbm9ybWFsX2ZyYWdtZW50X2JlZ2luLFxuXHRcdG5vcm1hbF9mcmFnbWVudF9tYXBzOiBub3JtYWxfZnJhZ21lbnRfbWFwcyxcblx0XHRub3JtYWxtYXBfcGFyc19mcmFnbWVudDogbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbjogY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbixcblx0XHRjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM6IGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcyxcblx0XHRjbGVhcmNvYXRfcGFyc19mcmFnbWVudDogY2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQsXG5cdFx0cGFja2luZzogcGFja2luZyxcblx0XHRwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50OiBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50LFxuXHRcdHByb2plY3RfdmVydGV4OiBwcm9qZWN0X3ZlcnRleCxcblx0XHRkaXRoZXJpbmdfZnJhZ21lbnQ6IGRpdGhlcmluZ19mcmFnbWVudCxcblx0XHRkaXRoZXJpbmdfcGFyc19mcmFnbWVudDogZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQsXG5cdFx0cm91Z2huZXNzbWFwX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfZnJhZ21lbnQsXG5cdFx0cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCxcblx0XHRzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6IHNoYWRvd21hcF9wYXJzX3ZlcnRleCxcblx0XHRzaGFkb3dtYXBfdmVydGV4OiBzaGFkb3dtYXBfdmVydGV4LFxuXHRcdHNoYWRvd21hc2tfcGFyc19mcmFnbWVudDogc2hhZG93bWFza19wYXJzX2ZyYWdtZW50LFxuXHRcdHNraW5iYXNlX3ZlcnRleDogc2tpbmJhc2VfdmVydGV4LFxuXHRcdHNraW5uaW5nX3BhcnNfdmVydGV4OiBza2lubmluZ19wYXJzX3ZlcnRleCxcblx0XHRza2lubmluZ192ZXJ0ZXg6IHNraW5uaW5nX3ZlcnRleCxcblx0XHRza2lubm9ybWFsX3ZlcnRleDogc2tpbm5vcm1hbF92ZXJ0ZXgsXG5cdFx0c3BlY3VsYXJtYXBfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX2ZyYWdtZW50LFxuXHRcdHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0dG9uZW1hcHBpbmdfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX2ZyYWdtZW50LFxuXHRcdHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQsXG5cdFx0dHJhbnNtaXNzaW9uX2ZyYWdtZW50OiB0cmFuc21pc3Npb25fZnJhZ21lbnQsXG5cdFx0dHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQ6IHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50LFxuXHRcdHV2X3BhcnNfZnJhZ21lbnQ6IHV2X3BhcnNfZnJhZ21lbnQsXG5cdFx0dXZfcGFyc192ZXJ0ZXg6IHV2X3BhcnNfdmVydGV4LFxuXHRcdHV2X3ZlcnRleDogdXZfdmVydGV4LFxuXHRcdHV2Ml9wYXJzX2ZyYWdtZW50OiB1djJfcGFyc19mcmFnbWVudCxcblx0XHR1djJfcGFyc192ZXJ0ZXg6IHV2Ml9wYXJzX3ZlcnRleCxcblx0XHR1djJfdmVydGV4OiB1djJfdmVydGV4LFxuXHRcdHdvcmxkcG9zX3ZlcnRleDogd29ybGRwb3NfdmVydGV4LFxuXHRcdGJhY2tncm91bmRfZnJhZzogYmFja2dyb3VuZF9mcmFnLFxuXHRcdGJhY2tncm91bmRfdmVydDogYmFja2dyb3VuZF92ZXJ0LFxuXHRcdGN1YmVfZnJhZzogY3ViZV9mcmFnLFxuXHRcdGN1YmVfdmVydDogY3ViZV92ZXJ0LFxuXHRcdGRlcHRoX2ZyYWc6IGRlcHRoX2ZyYWcsXG5cdFx0ZGVwdGhfdmVydDogZGVwdGhfdmVydCxcblx0XHRkaXN0YW5jZVJHQkFfZnJhZzogZGlzdGFuY2VSR0JBX2ZyYWcsXG5cdFx0ZGlzdGFuY2VSR0JBX3ZlcnQ6IGRpc3RhbmNlUkdCQV92ZXJ0LFxuXHRcdGVxdWlyZWN0X2ZyYWc6IGVxdWlyZWN0X2ZyYWcsXG5cdFx0ZXF1aXJlY3RfdmVydDogZXF1aXJlY3RfdmVydCxcblx0XHRsaW5lZGFzaGVkX2ZyYWc6IGxpbmVkYXNoZWRfZnJhZyxcblx0XHRsaW5lZGFzaGVkX3ZlcnQ6IGxpbmVkYXNoZWRfdmVydCxcblx0XHRtZXNoYmFzaWNfZnJhZzogbWVzaGJhc2ljX2ZyYWcsXG5cdFx0bWVzaGJhc2ljX3ZlcnQ6IG1lc2hiYXNpY192ZXJ0LFxuXHRcdG1lc2hsYW1iZXJ0X2ZyYWc6IG1lc2hsYW1iZXJ0X2ZyYWcsXG5cdFx0bWVzaGxhbWJlcnRfdmVydDogbWVzaGxhbWJlcnRfdmVydCxcblx0XHRtZXNobWF0Y2FwX2ZyYWc6IG1lc2htYXRjYXBfZnJhZyxcblx0XHRtZXNobWF0Y2FwX3ZlcnQ6IG1lc2htYXRjYXBfdmVydCxcblx0XHRtZXNodG9vbl9mcmFnOiBtZXNodG9vbl9mcmFnLFxuXHRcdG1lc2h0b29uX3ZlcnQ6IG1lc2h0b29uX3ZlcnQsXG5cdFx0bWVzaHBob25nX2ZyYWc6IG1lc2hwaG9uZ19mcmFnLFxuXHRcdG1lc2hwaG9uZ192ZXJ0OiBtZXNocGhvbmdfdmVydCxcblx0XHRtZXNocGh5c2ljYWxfZnJhZzogbWVzaHBoeXNpY2FsX2ZyYWcsXG5cdFx0bWVzaHBoeXNpY2FsX3ZlcnQ6IG1lc2hwaHlzaWNhbF92ZXJ0LFxuXHRcdG5vcm1hbF9mcmFnOiBub3JtYWxfZnJhZyxcblx0XHRub3JtYWxfdmVydDogbm9ybWFsX3ZlcnQsXG5cdFx0cG9pbnRzX2ZyYWc6IHBvaW50c19mcmFnLFxuXHRcdHBvaW50c192ZXJ0OiBwb2ludHNfdmVydCxcblx0XHRzaGFkb3dfZnJhZzogc2hhZG93X2ZyYWcsXG5cdFx0c2hhZG93X3ZlcnQ6IHNoYWRvd192ZXJ0LFxuXHRcdHNwcml0ZV9mcmFnOiBzcHJpdGVfZnJhZyxcblx0XHRzcHJpdGVfdmVydDogc3ByaXRlX3ZlcnRcblx0fTtcblxuXHQvKipcblx0ICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcblx0ICovXG5cblx0Y29uc3QgVW5pZm9ybXNMaWIgPSB7XG5cdFx0Y29tbW9uOiB7XG5cdFx0XHRkaWZmdXNlOiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgQ29sb3IoMHhmZmZmZmYpXG5cdFx0XHR9LFxuXHRcdFx0b3BhY2l0eToge1xuXHRcdFx0XHR2YWx1ZTogMS4wXG5cdFx0XHR9LFxuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0dXZUcmFuc2Zvcm06IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBNYXRyaXgzKClcblx0XHRcdH0sXG5cdFx0XHR1djJUcmFuc2Zvcm06IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBNYXRyaXgzKClcblx0XHRcdH0sXG5cdFx0XHRhbHBoYU1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3BlY3VsYXJtYXA6IHtcblx0XHRcdHNwZWN1bGFyTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbnZtYXA6IHtcblx0XHRcdGVudk1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdGZsaXBFbnZNYXA6IHtcblx0XHRcdFx0dmFsdWU6IC0xXG5cdFx0XHR9LFxuXHRcdFx0cmVmbGVjdGl2aXR5OiB7XG5cdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdH0sXG5cdFx0XHRyZWZyYWN0aW9uUmF0aW86IHtcblx0XHRcdFx0dmFsdWU6IDAuOThcblx0XHRcdH0sXG5cdFx0XHRtYXhNaXBMZXZlbDoge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW9tYXA6IHtcblx0XHRcdGFvTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0YW9NYXBJbnRlbnNpdHk6IHtcblx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdH1cblx0XHR9LFxuXHRcdGxpZ2h0bWFwOiB7XG5cdFx0XHRsaWdodE1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdGxpZ2h0TWFwSW50ZW5zaXR5OiB7XG5cdFx0XHRcdHZhbHVlOiAxXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbWlzc2l2ZW1hcDoge1xuXHRcdFx0ZW1pc3NpdmVNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH1cblx0XHR9LFxuXHRcdGJ1bXBtYXA6IHtcblx0XHRcdGJ1bXBNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRidW1wU2NhbGU6IHtcblx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdH1cblx0XHR9LFxuXHRcdG5vcm1hbG1hcDoge1xuXHRcdFx0bm9ybWFsTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0bm9ybWFsU2NhbGU6IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBWZWN0b3IyKDEsIDEpXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkaXNwbGFjZW1lbnRtYXA6IHtcblx0XHRcdGRpc3BsYWNlbWVudE1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdGRpc3BsYWNlbWVudFNjYWxlOiB7XG5cdFx0XHRcdHZhbHVlOiAxXG5cdFx0XHR9LFxuXHRcdFx0ZGlzcGxhY2VtZW50Qmlhczoge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cm91Z2huZXNzbWFwOiB7XG5cdFx0XHRyb3VnaG5lc3NNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH1cblx0XHR9LFxuXHRcdG1ldGFsbmVzc21hcDoge1xuXHRcdFx0bWV0YWxuZXNzTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRncmFkaWVudG1hcDoge1xuXHRcdFx0Z3JhZGllbnRNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH1cblx0XHR9LFxuXHRcdGZvZzoge1xuXHRcdFx0Zm9nRGVuc2l0eToge1xuXHRcdFx0XHR2YWx1ZTogMC4wMDAyNVxuXHRcdFx0fSxcblx0XHRcdGZvZ05lYXI6IHtcblx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdH0sXG5cdFx0XHRmb2dGYXI6IHtcblx0XHRcdFx0dmFsdWU6IDIwMDBcblx0XHRcdH0sXG5cdFx0XHRmb2dDb2xvcjoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IENvbG9yKDB4ZmZmZmZmKVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGlnaHRzOiB7XG5cdFx0XHRhbWJpZW50TGlnaHRDb2xvcjoge1xuXHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdH0sXG5cdFx0XHRsaWdodFByb2JlOiB7XG5cdFx0XHRcdHZhbHVlOiBbXVxuXHRcdFx0fSxcblx0XHRcdGRpcmVjdGlvbmFsTGlnaHRzOiB7XG5cdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0cHJvcGVydGllczoge1xuXHRcdFx0XHRcdGRpcmVjdGlvbjoge30sXG5cdFx0XHRcdFx0Y29sb3I6IHt9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkaXJlY3Rpb25hbExpZ2h0U2hhZG93czoge1xuXHRcdFx0XHR2YWx1ZTogW10sXG5cdFx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0XHRzaGFkb3dCaWFzOiB7fSxcblx0XHRcdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiB7fSxcblx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IHt9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkaXJlY3Rpb25hbFNoYWRvd01hcDoge1xuXHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdH0sXG5cdFx0XHRkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdH0sXG5cdFx0XHRzcG90TGlnaHRzOiB7XG5cdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0cHJvcGVydGllczoge1xuXHRcdFx0XHRcdGNvbG9yOiB7fSxcblx0XHRcdFx0XHRwb3NpdGlvbjoge30sXG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdFx0XHRkaXN0YW5jZToge30sXG5cdFx0XHRcdFx0Y29uZUNvczoge30sXG5cdFx0XHRcdFx0cGVudW1icmFDb3M6IHt9LFxuXHRcdFx0XHRcdGRlY2F5OiB7fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c3BvdExpZ2h0U2hhZG93czoge1xuXHRcdFx0XHR2YWx1ZTogW10sXG5cdFx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0XHRzaGFkb3dCaWFzOiB7fSxcblx0XHRcdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiB7fSxcblx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IHt9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzcG90U2hhZG93TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBbXVxuXHRcdFx0fSxcblx0XHRcdHNwb3RTaGFkb3dNYXRyaXg6IHtcblx0XHRcdFx0dmFsdWU6IFtdXG5cdFx0XHR9LFxuXHRcdFx0cG9pbnRMaWdodHM6IHtcblx0XHRcdFx0dmFsdWU6IFtdLFxuXHRcdFx0XHRwcm9wZXJ0aWVzOiB7XG5cdFx0XHRcdFx0Y29sb3I6IHt9LFxuXHRcdFx0XHRcdHBvc2l0aW9uOiB7fSxcblx0XHRcdFx0XHRkZWNheToge30sXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IHt9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRwb2ludExpZ2h0U2hhZG93czoge1xuXHRcdFx0XHR2YWx1ZTogW10sXG5cdFx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0XHRzaGFkb3dCaWFzOiB7fSxcblx0XHRcdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiB7fSxcblx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYU5lYXI6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYUZhcjoge31cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHBvaW50U2hhZG93TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBbXVxuXHRcdFx0fSxcblx0XHRcdHBvaW50U2hhZG93TWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBbXVxuXHRcdFx0fSxcblx0XHRcdGhlbWlzcGhlcmVMaWdodHM6IHtcblx0XHRcdFx0dmFsdWU6IFtdLFxuXHRcdFx0XHRwcm9wZXJ0aWVzOiB7XG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdFx0XHRza3lDb2xvcjoge30sXG5cdFx0XHRcdFx0Z3JvdW5kQ29sb3I6IHt9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogUmVjdEFyZWFMaWdodCBCUkRGIGRhdGEgbmVlZHMgdG8gYmUgbW92ZWQgZnJvbSBleGFtcGxlIHRvIG1haW4gc3JjXG5cdFx0XHRyZWN0QXJlYUxpZ2h0czoge1xuXHRcdFx0XHR2YWx1ZTogW10sXG5cdFx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0XHRjb2xvcjoge30sXG5cdFx0XHRcdFx0cG9zaXRpb246IHt9LFxuXHRcdFx0XHRcdHdpZHRoOiB7fSxcblx0XHRcdFx0XHRoZWlnaHQ6IHt9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRsdGNfMToge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdGx0Y18yOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRwb2ludHM6IHtcblx0XHRcdGRpZmZ1c2U6IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBDb2xvcigweGZmZmZmZilcblx0XHRcdH0sXG5cdFx0XHRvcGFjaXR5OiB7XG5cdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdH0sXG5cdFx0XHRzaXplOiB7XG5cdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdH0sXG5cdFx0XHRzY2FsZToge1xuXHRcdFx0XHR2YWx1ZTogMS4wXG5cdFx0XHR9LFxuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0YWxwaGFNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR1dlRyYW5zZm9ybToge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3ByaXRlOiB7XG5cdFx0XHRkaWZmdXNlOiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgQ29sb3IoMHhmZmZmZmYpXG5cdFx0XHR9LFxuXHRcdFx0b3BhY2l0eToge1xuXHRcdFx0XHR2YWx1ZTogMS4wXG5cdFx0XHR9LFxuXHRcdFx0Y2VudGVyOiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgVmVjdG9yMigwLjUsIDAuNSlcblx0XHRcdH0sXG5cdFx0XHRyb3RhdGlvbjoge1xuXHRcdFx0XHR2YWx1ZTogMC4wXG5cdFx0XHR9LFxuXHRcdFx0bWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0YWxwaGFNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR1dlRyYW5zZm9ybToge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRjb25zdCBTaGFkZXJMaWIgPSB7XG5cdFx0YmFzaWM6IHtcblx0XHRcdHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLCBVbmlmb3Jtc0xpYi5lbnZtYXAsIFVuaWZvcm1zTGliLmFvbWFwLCBVbmlmb3Jtc0xpYi5saWdodG1hcCwgVW5pZm9ybXNMaWIuZm9nXSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY192ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY19mcmFnXG5cdFx0fSxcblx0XHRsYW1iZXJ0OiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCwgVW5pZm9ybXNMaWIuZW52bWFwLCBVbmlmb3Jtc0xpYi5hb21hcCwgVW5pZm9ybXNMaWIubGlnaHRtYXAsIFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLCBVbmlmb3Jtc0xpYi5mb2csIFVuaWZvcm1zTGliLmxpZ2h0cywge1xuXHRcdFx0XHRlbWlzc2l2ZToge1xuXHRcdFx0XHRcdHZhbHVlOiBuZXcgQ29sb3IoMHgwMDAwMDApXG5cdFx0XHRcdH1cblx0XHRcdH1dKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGxhbWJlcnRfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF9mcmFnXG5cdFx0fSxcblx0XHRwaG9uZzoge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsIFVuaWZvcm1zTGliLmVudm1hcCwgVW5pZm9ybXNMaWIuYW9tYXAsIFVuaWZvcm1zTGliLmxpZ2h0bWFwLCBVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCwgVW5pZm9ybXNMaWIuYnVtcG1hcCwgVW5pZm9ybXNMaWIubm9ybWFsbWFwLCBVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsIFVuaWZvcm1zTGliLmZvZywgVW5pZm9ybXNMaWIubGlnaHRzLCB7XG5cdFx0XHRcdGVtaXNzaXZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBDb2xvcigweDAwMDAwMClcblx0XHRcdFx0fSxcblx0XHRcdFx0c3BlY3VsYXI6IHtcblx0XHRcdFx0XHR2YWx1ZTogbmV3IENvbG9yKDB4MTExMTExKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzaGluaW5lc3M6IHtcblx0XHRcdFx0XHR2YWx1ZTogMzBcblx0XHRcdFx0fVxuXHRcdFx0fV0pLFxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfZnJhZ1xuXHRcdH0sXG5cdFx0c3RhbmRhcmQ6IHtcblx0XHRcdHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLmVudm1hcCwgVW5pZm9ybXNMaWIuYW9tYXAsIFVuaWZvcm1zTGliLmxpZ2h0bWFwLCBVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCwgVW5pZm9ybXNMaWIuYnVtcG1hcCwgVW5pZm9ybXNMaWIubm9ybWFsbWFwLCBVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsIFVuaWZvcm1zTGliLnJvdWdobmVzc21hcCwgVW5pZm9ybXNMaWIubWV0YWxuZXNzbWFwLCBVbmlmb3Jtc0xpYi5mb2csIFVuaWZvcm1zTGliLmxpZ2h0cywge1xuXHRcdFx0XHRlbWlzc2l2ZToge1xuXHRcdFx0XHRcdHZhbHVlOiBuZXcgQ29sb3IoMHgwMDAwMDApXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJvdWdobmVzczoge1xuXHRcdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdFx0fSxcblx0XHRcdFx0bWV0YWxuZXNzOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDAuMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlbnZNYXBJbnRlbnNpdHk6IHtcblx0XHRcdFx0XHR2YWx1ZTogMVxuXHRcdFx0XHR9IC8vIHRlbXBvcmFyeVxuXG5cdFx0XHR9XSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF9mcmFnXG5cdFx0fSxcblx0XHR0b29uOiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5hb21hcCwgVW5pZm9ybXNMaWIubGlnaHRtYXAsIFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwgVW5pZm9ybXNMaWIuZ3JhZGllbnRtYXAsIFVuaWZvcm1zTGliLmZvZywgVW5pZm9ybXNMaWIubGlnaHRzLCB7XG5cdFx0XHRcdGVtaXNzaXZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBDb2xvcigweDAwMDAwMClcblx0XHRcdFx0fVxuXHRcdFx0fV0pLFxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNodG9vbl92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2h0b29uX2ZyYWdcblx0XHR9LFxuXHRcdG1hdGNhcDoge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuYnVtcG1hcCwgVW5pZm9ybXNMaWIubm9ybWFsbWFwLCBVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsIFVuaWZvcm1zTGliLmZvZywge1xuXHRcdFx0XHRtYXRjYXA6IHtcblx0XHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHR9XSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2htYXRjYXBfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobWF0Y2FwX2ZyYWdcblx0XHR9LFxuXHRcdHBvaW50czoge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLnBvaW50cywgVW5pZm9ybXNMaWIuZm9nXSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c192ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c19mcmFnXG5cdFx0fSxcblx0XHRkYXNoZWQ6IHtcblx0XHRcdHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLmZvZywge1xuXHRcdFx0XHRzY2FsZToge1xuXHRcdFx0XHRcdHZhbHVlOiAxXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRhc2hTaXplOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdFx0fSxcblx0XHRcdFx0dG90YWxTaXplOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDJcblx0XHRcdFx0fVxuXHRcdFx0fV0pLFxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubGluZWRhc2hlZF9mcmFnXG5cdFx0fSxcblx0XHRkZXB0aDoge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwXSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmRlcHRoX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfZnJhZ1xuXHRcdH0sXG5cdFx0bm9ybWFsOiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwge1xuXHRcdFx0XHRvcGFjaXR5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IDEuMFxuXHRcdFx0XHR9XG5cdFx0XHR9XSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm5vcm1hbF92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm5vcm1hbF9mcmFnXG5cdFx0fSxcblx0XHRzcHJpdGU6IHtcblx0XHRcdHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5zcHJpdGUsIFVuaWZvcm1zTGliLmZvZ10pLFxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5zcHJpdGVfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zcHJpdGVfZnJhZ1xuXHRcdH0sXG5cdFx0YmFja2dyb3VuZDoge1xuXHRcdFx0dW5pZm9ybXM6IHtcblx0XHRcdFx0dXZUcmFuc2Zvcm06IHtcblx0XHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR0MkQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5iYWNrZ3JvdW5kX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZF9mcmFnXG5cdFx0fSxcblxuXHRcdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvL1x0Q3ViZSBtYXAgc2hhZGVyXG5cdFx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0XHRjdWJlOiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuZW52bWFwLCB7XG5cdFx0XHRcdG9wYWNpdHk6IHtcblx0XHRcdFx0XHR2YWx1ZTogMS4wXG5cdFx0XHRcdH1cblx0XHRcdH1dKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuY3ViZV92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfZnJhZ1xuXHRcdH0sXG5cdFx0ZXF1aXJlY3Q6IHtcblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdHRFcXVpcmVjdDoge1xuXHRcdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZXF1aXJlY3RfZnJhZ1xuXHRcdH0sXG5cdFx0ZGlzdGFuY2VSR0JBOiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsIHtcblx0XHRcdFx0cmVmZXJlbmNlUG9zaXRpb246IHtcblx0XHRcdFx0XHR2YWx1ZTogbmV3IFZlY3RvcjMoKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZWFyRGlzdGFuY2U6IHtcblx0XHRcdFx0XHR2YWx1ZTogMVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmYXJEaXN0YW5jZToge1xuXHRcdFx0XHRcdHZhbHVlOiAxMDAwXG5cdFx0XHRcdH1cblx0XHRcdH1dKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX2ZyYWdcblx0XHR9LFxuXHRcdHNoYWRvdzoge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmxpZ2h0cywgVW5pZm9ybXNMaWIuZm9nLCB7XG5cdFx0XHRcdGNvbG9yOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBDb2xvcigweDAwMDAwKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRvcGFjaXR5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IDEuMFxuXHRcdFx0XHR9XG5cdFx0XHR9XSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnNoYWRvd192ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLnNoYWRvd19mcmFnXG5cdFx0fVxuXHR9O1xuXHRTaGFkZXJMaWIucGh5c2ljYWwgPSB7XG5cdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1NoYWRlckxpYi5zdGFuZGFyZC51bmlmb3Jtcywge1xuXHRcdFx0Y2xlYXJjb2F0OiB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9LFxuXHRcdFx0Y2xlYXJjb2F0TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzOiB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9LFxuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0Y2xlYXJjb2F0Tm9ybWFsU2NhbGU6IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBWZWN0b3IyKDEsIDEpXG5cdFx0XHR9LFxuXHRcdFx0Y2xlYXJjb2F0Tm9ybWFsTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0c2hlZW46IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBDb2xvcigweDAwMDAwMClcblx0XHRcdH0sXG5cdFx0XHR0cmFuc21pc3Npb246IHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0sXG5cdFx0XHR0cmFuc21pc3Npb25NYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR0cmFuc21pc3Npb25TYW1wbGVyU2l6ZToge1xuXHRcdFx0XHR2YWx1ZTogbmV3IFZlY3RvcjIoKVxuXHRcdFx0fSxcblx0XHRcdHRyYW5zbWlzc2lvblNhbXBsZXJNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR0aGlja25lc3M6IHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0sXG5cdFx0XHR0aGlja25lc3NNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRhdHRlbnVhdGlvbkRpc3RhbmNlOiB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9LFxuXHRcdFx0YXR0ZW51YXRpb25UaW50OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgQ29sb3IoMHgwMDAwMDApXG5cdFx0XHR9LFxuXHRcdFx0c3BlY3VsYXJJbnRlbnNpdHk6IHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0sXG5cdFx0XHRzcGVjdWxhckludGVuc2l0eU1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdHNwZWN1bGFyVGludDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IENvbG9yKDEsIDEsIDEpXG5cdFx0XHR9LFxuXHRcdFx0c3BlY3VsYXJUaW50TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9XG5cdFx0fV0pLFxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF9mcmFnXG5cdH07XG5cblx0ZnVuY3Rpb24gV2ViR0xCYWNrZ3JvdW5kKHJlbmRlcmVyLCBjdWJlbWFwcywgc3RhdGUsIG9iamVjdHMsIHByZW11bHRpcGxpZWRBbHBoYSkge1xuXHRcdGNvbnN0IGNsZWFyQ29sb3IgPSBuZXcgQ29sb3IoMHgwMDAwMDApO1xuXHRcdGxldCBjbGVhckFscGhhID0gMDtcblx0XHRsZXQgcGxhbmVNZXNoO1xuXHRcdGxldCBib3hNZXNoO1xuXHRcdGxldCBjdXJyZW50QmFja2dyb3VuZCA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiA9IDA7XG5cdFx0bGV0IGN1cnJlbnRUb25lbWFwcGluZyA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiByZW5kZXIocmVuZGVyTGlzdCwgc2NlbmUpIHtcblx0XHRcdGxldCBmb3JjZUNsZWFyID0gZmFsc2U7XG5cdFx0XHRsZXQgYmFja2dyb3VuZCA9IHNjZW5lLmlzU2NlbmUgPT09IHRydWUgPyBzY2VuZS5iYWNrZ3JvdW5kIDogbnVsbDtcblxuXHRcdFx0aWYgKGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc1RleHR1cmUpIHtcblx0XHRcdFx0YmFja2dyb3VuZCA9IGN1YmVtYXBzLmdldChiYWNrZ3JvdW5kKTtcblx0XHRcdH0gLy8gSWdub3JlIGJhY2tncm91bmQgaW4gQVJcblx0XHRcdC8vIFRPRE86IFJlY29uc2lkZXIgdGhpcy5cblxuXG5cdFx0XHRjb25zdCB4ciA9IHJlbmRlcmVyLnhyO1xuXHRcdFx0Y29uc3Qgc2Vzc2lvbiA9IHhyLmdldFNlc3Npb24gJiYgeHIuZ2V0U2Vzc2lvbigpO1xuXG5cdFx0XHRpZiAoc2Vzc2lvbiAmJiBzZXNzaW9uLmVudmlyb25tZW50QmxlbmRNb2RlID09PSAnYWRkaXRpdmUnKSB7XG5cdFx0XHRcdGJhY2tncm91bmQgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYmFja2dyb3VuZCA9PT0gbnVsbCkge1xuXHRcdFx0XHRzZXRDbGVhcihjbGVhckNvbG9yLCBjbGVhckFscGhhKTtcblx0XHRcdH0gZWxzZSBpZiAoYmFja2dyb3VuZCAmJiBiYWNrZ3JvdW5kLmlzQ29sb3IpIHtcblx0XHRcdFx0c2V0Q2xlYXIoYmFja2dyb3VuZCwgMSk7XG5cdFx0XHRcdGZvcmNlQ2xlYXIgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVuZGVyZXIuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIpIHtcblx0XHRcdFx0cmVuZGVyZXIuY2xlYXIocmVuZGVyZXIuYXV0b0NsZWFyQ29sb3IsIHJlbmRlcmVyLmF1dG9DbGVhckRlcHRoLCByZW5kZXJlci5hdXRvQ2xlYXJTdGVuY2lsKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJhY2tncm91bmQgJiYgKGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSB8fCBiYWNrZ3JvdW5kLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nKSkge1xuXHRcdFx0XHRpZiAoYm94TWVzaCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ym94TWVzaCA9IG5ldyBNZXNoKG5ldyBCb3hHZW9tZXRyeSgxLCAxLCAxKSwgbmV3IFNoYWRlck1hdGVyaWFsKHtcblx0XHRcdFx0XHRcdG5hbWU6ICdCYWNrZ3JvdW5kQ3ViZU1hdGVyaWFsJyxcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBjbG9uZVVuaWZvcm1zKFNoYWRlckxpYi5jdWJlLnVuaWZvcm1zKSxcblx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyTGliLmN1YmUudmVydGV4U2hhZGVyLFxuXHRcdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckxpYi5jdWJlLmZyYWdtZW50U2hhZGVyLFxuXHRcdFx0XHRcdFx0c2lkZTogQmFja1NpZGUsXG5cdFx0XHRcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRmb2c6IGZhbHNlXG5cdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdGJveE1lc2guZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCdub3JtYWwnKTtcblx0XHRcdFx0XHRib3hNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgndXYnKTtcblxuXHRcdFx0XHRcdGJveE1lc2gub25CZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEpIHtcblx0XHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weVBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdFx0fTsgLy8gZW5hYmxlIGNvZGUgaW5qZWN0aW9uIGZvciBub24tYnVpbHQtaW4gbWF0ZXJpYWxcblxuXG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGJveE1lc2gubWF0ZXJpYWwsICdlbnZNYXAnLCB7XG5cdFx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMudW5pZm9ybXMuZW52TWFwLnZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdG9iamVjdHMudXBkYXRlKGJveE1lc2gpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ym94TWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBiYWNrZ3JvdW5kO1xuXHRcdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSBiYWNrZ3JvdW5kLmlzQ3ViZVRleHR1cmUgJiYgYmFja2dyb3VuZC5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IGZhbHNlID8gLTEgOiAxO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50QmFja2dyb3VuZCAhPT0gYmFja2dyb3VuZCB8fCBjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gIT09IGJhY2tncm91bmQudmVyc2lvbiB8fCBjdXJyZW50VG9uZW1hcHBpbmcgIT09IHJlbmRlcmVyLnRvbmVNYXBwaW5nKSB7XG5cdFx0XHRcdFx0Ym94TWVzaC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y3VycmVudEJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXHRcdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiA9IGJhY2tncm91bmQudmVyc2lvbjtcblx0XHRcdFx0XHRjdXJyZW50VG9uZW1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcblx0XHRcdFx0fSAvLyBwdXNoIHRvIHRoZSBwcmUtc29ydGVkIG9wYXF1ZSByZW5kZXIgbGlzdFxuXG5cblx0XHRcdFx0cmVuZGVyTGlzdC51bnNoaWZ0KGJveE1lc2gsIGJveE1lc2guZ2VvbWV0cnksIGJveE1lc2gubWF0ZXJpYWwsIDAsIDAsIG51bGwpO1xuXHRcdFx0fSBlbHNlIGlmIChiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdGlmIChwbGFuZU1lc2ggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHBsYW5lTWVzaCA9IG5ldyBNZXNoKG5ldyBQbGFuZUdlb21ldHJ5KDIsIDIpLCBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuXHRcdFx0XHRcdFx0bmFtZTogJ0JhY2tncm91bmRNYXRlcmlhbCcsXG5cdFx0XHRcdFx0XHR1bmlmb3JtczogY2xvbmVVbmlmb3JtcyhTaGFkZXJMaWIuYmFja2dyb3VuZC51bmlmb3JtcyksXG5cdFx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckxpYi5iYWNrZ3JvdW5kLnZlcnRleFNoYWRlcixcblx0XHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZC5mcmFnbWVudFNoYWRlcixcblx0XHRcdFx0XHRcdHNpZGU6IEZyb250U2lkZSxcblx0XHRcdFx0XHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdFx0XHRcdGZvZzogZmFsc2Vcblx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0cGxhbmVNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgnbm9ybWFsJyk7IC8vIGVuYWJsZSBjb2RlIGluamVjdGlvbiBmb3Igbm9uLWJ1aWx0LWluIG1hdGVyaWFsXG5cblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocGxhbmVNZXNoLm1hdGVyaWFsLCAnbWFwJywge1xuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnVuaWZvcm1zLnQyRC52YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRvYmplY3RzLnVwZGF0ZShwbGFuZU1lc2gpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnQyRC52YWx1ZSA9IGJhY2tncm91bmQ7XG5cblx0XHRcdFx0aWYgKGJhY2tncm91bmQubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGJhY2tncm91bmQudXBkYXRlTWF0cml4KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwbGFuZU1lc2gubWF0ZXJpYWwudW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weShiYWNrZ3JvdW5kLm1hdHJpeCk7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8IGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiAhPT0gYmFja2dyb3VuZC52ZXJzaW9uIHx8IGN1cnJlbnRUb25lbWFwcGluZyAhPT0gcmVuZGVyZXIudG9uZU1hcHBpbmcpIHtcblx0XHRcdFx0XHRwbGFuZU1lc2gubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblx0XHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gPSBiYWNrZ3JvdW5kLnZlcnNpb247XG5cdFx0XHRcdFx0Y3VycmVudFRvbmVtYXBwaW5nID0gcmVuZGVyZXIudG9uZU1hcHBpbmc7XG5cdFx0XHRcdH0gLy8gcHVzaCB0byB0aGUgcHJlLXNvcnRlZCBvcGFxdWUgcmVuZGVyIGxpc3RcblxuXG5cdFx0XHRcdHJlbmRlckxpc3QudW5zaGlmdChwbGFuZU1lc2gsIHBsYW5lTWVzaC5nZW9tZXRyeSwgcGxhbmVNZXNoLm1hdGVyaWFsLCAwLCAwLCBudWxsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRDbGVhcihjb2xvciwgYWxwaGEpIHtcblx0XHRcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgYWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldENsZWFyQ29sb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGNsZWFyQ29sb3I7XG5cdFx0XHR9LFxuXHRcdFx0c2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gKGNvbG9yLCBhbHBoYSA9IDEpIHtcblx0XHRcdFx0Y2xlYXJDb2xvci5zZXQoY29sb3IpO1xuXHRcdFx0XHRjbGVhckFscGhhID0gYWxwaGE7XG5cdFx0XHRcdHNldENsZWFyKGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEpO1xuXHRcdFx0fSxcblx0XHRcdGdldENsZWFyQWxwaGE6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGNsZWFyQWxwaGE7XG5cdFx0XHR9LFxuXHRcdFx0c2V0Q2xlYXJBbHBoYTogZnVuY3Rpb24gKGFscGhhKSB7XG5cdFx0XHRcdGNsZWFyQWxwaGEgPSBhbHBoYTtcblx0XHRcdFx0c2V0Q2xlYXIoY2xlYXJDb2xvciwgY2xlYXJBbHBoYSk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiByZW5kZXJcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xCaW5kaW5nU3RhdGVzKGdsLCBleHRlbnNpb25zLCBhdHRyaWJ1dGVzLCBjYXBhYmlsaXRpZXMpIHtcblx0XHRjb25zdCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUyk7XG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyID8gbnVsbCA6IGV4dGVuc2lvbnMuZ2V0KCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpO1xuXHRcdGNvbnN0IHZhb0F2YWlsYWJsZSA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMiB8fCBleHRlbnNpb24gIT09IG51bGw7XG5cdFx0Y29uc3QgYmluZGluZ1N0YXRlcyA9IHt9O1xuXHRcdGNvbnN0IGRlZmF1bHRTdGF0ZSA9IGNyZWF0ZUJpbmRpbmdTdGF0ZShudWxsKTtcblx0XHRsZXQgY3VycmVudFN0YXRlID0gZGVmYXVsdFN0YXRlO1xuXG5cdFx0ZnVuY3Rpb24gc2V0dXAob2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIGluZGV4KSB7XG5cdFx0XHRsZXQgdXBkYXRlQnVmZmVycyA9IGZhbHNlO1xuXG5cdFx0XHRpZiAodmFvQXZhaWxhYmxlKSB7XG5cdFx0XHRcdGNvbnN0IHN0YXRlID0gZ2V0QmluZGluZ1N0YXRlKGdlb21ldHJ5LCBwcm9ncmFtLCBtYXRlcmlhbCk7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRTdGF0ZSAhPT0gc3RhdGUpIHtcblx0XHRcdFx0XHRjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0XHRcdFx0XHRiaW5kVmVydGV4QXJyYXlPYmplY3QoY3VycmVudFN0YXRlLm9iamVjdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1cGRhdGVCdWZmZXJzID0gbmVlZHNVcGRhdGUoZ2VvbWV0cnksIGluZGV4KTtcblx0XHRcdFx0aWYgKHVwZGF0ZUJ1ZmZlcnMpIHNhdmVDYWNoZShnZW9tZXRyeSwgaW5kZXgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qgd2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGUuZ2VvbWV0cnkgIT09IGdlb21ldHJ5LmlkIHx8IGN1cnJlbnRTdGF0ZS5wcm9ncmFtICE9PSBwcm9ncmFtLmlkIHx8IGN1cnJlbnRTdGF0ZS53aXJlZnJhbWUgIT09IHdpcmVmcmFtZSkge1xuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZS5nZW9tZXRyeSA9IGdlb21ldHJ5LmlkO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZS5wcm9ncmFtID0gcHJvZ3JhbS5pZDtcblx0XHRcdFx0XHRjdXJyZW50U3RhdGUud2lyZWZyYW1lID0gd2lyZWZyYW1lO1xuXHRcdFx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvYmplY3QuaXNJbnN0YW5jZWRNZXNoID09PSB0cnVlKSB7XG5cdFx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0YXR0cmlidXRlcy51cGRhdGUoaW5kZXgsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHVwZGF0ZUJ1ZmZlcnMpIHtcblx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5KTtcblxuXHRcdFx0XHRpZiAoaW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGVzLmdldChpbmRleCkuYnVmZmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVZlcnRleEFycmF5T2JqZWN0KCkge1xuXHRcdFx0aWYgKGNhcGFiaWxpdGllcy5pc1dlYkdMMikgcmV0dXJuIGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLmNyZWF0ZVZlcnRleEFycmF5T0VTKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYmluZFZlcnRleEFycmF5T2JqZWN0KHZhbykge1xuXHRcdFx0aWYgKGNhcGFiaWxpdGllcy5pc1dlYkdMMikgcmV0dXJuIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVModmFvKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWxldGVWZXJ0ZXhBcnJheU9iamVjdCh2YW8pIHtcblx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHJldHVybiBnbC5kZWxldGVWZXJ0ZXhBcnJheSh2YW8pO1xuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh2YW8pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEJpbmRpbmdTdGF0ZShnZW9tZXRyeSwgcHJvZ3JhbSwgbWF0ZXJpYWwpIHtcblx0XHRcdGNvbnN0IHdpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZTtcblx0XHRcdGxldCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1tnZW9tZXRyeS5pZF07XG5cblx0XHRcdGlmIChwcm9ncmFtTWFwID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHJvZ3JhbU1hcCA9IHt9O1xuXHRcdFx0XHRiaW5kaW5nU3RhdGVzW2dlb21ldHJ5LmlkXSA9IHByb2dyYW1NYXA7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbcHJvZ3JhbS5pZF07XG5cblx0XHRcdGlmIChzdGF0ZU1hcCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHN0YXRlTWFwID0ge307XG5cdFx0XHRcdHByb2dyYW1NYXBbcHJvZ3JhbS5pZF0gPSBzdGF0ZU1hcDtcblx0XHRcdH1cblxuXHRcdFx0bGV0IHN0YXRlID0gc3RhdGVNYXBbd2lyZWZyYW1lXTtcblxuXHRcdFx0aWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c3RhdGUgPSBjcmVhdGVCaW5kaW5nU3RhdGUoY3JlYXRlVmVydGV4QXJyYXlPYmplY3QoKSk7XG5cdFx0XHRcdHN0YXRlTWFwW3dpcmVmcmFtZV0gPSBzdGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUJpbmRpbmdTdGF0ZSh2YW8pIHtcblx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBbXTtcblx0XHRcdGNvbnN0IGVuYWJsZWRBdHRyaWJ1dGVzID0gW107XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVEaXZpc29ycyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1heFZlcnRleEF0dHJpYnV0ZXM7IGkrKykge1xuXHRcdFx0XHRuZXdBdHRyaWJ1dGVzW2ldID0gMDtcblx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbaV0gPSAwO1xuXHRcdFx0XHRhdHRyaWJ1dGVEaXZpc29yc1tpXSA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG9uIG5vbi1WQU8gc3VwcG9ydCBicm93c2VyXG5cdFx0XHRcdGdlb21ldHJ5OiBudWxsLFxuXHRcdFx0XHRwcm9ncmFtOiBudWxsLFxuXHRcdFx0XHR3aXJlZnJhbWU6IGZhbHNlLFxuXHRcdFx0XHRuZXdBdHRyaWJ1dGVzOiBuZXdBdHRyaWJ1dGVzLFxuXHRcdFx0XHRlbmFibGVkQXR0cmlidXRlczogZW5hYmxlZEF0dHJpYnV0ZXMsXG5cdFx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzOiBhdHRyaWJ1dGVEaXZpc29ycyxcblx0XHRcdFx0b2JqZWN0OiB2YW8sXG5cdFx0XHRcdGF0dHJpYnV0ZXM6IHt9LFxuXHRcdFx0XHRpbmRleDogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBuZWVkc1VwZGF0ZShnZW9tZXRyeSwgaW5kZXgpIHtcblx0XHRcdGNvbnN0IGNhY2hlZEF0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUuYXR0cmlidXRlcztcblx0XHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0XHRsZXQgYXR0cmlidXRlc051bSA9IDA7XG5cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIGdlb21ldHJ5QXR0cmlidXRlcykge1xuXHRcdFx0XHRjb25zdCBjYWNoZWRBdHRyaWJ1dGUgPSBjYWNoZWRBdHRyaWJ1dGVzW2tleV07XG5cdFx0XHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzW2tleV07XG5cdFx0XHRcdGlmIChjYWNoZWRBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG5cdFx0XHRcdGlmIChjYWNoZWRBdHRyaWJ1dGUuYXR0cmlidXRlICE9PSBnZW9tZXRyeUF0dHJpYnV0ZSkgcmV0dXJuIHRydWU7XG5cdFx0XHRcdGlmIChjYWNoZWRBdHRyaWJ1dGUuZGF0YSAhPT0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YSkgcmV0dXJuIHRydWU7XG5cdFx0XHRcdGF0dHJpYnV0ZXNOdW0rKztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzTnVtICE9PSBhdHRyaWJ1dGVzTnVtKSByZXR1cm4gdHJ1ZTtcblx0XHRcdGlmIChjdXJyZW50U3RhdGUuaW5kZXggIT09IGluZGV4KSByZXR1cm4gdHJ1ZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzYXZlQ2FjaGUoZ2VvbWV0cnksIGluZGV4KSB7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHt9O1xuXHRcdFx0Y29uc3QgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0XHRsZXQgYXR0cmlidXRlc051bSA9IDA7XG5cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuXHRcdFx0XHRjb25zdCBkYXRhID0ge307XG5cdFx0XHRcdGRhdGEuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG5cdFx0XHRcdGlmIChhdHRyaWJ1dGUuZGF0YSkge1xuXHRcdFx0XHRcdGRhdGEuZGF0YSA9IGF0dHJpYnV0ZS5kYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FjaGVba2V5XSA9IGRhdGE7XG5cdFx0XHRcdGF0dHJpYnV0ZXNOdW0rKztcblx0XHRcdH1cblxuXHRcdFx0Y3VycmVudFN0YXRlLmF0dHJpYnV0ZXMgPSBjYWNoZTtcblx0XHRcdGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzTnVtID0gYXR0cmlidXRlc051bTtcblx0XHRcdGN1cnJlbnRTdGF0ZS5pbmRleCA9IGluZGV4O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluaXRBdHRyaWJ1dGVzKCkge1xuXHRcdFx0Y29uc3QgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBuZXdBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0bmV3QXR0cmlidXRlc1tpXSA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuXHRcdFx0ZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcihhdHRyaWJ1dGUsIDApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlKSB7XG5cdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLm5ld0F0dHJpYnV0ZXM7XG5cdFx0XHRjb25zdCBlbmFibGVkQXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5lbmFibGVkQXR0cmlidXRlcztcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZURpdmlzb3JzID0gY3VycmVudFN0YXRlLmF0dHJpYnV0ZURpdmlzb3JzO1xuXHRcdFx0bmV3QXR0cmlidXRlc1thdHRyaWJ1dGVdID0gMTtcblxuXHRcdFx0aWYgKGVuYWJsZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPT09IDApIHtcblx0XHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlidXRlKTtcblx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhdHRyaWJ1dGVEaXZpc29yc1thdHRyaWJ1dGVdICE9PSBtZXNoUGVyQXR0cmlidXRlKSB7XG5cdFx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMiA/IGdsIDogZXh0ZW5zaW9ucy5nZXQoJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcblx0XHRcdFx0ZXh0ZW5zaW9uW2NhcGFiaWxpdGllcy5pc1dlYkdMMiA/ICd2ZXJ0ZXhBdHRyaWJEaXZpc29yJyA6ICd2ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUnXShhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUpO1xuXHRcdFx0XHRhdHRyaWJ1dGVEaXZpc29yc1thdHRyaWJ1dGVdID0gbWVzaFBlckF0dHJpYnV0ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkaXNhYmxlVW51c2VkQXR0cmlidXRlcygpIHtcblx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUubmV3QXR0cmlidXRlcztcblx0XHRcdGNvbnN0IGVuYWJsZWRBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChlbmFibGVkQXR0cmlidXRlc1tpXSAhPT0gbmV3QXR0cmlidXRlc1tpXSkge1xuXHRcdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcblx0XHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1tpXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB2ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCkge1xuXHRcdFx0aWYgKGNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gdHJ1ZSAmJiAodHlwZSA9PT0gZ2wuSU5UIHx8IHR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCkpIHtcblx0XHRcdFx0Z2wudmVydGV4QXR0cmliSVBvaW50ZXIoaW5kZXgsIHNpemUsIHR5cGUsIHN0cmlkZSwgb2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMob2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnkpIHtcblx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPT09IGZhbHNlICYmIChvYmplY3QuaXNJbnN0YW5jZWRNZXNoIHx8IGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkpKSB7XG5cdFx0XHRcdGlmIChleHRlbnNpb25zLmdldCgnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpID09PSBudWxsKSByZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGluaXRBdHRyaWJ1dGVzKCk7XG5cdFx0XHRjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdFx0Y29uc3QgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblx0XHRcdGNvbnN0IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7XG5cblx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcykge1xuXHRcdFx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbbmFtZV07XG5cblx0XHRcdFx0aWYgKHByb2dyYW1BdHRyaWJ1dGUgPj0gMCkge1xuXHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzW25hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5ub3JtYWxpemVkO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xuXHRcdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlcy5nZXQoZ2VvbWV0cnlBdHRyaWJ1dGUpOyAvLyBUT0RPIEF0dHJpYnV0ZSBtYXkgbm90IGJlIGF2YWlsYWJsZSBvbiBjb250ZXh0IHJlc3RvcmVcblxuXHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IGF0dHJpYnV0ZS5idWZmZXI7XG5cdFx0XHRcdFx0XHRjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG5cdFx0XHRcdFx0XHRjb25zdCBieXRlc1BlckVsZW1lbnQgPSBhdHRyaWJ1dGUuYnl0ZXNQZXJFbGVtZW50O1xuXG5cdFx0XHRcdFx0XHRpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc3RyaWRlID0gZGF0YS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YSAmJiBkYXRhLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKHByb2dyYW1BdHRyaWJ1dGUsIGRhdGEubWVzaFBlckF0dHJpYnV0ZSk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPSBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKiBkYXRhLmNvdW50O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUocHJvZ3JhbUF0dHJpYnV0ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRcdFx0XHRcdFx0dmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtQXR0cmlidXRlLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUgKiBieXRlc1BlckVsZW1lbnQsIG9mZnNldCAqIGJ5dGVzUGVyRWxlbWVudCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUpIHtcblx0XHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUocHJvZ3JhbUF0dHJpYnV0ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRcdFx0XHRcdFx0dmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtQXR0cmlidXRlLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCAwLCAwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5hbWUgPT09ICdpbnN0YW5jZU1hdHJpeCcpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0KG9iamVjdC5pbnN0YW5jZU1hdHJpeCk7IC8vIFRPRE8gQXR0cmlidXRlIG1heSBub3QgYmUgYXZhaWxhYmxlIG9uIGNvbnRleHQgcmVzdG9yZVxuXG5cdFx0XHRcdFx0XHRpZiAoYXR0cmlidXRlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gYXR0cmlidXRlLmJ1ZmZlcjtcblx0XHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IocHJvZ3JhbUF0dHJpYnV0ZSArIDAsIDEpO1xuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcihwcm9ncmFtQXR0cmlidXRlICsgMSwgMSk7XG5cdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKHByb2dyYW1BdHRyaWJ1dGUgKyAyLCAxKTtcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IocHJvZ3JhbUF0dHJpYnV0ZSArIDMsIDEpO1xuXHRcdFx0XHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW1BdHRyaWJ1dGUgKyAwLCA0LCB0eXBlLCBmYWxzZSwgNjQsIDApO1xuXHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtQXR0cmlidXRlICsgMSwgNCwgdHlwZSwgZmFsc2UsIDY0LCAxNik7XG5cdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW1BdHRyaWJ1dGUgKyAyLCA0LCB0eXBlLCBmYWxzZSwgNjQsIDMyKTtcblx0XHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbUF0dHJpYnV0ZSArIDMsIDQsIHR5cGUsIGZhbHNlLCA2NCwgNDgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJ2luc3RhbmNlQ29sb3InKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldChvYmplY3QuaW5zdGFuY2VDb2xvcik7IC8vIFRPRE8gQXR0cmlidXRlIG1heSBub3QgYmUgYXZhaWxhYmxlIG9uIGNvbnRleHQgcmVzdG9yZVxuXG5cdFx0XHRcdFx0XHRpZiAoYXR0cmlidXRlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gYXR0cmlidXRlLmJ1ZmZlcjtcblx0XHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IocHJvZ3JhbUF0dHJpYnV0ZSwgMSk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbUF0dHJpYnV0ZSwgMywgdHlwZSwgZmFsc2UsIDEyLCAwKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1tuYW1lXTtcblxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0c3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWIyZnYocHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWIzZnYocHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWI0ZnYocHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliMWZ2KHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRkaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRyZXNldCgpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGdlb21ldHJ5SWQgaW4gYmluZGluZ1N0YXRlcykge1xuXHRcdFx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1tnZW9tZXRyeUlkXTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IHByb2dyYW1JZCBpbiBwcm9ncmFtTWFwKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhdGVNYXAgPSBwcm9ncmFtTWFwW3Byb2dyYW1JZF07XG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlVmVydGV4QXJyYXlPYmplY3Qoc3RhdGVNYXBbd2lyZWZyYW1lXS5vYmplY3QpO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlTWFwW3dpcmVmcmFtZV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGVsZXRlIHByb2dyYW1NYXBbcHJvZ3JhbUlkXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBiaW5kaW5nU3RhdGVzW2dlb21ldHJ5SWRdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5KGdlb21ldHJ5KSB7XG5cdFx0XHRpZiAoYmluZGluZ1N0YXRlc1tnZW9tZXRyeS5pZF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcdFx0Y29uc3QgcHJvZ3JhbU1hcCA9IGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnkuaWRdO1xuXG5cdFx0XHRmb3IgKGNvbnN0IHByb2dyYW1JZCBpbiBwcm9ncmFtTWFwKSB7XG5cdFx0XHRcdGNvbnN0IHN0YXRlTWFwID0gcHJvZ3JhbU1hcFtwcm9ncmFtSWRdO1xuXG5cdFx0XHRcdGZvciAoY29uc3Qgd2lyZWZyYW1lIGluIHN0YXRlTWFwKSB7XG5cdFx0XHRcdFx0ZGVsZXRlVmVydGV4QXJyYXlPYmplY3Qoc3RhdGVNYXBbd2lyZWZyYW1lXS5vYmplY3QpO1xuXHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZU1hcFt3aXJlZnJhbWVdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHByb2dyYW1NYXBbcHJvZ3JhbUlkXTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnkuaWRdO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbGVhc2VTdGF0ZXNPZlByb2dyYW0ocHJvZ3JhbSkge1xuXHRcdFx0Zm9yIChjb25zdCBnZW9tZXRyeUlkIGluIGJpbmRpbmdTdGF0ZXMpIHtcblx0XHRcdFx0Y29uc3QgcHJvZ3JhbU1hcCA9IGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnlJZF07XG5cdFx0XHRcdGlmIChwcm9ncmFtTWFwW3Byb2dyYW0uaWRdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXHRcdFx0XHRjb25zdCBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbcHJvZ3JhbS5pZF07XG5cblx0XHRcdFx0Zm9yIChjb25zdCB3aXJlZnJhbWUgaW4gc3RhdGVNYXApIHtcblx0XHRcdFx0XHRkZWxldGVWZXJ0ZXhBcnJheU9iamVjdChzdGF0ZU1hcFt3aXJlZnJhbWVdLm9iamVjdCk7XG5cdFx0XHRcdFx0ZGVsZXRlIHN0YXRlTWFwW3dpcmVmcmFtZV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgcHJvZ3JhbU1hcFtwcm9ncmFtLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNldCgpIHtcblx0XHRcdHJlc2V0RGVmYXVsdFN0YXRlKCk7XG5cdFx0XHRpZiAoY3VycmVudFN0YXRlID09PSBkZWZhdWx0U3RhdGUpIHJldHVybjtcblx0XHRcdGN1cnJlbnRTdGF0ZSA9IGRlZmF1bHRTdGF0ZTtcblx0XHRcdGJpbmRWZXJ0ZXhBcnJheU9iamVjdChjdXJyZW50U3RhdGUub2JqZWN0KTtcblx0XHR9IC8vIGZvciBiYWNrd2FyZC1jb21wYXRpbGliaXR5XG5cblxuXHRcdGZ1bmN0aW9uIHJlc2V0RGVmYXVsdFN0YXRlKCkge1xuXHRcdFx0ZGVmYXVsdFN0YXRlLmdlb21ldHJ5ID0gbnVsbDtcblx0XHRcdGRlZmF1bHRTdGF0ZS5wcm9ncmFtID0gbnVsbDtcblx0XHRcdGRlZmF1bHRTdGF0ZS53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2V0dXA6IHNldHVwLFxuXHRcdFx0cmVzZXQ6IHJlc2V0LFxuXHRcdFx0cmVzZXREZWZhdWx0U3RhdGU6IHJlc2V0RGVmYXVsdFN0YXRlLFxuXHRcdFx0ZGlzcG9zZTogZGlzcG9zZSxcblx0XHRcdHJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5OiByZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeSxcblx0XHRcdHJlbGVhc2VTdGF0ZXNPZlByb2dyYW06IHJlbGVhc2VTdGF0ZXNPZlByb2dyYW0sXG5cdFx0XHRpbml0QXR0cmlidXRlczogaW5pdEF0dHJpYnV0ZXMsXG5cdFx0XHRlbmFibGVBdHRyaWJ1dGU6IGVuYWJsZUF0dHJpYnV0ZSxcblx0XHRcdGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzOiBkaXNhYmxlVW51c2VkQXR0cmlidXRlc1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEJ1ZmZlclJlbmRlcmVyKGdsLCBleHRlbnNpb25zLCBpbmZvLCBjYXBhYmlsaXRpZXMpIHtcblx0XHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcblx0XHRsZXQgbW9kZTtcblxuXHRcdGZ1bmN0aW9uIHNldE1vZGUodmFsdWUpIHtcblx0XHRcdG1vZGUgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXIoc3RhcnQsIGNvdW50KSB7XG5cdFx0XHRnbC5kcmF3QXJyYXlzKG1vZGUsIHN0YXJ0LCBjb3VudCk7XG5cdFx0XHRpbmZvLnVwZGF0ZShjb3VudCwgbW9kZSwgMSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKHN0YXJ0LCBjb3VudCwgcHJpbWNvdW50KSB7XG5cdFx0XHRpZiAocHJpbWNvdW50ID09PSAwKSByZXR1cm47XG5cdFx0XHRsZXQgZXh0ZW5zaW9uLCBtZXRob2ROYW1lO1xuXG5cdFx0XHRpZiAoaXNXZWJHTDIpIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2w7XG5cdFx0XHRcdG1ldGhvZE5hbWUgPSAnZHJhd0FycmF5c0luc3RhbmNlZCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuXHRcdFx0XHRtZXRob2ROYW1lID0gJ2RyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSc7XG5cblx0XHRcdFx0aWYgKGV4dGVuc2lvbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRleHRlbnNpb25bbWV0aG9kTmFtZV0obW9kZSwgc3RhcnQsIGNvdW50LCBwcmltY291bnQpO1xuXHRcdFx0aW5mby51cGRhdGUoY291bnQsIG1vZGUsIHByaW1jb3VudCk7XG5cdFx0fSAvL1xuXG5cblx0XHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xuXHRcdHRoaXMucmVuZGVyID0gcmVuZGVyO1xuXHRcdHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xDYXBhYmlsaXRpZXMoZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMpIHtcblx0XHRsZXQgbWF4QW5pc290cm9weTtcblxuXHRcdGZ1bmN0aW9uIGdldE1heEFuaXNvdHJvcHkoKSB7XG5cdFx0XHRpZiAobWF4QW5pc290cm9weSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbWF4QW5pc290cm9weTtcblxuXHRcdFx0aWYgKGV4dGVuc2lvbnMuaGFzKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyk7XG5cdFx0XHRcdG1heEFuaXNvdHJvcHkgPSBnbC5nZXRQYXJhbWV0ZXIoZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXhBbmlzb3Ryb3B5ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1heEFuaXNvdHJvcHk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TWF4UHJlY2lzaW9uKHByZWNpc2lvbikge1xuXHRcdFx0aWYgKHByZWNpc2lvbiA9PT0gJ2hpZ2hwJykge1xuXHRcdFx0XHRpZiAoZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpLnByZWNpc2lvbiA+IDAgJiYgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCkucHJlY2lzaW9uID4gMCkge1xuXHRcdFx0XHRcdHJldHVybiAnaGlnaHAnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJlY2lzaW9uID0gJ21lZGl1bXAnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJlY2lzaW9uID09PSAnbWVkaXVtcCcpIHtcblx0XHRcdFx0aWYgKGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpLnByZWNpc2lvbiA+IDAgJiYgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKS5wcmVjaXNpb24gPiAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdtZWRpdW1wJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gJ2xvd3AnO1xuXHRcdH1cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuXG5cblx0XHRjb25zdCBpc1dlYkdMMiA9IHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgfHwgdHlwZW9mIFdlYkdMMkNvbXB1dGVSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBnbCBpbnN0YW5jZW9mIFdlYkdMMkNvbXB1dGVSZW5kZXJpbmdDb250ZXh0O1xuXHRcdC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cblxuXHRcdGxldCBwcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnO1xuXHRcdGNvbnN0IG1heFByZWNpc2lvbiA9IGdldE1heFByZWNpc2lvbihwcmVjaXNpb24pO1xuXG5cdFx0aWYgKG1heFByZWNpc2lvbiAhPT0gcHJlY2lzaW9uKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgcHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBtYXhQcmVjaXNpb24sICdpbnN0ZWFkLicpO1xuXHRcdFx0cHJlY2lzaW9uID0gbWF4UHJlY2lzaW9uO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRyYXdCdWZmZXJzID0gaXNXZWJHTDIgfHwgZXh0ZW5zaW9ucy5oYXMoJ1dFQkdMX2RyYXdfYnVmZmVycycpO1xuXHRcdGNvbnN0IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPT09IHRydWU7XG5cdFx0Y29uc3QgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuXHRcdGNvbnN0IG1heFZlcnRleFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG5cdFx0Y29uc3QgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG5cdFx0Y29uc3QgbWF4Q3ViZW1hcFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSk7XG5cdFx0Y29uc3QgbWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX0FUVFJJQlMpO1xuXHRcdGNvbnN0IG1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKTtcblx0XHRjb25zdCBtYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkFSWUlOR19WRUNUT1JTKTtcblx0XHRjb25zdCBtYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpO1xuXHRcdGNvbnN0IHZlcnRleFRleHR1cmVzID0gbWF4VmVydGV4VGV4dHVyZXMgPiAwO1xuXHRcdGNvbnN0IGZsb2F0RnJhZ21lbnRUZXh0dXJlcyA9IGlzV2ViR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuXHRcdGNvbnN0IGZsb2F0VmVydGV4VGV4dHVyZXMgPSB2ZXJ0ZXhUZXh0dXJlcyAmJiBmbG9hdEZyYWdtZW50VGV4dHVyZXM7XG5cdFx0Y29uc3QgbWF4U2FtcGxlcyA9IGlzV2ViR0wyID8gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9TQU1QTEVTKSA6IDA7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlzV2ViR0wyOiBpc1dlYkdMMixcblx0XHRcdGRyYXdCdWZmZXJzOiBkcmF3QnVmZmVycyxcblx0XHRcdGdldE1heEFuaXNvdHJvcHk6IGdldE1heEFuaXNvdHJvcHksXG5cdFx0XHRnZXRNYXhQcmVjaXNpb246IGdldE1heFByZWNpc2lvbixcblx0XHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxuXHRcdFx0bG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblx0XHRcdG1heFRleHR1cmVzOiBtYXhUZXh0dXJlcyxcblx0XHRcdG1heFZlcnRleFRleHR1cmVzOiBtYXhWZXJ0ZXhUZXh0dXJlcyxcblx0XHRcdG1heFRleHR1cmVTaXplOiBtYXhUZXh0dXJlU2l6ZSxcblx0XHRcdG1heEN1YmVtYXBTaXplOiBtYXhDdWJlbWFwU2l6ZSxcblx0XHRcdG1heEF0dHJpYnV0ZXM6IG1heEF0dHJpYnV0ZXMsXG5cdFx0XHRtYXhWZXJ0ZXhVbmlmb3JtczogbWF4VmVydGV4VW5pZm9ybXMsXG5cdFx0XHRtYXhWYXJ5aW5nczogbWF4VmFyeWluZ3MsXG5cdFx0XHRtYXhGcmFnbWVudFVuaWZvcm1zOiBtYXhGcmFnbWVudFVuaWZvcm1zLFxuXHRcdFx0dmVydGV4VGV4dHVyZXM6IHZlcnRleFRleHR1cmVzLFxuXHRcdFx0ZmxvYXRGcmFnbWVudFRleHR1cmVzOiBmbG9hdEZyYWdtZW50VGV4dHVyZXMsXG5cdFx0XHRmbG9hdFZlcnRleFRleHR1cmVzOiBmbG9hdFZlcnRleFRleHR1cmVzLFxuXHRcdFx0bWF4U2FtcGxlczogbWF4U2FtcGxlc1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTENsaXBwaW5nKHByb3BlcnRpZXMpIHtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0bGV0IGdsb2JhbFN0YXRlID0gbnVsbCxcblx0XHRcdFx0bnVtR2xvYmFsUGxhbmVzID0gMCxcblx0XHRcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcblx0XHRcdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xuXHRcdGNvbnN0IHBsYW5lID0gbmV3IFBsYW5lKCksXG5cdFx0XHRcdFx0dmlld05vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCksXG5cdFx0XHRcdFx0dW5pZm9ybSA9IHtcblx0XHRcdHZhbHVlOiBudWxsLFxuXHRcdFx0bmVlZHNVcGRhdGU6IGZhbHNlXG5cdFx0fTtcblx0XHR0aGlzLnVuaWZvcm0gPSB1bmlmb3JtO1xuXHRcdHRoaXMubnVtUGxhbmVzID0gMDtcblx0XHR0aGlzLm51bUludGVyc2VjdGlvbiA9IDA7XG5cblx0XHR0aGlzLmluaXQgPSBmdW5jdGlvbiAocGxhbmVzLCBlbmFibGVMb2NhbENsaXBwaW5nLCBjYW1lcmEpIHtcblx0XHRcdGNvbnN0IGVuYWJsZWQgPSBwbGFuZXMubGVuZ3RoICE9PSAwIHx8IGVuYWJsZUxvY2FsQ2xpcHBpbmcgfHwgLy8gZW5hYmxlIHN0YXRlIG9mIHByZXZpb3VzIGZyYW1lIC0gdGhlIGNsaXBwaW5nIGNvZGUgaGFzIHRvXG5cdFx0XHQvLyBydW4gYW5vdGhlciBmcmFtZSBpbiBvcmRlciB0byByZXNldCB0aGUgc3RhdGU6XG5cdFx0XHRudW1HbG9iYWxQbGFuZXMgIT09IDAgfHwgbG9jYWxDbGlwcGluZ0VuYWJsZWQ7XG5cdFx0XHRsb2NhbENsaXBwaW5nRW5hYmxlZCA9IGVuYWJsZUxvY2FsQ2xpcHBpbmc7XG5cdFx0XHRnbG9iYWxTdGF0ZSA9IHByb2plY3RQbGFuZXMocGxhbmVzLCBjYW1lcmEsIDApO1xuXHRcdFx0bnVtR2xvYmFsUGxhbmVzID0gcGxhbmVzLmxlbmd0aDtcblx0XHRcdHJldHVybiBlbmFibGVkO1xuXHRcdH07XG5cblx0XHR0aGlzLmJlZ2luU2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbmRlcmluZ1NoYWRvd3MgPSB0cnVlO1xuXHRcdFx0cHJvamVjdFBsYW5lcyhudWxsKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5lbmRTaGFkb3dzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xuXHRcdFx0cmVzZXRHbG9iYWxTdGF0ZSgpO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFN0YXRlID0gZnVuY3Rpb24gKG1hdGVyaWFsLCBjYW1lcmEsIHVzZUNhY2hlKSB7XG5cdFx0XHRjb25zdCBwbGFuZXMgPSBtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcyxcblx0XHRcdFx0XHRcdGNsaXBJbnRlcnNlY3Rpb24gPSBtYXRlcmlhbC5jbGlwSW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRcdFx0Y2xpcFNoYWRvd3MgPSBtYXRlcmlhbC5jbGlwU2hhZG93cztcblx0XHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKTtcblxuXHRcdFx0aWYgKCFsb2NhbENsaXBwaW5nRW5hYmxlZCB8fCBwbGFuZXMgPT09IG51bGwgfHwgcGxhbmVzLmxlbmd0aCA9PT0gMCB8fCByZW5kZXJpbmdTaGFkb3dzICYmICFjbGlwU2hhZG93cykge1xuXHRcdFx0XHQvLyB0aGVyZSdzIG5vIGxvY2FsIGNsaXBwaW5nXG5cdFx0XHRcdGlmIChyZW5kZXJpbmdTaGFkb3dzKSB7XG5cdFx0XHRcdFx0Ly8gdGhlcmUncyBubyBnbG9iYWwgY2xpcHBpbmdcblx0XHRcdFx0XHRwcm9qZWN0UGxhbmVzKG51bGwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc2V0R2xvYmFsU3RhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qgbkdsb2JhbCA9IHJlbmRlcmluZ1NoYWRvd3MgPyAwIDogbnVtR2xvYmFsUGxhbmVzLFxuXHRcdFx0XHRcdFx0XHRsR2xvYmFsID0gbkdsb2JhbCAqIDQ7XG5cdFx0XHRcdGxldCBkc3RBcnJheSA9IG1hdGVyaWFsUHJvcGVydGllcy5jbGlwcGluZ1N0YXRlIHx8IG51bGw7XG5cdFx0XHRcdHVuaWZvcm0udmFsdWUgPSBkc3RBcnJheTsgLy8gZW5zdXJlIHVuaXF1ZSBzdGF0ZVxuXG5cdFx0XHRcdGRzdEFycmF5ID0gcHJvamVjdFBsYW5lcyhwbGFuZXMsIGNhbWVyYSwgbEdsb2JhbCwgdXNlQ2FjaGUpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBsR2xvYmFsOyArK2kpIHtcblx0XHRcdFx0XHRkc3RBcnJheVtpXSA9IGdsb2JhbFN0YXRlW2ldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmNsaXBwaW5nU3RhdGUgPSBkc3RBcnJheTtcblx0XHRcdFx0dGhpcy5udW1JbnRlcnNlY3Rpb24gPSBjbGlwSW50ZXJzZWN0aW9uID8gdGhpcy5udW1QbGFuZXMgOiAwO1xuXHRcdFx0XHR0aGlzLm51bVBsYW5lcyArPSBuR2xvYmFsO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNldEdsb2JhbFN0YXRlKCkge1xuXHRcdFx0aWYgKHVuaWZvcm0udmFsdWUgIT09IGdsb2JhbFN0YXRlKSB7XG5cdFx0XHRcdHVuaWZvcm0udmFsdWUgPSBnbG9iYWxTdGF0ZTtcblx0XHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IG51bUdsb2JhbFBsYW5lcyA+IDA7XG5cdFx0XHR9XG5cblx0XHRcdHNjb3BlLm51bVBsYW5lcyA9IG51bUdsb2JhbFBsYW5lcztcblx0XHRcdHNjb3BlLm51bUludGVyc2VjdGlvbiA9IDA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHJvamVjdFBsYW5lcyhwbGFuZXMsIGNhbWVyYSwgZHN0T2Zmc2V0LCBza2lwVHJhbnNmb3JtKSB7XG5cdFx0XHRjb25zdCBuUGxhbmVzID0gcGxhbmVzICE9PSBudWxsID8gcGxhbmVzLmxlbmd0aCA6IDA7XG5cdFx0XHRsZXQgZHN0QXJyYXkgPSBudWxsO1xuXG5cdFx0XHRpZiAoblBsYW5lcyAhPT0gMCkge1xuXHRcdFx0XHRkc3RBcnJheSA9IHVuaWZvcm0udmFsdWU7XG5cblx0XHRcdFx0aWYgKHNraXBUcmFuc2Zvcm0gIT09IHRydWUgfHwgZHN0QXJyYXkgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjb25zdCBmbGF0U2l6ZSA9IGRzdE9mZnNldCArIG5QbGFuZXMgKiA0LFxuXHRcdFx0XHRcdFx0XHRcdHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuXHRcdFx0XHRcdHZpZXdOb3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KHZpZXdNYXRyaXgpO1xuXG5cdFx0XHRcdFx0aWYgKGRzdEFycmF5ID09PSBudWxsIHx8IGRzdEFycmF5Lmxlbmd0aCA8IGZsYXRTaXplKSB7XG5cdFx0XHRcdFx0XHRkc3RBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdFNpemUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpNCA9IGRzdE9mZnNldDsgaSAhPT0gblBsYW5lczsgKytpLCBpNCArPSA0KSB7XG5cdFx0XHRcdFx0XHRwbGFuZS5jb3B5KHBsYW5lc1tpXSkuYXBwbHlNYXRyaXg0KHZpZXdNYXRyaXgsIHZpZXdOb3JtYWxNYXRyaXgpO1xuXHRcdFx0XHRcdFx0cGxhbmUubm9ybWFsLnRvQXJyYXkoZHN0QXJyYXksIGk0KTtcblx0XHRcdFx0XHRcdGRzdEFycmF5W2k0ICsgM10gPSBwbGFuZS5jb25zdGFudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7XG5cdFx0XHRcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzY29wZS5udW1QbGFuZXMgPSBuUGxhbmVzO1xuXHRcdFx0c2NvcGUubnVtSW50ZXJzZWN0aW9uID0gMDtcblx0XHRcdHJldHVybiBkc3RBcnJheTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEN1YmVNYXBzKHJlbmRlcmVyKSB7XG5cdFx0bGV0IGN1YmVtYXBzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdGZ1bmN0aW9uIG1hcFRleHR1cmVNYXBwaW5nKHRleHR1cmUsIG1hcHBpbmcpIHtcblx0XHRcdGlmIChtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZykge1xuXHRcdFx0XHR0ZXh0dXJlLm1hcHBpbmcgPSBDdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG5cdFx0XHR9IGVsc2UgaWYgKG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nKSB7XG5cdFx0XHRcdHRleHR1cmUubWFwcGluZyA9IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0KHRleHR1cmUpIHtcblx0XHRcdGlmICh0ZXh0dXJlICYmIHRleHR1cmUuaXNUZXh0dXJlICYmIHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSkge1xuXHRcdFx0XHRjb25zdCBtYXBwaW5nID0gdGV4dHVyZS5tYXBwaW5nO1xuXG5cdFx0XHRcdGlmIChtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZykge1xuXHRcdFx0XHRcdGlmIChjdWJlbWFwcy5oYXModGV4dHVyZSkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGN1YmVtYXAgPSBjdWJlbWFwcy5nZXQodGV4dHVyZSkudGV4dHVyZTtcblx0XHRcdFx0XHRcdHJldHVybiBtYXBUZXh0dXJlTWFwcGluZyhjdWJlbWFwLCB0ZXh0dXJlLm1hcHBpbmcpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cblx0XHRcdFx0XHRcdGlmIChpbWFnZSAmJiBpbWFnZS5oZWlnaHQgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMQ3ViZVJlbmRlclRhcmdldChpbWFnZS5oZWlnaHQgLyAyKTtcblx0XHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0LmZyb21FcXVpcmVjdGFuZ3VsYXJUZXh0dXJlKHJlbmRlcmVyLCB0ZXh0dXJlKTtcblx0XHRcdFx0XHRcdFx0Y3ViZW1hcHMuc2V0KHRleHR1cmUsIHJlbmRlclRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChjdXJyZW50UmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBtYXBUZXh0dXJlTWFwcGluZyhyZW5kZXJUYXJnZXQudGV4dHVyZSwgdGV4dHVyZS5tYXBwaW5nKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIGltYWdlIG5vdCB5ZXQgcmVhZHkuIHRyeSB0aGUgY29udmVyc2lvbiBuZXh0IGZyYW1lXG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKGV2ZW50KSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSk7XG5cdFx0XHRjb25zdCBjdWJlbWFwID0gY3ViZW1hcHMuZ2V0KHRleHR1cmUpO1xuXG5cdFx0XHRpZiAoY3ViZW1hcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGN1YmVtYXBzLmRlbGV0ZSh0ZXh0dXJlKTtcblx0XHRcdFx0Y3ViZW1hcC5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdGN1YmVtYXBzID0gbmV3IFdlYWtNYXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdFx0fTtcblx0fVxuXG5cdGNsYXNzIE9ydGhvZ3JhcGhpY0NhbWVyYSBleHRlbmRzIENhbWVyYSB7XG5cdFx0Y29uc3RydWN0b3IobGVmdCA9IC0xLCByaWdodCA9IDEsIHRvcCA9IDEsIGJvdHRvbSA9IC0xLCBuZWFyID0gMC4xLCBmYXIgPSAyMDAwKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XG5cdFx0XHR0aGlzLnpvb20gPSAxO1xuXHRcdFx0dGhpcy52aWV3ID0gbnVsbDtcblx0XHRcdHRoaXMubGVmdCA9IGxlZnQ7XG5cdFx0XHR0aGlzLnJpZ2h0ID0gcmlnaHQ7XG5cdFx0XHR0aGlzLnRvcCA9IHRvcDtcblx0XHRcdHRoaXMuYm90dG9tID0gYm90dG9tO1xuXHRcdFx0dGhpcy5uZWFyID0gbmVhcjtcblx0XHRcdHRoaXMuZmFyID0gZmFyO1xuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0XHR0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcblx0XHRcdHRoaXMucmlnaHQgPSBzb3VyY2UucmlnaHQ7XG5cdFx0XHR0aGlzLnRvcCA9IHNvdXJjZS50b3A7XG5cdFx0XHR0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XG5cdFx0XHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcblx0XHRcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcblx0XHRcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXHRcdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLnZpZXcpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0Vmlld09mZnNldChmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRcdGlmICh0aGlzLnZpZXcgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy52aWV3ID0ge1xuXHRcdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdFx0ZnVsbFdpZHRoOiAxLFxuXHRcdFx0XHRcdGZ1bGxIZWlnaHQ6IDEsXG5cdFx0XHRcdFx0b2Zmc2V0WDogMCxcblx0XHRcdFx0XHRvZmZzZXRZOiAwLFxuXHRcdFx0XHRcdHdpZHRoOiAxLFxuXHRcdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XG5cdFx0XHR0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuXHRcdFx0dGhpcy52aWV3LmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xuXHRcdFx0dGhpcy52aWV3Lm9mZnNldFggPSB4O1xuXHRcdFx0dGhpcy52aWV3Lm9mZnNldFkgPSB5O1xuXHRcdFx0dGhpcy52aWV3LndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0fVxuXG5cdFx0Y2xlYXJWaWV3T2Zmc2V0KCkge1xuXHRcdFx0aWYgKHRoaXMudmlldyAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHR9XG5cblx0XHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkge1xuXHRcdFx0Y29uc3QgZHggPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCkgLyAoMiAqIHRoaXMuem9vbSk7XG5cdFx0XHRjb25zdCBkeSA9ICh0aGlzLnRvcCAtIHRoaXMuYm90dG9tKSAvICgyICogdGhpcy56b29tKTtcblx0XHRcdGNvbnN0IGN4ID0gKHRoaXMucmlnaHQgKyB0aGlzLmxlZnQpIC8gMjtcblx0XHRcdGNvbnN0IGN5ID0gKHRoaXMudG9wICsgdGhpcy5ib3R0b20pIC8gMjtcblx0XHRcdGxldCBsZWZ0ID0gY3ggLSBkeDtcblx0XHRcdGxldCByaWdodCA9IGN4ICsgZHg7XG5cdFx0XHRsZXQgdG9wID0gY3kgKyBkeTtcblx0XHRcdGxldCBib3R0b20gPSBjeSAtIGR5O1xuXG5cdFx0XHRpZiAodGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkKSB7XG5cdFx0XHRcdGNvbnN0IHNjYWxlVyA9ICh0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0KSAvIHRoaXMudmlldy5mdWxsV2lkdGggLyB0aGlzLnpvb207XG5cdFx0XHRcdGNvbnN0IHNjYWxlSCA9ICh0aGlzLnRvcCAtIHRoaXMuYm90dG9tKSAvIHRoaXMudmlldy5mdWxsSGVpZ2h0IC8gdGhpcy56b29tO1xuXHRcdFx0XHRsZWZ0ICs9IHNjYWxlVyAqIHRoaXMudmlldy5vZmZzZXRYO1xuXHRcdFx0XHRyaWdodCA9IGxlZnQgKyBzY2FsZVcgKiB0aGlzLnZpZXcud2lkdGg7XG5cdFx0XHRcdHRvcCAtPSBzY2FsZUggKiB0aGlzLnZpZXcub2Zmc2V0WTtcblx0XHRcdFx0Ym90dG9tID0gdG9wIC0gc2NhbGVIICogdGhpcy52aWV3LmhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcblx0XHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSh0aGlzLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpO1xuXHRcdH1cblxuXHRcdHRvSlNPTihtZXRhKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblx0XHRcdGRhdGEub2JqZWN0LmxlZnQgPSB0aGlzLmxlZnQ7XG5cdFx0XHRkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XG5cdFx0XHRkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcblx0XHRcdGRhdGEub2JqZWN0LmJvdHRvbSA9IHRoaXMuYm90dG9tO1xuXHRcdFx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcblx0XHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXHRcdFx0aWYgKHRoaXMudmlldyAhPT0gbnVsbCkgZGF0YS5vYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudmlldyk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0fVxuXG5cdE9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuaXNPcnRob2dyYXBoaWNDYW1lcmEgPSB0cnVlO1xuXG5cdGNsYXNzIFJhd1NoYWRlck1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKHBhcmFtZXRlcnMpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcblx0XHR9XG5cblx0fVxuXG5cdFJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5pc1Jhd1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcblxuXHRjb25zdCBMT0RfTUlOID0gNDtcblx0Y29uc3QgTE9EX01BWCA9IDg7XG5cdGNvbnN0IFNJWkVfTUFYID0gTWF0aC5wb3coMiwgTE9EX01BWCk7IC8vIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25zIChyYWRpYW5zKSBhc3NvY2lhdGVkIHdpdGggdGhlIGV4dHJhIG1pcHMuIFRoZXNlIGFyZVxuXHQvLyBjaG9zZW4gdG8gYXBwcm94aW1hdGUgYSBUcm93YnJpZGdlLVJlaXR6IGRpc3RyaWJ1dGlvbiBmdW5jdGlvbiB0aW1lcyB0aGVcblx0Ly8gZ2VvbWV0cmljIHNoYWRvd2luZyBmdW5jdGlvbi4gVGhlc2Ugc2lnbWEgdmFsdWVzIHNxdWFyZWQgbXVzdCBtYXRjaCB0aGVcblx0Ly8gdmFyaWFuY2UgI2RlZmluZXMgaW4gY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50Lmdsc2wuanMuXG5cblx0Y29uc3QgRVhUUkFfTE9EX1NJR01BID0gWzAuMTI1LCAwLjIxNSwgMC4zNSwgMC40NDYsIDAuNTI2LCAwLjU4Ml07XG5cdGNvbnN0IFRPVEFMX0xPRFMgPSBMT0RfTUFYIC0gTE9EX01JTiArIDEgKyBFWFRSQV9MT0RfU0lHTUEubGVuZ3RoOyAvLyBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIGJsdXIgZm9yIGxvb3AuIFNtYWxsZXIgc2lnbWFzIHdpbGwgdXNlIGZld2VyXG5cdC8vIHNhbXBsZXMgYW5kIGV4aXQgZWFybHksIGJ1dCBub3QgcmVjb21waWxlIHRoZSBzaGFkZXIuXG5cblx0Y29uc3QgTUFYX1NBTVBMRVMgPSAyMDtcblx0Y29uc3QgRU5DT0RJTkdTID0ge1xuXHRcdFtMaW5lYXJFbmNvZGluZ106IDAsXG5cdFx0W3NSR0JFbmNvZGluZ106IDEsXG5cdFx0W1JHQkVFbmNvZGluZ106IDIsXG5cdFx0W1JHQk03RW5jb2RpbmddOiAzLFxuXHRcdFtSR0JNMTZFbmNvZGluZ106IDQsXG5cdFx0W1JHQkRFbmNvZGluZ106IDUsXG5cdFx0W0dhbW1hRW5jb2RpbmddOiA2XG5cdH07XG5cdGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0c2lkZTogQmFja1NpZGUsXG5cdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0ZGVwdGhUZXN0OiBmYWxzZVxuXHR9KTtcblx0Y29uc3QgYmFja2dyb3VuZEJveCA9IG5ldyBNZXNoKG5ldyBCb3hHZW9tZXRyeSgpLCBiYWNrZ3JvdW5kTWF0ZXJpYWwpO1xuXG5cdGNvbnN0IF9mbGF0Q2FtZXJhID0gLypAX19QVVJFX18qL25ldyBPcnRob2dyYXBoaWNDYW1lcmEoKTtcblxuXHRjb25zdCB7XG5cdFx0X2xvZFBsYW5lcyxcblx0XHRfc2l6ZUxvZHMsXG5cdFx0X3NpZ21hc1xuXHR9ID0gLypAX19QVVJFX18qL19jcmVhdGVQbGFuZXMoKTtcblxuXHRjb25zdCBfY2xlYXJDb2xvciA9IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoKTtcblxuXHRsZXQgX29sZFRhcmdldCA9IG51bGw7IC8vIEdvbGRlbiBSYXRpb1xuXG5cdGNvbnN0IFBISSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5cdGNvbnN0IElOVl9QSEkgPSAxIC8gUEhJOyAvLyBWZXJ0aWNlcyBvZiBhIGRvZGVjYWhlZHJvbiAoZXhjZXB0IHRoZSBvcHBvc2l0ZXMsIHdoaWNoIHJlcHJlc2VudCB0aGVcblx0Ly8gc2FtZSBheGlzKSwgdXNlZCBhcyBheGlzIGRpcmVjdGlvbnMgZXZlbmx5IHNwcmVhZCBvbiBhIHNwaGVyZS5cblxuXHRjb25zdCBfYXhpc0RpcmVjdGlvbnMgPSBbLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDEsIDEsIDEpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoLTEsIDEsIDEpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoMSwgMSwgLTEpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoLTEsIDEsIC0xKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDAsIFBISSwgSU5WX1BISSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCBQSEksIC1JTlZfUEhJKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKElOVl9QSEksIDAsIFBISSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygtSU5WX1BISSwgMCwgUEhJKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKFBISSwgSU5WX1BISSwgMCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygtUEhJLCBJTlZfUEhJLCAwKV07XG5cdC8qKlxuXHQgKiBUaGlzIGNsYXNzIGdlbmVyYXRlcyBhIFByZWZpbHRlcmVkLCBNaXBtYXBwZWQgUmFkaWFuY2UgRW52aXJvbm1lbnQgTWFwXG5cdCAqIChQTVJFTSkgZnJvbSBhIGN1YmVNYXAgZW52aXJvbm1lbnQgdGV4dHVyZS4gVGhpcyBhbGxvd3MgZGlmZmVyZW50IGxldmVscyBvZlxuXHQgKiBibHVyIHRvIGJlIHF1aWNrbHkgYWNjZXNzZWQgYmFzZWQgb24gbWF0ZXJpYWwgcm91Z2huZXNzLiBJdCBpcyBwYWNrZWQgaW50byBhXG5cdCAqIHNwZWNpYWwgQ3ViZVVWIGZvcm1hdCB0aGF0IGFsbG93cyB1cyB0byBwZXJmb3JtIGN1c3RvbSBpbnRlcnBvbGF0aW9uIHNvIHRoYXRcblx0ICogd2UgY2FuIHN1cHBvcnQgbm9ubGluZWFyIGZvcm1hdHMgc3VjaCBhcyBSR0JFLiBVbmxpa2UgYSB0cmFkaXRpb25hbCBtaXBtYXBcblx0ICogY2hhaW4sIGl0IG9ubHkgZ29lcyBkb3duIHRvIHRoZSBMT0RfTUlOIGxldmVsIChhYm92ZSksIGFuZCB0aGVuIGNyZWF0ZXMgZXh0cmFcblx0ICogZXZlbiBtb3JlIGZpbHRlcmVkICdtaXBzJyBhdCB0aGUgc2FtZSBMT0RfTUlOIHJlc29sdXRpb24sIGFzc29jaWF0ZWQgd2l0aFxuXHQgKiBoaWdoZXIgcm91Z2huZXNzIGxldmVscy4gSW4gdGhpcyB3YXkgd2UgbWFpbnRhaW4gcmVzb2x1dGlvbiB0byBzbW9vdGhseVxuXHQgKiBpbnRlcnBvbGF0ZSBkaWZmdXNlIGxpZ2h0aW5nIHdoaWxlIGxpbWl0aW5nIHNhbXBsaW5nIGNvbXB1dGF0aW9uLlxuXHQgKlxuXHQgKiBQYXBlcjogRmFzdCwgQWNjdXJhdGUgSW1hZ2UtQmFzZWQgTGlnaHRpbmdcblx0ICogaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xNXk4cl9VcEtsVTlTdlY0SUxiMEMzcUNQZWNTOHB2THovdmlld1xuXHQqL1xuXG5cdGZ1bmN0aW9uIGNvbnZlcnRMaW5lYXJUb1JHQkUoY29sb3IpIHtcblx0XHRjb25zdCBtYXhDb21wb25lbnQgPSBNYXRoLm1heChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblx0XHRjb25zdCBmRXhwID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5jZWlsKE1hdGgubG9nMihtYXhDb21wb25lbnQpKSwgLTEyOC4wKSwgMTI3LjApO1xuXHRcdGNvbG9yLm11bHRpcGx5U2NhbGFyKE1hdGgucG93KDIuMCwgLWZFeHApKTtcblx0XHRjb25zdCBhbHBoYSA9IChmRXhwICsgMTI4LjApIC8gMjU1LjA7XG5cdFx0cmV0dXJuIGFscGhhO1xuXHR9XG5cblx0Y2xhc3MgUE1SRU1HZW5lcmF0b3Ige1xuXHRcdGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdFx0dGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgPSBudWxsO1xuXHRcdFx0dGhpcy5fYmx1ck1hdGVyaWFsID0gX2dldEJsdXJTaGFkZXIoTUFYX1NBTVBMRVMpO1xuXHRcdFx0dGhpcy5fZXF1aXJlY3RTaGFkZXIgPSBudWxsO1xuXHRcdFx0dGhpcy5fY3ViZW1hcFNoYWRlciA9IG51bGw7XG5cblx0XHRcdHRoaXMuX2NvbXBpbGVNYXRlcmlhbCh0aGlzLl9ibHVyTWF0ZXJpYWwpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGEgc3VwcGxpZWQgU2NlbmUsIHdoaWNoIGNhbiBiZSBmYXN0ZXIgdGhhbiB1c2luZyBhblxuXHRcdCAqIGltYWdlIGlmIG5ldHdvcmtpbmcgYmFuZHdpZHRoIGlzIGxvdy4gT3B0aW9uYWwgc2lnbWEgc3BlY2lmaWVzIGEgYmx1ciByYWRpdXNcblx0XHQgKiBpbiByYWRpYW5zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNjZW5lIGJlZm9yZSBQTVJFTSBnZW5lcmF0aW9uLiBPcHRpb25hbCBuZWFyXG5cdFx0ICogYW5kIGZhciBwbGFuZXMgZW5zdXJlIHRoZSBzY2VuZSBpcyByZW5kZXJlZCBpbiBpdHMgZW50aXJldHkgKHRoZSBjdWJlQ2FtZXJhXG5cdFx0ICogaXMgcGxhY2VkIGF0IHRoZSBvcmlnaW4pLlxuXHRcdCAqL1xuXG5cblx0XHRmcm9tU2NlbmUoc2NlbmUsIHNpZ21hID0gMCwgbmVhciA9IDAuMSwgZmFyID0gMTAwKSB7XG5cdFx0XHRfb2xkVGFyZ2V0ID0gdGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cblx0XHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xuXG5cdFx0XHR0aGlzLl9zY2VuZVRvQ3ViZVVWKHNjZW5lLCBuZWFyLCBmYXIsIGN1YmVVVlJlbmRlclRhcmdldCk7XG5cblx0XHRcdGlmIChzaWdtYSA+IDApIHtcblx0XHRcdFx0dGhpcy5fYmx1cihjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIHNpZ21hKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYXBwbHlQTVJFTShjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHR0aGlzLl9jbGVhbnVwKGN1YmVVVlJlbmRlclRhcmdldCk7XG5cblx0XHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYXRlcyBhIFBNUkVNIGZyb20gYW4gZXF1aXJlY3Rhbmd1bGFyIHRleHR1cmUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgTERSXG5cdFx0ICogKFJHQkZvcm1hdCkgb3IgSERSIChSR0JFRm9ybWF0KS4gVGhlIGlkZWFsIGlucHV0IGltYWdlIHNpemUgaXMgMWsgKDEwMjQgeCA1MTIpLFxuXHRcdCAqIGFzIHRoaXMgbWF0Y2hlcyBiZXN0IHdpdGggdGhlIDI1NiB4IDI1NiBjdWJlbWFwIG91dHB1dC5cblx0XHQgKi9cblxuXG5cdFx0ZnJvbUVxdWlyZWN0YW5ndWxhcihlcXVpcmVjdGFuZ3VsYXIpIHtcblx0XHRcdHJldHVybiB0aGlzLl9mcm9tVGV4dHVyZShlcXVpcmVjdGFuZ3VsYXIpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGN1YmVtYXAgdGV4dHVyZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBMRFJcblx0XHQgKiAoUkdCRm9ybWF0KSBvciBIRFIgKFJHQkVGb3JtYXQpLiBUaGUgaWRlYWwgaW5wdXQgY3ViZSBzaXplIGlzIDI1NiB4IDI1Nixcblx0XHQgKiBhcyB0aGlzIG1hdGNoZXMgYmVzdCB3aXRoIHRoZSAyNTYgeCAyNTYgY3ViZW1hcCBvdXRwdXQuXG5cdFx0ICovXG5cblxuXHRcdGZyb21DdWJlbWFwKGN1YmVtYXApIHtcblx0XHRcdHJldHVybiB0aGlzLl9mcm9tVGV4dHVyZShjdWJlbWFwKTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogUHJlLWNvbXBpbGVzIHRoZSBjdWJlbWFwIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xuXHRcdCAqIHlvdXIgdGV4dHVyZSdzIG5ldHdvcmsgZmV0Y2ggZm9yIGluY3JlYXNlZCBjb25jdXJyZW5jeS5cblx0XHQgKi9cblxuXG5cdFx0Y29tcGlsZUN1YmVtYXBTaGFkZXIoKSB7XG5cdFx0XHRpZiAodGhpcy5fY3ViZW1hcFNoYWRlciA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9jdWJlbWFwU2hhZGVyID0gX2dldEN1YmVtYXBTaGFkZXIoKTtcblxuXHRcdFx0XHR0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fY3ViZW1hcFNoYWRlcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFByZS1jb21waWxlcyB0aGUgZXF1aXJlY3Rhbmd1bGFyIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xuXHRcdCAqIHlvdXIgdGV4dHVyZSdzIG5ldHdvcmsgZmV0Y2ggZm9yIGluY3JlYXNlZCBjb25jdXJyZW5jeS5cblx0XHQgKi9cblxuXG5cdFx0Y29tcGlsZUVxdWlyZWN0YW5ndWxhclNoYWRlcigpIHtcblx0XHRcdGlmICh0aGlzLl9lcXVpcmVjdFNoYWRlciA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9lcXVpcmVjdFNoYWRlciA9IF9nZXRFcXVpcmVjdFNoYWRlcigpO1xuXG5cdFx0XHRcdHRoaXMuX2NvbXBpbGVNYXRlcmlhbCh0aGlzLl9lcXVpcmVjdFNoYWRlcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIERpc3Bvc2VzIG9mIHRoZSBQTVJFTUdlbmVyYXRvcidzIGludGVybmFsIG1lbW9yeS4gTm90ZSB0aGF0IFBNUkVNR2VuZXJhdG9yIGlzIGEgc3RhdGljIGNsYXNzLFxuXHRcdCAqIHNvIHlvdSBzaG91bGQgbm90IG5lZWQgbW9yZSB0aGFuIG9uZSBQTVJFTUdlbmVyYXRvciBvYmplY3QuIElmIHlvdSBkbywgY2FsbGluZyBkaXNwb3NlKCkgb25cblx0XHQgKiBvbmUgb2YgdGhlbSB3aWxsIGNhdXNlIGFueSBvdGhlcnMgdG8gYWxzbyBiZWNvbWUgdW51c2FibGUuXG5cdFx0ICovXG5cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLl9ibHVyTWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdFx0XHRpZiAodGhpcy5fY3ViZW1hcFNoYWRlciAhPT0gbnVsbCkgdGhpcy5fY3ViZW1hcFNoYWRlci5kaXNwb3NlKCk7XG5cdFx0XHRpZiAodGhpcy5fZXF1aXJlY3RTaGFkZXIgIT09IG51bGwpIHRoaXMuX2VxdWlyZWN0U2hhZGVyLmRpc3Bvc2UoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBfbG9kUGxhbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdF9sb2RQbGFuZXNbaV0uZGlzcG9zZSgpO1xuXHRcdFx0fVxuXHRcdH0gLy8gcHJpdmF0ZSBpbnRlcmZhY2VcblxuXG5cdFx0X2NsZWFudXAob3V0cHV0VGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC5kaXNwb3NlKCk7XG5cblx0XHRcdHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChfb2xkVGFyZ2V0KTtcblxuXHRcdFx0b3V0cHV0VGFyZ2V0LnNjaXNzb3JUZXN0ID0gZmFsc2U7XG5cblx0XHRcdF9zZXRWaWV3cG9ydChvdXRwdXRUYXJnZXQsIDAsIDAsIG91dHB1dFRhcmdldC53aWR0aCwgb3V0cHV0VGFyZ2V0LmhlaWdodCk7XG5cdFx0fVxuXG5cdFx0X2Zyb21UZXh0dXJlKHRleHR1cmUpIHtcblx0XHRcdF9vbGRUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblxuXHRcdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gdGhpcy5fYWxsb2NhdGVUYXJnZXRzKHRleHR1cmUpO1xuXG5cdFx0XHR0aGlzLl90ZXh0dXJlVG9DdWJlVVYodGV4dHVyZSwgY3ViZVVWUmVuZGVyVGFyZ2V0KTtcblxuXHRcdFx0dGhpcy5fYXBwbHlQTVJFTShjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHR0aGlzLl9jbGVhbnVwKGN1YmVVVlJlbmRlclRhcmdldCk7XG5cblx0XHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cdFx0fVxuXG5cdFx0X2FsbG9jYXRlVGFyZ2V0cyh0ZXh0dXJlKSB7XG5cdFx0XHQvLyB3YXJuaW5nOiBudWxsIHRleHR1cmUgaXMgdmFsaWRcblx0XHRcdGNvbnN0IHBhcmFtcyA9IHtcblx0XHRcdFx0bWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuXHRcdFx0XHRtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwczogZmFsc2UsXG5cdFx0XHRcdHR5cGU6IFVuc2lnbmVkQnl0ZVR5cGUsXG5cdFx0XHRcdGZvcm1hdDogUkdCRUZvcm1hdCxcblx0XHRcdFx0ZW5jb2Rpbmc6IF9pc0xEUih0ZXh0dXJlKSA/IHRleHR1cmUuZW5jb2RpbmcgOiBSR0JFRW5jb2RpbmcsXG5cdFx0XHRcdGRlcHRoQnVmZmVyOiBmYWxzZVxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gX2NyZWF0ZVJlbmRlclRhcmdldChwYXJhbXMpO1xuXG5cdFx0XHRjdWJlVVZSZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPSB0ZXh0dXJlID8gZmFsc2UgOiB0cnVlO1xuXHRcdFx0dGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgPSBfY3JlYXRlUmVuZGVyVGFyZ2V0KHBhcmFtcyk7XG5cdFx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuXHRcdH1cblxuXHRcdF9jb21waWxlTWF0ZXJpYWwobWF0ZXJpYWwpIHtcblx0XHRcdGNvbnN0IHRtcE1lc2ggPSBuZXcgTWVzaChfbG9kUGxhbmVzWzBdLCBtYXRlcmlhbCk7XG5cblx0XHRcdHRoaXMuX3JlbmRlcmVyLmNvbXBpbGUodG1wTWVzaCwgX2ZsYXRDYW1lcmEpO1xuXHRcdH1cblxuXHRcdF9zY2VuZVRvQ3ViZVVWKHNjZW5lLCBuZWFyLCBmYXIsIGN1YmVVVlJlbmRlclRhcmdldCkge1xuXHRcdFx0Y29uc3QgZm92ID0gOTA7XG5cdFx0XHRjb25zdCBhc3BlY3QgPSAxO1xuXHRcdFx0Y29uc3QgY3ViZUNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRcdGNvbnN0IHVwU2lnbiA9IFsxLCAtMSwgMSwgMSwgMSwgMV07XG5cdFx0XHRjb25zdCBmb3J3YXJkU2lnbiA9IFsxLCAxLCAxLCAtMSwgLTEsIC0xXTtcblx0XHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG5cdFx0XHRjb25zdCBvcmlnaW5hbEF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcblx0XHRcdGNvbnN0IG91dHB1dEVuY29kaW5nID0gcmVuZGVyZXIub3V0cHV0RW5jb2Rpbmc7XG5cdFx0XHRjb25zdCB0b25lTWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xuXHRcdFx0cmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcihfY2xlYXJDb2xvcik7XG5cdFx0XHRyZW5kZXJlci50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG5cdFx0XHRyZW5kZXJlci5vdXRwdXRFbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xuXHRcdFx0cmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XG5cdFx0XHRsZXQgdXNlU29saWRDb2xvciA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG5cblx0XHRcdGlmIChiYWNrZ3JvdW5kKSB7XG5cdFx0XHRcdGlmIChiYWNrZ3JvdW5kLmlzQ29sb3IpIHtcblx0XHRcdFx0XHRiYWNrZ3JvdW5kTWF0ZXJpYWwuY29sb3IuY29weShiYWNrZ3JvdW5kKS5jb252ZXJ0U1JHQlRvTGluZWFyKCk7XG5cdFx0XHRcdFx0c2NlbmUuYmFja2dyb3VuZCA9IG51bGw7XG5cdFx0XHRcdFx0Y29uc3QgYWxwaGEgPSBjb252ZXJ0TGluZWFyVG9SR0JFKGJhY2tncm91bmRNYXRlcmlhbC5jb2xvcik7XG5cdFx0XHRcdFx0YmFja2dyb3VuZE1hdGVyaWFsLm9wYWNpdHkgPSBhbHBoYTtcblx0XHRcdFx0XHR1c2VTb2xpZENvbG9yID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YmFja2dyb3VuZE1hdGVyaWFsLmNvbG9yLmNvcHkoX2NsZWFyQ29sb3IpLmNvbnZlcnRTUkdCVG9MaW5lYXIoKTtcblx0XHRcdFx0Y29uc3QgYWxwaGEgPSBjb252ZXJ0TGluZWFyVG9SR0JFKGJhY2tncm91bmRNYXRlcmlhbC5jb2xvcik7XG5cdFx0XHRcdGJhY2tncm91bmRNYXRlcmlhbC5vcGFjaXR5ID0gYWxwaGE7XG5cdFx0XHRcdHVzZVNvbGlkQ29sb3IgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRjb25zdCBjb2wgPSBpICUgMztcblxuXHRcdFx0XHRpZiAoY29sID09IDApIHtcblx0XHRcdFx0XHRjdWJlQ2FtZXJhLnVwLnNldCgwLCB1cFNpZ25baV0sIDApO1xuXHRcdFx0XHRcdGN1YmVDYW1lcmEubG9va0F0KGZvcndhcmRTaWduW2ldLCAwLCAwKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjb2wgPT0gMSkge1xuXHRcdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KDAsIDAsIHVwU2lnbltpXSk7XG5cdFx0XHRcdFx0Y3ViZUNhbWVyYS5sb29rQXQoMCwgZm9yd2FyZFNpZ25baV0sIDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KDAsIHVwU2lnbltpXSwgMCk7XG5cdFx0XHRcdFx0Y3ViZUNhbWVyYS5sb29rQXQoMCwgMCwgZm9yd2FyZFNpZ25baV0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3NldFZpZXdwb3J0KGN1YmVVVlJlbmRlclRhcmdldCwgY29sICogU0laRV9NQVgsIGkgPiAyID8gU0laRV9NQVggOiAwLCBTSVpFX01BWCwgU0laRV9NQVgpO1xuXG5cdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRcdGlmICh1c2VTb2xpZENvbG9yKSB7XG5cdFx0XHRcdFx0cmVuZGVyZXIucmVuZGVyKGJhY2tncm91bmRCb3gsIGN1YmVDYW1lcmEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjdWJlQ2FtZXJhKTtcblx0XHRcdH1cblxuXHRcdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSB0b25lTWFwcGluZztcblx0XHRcdHJlbmRlcmVyLm91dHB1dEVuY29kaW5nID0gb3V0cHV0RW5jb2Rpbmc7XG5cdFx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBvcmlnaW5hbEF1dG9DbGVhcjtcblx0XHR9XG5cblx0XHRfdGV4dHVyZVRvQ3ViZVVWKHRleHR1cmUsIGN1YmVVVlJlbmRlclRhcmdldCkge1xuXHRcdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdFx0aWYgKHRleHR1cmUuaXNDdWJlVGV4dHVyZSkge1xuXHRcdFx0XHRpZiAodGhpcy5fY3ViZW1hcFNoYWRlciA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fY3ViZW1hcFNoYWRlciA9IF9nZXRDdWJlbWFwU2hhZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9lcXVpcmVjdFNoYWRlciA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fZXF1aXJlY3RTaGFkZXIgPSBfZ2V0RXF1aXJlY3RTaGFkZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IHRleHR1cmUuaXNDdWJlVGV4dHVyZSA/IHRoaXMuX2N1YmVtYXBTaGFkZXIgOiB0aGlzLl9lcXVpcmVjdFNoYWRlcjtcblx0XHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaChfbG9kUGxhbmVzWzBdLCBtYXRlcmlhbCk7XG5cdFx0XHRjb25zdCB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuXHRcdFx0dW5pZm9ybXNbJ2Vudk1hcCddLnZhbHVlID0gdGV4dHVyZTtcblxuXHRcdFx0aWYgKCF0ZXh0dXJlLmlzQ3ViZVRleHR1cmUpIHtcblx0XHRcdFx0dW5pZm9ybXNbJ3RleGVsU2l6ZSddLnZhbHVlLnNldCgxLjAgLyB0ZXh0dXJlLmltYWdlLndpZHRoLCAxLjAgLyB0ZXh0dXJlLmltYWdlLmhlaWdodCk7XG5cdFx0XHR9XG5cblx0XHRcdHVuaWZvcm1zWydpbnB1dEVuY29kaW5nJ10udmFsdWUgPSBFTkNPRElOR1NbdGV4dHVyZS5lbmNvZGluZ107XG5cdFx0XHR1bmlmb3Jtc1snb3V0cHV0RW5jb2RpbmcnXS52YWx1ZSA9IEVOQ09ESU5HU1tjdWJlVVZSZW5kZXJUYXJnZXQudGV4dHVyZS5lbmNvZGluZ107XG5cblx0XHRcdF9zZXRWaWV3cG9ydChjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIDMgKiBTSVpFX01BWCwgMiAqIFNJWkVfTUFYKTtcblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1YmVVVlJlbmRlclRhcmdldCk7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIobWVzaCwgX2ZsYXRDYW1lcmEpO1xuXHRcdH1cblxuXHRcdF9hcHBseVBNUkVNKGN1YmVVVlJlbmRlclRhcmdldCkge1xuXHRcdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblx0XHRcdGNvbnN0IGF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcblx0XHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IFRPVEFMX0xPRFM7IGkrKykge1xuXHRcdFx0XHRjb25zdCBzaWdtYSA9IE1hdGguc3FydChfc2lnbWFzW2ldICogX3NpZ21hc1tpXSAtIF9zaWdtYXNbaSAtIDFdICogX3NpZ21hc1tpIC0gMV0pO1xuXHRcdFx0XHRjb25zdCBwb2xlQXhpcyA9IF9heGlzRGlyZWN0aW9uc1soaSAtIDEpICUgX2F4aXNEaXJlY3Rpb25zLmxlbmd0aF07XG5cblx0XHRcdFx0dGhpcy5fYmx1cihjdWJlVVZSZW5kZXJUYXJnZXQsIGkgLSAxLCBpLCBzaWdtYSwgcG9sZUF4aXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgYSB0d28tcGFzcyBHYXVzc2lhbiBibHVyIGZvciBhIGN1YmVtYXAuIE5vcm1hbGx5IHRoaXMgaXMgZG9uZVxuXHRcdCAqIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSwgYnV0IHRoaXMgYnJlYWtzIGRvd24gb24gYSBjdWJlLiBIZXJlIHdlIGFwcGx5XG5cdFx0ICogdGhlIGJsdXIgbGF0aXR1ZGluYWxseSAoYXJvdW5kIHRoZSBwb2xlcyksIGFuZCB0aGVuIGxvbmdpdHVkaW5hbGx5ICh0b3dhcmRzXG5cdFx0ICogdGhlIHBvbGVzKSB0byBhcHByb3hpbWF0ZSB0aGUgb3J0aG9nb25hbGx5LXNlcGFyYWJsZSBibHVyLiBJdCBpcyBsZWFzdFxuXHRcdCAqIGFjY3VyYXRlIGF0IHRoZSBwb2xlcywgYnV0IHN0aWxsIGRvZXMgYSBkZWNlbnQgam9iLlxuXHRcdCAqL1xuXG5cblx0XHRfYmx1cihjdWJlVVZSZW5kZXJUYXJnZXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hLCBwb2xlQXhpcykge1xuXHRcdFx0Y29uc3QgcGluZ1BvbmdSZW5kZXJUYXJnZXQgPSB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldDtcblxuXHRcdFx0dGhpcy5faGFsZkJsdXIoY3ViZVVWUmVuZGVyVGFyZ2V0LCBwaW5nUG9uZ1JlbmRlclRhcmdldCwgbG9kSW4sIGxvZE91dCwgc2lnbWEsICdsYXRpdHVkaW5hbCcsIHBvbGVBeGlzKTtcblxuXHRcdFx0dGhpcy5faGFsZkJsdXIocGluZ1BvbmdSZW5kZXJUYXJnZXQsIGN1YmVVVlJlbmRlclRhcmdldCwgbG9kT3V0LCBsb2RPdXQsIHNpZ21hLCAnbG9uZ2l0dWRpbmFsJywgcG9sZUF4aXMpO1xuXHRcdH1cblxuXHRcdF9oYWxmQmx1cih0YXJnZXRJbiwgdGFyZ2V0T3V0LCBsb2RJbiwgbG9kT3V0LCBzaWdtYVJhZGlhbnMsIGRpcmVjdGlvbiwgcG9sZUF4aXMpIHtcblx0XHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG5cdFx0XHRjb25zdCBibHVyTWF0ZXJpYWwgPSB0aGlzLl9ibHVyTWF0ZXJpYWw7XG5cblx0XHRcdGlmIChkaXJlY3Rpb24gIT09ICdsYXRpdHVkaW5hbCcgJiYgZGlyZWN0aW9uICE9PSAnbG9uZ2l0dWRpbmFsJykge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdibHVyIGRpcmVjdGlvbiBtdXN0IGJlIGVpdGhlciBsYXRpdHVkaW5hbCBvciBsb25naXR1ZGluYWwhJyk7XG5cdFx0XHR9IC8vIE51bWJlciBvZiBzdGFuZGFyZCBkZXZpYXRpb25zIGF0IHdoaWNoIHRvIGN1dCBvZmYgdGhlIGRpc2NyZXRlIGFwcHJveGltYXRpb24uXG5cblxuXHRcdFx0Y29uc3QgU1RBTkRBUkRfREVWSUFUSU9OUyA9IDM7XG5cdFx0XHRjb25zdCBibHVyTWVzaCA9IG5ldyBNZXNoKF9sb2RQbGFuZXNbbG9kT3V0XSwgYmx1ck1hdGVyaWFsKTtcblx0XHRcdGNvbnN0IGJsdXJVbmlmb3JtcyA9IGJsdXJNYXRlcmlhbC51bmlmb3Jtcztcblx0XHRcdGNvbnN0IHBpeGVscyA9IF9zaXplTG9kc1tsb2RJbl0gLSAxO1xuXHRcdFx0Y29uc3QgcmFkaWFuc1BlclBpeGVsID0gaXNGaW5pdGUoc2lnbWFSYWRpYW5zKSA/IE1hdGguUEkgLyAoMiAqIHBpeGVscykgOiAyICogTWF0aC5QSSAvICgyICogTUFYX1NBTVBMRVMgLSAxKTtcblx0XHRcdGNvbnN0IHNpZ21hUGl4ZWxzID0gc2lnbWFSYWRpYW5zIC8gcmFkaWFuc1BlclBpeGVsO1xuXHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGlzRmluaXRlKHNpZ21hUmFkaWFucykgPyAxICsgTWF0aC5mbG9vcihTVEFOREFSRF9ERVZJQVRJT05TICogc2lnbWFQaXhlbHMpIDogTUFYX1NBTVBMRVM7XG5cblx0XHRcdGlmIChzYW1wbGVzID4gTUFYX1NBTVBMRVMpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBzaWdtYVJhZGlhbnMsICR7c2lnbWFSYWRpYW5zfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke3NhbXBsZXN9IHNhbXBsZXMgd2hlbiB0aGUgbWF4aW11bSBpcyBzZXQgdG8gJHtNQVhfU0FNUExFU31gKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgd2VpZ2h0cyA9IFtdO1xuXHRcdFx0bGV0IHN1bSA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX1NBTVBMRVM7ICsraSkge1xuXHRcdFx0XHRjb25zdCB4ID0gaSAvIHNpZ21hUGl4ZWxzO1xuXHRcdFx0XHRjb25zdCB3ZWlnaHQgPSBNYXRoLmV4cCgteCAqIHggLyAyKTtcblx0XHRcdFx0d2VpZ2h0cy5wdXNoKHdlaWdodCk7XG5cblx0XHRcdFx0aWYgKGkgPT0gMCkge1xuXHRcdFx0XHRcdHN1bSArPSB3ZWlnaHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA8IHNhbXBsZXMpIHtcblx0XHRcdFx0XHRzdW0gKz0gMiAqIHdlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0d2VpZ2h0c1tpXSA9IHdlaWdodHNbaV0gLyBzdW07XG5cdFx0XHR9XG5cblx0XHRcdGJsdXJVbmlmb3Jtc1snZW52TWFwJ10udmFsdWUgPSB0YXJnZXRJbi50ZXh0dXJlO1xuXHRcdFx0Ymx1clVuaWZvcm1zWydzYW1wbGVzJ10udmFsdWUgPSBzYW1wbGVzO1xuXHRcdFx0Ymx1clVuaWZvcm1zWyd3ZWlnaHRzJ10udmFsdWUgPSB3ZWlnaHRzO1xuXHRcdFx0Ymx1clVuaWZvcm1zWydsYXRpdHVkaW5hbCddLnZhbHVlID0gZGlyZWN0aW9uID09PSAnbGF0aXR1ZGluYWwnO1xuXG5cdFx0XHRpZiAocG9sZUF4aXMpIHtcblx0XHRcdFx0Ymx1clVuaWZvcm1zWydwb2xlQXhpcyddLnZhbHVlID0gcG9sZUF4aXM7XG5cdFx0XHR9XG5cblx0XHRcdGJsdXJVbmlmb3Jtc1snZFRoZXRhJ10udmFsdWUgPSByYWRpYW5zUGVyUGl4ZWw7XG5cdFx0XHRibHVyVW5pZm9ybXNbJ21pcEludCddLnZhbHVlID0gTE9EX01BWCAtIGxvZEluO1xuXHRcdFx0Ymx1clVuaWZvcm1zWydpbnB1dEVuY29kaW5nJ10udmFsdWUgPSBFTkNPRElOR1NbdGFyZ2V0SW4udGV4dHVyZS5lbmNvZGluZ107XG5cdFx0XHRibHVyVW5pZm9ybXNbJ291dHB1dEVuY29kaW5nJ10udmFsdWUgPSBFTkNPRElOR1NbdGFyZ2V0SW4udGV4dHVyZS5lbmNvZGluZ107XG5cdFx0XHRjb25zdCBvdXRwdXRTaXplID0gX3NpemVMb2RzW2xvZE91dF07XG5cdFx0XHRjb25zdCB4ID0gMyAqIE1hdGgubWF4KDAsIFNJWkVfTUFYIC0gMiAqIG91dHB1dFNpemUpO1xuXHRcdFx0Y29uc3QgeSA9IChsb2RPdXQgPT09IDAgPyAwIDogMiAqIFNJWkVfTUFYKSArIDIgKiBvdXRwdXRTaXplICogKGxvZE91dCA+IExPRF9NQVggLSBMT0RfTUlOID8gbG9kT3V0IC0gTE9EX01BWCArIExPRF9NSU4gOiAwKTtcblxuXHRcdFx0X3NldFZpZXdwb3J0KHRhcmdldE91dCwgeCwgeSwgMyAqIG91dHB1dFNpemUsIDIgKiBvdXRwdXRTaXplKTtcblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRhcmdldE91dCk7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoYmx1ck1lc2gsIF9mbGF0Q2FtZXJhKTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9pc0xEUih0ZXh0dXJlKSB7XG5cdFx0aWYgKHRleHR1cmUgPT09IHVuZGVmaW5lZCB8fCB0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdGV4dHVyZS5lbmNvZGluZyA9PT0gTGluZWFyRW5jb2RpbmcgfHwgdGV4dHVyZS5lbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nIHx8IHRleHR1cmUuZW5jb2RpbmcgPT09IEdhbW1hRW5jb2Rpbmc7XG5cdH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlUGxhbmVzKCkge1xuXHRcdGNvbnN0IF9sb2RQbGFuZXMgPSBbXTtcblx0XHRjb25zdCBfc2l6ZUxvZHMgPSBbXTtcblx0XHRjb25zdCBfc2lnbWFzID0gW107XG5cdFx0bGV0IGxvZCA9IExPRF9NQVg7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IFRPVEFMX0xPRFM7IGkrKykge1xuXHRcdFx0Y29uc3Qgc2l6ZUxvZCA9IE1hdGgucG93KDIsIGxvZCk7XG5cblx0XHRcdF9zaXplTG9kcy5wdXNoKHNpemVMb2QpO1xuXG5cdFx0XHRsZXQgc2lnbWEgPSAxLjAgLyBzaXplTG9kO1xuXG5cdFx0XHRpZiAoaSA+IExPRF9NQVggLSBMT0RfTUlOKSB7XG5cdFx0XHRcdHNpZ21hID0gRVhUUkFfTE9EX1NJR01BW2kgLSBMT0RfTUFYICsgTE9EX01JTiAtIDFdO1xuXHRcdFx0fSBlbHNlIGlmIChpID09IDApIHtcblx0XHRcdFx0c2lnbWEgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRfc2lnbWFzLnB1c2goc2lnbWEpO1xuXG5cdFx0XHRjb25zdCB0ZXhlbFNpemUgPSAxLjAgLyAoc2l6ZUxvZCAtIDEpO1xuXHRcdFx0Y29uc3QgbWluID0gLXRleGVsU2l6ZSAvIDI7XG5cdFx0XHRjb25zdCBtYXggPSAxICsgdGV4ZWxTaXplIC8gMjtcblx0XHRcdGNvbnN0IHV2MSA9IFttaW4sIG1pbiwgbWF4LCBtaW4sIG1heCwgbWF4LCBtaW4sIG1pbiwgbWF4LCBtYXgsIG1pbiwgbWF4XTtcblx0XHRcdGNvbnN0IGN1YmVGYWNlcyA9IDY7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IDY7XG5cdFx0XHRjb25zdCBwb3NpdGlvblNpemUgPSAzO1xuXHRcdFx0Y29uc3QgdXZTaXplID0gMjtcblx0XHRcdGNvbnN0IGZhY2VJbmRleFNpemUgPSAxO1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uU2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzKTtcblx0XHRcdGNvbnN0IHV2ID0gbmV3IEZsb2F0MzJBcnJheSh1dlNpemUgKiB2ZXJ0aWNlcyAqIGN1YmVGYWNlcyk7XG5cdFx0XHRjb25zdCBmYWNlSW5kZXggPSBuZXcgRmxvYXQzMkFycmF5KGZhY2VJbmRleFNpemUgKiB2ZXJ0aWNlcyAqIGN1YmVGYWNlcyk7XG5cblx0XHRcdGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgY3ViZUZhY2VzOyBmYWNlKyspIHtcblx0XHRcdFx0Y29uc3QgeCA9IGZhY2UgJSAzICogMiAvIDMgLSAxO1xuXHRcdFx0XHRjb25zdCB5ID0gZmFjZSA+IDIgPyAwIDogLTE7XG5cdFx0XHRcdGNvbnN0IGNvb3JkaW5hdGVzID0gW3gsIHksIDAsIHggKyAyIC8gMywgeSwgMCwgeCArIDIgLyAzLCB5ICsgMSwgMCwgeCwgeSwgMCwgeCArIDIgLyAzLCB5ICsgMSwgMCwgeCwgeSArIDEsIDBdO1xuXHRcdFx0XHRwb3NpdGlvbi5zZXQoY29vcmRpbmF0ZXMsIHBvc2l0aW9uU2l6ZSAqIHZlcnRpY2VzICogZmFjZSk7XG5cdFx0XHRcdHV2LnNldCh1djEsIHV2U2l6ZSAqIHZlcnRpY2VzICogZmFjZSk7XG5cdFx0XHRcdGNvbnN0IGZpbGwgPSBbZmFjZSwgZmFjZSwgZmFjZSwgZmFjZSwgZmFjZSwgZmFjZV07XG5cdFx0XHRcdGZhY2VJbmRleC5zZXQoZmlsbCwgZmFjZUluZGV4U2l6ZSAqIHZlcnRpY2VzICogZmFjZSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBsYW5lcyA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0cGxhbmVzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBwb3NpdGlvblNpemUpKTtcblx0XHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSh1diwgdXZTaXplKSk7XG5cdFx0XHRwbGFuZXMuc2V0QXR0cmlidXRlKCdmYWNlSW5kZXgnLCBuZXcgQnVmZmVyQXR0cmlidXRlKGZhY2VJbmRleCwgZmFjZUluZGV4U2l6ZSkpO1xuXG5cdFx0XHRfbG9kUGxhbmVzLnB1c2gocGxhbmVzKTtcblxuXHRcdFx0aWYgKGxvZCA+IExPRF9NSU4pIHtcblx0XHRcdFx0bG9kLS07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdF9sb2RQbGFuZXMsXG5cdFx0XHRfc2l6ZUxvZHMsXG5cdFx0XHRfc2lnbWFzXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVSZW5kZXJUYXJnZXQocGFyYW1zKSB7XG5cdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDMgKiBTSVpFX01BWCwgMyAqIFNJWkVfTUFYLCBwYXJhbXMpO1xuXHRcdGN1YmVVVlJlbmRlclRhcmdldC50ZXh0dXJlLm1hcHBpbmcgPSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZztcblx0XHRjdWJlVVZSZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gJ1BNUkVNLmN1YmVVdic7XG5cdFx0Y3ViZVVWUmVuZGVyVGFyZ2V0LnNjaXNzb3JUZXN0ID0gdHJ1ZTtcblx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gX3NldFZpZXdwb3J0KHRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRhcmdldC52aWV3cG9ydC5zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0dGFyZ2V0LnNjaXNzb3Iuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2dldEJsdXJTaGFkZXIobWF4U2FtcGxlcykge1xuXHRcdGNvbnN0IHdlaWdodHMgPSBuZXcgRmxvYXQzMkFycmF5KG1heFNhbXBsZXMpO1xuXHRcdGNvbnN0IHBvbGVBeGlzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG5cdFx0Y29uc3Qgc2hhZGVyTWF0ZXJpYWwgPSBuZXcgUmF3U2hhZGVyTWF0ZXJpYWwoe1xuXHRcdFx0bmFtZTogJ1NwaGVyaWNhbEdhdXNzaWFuQmx1cicsXG5cdFx0XHRkZWZpbmVzOiB7XG5cdFx0XHRcdCduJzogbWF4U2FtcGxlc1xuXHRcdFx0fSxcblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdCdlbnZNYXAnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdFx0fSxcblx0XHRcdFx0J3NhbXBsZXMnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdFx0fSxcblx0XHRcdFx0J3dlaWdodHMnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHdlaWdodHNcblx0XHRcdFx0fSxcblx0XHRcdFx0J2xhdGl0dWRpbmFsJzoge1xuXHRcdFx0XHRcdHZhbHVlOiBmYWxzZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnZFRoZXRhJzoge1xuXHRcdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdtaXBJbnQnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0fSxcblx0XHRcdFx0J3BvbGVBeGlzJzoge1xuXHRcdFx0XHRcdHZhbHVlOiBwb2xlQXhpc1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQnaW5wdXRFbmNvZGluZyc6IHtcblx0XHRcdFx0XHR2YWx1ZTogRU5DT0RJTkdTW0xpbmVhckVuY29kaW5nXVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnb3V0cHV0RW5jb2RpbmcnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IEVOQ09ESU5HU1tMaW5lYXJFbmNvZGluZ11cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHZlcnRleFNoYWRlcjogX2dldENvbW1vblZlcnRleFNoYWRlcigpLFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6XG5cdFx0XHQvKiBnbHNsICovXG5cdFx0XHRgXG5cblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcblxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xuXHRcdFx0dW5pZm9ybSBpbnQgc2FtcGxlcztcblx0XHRcdHVuaWZvcm0gZmxvYXQgd2VpZ2h0c1sgbiBdO1xuXHRcdFx0dW5pZm9ybSBib29sIGxhdGl0dWRpbmFsO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCBkVGhldGE7XG5cdFx0XHR1bmlmb3JtIGZsb2F0IG1pcEludDtcblx0XHRcdHVuaWZvcm0gdmVjMyBwb2xlQXhpcztcblxuXHRcdFx0JHtfZ2V0RW5jb2RpbmdzKCl9XG5cblx0XHRcdCNkZWZpbmUgRU5WTUFQX1RZUEVfQ1VCRV9VVlxuXHRcdFx0I2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cblxuXHRcdFx0dmVjMyBnZXRTYW1wbGUoIGZsb2F0IHRoZXRhLCB2ZWMzIGF4aXMgKSB7XG5cblx0XHRcdFx0ZmxvYXQgY29zVGhldGEgPSBjb3MoIHRoZXRhICk7XG5cdFx0XHRcdC8vIFJvZHJpZ3VlcycgYXhpcy1hbmdsZSByb3RhdGlvblxuXHRcdFx0XHR2ZWMzIHNhbXBsZURpcmVjdGlvbiA9IHZPdXRwdXREaXJlY3Rpb24gKiBjb3NUaGV0YVxuXHRcdFx0XHRcdCsgY3Jvc3MoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqIHNpbiggdGhldGEgKVxuXHRcdFx0XHRcdCsgYXhpcyAqIGRvdCggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogKCAxLjAgLSBjb3NUaGV0YSApO1xuXG5cdFx0XHRcdHJldHVybiBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXJlY3Rpb24sIG1pcEludCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHR2ZWMzIGF4aXMgPSBsYXRpdHVkaW5hbCA/IHBvbGVBeGlzIDogY3Jvc3MoIHBvbGVBeGlzLCB2T3V0cHV0RGlyZWN0aW9uICk7XG5cblx0XHRcdFx0aWYgKCBhbGwoIGVxdWFsKCBheGlzLCB2ZWMzKCAwLjAgKSApICkgKSB7XG5cblx0XHRcdFx0XHRheGlzID0gdmVjMyggdk91dHB1dERpcmVjdGlvbi56LCAwLjAsIC0gdk91dHB1dERpcmVjdGlvbi54ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGF4aXMgPSBub3JtYWxpemUoIGF4aXMgKTtcblxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyAwIF0gKiBnZXRTYW1wbGUoIDAuMCwgYXhpcyApO1xuXG5cdFx0XHRcdGZvciAoIGludCBpID0gMTsgaSA8IG47IGkrKyApIHtcblxuXHRcdFx0XHRcdGlmICggaSA+PSBzYW1wbGVzICkge1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZsb2F0IHRoZXRhID0gZFRoZXRhICogZmxvYXQoIGkgKTtcblx0XHRcdFx0XHRnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggLTEuMCAqIHRoZXRhLCBheGlzICk7XG5cdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIHRoZXRhLCBheGlzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1xuXG5cdFx0XHR9XG5cdFx0YCxcblx0XHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlXG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNoYWRlck1hdGVyaWFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2dldEVxdWlyZWN0U2hhZGVyKCkge1xuXHRcdGNvbnN0IHRleGVsU2l6ZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuXHRcdGNvbnN0IHNoYWRlck1hdGVyaWFsID0gbmV3IFJhd1NoYWRlck1hdGVyaWFsKHtcblx0XHRcdG5hbWU6ICdFcXVpcmVjdGFuZ3VsYXJUb0N1YmVVVicsXG5cdFx0XHR1bmlmb3Jtczoge1xuXHRcdFx0XHQnZW52TWFwJzoge1xuXHRcdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCd0ZXhlbFNpemUnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHRleGVsU2l6ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnaW5wdXRFbmNvZGluZyc6IHtcblx0XHRcdFx0XHR2YWx1ZTogRU5DT0RJTkdTW0xpbmVhckVuY29kaW5nXVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnb3V0cHV0RW5jb2RpbmcnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IEVOQ09ESU5HU1tMaW5lYXJFbmNvZGluZ11cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHZlcnRleFNoYWRlcjogX2dldENvbW1vblZlcnRleFNoYWRlcigpLFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6XG5cdFx0XHQvKiBnbHNsICovXG5cdFx0XHRgXG5cblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcblxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xuXHRcdFx0dW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuXHRcdFx0JHtfZ2V0RW5jb2RpbmdzKCl9XG5cblx0XHRcdCNpbmNsdWRlIDxjb21tb24+XG5cblx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcblxuXHRcdFx0XHR2ZWMzIG91dHB1dERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdk91dHB1dERpcmVjdGlvbiApO1xuXHRcdFx0XHR2ZWMyIHV2ID0gZXF1aXJlY3RVdiggb3V0cHV0RGlyZWN0aW9uICk7XG5cblx0XHRcdFx0dmVjMiBmID0gZnJhY3QoIHV2IC8gdGV4ZWxTaXplIC0gMC41ICk7XG5cdFx0XHRcdHV2IC09IGYgKiB0ZXhlbFNpemU7XG5cdFx0XHRcdHZlYzMgdGwgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQgKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XG5cdFx0XHRcdHV2LnggKz0gdGV4ZWxTaXplLng7XG5cdFx0XHRcdHZlYzMgdHIgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQgKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XG5cdFx0XHRcdHV2LnkgKz0gdGV4ZWxTaXplLnk7XG5cdFx0XHRcdHZlYzMgYnIgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQgKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XG5cdFx0XHRcdHV2LnggLT0gdGV4ZWxTaXplLng7XG5cdFx0XHRcdHZlYzMgYmwgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQgKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XG5cblx0XHRcdFx0dmVjMyB0bSA9IG1peCggdGwsIHRyLCBmLnggKTtcblx0XHRcdFx0dmVjMyBibSA9IG1peCggYmwsIGJyLCBmLnggKTtcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggdG0sIGJtLCBmLnkgKTtcblxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTtcblxuXHRcdFx0fVxuXHRcdGAsXG5cdFx0XHRibGVuZGluZzogTm9CbGVuZGluZyxcblx0XHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZVxuXHRcdH0pO1xuXHRcdHJldHVybiBzaGFkZXJNYXRlcmlhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIF9nZXRDdWJlbWFwU2hhZGVyKCkge1xuXHRcdGNvbnN0IHNoYWRlck1hdGVyaWFsID0gbmV3IFJhd1NoYWRlck1hdGVyaWFsKHtcblx0XHRcdG5hbWU6ICdDdWJlbWFwVG9DdWJlVVYnLFxuXHRcdFx0dW5pZm9ybXM6IHtcblx0XHRcdFx0J2Vudk1hcCc6IHtcblx0XHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnaW5wdXRFbmNvZGluZyc6IHtcblx0XHRcdFx0XHR2YWx1ZTogRU5DT0RJTkdTW0xpbmVhckVuY29kaW5nXVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnb3V0cHV0RW5jb2RpbmcnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IEVOQ09ESU5HU1tMaW5lYXJFbmNvZGluZ11cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHZlcnRleFNoYWRlcjogX2dldENvbW1vblZlcnRleFNoYWRlcigpLFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6XG5cdFx0XHQvKiBnbHNsICovXG5cdFx0XHRgXG5cblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcblxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XG5cblx0XHRcdCR7X2dldEVuY29kaW5ncygpfVxuXG5cdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCAtIHZPdXRwdXREaXJlY3Rpb24ueCwgdk91dHB1dERpcmVjdGlvbi55eiApICkgKS5yZ2I7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1xuXG5cdFx0XHR9XG5cdFx0YCxcblx0XHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlXG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNoYWRlck1hdGVyaWFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2dldENvbW1vblZlcnRleFNoYWRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0LyogZ2xzbCAqL1xuXHRcdFx0YFxuXG5cdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuXG5cdFx0YXR0cmlidXRlIHZlYzMgcG9zaXRpb247XG5cdFx0YXR0cmlidXRlIHZlYzIgdXY7XG5cdFx0YXR0cmlidXRlIGZsb2F0IGZhY2VJbmRleDtcblxuXHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0Ly8gUkggY29vcmRpbmF0ZSBzeXN0ZW07IFBNUkVNIGZhY2UtaW5kZXhpbmcgY29udmVudGlvblxuXHRcdHZlYzMgZ2V0RGlyZWN0aW9uKCB2ZWMyIHV2LCBmbG9hdCBmYWNlICkge1xuXG5cdFx0XHR1diA9IDIuMCAqIHV2IC0gMS4wO1xuXG5cdFx0XHR2ZWMzIGRpcmVjdGlvbiA9IHZlYzMoIHV2LCAxLjAgKTtcblxuXHRcdFx0aWYgKCBmYWNlID09IDAuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4OyAvLyAoIDEsIHYsIHUgKSBwb3MgeFxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDEuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24ueHp5O1xuXHRcdFx0XHRkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtdSwgMSwgLXYgKSBwb3MgeVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDIuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24ueCAqPSAtMS4wOyAvLyAoIC11LCB2LCAxICkgcG9zIHpcblxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSA9PSAzLjAgKSB7XG5cblx0XHRcdFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnp5eDtcblx0XHRcdFx0ZGlyZWN0aW9uLnh6ICo9IC0xLjA7IC8vICggLTEsIHYsIC11ICkgbmVnIHhcblxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSA9PSA0LjAgKSB7XG5cblx0XHRcdFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnh6eTtcblx0XHRcdFx0ZGlyZWN0aW9uLnh5ICo9IC0xLjA7IC8vICggLXUsIC0xLCB2ICkgbmVnIHlcblxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSA9PSA1LjAgKSB7XG5cblx0XHRcdFx0ZGlyZWN0aW9uLnogKj0gLTEuMDsgLy8gKCB1LCB2LCAtMSApIG5lZyB6XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRpcmVjdGlvbjtcblxuXHRcdH1cblxuXHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0dk91dHB1dERpcmVjdGlvbiA9IGdldERpcmVjdGlvbiggdXYsIGZhY2VJbmRleCApO1xuXHRcdFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG5cblx0XHR9XG5cdGBcblx0XHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2dldEVuY29kaW5ncygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0LyogZ2xzbCAqL1xuXHRcdFx0YFxuXG5cdFx0dW5pZm9ybSBpbnQgaW5wdXRFbmNvZGluZztcblx0XHR1bmlmb3JtIGludCBvdXRwdXRFbmNvZGluZztcblxuXHRcdCNpbmNsdWRlIDxlbmNvZGluZ3NfcGFyc19mcmFnbWVudD5cblxuXHRcdHZlYzQgaW5wdXRUZXhlbFRvTGluZWFyKCB2ZWM0IHZhbHVlICkge1xuXG5cdFx0XHRpZiAoIGlucHV0RW5jb2RpbmcgPT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGlucHV0RW5jb2RpbmcgPT0gMSApIHtcblxuXHRcdFx0XHRyZXR1cm4gc1JHQlRvTGluZWFyKCB2YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBpbnB1dEVuY29kaW5nID09IDIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIFJHQkVUb0xpbmVhciggdmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaW5wdXRFbmNvZGluZyA9PSAzICkge1xuXG5cdFx0XHRcdHJldHVybiBSR0JNVG9MaW5lYXIoIHZhbHVlLCA3LjAgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaW5wdXRFbmNvZGluZyA9PSA0ICkge1xuXG5cdFx0XHRcdHJldHVybiBSR0JNVG9MaW5lYXIoIHZhbHVlLCAxNi4wICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGlucHV0RW5jb2RpbmcgPT0gNSApIHtcblxuXHRcdFx0XHRyZXR1cm4gUkdCRFRvTGluZWFyKCB2YWx1ZSwgMjU2LjAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gR2FtbWFUb0xpbmVhciggdmFsdWUsIDIuMiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2ZWM0IGxpbmVhclRvT3V0cHV0VGV4ZWwoIHZlYzQgdmFsdWUgKSB7XG5cblx0XHRcdGlmICggb3V0cHV0RW5jb2RpbmcgPT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG91dHB1dEVuY29kaW5nID09IDEgKSB7XG5cblx0XHRcdFx0cmV0dXJuIExpbmVhclRvc1JHQiggdmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb3V0cHV0RW5jb2RpbmcgPT0gMiApIHtcblxuXHRcdFx0XHRyZXR1cm4gTGluZWFyVG9SR0JFKCB2YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvdXRwdXRFbmNvZGluZyA9PSAzICkge1xuXG5cdFx0XHRcdHJldHVybiBMaW5lYXJUb1JHQk0oIHZhbHVlLCA3LjAgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb3V0cHV0RW5jb2RpbmcgPT0gNCApIHtcblxuXHRcdFx0XHRyZXR1cm4gTGluZWFyVG9SR0JNKCB2YWx1ZSwgMTYuMCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvdXRwdXRFbmNvZGluZyA9PSA1ICkge1xuXG5cdFx0XHRcdHJldHVybiBMaW5lYXJUb1JHQkQoIHZhbHVlLCAyNTYuMCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBMaW5lYXJUb0dhbW1hKCB2YWx1ZSwgMi4yICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZlYzQgZW52TWFwVGV4ZWxUb0xpbmVhciggdmVjNCBjb2xvciApIHtcblxuXHRcdFx0cmV0dXJuIGlucHV0VGV4ZWxUb0xpbmVhciggY29sb3IgKTtcblxuXHRcdH1cblx0YFxuXHRcdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEN1YmVVVk1hcHMocmVuZGVyZXIpIHtcblx0XHRsZXQgY3ViZVVWbWFwcyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0bGV0IHBtcmVtR2VuZXJhdG9yID0gbnVsbDtcblxuXHRcdGZ1bmN0aW9uIGdldCh0ZXh0dXJlKSB7XG5cdFx0XHRpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzVGV4dHVyZSAmJiB0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29uc3QgbWFwcGluZyA9IHRleHR1cmUubWFwcGluZztcblx0XHRcdFx0Y29uc3QgaXNFcXVpcmVjdE1hcCA9IG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nIHx8IG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nO1xuXHRcdFx0XHRjb25zdCBpc0N1YmVNYXAgPSBtYXBwaW5nID09PSBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nO1xuXG5cdFx0XHRcdGlmIChpc0VxdWlyZWN0TWFwIHx8IGlzQ3ViZU1hcCkge1xuXHRcdFx0XHRcdC8vIGVxdWlyZWN0L2N1YmUgbWFwIHRvIGN1YmVVViBjb252ZXJzaW9uXG5cdFx0XHRcdFx0aWYgKGN1YmVVVm1hcHMuaGFzKHRleHR1cmUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY3ViZVVWbWFwcy5nZXQodGV4dHVyZSkudGV4dHVyZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG5cdFx0XHRcdFx0XHRpZiAoaXNFcXVpcmVjdE1hcCAmJiBpbWFnZSAmJiBpbWFnZS5oZWlnaHQgPiAwIHx8IGlzQ3ViZU1hcCAmJiBpbWFnZSAmJiBpc0N1YmVUZXh0dXJlQ29tcGxldGUoaW1hZ2UpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRcdFx0XHRcdFx0aWYgKHBtcmVtR2VuZXJhdG9yID09PSBudWxsKSBwbXJlbUdlbmVyYXRvciA9IG5ldyBQTVJFTUdlbmVyYXRvcihyZW5kZXJlcik7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IGlzRXF1aXJlY3RNYXAgPyBwbXJlbUdlbmVyYXRvci5mcm9tRXF1aXJlY3Rhbmd1bGFyKHRleHR1cmUpIDogcG1yZW1HZW5lcmF0b3IuZnJvbUN1YmVtYXAodGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRcdGN1YmVVVm1hcHMuc2V0KHRleHR1cmUsIHJlbmRlclRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChjdXJyZW50UmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIGltYWdlIG5vdCB5ZXQgcmVhZHkuIHRyeSB0aGUgY29udmVyc2lvbiBuZXh0IGZyYW1lXG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0N1YmVUZXh0dXJlQ29tcGxldGUoaW1hZ2UpIHtcblx0XHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XHRjb25zdCBsZW5ndGggPSA2O1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChpbWFnZVtpXSAhPT0gdW5kZWZpbmVkKSBjb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY291bnQgPT09IGxlbmd0aDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKGV2ZW50KSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSk7XG5cdFx0XHRjb25zdCBjdWJlbWFwVVYgPSBjdWJlVVZtYXBzLmdldCh0ZXh0dXJlKTtcblxuXHRcdFx0aWYgKGN1YmVtYXBVViAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGN1YmVtYXBVVi5kZWxldGUodGV4dHVyZSk7XG5cdFx0XHRcdGN1YmVtYXBVVi5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdGN1YmVVVm1hcHMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdFx0XHRpZiAocG1yZW1HZW5lcmF0b3IgIT09IG51bGwpIHtcblx0XHRcdFx0cG1yZW1HZW5lcmF0b3IuZGlzcG9zZSgpO1xuXHRcdFx0XHRwbXJlbUdlbmVyYXRvciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEV4dGVuc2lvbnMoZ2wpIHtcblx0XHRjb25zdCBleHRlbnNpb25zID0ge307XG5cblx0XHRmdW5jdGlvbiBnZXRFeHRlbnNpb24obmFtZSkge1xuXHRcdFx0aWYgKGV4dGVuc2lvbnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uc1tuYW1lXTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGV4dGVuc2lvbjtcblxuXHRcdFx0c3dpdGNoIChuYW1lKSB7XG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2RlcHRoX3RleHR1cmUnOlxuXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZGVwdGhfdGV4dHVyZScpIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcblx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpIHx8IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcblx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJykgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XG5cdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbihuYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0ZXh0ZW5zaW9uc1tuYW1lXSA9IGV4dGVuc2lvbjtcblx0XHRcdHJldHVybiBleHRlbnNpb247XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGhhczogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGdldEV4dGVuc2lvbihuYW1lKSAhPT0gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbiAoY2FwYWJpbGl0aWVzKSB7XG5cdFx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHtcblx0XHRcdFx0XHRnZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRnZXRFeHRlbnNpb24oJ1dFQkdMX2RlcHRoX3RleHR1cmUnKTtcblx0XHRcdFx0XHRnZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG5cdFx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG5cdFx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicpO1xuXHRcdFx0XHRcdGdldEV4dGVuc2lvbignT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyk7XG5cdFx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50Jyk7XG5cdFx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpO1xuXHRcdFx0XHRcdGdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKTtcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnKTtcblx0XHRcdH0sXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGdldEV4dGVuc2lvbihuYW1lKTtcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9uID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgbmFtZSArICcgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEdlb21ldHJpZXMoZ2wsIGF0dHJpYnV0ZXMsIGluZm8sIGJpbmRpbmdTdGF0ZXMpIHtcblx0XHRjb25zdCBnZW9tZXRyaWVzID0ge307XG5cdFx0Y29uc3Qgd2lyZWZyYW1lQXR0cmlidXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHRmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZShldmVudCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XG5cblx0XHRcdGlmIChnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRhdHRyaWJ1dGVzLnJlbW92ZShnZW9tZXRyeS5pbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKGdlb21ldHJ5LmF0dHJpYnV0ZXNbbmFtZV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UpO1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdO1xuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoZ2VvbWV0cnkpO1xuXG5cdFx0XHRpZiAoYXR0cmlidXRlKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKGF0dHJpYnV0ZSk7XG5cdFx0XHRcdHdpcmVmcmFtZUF0dHJpYnV0ZXMuZGVsZXRlKGdlb21ldHJ5KTtcblx0XHRcdH1cblxuXHRcdFx0YmluZGluZ1N0YXRlcy5yZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeShnZW9tZXRyeSk7XG5cblx0XHRcdGlmIChnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID09PSB0cnVlKSB7XG5cdFx0XHRcdGRlbGV0ZSBnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudDtcblx0XHRcdH0gLy9cblxuXG5cdFx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzLS07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0KG9iamVjdCwgZ2VvbWV0cnkpIHtcblx0XHRcdGlmIChnZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSA9PT0gdHJ1ZSkgcmV0dXJuIGdlb21ldHJ5O1xuXHRcdFx0Z2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlKTtcblx0XHRcdGdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdID0gdHJ1ZTtcblx0XHRcdGluZm8ubWVtb3J5Lmdlb21ldHJpZXMrKztcblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUoZ2VvbWV0cnkpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7IC8vIFVwZGF0aW5nIGluZGV4IGJ1ZmZlciBpbiBWQU8gbm93LiBTZWUgV2ViR0xCaW5kaW5nU3RhdGVzLlxuXG5cdFx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gZ2VvbWV0cnlBdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKGdlb21ldHJ5QXR0cmlidXRlc1tuYW1lXSwgZ2wuQVJSQVlfQlVGRkVSKTtcblx0XHRcdH0gLy8gbW9ycGggdGFyZ2V0c1xuXG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblxuXHRcdFx0Zm9yIChjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0XHRjb25zdCBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1tuYW1lXTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKGFycmF5W2ldLCBnbC5BUlJBWV9CVUZGRVIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KSB7XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCBnZW9tZXRyeUluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBnZW9tZXRyeVBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGxldCB2ZXJzaW9uID0gMDtcblxuXHRcdFx0aWYgKGdlb21ldHJ5SW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBnZW9tZXRyeUluZGV4LmFycmF5O1xuXHRcdFx0XHR2ZXJzaW9uID0gZ2VvbWV0cnlJbmRleC52ZXJzaW9uO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGFycmF5W2kgKyAwXTtcblx0XHRcdFx0XHRjb25zdCBiID0gYXJyYXlbaSArIDFdO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBhcnJheVtpICsgMl07XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGIsIGMsIGMsIGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBhcnJheSA9IGdlb21ldHJ5UG9zaXRpb24uYXJyYXk7XG5cdFx0XHRcdHZlcnNpb24gPSBnZW9tZXRyeVBvc2l0aW9uLnZlcnNpb247XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGggLyAzIC0gMTsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBpICsgMDtcblx0XHRcdFx0XHRjb25zdCBiID0gaSArIDE7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IGkgKyAyO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBiLCBjLCBjLCBhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBuZXcgKGFycmF5TWF4KGluZGljZXMpID4gNjU1MzUgPyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgOiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUpKGluZGljZXMsIDEpO1xuXHRcdFx0YXR0cmlidXRlLnZlcnNpb24gPSB2ZXJzaW9uOyAvLyBVcGRhdGluZyBpbmRleCBidWZmZXIgaW4gVkFPIG5vdy4gU2VlIFdlYkdMQmluZGluZ1N0YXRlc1xuXHRcdFx0Ly9cblxuXHRcdFx0Y29uc3QgcHJldmlvdXNBdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzLmdldChnZW9tZXRyeSk7XG5cdFx0XHRpZiAocHJldmlvdXNBdHRyaWJ1dGUpIGF0dHJpYnV0ZXMucmVtb3ZlKHByZXZpb3VzQXR0cmlidXRlKTsgLy9cblxuXHRcdFx0d2lyZWZyYW1lQXR0cmlidXRlcy5zZXQoZ2VvbWV0cnksIGF0dHJpYnV0ZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0V2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KSB7XG5cdFx0XHRjb25zdCBjdXJyZW50QXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoZ2VvbWV0cnkpO1xuXG5cdFx0XHRpZiAoY3VycmVudEF0dHJpYnV0ZSkge1xuXHRcdFx0XHRjb25zdCBnZW9tZXRyeUluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cblx0XHRcdFx0aWYgKGdlb21ldHJ5SW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0XHQvLyBpZiB0aGUgYXR0cmlidXRlIGlzIG9ic29sZXRlLCBjcmVhdGUgYSBuZXcgb25lXG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRBdHRyaWJ1dGUudmVyc2lvbiA8IGdlb21ldHJ5SW5kZXgudmVyc2lvbikge1xuXHRcdFx0XHRcdFx0dXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVwZGF0ZVdpcmVmcmFtZUF0dHJpYnV0ZShnZW9tZXRyeSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB3aXJlZnJhbWVBdHRyaWJ1dGVzLmdldChnZW9tZXRyeSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0XHRnZXRXaXJlZnJhbWVBdHRyaWJ1dGU6IGdldFdpcmVmcmFtZUF0dHJpYnV0ZVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlcihnbCwgZXh0ZW5zaW9ucywgaW5mbywgY2FwYWJpbGl0aWVzKSB7XG5cdFx0Y29uc3QgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG5cdFx0bGV0IG1vZGU7XG5cblx0XHRmdW5jdGlvbiBzZXRNb2RlKHZhbHVlKSB7XG5cdFx0XHRtb2RlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0bGV0IHR5cGUsIGJ5dGVzUGVyRWxlbWVudDtcblxuXHRcdGZ1bmN0aW9uIHNldEluZGV4KHZhbHVlKSB7XG5cdFx0XHR0eXBlID0gdmFsdWUudHlwZTtcblx0XHRcdGJ5dGVzUGVyRWxlbWVudCA9IHZhbHVlLmJ5dGVzUGVyRWxlbWVudDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXIoc3RhcnQsIGNvdW50KSB7XG5cdFx0XHRnbC5kcmF3RWxlbWVudHMobW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50KTtcblx0XHRcdGluZm8udXBkYXRlKGNvdW50LCBtb2RlLCAxKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoc3RhcnQsIGNvdW50LCBwcmltY291bnQpIHtcblx0XHRcdGlmIChwcmltY291bnQgPT09IDApIHJldHVybjtcblx0XHRcdGxldCBleHRlbnNpb24sIG1ldGhvZE5hbWU7XG5cblx0XHRcdGlmIChpc1dlYkdMMikge1xuXHRcdFx0XHRleHRlbnNpb24gPSBnbDtcblx0XHRcdFx0bWV0aG9kTmFtZSA9ICdkcmF3RWxlbWVudHNJbnN0YW5jZWQnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcblx0XHRcdFx0bWV0aG9kTmFtZSA9ICdkcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSc7XG5cblx0XHRcdFx0aWYgKGV4dGVuc2lvbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZXh0ZW5zaW9uW21ldGhvZE5hbWVdKG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIGJ5dGVzUGVyRWxlbWVudCwgcHJpbWNvdW50KTtcblx0XHRcdGluZm8udXBkYXRlKGNvdW50LCBtb2RlLCBwcmltY291bnQpO1xuXHRcdH0gLy9cblxuXG5cdFx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcblx0XHR0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XG5cdFx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XG5cdFx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEluZm8oZ2wpIHtcblx0XHRjb25zdCBtZW1vcnkgPSB7XG5cdFx0XHRnZW9tZXRyaWVzOiAwLFxuXHRcdFx0dGV4dHVyZXM6IDBcblx0XHR9O1xuXHRcdGNvbnN0IHJlbmRlciA9IHtcblx0XHRcdGZyYW1lOiAwLFxuXHRcdFx0Y2FsbHM6IDAsXG5cdFx0XHR0cmlhbmdsZXM6IDAsXG5cdFx0XHRwb2ludHM6IDAsXG5cdFx0XHRsaW5lczogMFxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUoY291bnQsIG1vZGUsIGluc3RhbmNlQ291bnQpIHtcblx0XHRcdHJlbmRlci5jYWxscysrO1xuXG5cdFx0XHRzd2l0Y2ggKG1vZGUpIHtcblx0XHRcdFx0Y2FzZSBnbC5UUklBTkdMRVM6XG5cdFx0XHRcdFx0cmVuZGVyLnRyaWFuZ2xlcyArPSBpbnN0YW5jZUNvdW50ICogKGNvdW50IC8gMyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBnbC5MSU5FUzpcblx0XHRcdFx0XHRyZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIChjb3VudCAvIDIpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgZ2wuTElORV9TVFJJUDpcblx0XHRcdFx0XHRyZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIChjb3VudCAtIDEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgZ2wuTElORV9MT09QOlxuXHRcdFx0XHRcdHJlbmRlci5saW5lcyArPSBpbnN0YW5jZUNvdW50ICogY291bnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBnbC5QT0lOVFM6XG5cdFx0XHRcdFx0cmVuZGVyLnBvaW50cyArPSBpbnN0YW5jZUNvdW50ICogY291bnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTEluZm86IFVua25vd24gZHJhdyBtb2RlOicsIG1vZGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc2V0KCkge1xuXHRcdFx0cmVuZGVyLmZyYW1lKys7XG5cdFx0XHRyZW5kZXIuY2FsbHMgPSAwO1xuXHRcdFx0cmVuZGVyLnRyaWFuZ2xlcyA9IDA7XG5cdFx0XHRyZW5kZXIucG9pbnRzID0gMDtcblx0XHRcdHJlbmRlci5saW5lcyA9IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1lbW9yeTogbWVtb3J5LFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRwcm9ncmFtczogbnVsbCxcblx0XHRcdGF1dG9SZXNldDogdHJ1ZSxcblx0XHRcdHJlc2V0OiByZXNldCxcblx0XHRcdHVwZGF0ZTogdXBkYXRlXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIG51bWVyaWNhbFNvcnQoYSwgYikge1xuXHRcdHJldHVybiBhWzBdIC0gYlswXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFic051bWVyaWNhbFNvcnQoYSwgYikge1xuXHRcdHJldHVybiBNYXRoLmFicyhiWzFdKSAtIE1hdGguYWJzKGFbMV0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xNb3JwaHRhcmdldHMoZ2wpIHtcblx0XHRjb25zdCBpbmZsdWVuY2VzTGlzdCA9IHt9O1xuXHRcdGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG5cdFx0Y29uc3Qgd29ya0luZmx1ZW5jZXMgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHR3b3JrSW5mbHVlbmNlc1tpXSA9IFtpLCAwXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHByb2dyYW0pIHtcblx0XHRcdGNvbnN0IG9iamVjdEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzOyAvLyBXaGVuIG9iamVjdCBkb2Vzbid0IGhhdmUgbW9ycGggdGFyZ2V0IGluZmx1ZW5jZXMgZGVmaW5lZCwgd2UgdHJlYXQgaXQgYXMgYSAwLWxlbmd0aCBhcnJheVxuXHRcdFx0Ly8gVGhpcyBpcyBpbXBvcnRhbnQgdG8gbWFrZSBzdXJlIHdlIHNldCB1cCBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UgLyBtb3JwaFRhcmdldEluZmx1ZW5jZXNcblxuXHRcdFx0Y29uc3QgbGVuZ3RoID0gb2JqZWN0SW5mbHVlbmNlcyA9PT0gdW5kZWZpbmVkID8gMCA6IG9iamVjdEluZmx1ZW5jZXMubGVuZ3RoO1xuXHRcdFx0bGV0IGluZmx1ZW5jZXMgPSBpbmZsdWVuY2VzTGlzdFtnZW9tZXRyeS5pZF07XG5cblx0XHRcdGlmIChpbmZsdWVuY2VzID09PSB1bmRlZmluZWQgfHwgaW5mbHVlbmNlcy5sZW5ndGggIT09IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBpbml0aWFsaXNlIGxpc3Rcblx0XHRcdFx0aW5mbHVlbmNlcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpbmZsdWVuY2VzW2ldID0gW2ksIDBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5mbHVlbmNlc0xpc3RbZ2VvbWV0cnkuaWRdID0gaW5mbHVlbmNlcztcblx0XHRcdH0gLy8gQ29sbGVjdCBpbmZsdWVuY2VzXG5cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzW2ldO1xuXHRcdFx0XHRpbmZsdWVuY2VbMF0gPSBpO1xuXHRcdFx0XHRpbmZsdWVuY2VbMV0gPSBvYmplY3RJbmZsdWVuY2VzW2ldO1xuXHRcdFx0fVxuXG5cdFx0XHRpbmZsdWVuY2VzLnNvcnQoYWJzTnVtZXJpY2FsU29ydCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHRcdGlmIChpIDwgbGVuZ3RoICYmIGluZmx1ZW5jZXNbaV1bMV0pIHtcblx0XHRcdFx0XHR3b3JrSW5mbHVlbmNlc1tpXVswXSA9IGluZmx1ZW5jZXNbaV1bMF07XG5cdFx0XHRcdFx0d29ya0luZmx1ZW5jZXNbaV1bMV0gPSBpbmZsdWVuY2VzW2ldWzFdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdvcmtJbmZsdWVuY2VzW2ldWzBdID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cdFx0XHRcdFx0d29ya0luZmx1ZW5jZXNbaV1bMV0gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHdvcmtJbmZsdWVuY2VzLnNvcnQobnVtZXJpY2FsU29ydCk7XG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsO1xuXHRcdFx0bGV0IG1vcnBoSW5mbHVlbmNlc1N1bSA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGluZmx1ZW5jZSA9IHdvcmtJbmZsdWVuY2VzW2ldO1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGluZmx1ZW5jZVswXTtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBpbmZsdWVuY2VbMV07XG5cblx0XHRcdFx0aWYgKGluZGV4ICE9PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmIChtb3JwaFRhcmdldHMgJiYgZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdtb3JwaFRhcmdldCcgKyBpKSAhPT0gbW9ycGhUYXJnZXRzW2luZGV4XSkge1xuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdtb3JwaFRhcmdldCcgKyBpLCBtb3JwaFRhcmdldHNbaW5kZXhdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAobW9ycGhOb3JtYWxzICYmIGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnbW9ycGhOb3JtYWwnICsgaSkgIT09IG1vcnBoTm9ybWFsc1tpbmRleF0pIHtcblx0XHRcdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbW9ycGhOb3JtYWwnICsgaSwgbW9ycGhOb3JtYWxzW2luZGV4XSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzU3VtICs9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChtb3JwaFRhcmdldHMgJiYgZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCdtb3JwaFRhcmdldCcgKyBpKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCdtb3JwaFRhcmdldCcgKyBpKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAobW9ycGhOb3JtYWxzICYmIGdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSgnbW9ycGhOb3JtYWwnICsgaSkgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdGdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgnbW9ycGhOb3JtYWwnICsgaSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzW2ldID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBHTFNMIHNoYWRlciB1c2VzIGZvcm11bGEgYmFzZWluZmx1ZW5jZSAqIGJhc2UgKyBzdW0odGFyZ2V0ICogaW5mbHVlbmNlKVxuXHRcdFx0Ly8gVGhpcyBhbGxvd3MgdXMgdG8gc3dpdGNoIGJldHdlZW4gYWJzb2x1dGUgbW9ycGhzIGFuZCByZWxhdGl2ZSBtb3JwaHMgd2l0aG91dCBjaGFuZ2luZyBzaGFkZXIgY29kZVxuXHRcdFx0Ly8gV2hlbiBiYXNlaW5mbHVlbmNlID0gMSAtIHN1bShpbmZsdWVuY2UpLCB0aGUgYWJvdmUgaXMgZXF1aXZhbGVudCB0byBzdW0oKHRhcmdldCAtIGJhc2UpICogaW5mbHVlbmNlKVxuXG5cblx0XHRcdGNvbnN0IG1vcnBoQmFzZUluZmx1ZW5jZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID8gMSA6IDEgLSBtb3JwaEluZmx1ZW5jZXNTdW07XG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoZ2wsICdtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UnLCBtb3JwaEJhc2VJbmZsdWVuY2UpO1xuXHRcdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGdsLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgbW9ycGhJbmZsdWVuY2VzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xPYmplY3RzKGdsLCBnZW9tZXRyaWVzLCBhdHRyaWJ1dGVzLCBpbmZvKSB7XG5cdFx0bGV0IHVwZGF0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUob2JqZWN0KSB7XG5cdFx0XHRjb25zdCBmcmFtZSA9IGluZm8ucmVuZGVyLmZyYW1lO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KG9iamVjdCwgZ2VvbWV0cnkpOyAvLyBVcGRhdGUgb25jZSBwZXIgZnJhbWVcblxuXHRcdFx0aWYgKHVwZGF0ZU1hcC5nZXQoYnVmZmVyZ2VvbWV0cnkpICE9PSBmcmFtZSkge1xuXHRcdFx0XHRnZW9tZXRyaWVzLnVwZGF0ZShidWZmZXJnZW9tZXRyeSk7XG5cdFx0XHRcdHVwZGF0ZU1hcC5zZXQoYnVmZmVyZ2VvbWV0cnksIGZyYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9iamVjdC5pc0luc3RhbmNlZE1lc2gpIHtcblx0XHRcdFx0aWYgKG9iamVjdC5oYXNFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25JbnN0YW5jZWRNZXNoRGlzcG9zZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0b2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKG9iamVjdC5pbnN0YW5jZU1hdHJpeCwgZ2wuQVJSQVlfQlVGRkVSKTtcblxuXHRcdFx0XHRpZiAob2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwpIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZShvYmplY3QuaW5zdGFuY2VDb2xvciwgZ2wuQVJSQVlfQlVGRkVSKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdHVwZGF0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25JbnN0YW5jZWRNZXNoRGlzcG9zZShldmVudCkge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2VkTWVzaCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdGluc3RhbmNlZE1lc2gucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uSW5zdGFuY2VkTWVzaERpc3Bvc2UpO1xuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeCk7XG5cdFx0XHRpZiAoaW5zdGFuY2VkTWVzaC5pbnN0YW5jZUNvbG9yICE9PSBudWxsKSBhdHRyaWJ1dGVzLnJlbW92ZShpbnN0YW5jZWRNZXNoLmluc3RhbmNlQ29sb3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR1cGRhdGU6IHVwZGF0ZSxcblx0XHRcdGRpc3Bvc2U6IGRpc3Bvc2Vcblx0XHR9O1xuXHR9XG5cblx0Y2xhc3MgRGF0YVRleHR1cmUyREFycmF5IGV4dGVuZHMgVGV4dHVyZSB7XG5cdFx0Y29uc3RydWN0b3IoZGF0YSA9IG51bGwsIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxKSB7XG5cdFx0XHRzdXBlcihudWxsKTtcblx0XHRcdHRoaXMuaW1hZ2UgPSB7XG5cdFx0XHRcdGRhdGEsXG5cdFx0XHRcdHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQsXG5cdFx0XHRcdGRlcHRoXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXHRcdFx0dGhpcy5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXHRcdFx0dGhpcy53cmFwUiA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdH1cblxuXHREYXRhVGV4dHVyZTJEQXJyYXkucHJvdG90eXBlLmlzRGF0YVRleHR1cmUyREFycmF5ID0gdHJ1ZTtcblxuXHRjbGFzcyBEYXRhVGV4dHVyZTNEIGV4dGVuZHMgVGV4dHVyZSB7XG5cdFx0Y29uc3RydWN0b3IoZGF0YSA9IG51bGwsIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxKSB7XG5cdFx0XHQvLyBXZSdyZSBnb2luZyB0byBhZGQgLnNldFhYWCgpIG1ldGhvZHMgZm9yIHNldHRpbmcgcHJvcGVydGllcyBsYXRlci5cblx0XHRcdC8vIFVzZXJzIGNhbiBzdGlsbCBzZXQgaW4gRGF0YVRleHR1cmUzRCBkaXJlY3RseS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0Y29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZTNEKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuXHRcdFx0Ly8gXHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSAxNjtcblx0XHRcdC8vXG5cdFx0XHQvLyBTZWUgIzE0ODM5XG5cdFx0XHRzdXBlcihudWxsKTtcblx0XHRcdHRoaXMuaW1hZ2UgPSB7XG5cdFx0XHRcdGRhdGEsXG5cdFx0XHRcdHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQsXG5cdFx0XHRcdGRlcHRoXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXHRcdFx0dGhpcy5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXHRcdFx0dGhpcy53cmFwUiA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdH1cblxuXHREYXRhVGV4dHVyZTNELnByb3RvdHlwZS5pc0RhdGFUZXh0dXJlM0QgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBVbmlmb3JtcyBvZiBhIHByb2dyYW0uXG5cdCAqIFRob3NlIGZvcm0gYSB0cmVlIHN0cnVjdHVyZSB3aXRoIGEgc3BlY2lhbCB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciB0aGUgcm9vdCxcblx0ICogd2hpY2ggeW91IGdldCBieSBjYWxsaW5nICduZXcgV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0gKScuXG5cdCAqXG5cdCAqXG5cdCAqIFByb3BlcnRpZXMgb2YgaW5uZXIgbm9kZXMgaW5jbHVkaW5nIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxuXHQgKlxuXHQgKiAuc2VxIC0gYXJyYXkgb2YgbmVzdGVkIHVuaWZvcm1zXG5cdCAqIC5tYXAgLSBuZXN0ZWQgdW5pZm9ybXMgYnkgbmFtZVxuXHQgKlxuXHQgKlxuXHQgKiBNZXRob2RzIG9mIGFsbCBub2RlcyBleGNlcHQgdGhlIHRvcC1sZXZlbCBjb250YWluZXI6XG5cdCAqXG5cdCAqIC5zZXRWYWx1ZSggZ2wsIHZhbHVlLCBbdGV4dHVyZXNdIClcblx0ICpcblx0ICogXHRcdHVwbG9hZHMgYSB1bmlmb3JtIHZhbHVlKHMpXG5cdCAqXHRcdHRoZSAndGV4dHVyZXMnIHBhcmFtZXRlciBpcyBuZWVkZWQgZm9yIHNhbXBsZXIgdW5pZm9ybXNcblx0ICpcblx0ICpcblx0ICogU3RhdGljIG1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHRleHR1cmVzIGZhY3Rvcml6YXRpb25zKTpcblx0ICpcblx0ICogLnVwbG9hZCggZ2wsIHNlcSwgdmFsdWVzLCB0ZXh0dXJlcyApXG5cdCAqXG5cdCAqIFx0XHRzZXRzIHVuaWZvcm1zIGluICdzZXEnIHRvICd2YWx1ZXNbaWRdLnZhbHVlJ1xuXHQgKlxuXHQgKiAuc2VxV2l0aFZhbHVlKCBzZXEsIHZhbHVlcyApIDogZmlsdGVyZWRTZXFcblx0ICpcblx0ICogXHRcdGZpbHRlcnMgJ3NlcScgZW50cmllcyB3aXRoIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdmFsdWVzXG5cdCAqXG5cdCAqXG5cdCAqIE1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHRleHR1cmVzIGZhY3Rvcml6YXRpb25zKTpcblx0ICpcblx0ICogLnNldFZhbHVlKCBnbCwgbmFtZSwgdmFsdWUsIHRleHR1cmVzIClcblx0ICpcblx0ICogXHRcdHNldHMgdW5pZm9ybSB3aXRoXHRuYW1lICduYW1lJyB0byAndmFsdWUnXG5cdCAqXG5cdCAqIC5zZXRPcHRpb25hbCggZ2wsIG9iaiwgcHJvcCApXG5cdCAqXG5cdCAqIFx0XHRsaWtlIC5zZXQgZm9yIGFuIG9wdGlvbmFsIHByb3BlcnR5IG9mIHRoZSBvYmplY3Rcblx0ICpcblx0ICovXG5cdGNvbnN0IGVtcHR5VGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cdGNvbnN0IGVtcHR5VGV4dHVyZTJkQXJyYXkgPSBuZXcgRGF0YVRleHR1cmUyREFycmF5KCk7XG5cdGNvbnN0IGVtcHR5VGV4dHVyZTNkID0gbmV3IERhdGFUZXh0dXJlM0QoKTtcblx0Y29uc3QgZW1wdHlDdWJlVGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZSgpOyAvLyAtLS0gVXRpbGl0aWVzIC0tLVxuXHQvLyBBcnJheSBDYWNoZXMgKHByb3ZpZGUgdHlwZWQgYXJyYXlzIGZvciB0ZW1wb3JhcnkgYnkgc2l6ZSlcblxuXHRjb25zdCBhcnJheUNhY2hlRjMyID0gW107XG5cdGNvbnN0IGFycmF5Q2FjaGVJMzIgPSBbXTsgLy8gRmxvYXQzMkFycmF5IGNhY2hlcyB1c2VkIGZvciB1cGxvYWRpbmcgTWF0cml4IHVuaWZvcm1zXG5cblx0Y29uc3QgbWF0NGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG5cdGNvbnN0IG1hdDNhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG5cdGNvbnN0IG1hdDJhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7IC8vIEZsYXR0ZW5pbmcgZm9yIGFycmF5cyBvZiB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuXG5cdGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIG5CbG9ja3MsIGJsb2NrU2l6ZSkge1xuXHRcdGNvbnN0IGZpcnN0RWxlbSA9IGFycmF5WzBdO1xuXHRcdGlmIChmaXJzdEVsZW0gPD0gMCB8fCBmaXJzdEVsZW0gPiAwKSByZXR1cm4gYXJyYXk7IC8vIHVub3B0aW1pemVkOiAhIGlzTmFOKCBmaXJzdEVsZW0gKVxuXHRcdC8vIHNlZSBodHRwOi8vamFja3NvbmR1bnN0YW4uY29tL2FydGljbGVzLzk4M1xuXG5cdFx0Y29uc3QgbiA9IG5CbG9ja3MgKiBibG9ja1NpemU7XG5cdFx0bGV0IHIgPSBhcnJheUNhY2hlRjMyW25dO1xuXG5cdFx0aWYgKHIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ciA9IG5ldyBGbG9hdDMyQXJyYXkobik7XG5cdFx0XHRhcnJheUNhY2hlRjMyW25dID0gcjtcblx0XHR9XG5cblx0XHRpZiAobkJsb2NrcyAhPT0gMCkge1xuXHRcdFx0Zmlyc3RFbGVtLnRvQXJyYXkociwgMCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAxLCBvZmZzZXQgPSAwOyBpICE9PSBuQmxvY2tzOyArK2kpIHtcblx0XHRcdFx0b2Zmc2V0ICs9IGJsb2NrU2l6ZTtcblx0XHRcdFx0YXJyYXlbaV0udG9BcnJheShyLCBvZmZzZXQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXJyYXlzRXF1YWwoYSwgYikge1xuXHRcdGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBjb3B5QXJyYXkoYSwgYikge1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gYi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGFbaV0gPSBiW2ldO1xuXHRcdH1cblx0fSAvLyBUZXh0dXJlIHVuaXQgYWxsb2NhdGlvblxuXG5cblx0ZnVuY3Rpb24gYWxsb2NUZXhVbml0cyh0ZXh0dXJlcywgbikge1xuXHRcdGxldCByID0gYXJyYXlDYWNoZUkzMltuXTtcblxuXHRcdGlmIChyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHIgPSBuZXcgSW50MzJBcnJheShuKTtcblx0XHRcdGFycmF5Q2FjaGVJMzJbbl0gPSByO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdHJbaV0gPSB0ZXh0dXJlcy5hbGxvY2F0ZVRleHR1cmVVbml0KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHI7XG5cdH0gLy8gLS0tIFNldHRlcnMgLS0tXG5cdC8vIE5vdGU6IERlZmluaW5nIHRoZXNlIG1ldGhvZHMgZXh0ZXJuYWxseSwgYmVjYXVzZSB0aGV5IGNvbWUgaW4gYSBidW5jaFxuXHQvLyBhbmQgdGhpcyB3YXkgdGhlaXIgbmFtZXMgbWluaWZ5LlxuXHQvLyBTaW5nbGUgc2NhbGFyXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYxZihnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRpZiAoY2FjaGVbMF0gPT09IHYpIHJldHVybjtcblx0XHRnbC51bmlmb3JtMWYodGhpcy5hZGRyLCB2KTtcblx0XHRjYWNoZVswXSA9IHY7XG5cdH0gLy8gU2luZ2xlIGZsb2F0IHZlY3RvciAoZnJvbSBmbGF0IGFycmF5IG9yIFRIUkVFLlZlY3Rvck4pXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYyZihnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRcdGlmICh2LnggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGNhY2hlWzBdICE9PSB2LnggfHwgY2FjaGVbMV0gIT09IHYueSkge1xuXHRcdFx0XHRnbC51bmlmb3JtMmYodGhpcy5hZGRyLCB2LngsIHYueSk7XG5cdFx0XHRcdGNhY2hlWzBdID0gdi54O1xuXHRcdFx0XHRjYWNoZVsxXSA9IHYueTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdFx0Z2wudW5pZm9ybTJmdih0aGlzLmFkZHIsIHYpO1xuXHRcdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYzZihnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRcdGlmICh2LnggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGNhY2hlWzBdICE9PSB2LnggfHwgY2FjaGVbMV0gIT09IHYueSB8fCBjYWNoZVsyXSAhPT0gdi56KSB7XG5cdFx0XHRcdGdsLnVuaWZvcm0zZih0aGlzLmFkZHIsIHYueCwgdi55LCB2LnopO1xuXHRcdFx0XHRjYWNoZVswXSA9IHYueDtcblx0XHRcdFx0Y2FjaGVbMV0gPSB2Lnk7XG5cdFx0XHRcdGNhY2hlWzJdID0gdi56O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodi5yICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChjYWNoZVswXSAhPT0gdi5yIHx8IGNhY2hlWzFdICE9PSB2LmcgfHwgY2FjaGVbMl0gIT09IHYuYikge1xuXHRcdFx0XHRnbC51bmlmb3JtM2YodGhpcy5hZGRyLCB2LnIsIHYuZywgdi5iKTtcblx0XHRcdFx0Y2FjaGVbMF0gPSB2LnI7XG5cdFx0XHRcdGNhY2hlWzFdID0gdi5nO1xuXHRcdFx0XHRjYWNoZVsyXSA9IHYuYjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdFx0Z2wudW5pZm9ybTNmdih0aGlzLmFkZHIsIHYpO1xuXHRcdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVY0ZihnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRcdGlmICh2LnggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGNhY2hlWzBdICE9PSB2LnggfHwgY2FjaGVbMV0gIT09IHYueSB8fCBjYWNoZVsyXSAhPT0gdi56IHx8IGNhY2hlWzNdICE9PSB2LncpIHtcblx0XHRcdFx0Z2wudW5pZm9ybTRmKHRoaXMuYWRkciwgdi54LCB2LnksIHYueiwgdi53KTtcblx0XHRcdFx0Y2FjaGVbMF0gPSB2Lng7XG5cdFx0XHRcdGNhY2hlWzFdID0gdi55O1xuXHRcdFx0XHRjYWNoZVsyXSA9IHYuejtcblx0XHRcdFx0Y2FjaGVbM10gPSB2Lnc7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRcdGdsLnVuaWZvcm00ZnYodGhpcy5hZGRyLCB2KTtcblx0XHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdFx0fVxuXHR9IC8vIFNpbmdsZSBtYXRyaXggKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5NYXRyaXhOKVxuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVNMihnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRjb25zdCBlbGVtZW50cyA9IHYuZWxlbWVudHM7XG5cblx0XHRpZiAoZWxlbWVudHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsIGZhbHNlLCB2KTtcblx0XHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgZWxlbWVudHMpKSByZXR1cm47XG5cdFx0XHRtYXQyYXJyYXkuc2V0KGVsZW1lbnRzKTtcblx0XHRcdGdsLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCBmYWxzZSwgbWF0MmFycmF5KTtcblx0XHRcdGNvcHlBcnJheShjYWNoZSwgZWxlbWVudHMpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlTTMoZ2wsIHYpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0Y29uc3QgZWxlbWVudHMgPSB2LmVsZW1lbnRzO1xuXG5cdFx0aWYgKGVsZW1lbnRzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRcdGdsLnVuaWZvcm1NYXRyaXgzZnYodGhpcy5hZGRyLCBmYWxzZSwgdik7XG5cdFx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIGVsZW1lbnRzKSkgcmV0dXJuO1xuXHRcdFx0bWF0M2FycmF5LnNldChlbGVtZW50cyk7XG5cdFx0XHRnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwgZmFsc2UsIG1hdDNhcnJheSk7XG5cdFx0XHRjb3B5QXJyYXkoY2FjaGUsIGVsZW1lbnRzKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZU00KGdsLCB2KSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGNvbnN0IGVsZW1lbnRzID0gdi5lbGVtZW50cztcblxuXHRcdGlmIChlbGVtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuYWRkciwgZmFsc2UsIHYpO1xuXHRcdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCBlbGVtZW50cykpIHJldHVybjtcblx0XHRcdG1hdDRhcnJheS5zZXQoZWxlbWVudHMpO1xuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsIGZhbHNlLCBtYXQ0YXJyYXkpO1xuXHRcdFx0Y29weUFycmF5KGNhY2hlLCBlbGVtZW50cyk7XG5cdFx0fVxuXHR9IC8vIFNpbmdsZSBpbnRlZ2VyIC8gYm9vbGVhblxuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWMWkoZ2wsIHYpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0aWYgKGNhY2hlWzBdID09PSB2KSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdik7XG5cdFx0Y2FjaGVbMF0gPSB2O1xuXHR9IC8vIFNpbmdsZSBpbnRlZ2VyIC8gYm9vbGVhbiB2ZWN0b3IgKGZyb20gZmxhdCBhcnJheSlcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjJpKGdsLCB2KSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRnbC51bmlmb3JtMml2KHRoaXMuYWRkciwgdik7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjNpKGdsLCB2KSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRnbC51bmlmb3JtM2l2KHRoaXMuYWRkciwgdik7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjRpKGdsLCB2KSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRnbC51bmlmb3JtNGl2KHRoaXMuYWRkciwgdik7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0fSAvLyBTaW5nbGUgdW5zaWduZWQgaW50ZWdlclxuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWMXVpKGdsLCB2KSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGlmIChjYWNoZVswXSA9PT0gdikgcmV0dXJuO1xuXHRcdGdsLnVuaWZvcm0xdWkodGhpcy5hZGRyLCB2KTtcblx0XHRjYWNoZVswXSA9IHY7XG5cdH0gLy8gU2luZ2xlIHVuc2lnbmVkIGludGVnZXIgdmVjdG9yIChmcm9tIGZsYXQgYXJyYXkpXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYydWkoZ2wsIHYpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdGdsLnVuaWZvcm0ydWl2KHRoaXMuYWRkciwgdik7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjN1aShnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybTN1aXYodGhpcy5hZGRyLCB2KTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWNHVpKGdsLCB2KSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRnbC51bmlmb3JtNHVpdih0aGlzLmFkZHIsIHYpO1xuXHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdH0gLy8gU2luZ2xlIHRleHR1cmUgKDJEIC8gQ3ViZSlcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVDEoZ2wsIHYsIHRleHR1cmVzKSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGNvbnN0IHVuaXQgPSB0ZXh0dXJlcy5hbGxvY2F0ZVRleHR1cmVVbml0KCk7XG5cblx0XHRpZiAoY2FjaGVbMF0gIT09IHVuaXQpIHtcblx0XHRcdGdsLnVuaWZvcm0xaSh0aGlzLmFkZHIsIHVuaXQpO1xuXHRcdFx0Y2FjaGVbMF0gPSB1bml0O1xuXHRcdH1cblxuXHRcdHRleHR1cmVzLnNhZmVTZXRUZXh0dXJlMkQodiB8fCBlbXB0eVRleHR1cmUsIHVuaXQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVUM0QxKGdsLCB2LCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRjb25zdCB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXG5cdFx0aWYgKGNhY2hlWzBdICE9PSB1bml0KSB7XG5cdFx0XHRnbC51bmlmb3JtMWkodGhpcy5hZGRyLCB1bml0KTtcblx0XHRcdGNhY2hlWzBdID0gdW5pdDtcblx0XHR9XG5cblx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlM0QodiB8fCBlbXB0eVRleHR1cmUzZCwgdW5pdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVQ2KGdsLCB2LCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRjb25zdCB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXG5cdFx0aWYgKGNhY2hlWzBdICE9PSB1bml0KSB7XG5cdFx0XHRnbC51bmlmb3JtMWkodGhpcy5hZGRyLCB1bml0KTtcblx0XHRcdGNhY2hlWzBdID0gdW5pdDtcblx0XHR9XG5cblx0XHR0ZXh0dXJlcy5zYWZlU2V0VGV4dHVyZUN1YmUodiB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVDJEQXJyYXkxKGdsLCB2LCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRjb25zdCB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXG5cdFx0aWYgKGNhY2hlWzBdICE9PSB1bml0KSB7XG5cdFx0XHRnbC51bmlmb3JtMWkodGhpcy5hZGRyLCB1bml0KTtcblx0XHRcdGNhY2hlWzBdID0gdW5pdDtcblx0XHR9XG5cblx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSh2IHx8IGVtcHR5VGV4dHVyZTJkQXJyYXksIHVuaXQpO1xuXHR9IC8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIHRoZSBzaW5ndWxhciBjYXNlXG5cblxuXHRmdW5jdGlvbiBnZXRTaW5ndWxhclNldHRlcih0eXBlKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIDB4MTQwNjpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjFmO1xuXHRcdFx0Ly8gRkxPQVRcblxuXHRcdFx0Y2FzZSAweDhiNTA6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYyZjtcblx0XHRcdC8vIF9WRUMyXG5cblx0XHRcdGNhc2UgMHg4YjUxOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWM2Y7XG5cdFx0XHQvLyBfVkVDM1xuXG5cdFx0XHRjYXNlIDB4OGI1Mjpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjRmO1xuXHRcdFx0Ly8gX1ZFQzRcblxuXHRcdFx0Y2FzZSAweDhiNWE6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZU0yO1xuXHRcdFx0Ly8gX01BVDJcblxuXHRcdFx0Y2FzZSAweDhiNWI6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZU0zO1xuXHRcdFx0Ly8gX01BVDNcblxuXHRcdFx0Y2FzZSAweDhiNWM6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZU00O1xuXHRcdFx0Ly8gX01BVDRcblxuXHRcdFx0Y2FzZSAweDE0MDQ6XG5cdFx0XHRjYXNlIDB4OGI1Njpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjFpO1xuXHRcdFx0Ly8gSU5ULCBCT09MXG5cblx0XHRcdGNhc2UgMHg4YjUzOlxuXHRcdFx0Y2FzZSAweDhiNTc6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYyaTtcblx0XHRcdC8vIF9WRUMyXG5cblx0XHRcdGNhc2UgMHg4YjU0OlxuXHRcdFx0Y2FzZSAweDhiNTg6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYzaTtcblx0XHRcdC8vIF9WRUMzXG5cblx0XHRcdGNhc2UgMHg4YjU1OlxuXHRcdFx0Y2FzZSAweDhiNTk6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVY0aTtcblx0XHRcdC8vIF9WRUM0XG5cblx0XHRcdGNhc2UgMHgxNDA1OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWMXVpO1xuXHRcdFx0Ly8gVUlOVFxuXG5cdFx0XHRjYXNlIDB4OGRjNjpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjJ1aTtcblx0XHRcdC8vIF9WRUMyXG5cblx0XHRcdGNhc2UgMHg4ZGM3OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWM3VpO1xuXHRcdFx0Ly8gX1ZFQzNcblxuXHRcdFx0Y2FzZSAweDhkYzg6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVY0dWk7XG5cdFx0XHQvLyBfVkVDNFxuXG5cdFx0XHRjYXNlIDB4OGI1ZTogLy8gU0FNUExFUl8yRFxuXG5cdFx0XHRjYXNlIDB4OGQ2NjogLy8gU0FNUExFUl9FWFRFUk5BTF9PRVNcblxuXHRcdFx0Y2FzZSAweDhkY2E6IC8vIElOVF9TQU1QTEVSXzJEXG5cblx0XHRcdGNhc2UgMHg4ZGQyOiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8yRFxuXG5cdFx0XHRjYXNlIDB4OGI2Mjpcblx0XHRcdFx0Ly8gU0FNUExFUl8yRF9TSEFET1dcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVDE7XG5cblx0XHRcdGNhc2UgMHg4YjVmOiAvLyBTQU1QTEVSXzNEXG5cblx0XHRcdGNhc2UgMHg4ZGNiOiAvLyBJTlRfU0FNUExFUl8zRFxuXG5cdFx0XHRjYXNlIDB4OGRkMzpcblx0XHRcdFx0Ly8gVU5TSUdORURfSU5UX1NBTVBMRVJfM0Rcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVDNEMTtcblxuXHRcdFx0Y2FzZSAweDhiNjA6IC8vIFNBTVBMRVJfQ1VCRVxuXG5cdFx0XHRjYXNlIDB4OGRjYzogLy8gSU5UX1NBTVBMRVJfQ1VCRVxuXG5cdFx0XHRjYXNlIDB4OGRkNDogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRVxuXG5cdFx0XHRjYXNlIDB4OGRjNTpcblx0XHRcdFx0Ly8gU0FNUExFUl9DVUJFX1NIQURPV1xuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVUNjtcblxuXHRcdFx0Y2FzZSAweDhkYzE6IC8vIFNBTVBMRVJfMkRfQVJSQVlcblxuXHRcdFx0Y2FzZSAweDhkY2Y6IC8vIElOVF9TQU1QTEVSXzJEX0FSUkFZXG5cblx0XHRcdGNhc2UgMHg4ZGQ3OiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWVxuXG5cdFx0XHRjYXNlIDB4OGRjNDpcblx0XHRcdFx0Ly8gU0FNUExFUl8yRF9BUlJBWV9TSEFET1dcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVDJEQXJyYXkxO1xuXHRcdH1cblx0fSAvLyBBcnJheSBvZiBzY2FsYXJzXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYxZkFycmF5KGdsLCB2KSB7XG5cdFx0Z2wudW5pZm9ybTFmdih0aGlzLmFkZHIsIHYpO1xuXHR9IC8vIEFycmF5IG9mIHZlY3RvcnMgKGZyb20gZmxhdCBhcnJheSBvciBhcnJheSBvZiBUSFJFRS5WZWN0b3JOKVxuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWMmZBcnJheShnbCwgdikge1xuXHRcdGNvbnN0IGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgMik7XG5cdFx0Z2wudW5pZm9ybTJmdih0aGlzLmFkZHIsIGRhdGEpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWM2ZBcnJheShnbCwgdikge1xuXHRcdGNvbnN0IGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgMyk7XG5cdFx0Z2wudW5pZm9ybTNmdih0aGlzLmFkZHIsIGRhdGEpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWNGZBcnJheShnbCwgdikge1xuXHRcdGNvbnN0IGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgNCk7XG5cdFx0Z2wudW5pZm9ybTRmdih0aGlzLmFkZHIsIGRhdGEpO1xuXHR9IC8vIEFycmF5IG9mIG1hdHJpY2VzIChmcm9tIGZsYXQgYXJyYXkgb3IgYXJyYXkgb2YgVEhSRUUuTWF0cml4TilcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlTTJBcnJheShnbCwgdikge1xuXHRcdGNvbnN0IGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgNCk7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsIGZhbHNlLCBkYXRhKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlTTNBcnJheShnbCwgdikge1xuXHRcdGNvbnN0IGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgOSk7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsIGZhbHNlLCBkYXRhKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlTTRBcnJheShnbCwgdikge1xuXHRcdGNvbnN0IGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgMTYpO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCBmYWxzZSwgZGF0YSk7XG5cdH0gLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW5cblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjFpQXJyYXkoZ2wsIHYpIHtcblx0XHRnbC51bmlmb3JtMWl2KHRoaXMuYWRkciwgdik7XG5cdH0gLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW4gdmVjdG9ycyAoZnJvbSBmbGF0IGFycmF5KVxuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWMmlBcnJheShnbCwgdikge1xuXHRcdGdsLnVuaWZvcm0yaXYodGhpcy5hZGRyLCB2KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjNpQXJyYXkoZ2wsIHYpIHtcblx0XHRnbC51bmlmb3JtM2l2KHRoaXMuYWRkciwgdik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVY0aUFycmF5KGdsLCB2KSB7XG5cdFx0Z2wudW5pZm9ybTRpdih0aGlzLmFkZHIsIHYpO1xuXHR9IC8vIEFycmF5IG9mIHVuc2lnbmVkIGludGVnZXJcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjF1aUFycmF5KGdsLCB2KSB7XG5cdFx0Z2wudW5pZm9ybTF1aXYodGhpcy5hZGRyLCB2KTtcblx0fSAvLyBBcnJheSBvZiB1bnNpZ25lZCBpbnRlZ2VyIHZlY3RvcnMgKGZyb20gZmxhdCBhcnJheSlcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjJ1aUFycmF5KGdsLCB2KSB7XG5cdFx0Z2wudW5pZm9ybTJ1aXYodGhpcy5hZGRyLCB2KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjN1aUFycmF5KGdsLCB2KSB7XG5cdFx0Z2wudW5pZm9ybTN1aXYodGhpcy5hZGRyLCB2KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjR1aUFycmF5KGdsLCB2KSB7XG5cdFx0Z2wudW5pZm9ybTR1aXYodGhpcy5hZGRyLCB2KTtcblx0fSAvLyBBcnJheSBvZiB0ZXh0dXJlcyAoMkQgLyBDdWJlKVxuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVUMUFycmF5KGdsLCB2LCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblx0XHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHModGV4dHVyZXMsIG4pO1xuXHRcdGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB1bml0cyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHR0ZXh0dXJlcy5zYWZlU2V0VGV4dHVyZTJEKHZbaV0gfHwgZW1wdHlUZXh0dXJlLCB1bml0c1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVUNkFycmF5KGdsLCB2LCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblx0XHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHModGV4dHVyZXMsIG4pO1xuXHRcdGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB1bml0cyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHR0ZXh0dXJlcy5zYWZlU2V0VGV4dHVyZUN1YmUodltpXSB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0c1tpXSk7XG5cdFx0fVxuXHR9IC8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIGEgcHVyZSAoYm90dG9tLWxldmVsKSBhcnJheVxuXG5cblx0ZnVuY3Rpb24gZ2V0UHVyZUFycmF5U2V0dGVyKHR5cGUpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgMHgxNDA2OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWMWZBcnJheTtcblx0XHRcdC8vIEZMT0FUXG5cblx0XHRcdGNhc2UgMHg4YjUwOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWMmZBcnJheTtcblx0XHRcdC8vIF9WRUMyXG5cblx0XHRcdGNhc2UgMHg4YjUxOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWM2ZBcnJheTtcblx0XHRcdC8vIF9WRUMzXG5cblx0XHRcdGNhc2UgMHg4YjUyOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWNGZBcnJheTtcblx0XHRcdC8vIF9WRUM0XG5cblx0XHRcdGNhc2UgMHg4YjVhOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVNMkFycmF5O1xuXHRcdFx0Ly8gX01BVDJcblxuXHRcdFx0Y2FzZSAweDhiNWI6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZU0zQXJyYXk7XG5cdFx0XHQvLyBfTUFUM1xuXG5cdFx0XHRjYXNlIDB4OGI1Yzpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlTTRBcnJheTtcblx0XHRcdC8vIF9NQVQ0XG5cblx0XHRcdGNhc2UgMHgxNDA0OlxuXHRcdFx0Y2FzZSAweDhiNTY6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYxaUFycmF5O1xuXHRcdFx0Ly8gSU5ULCBCT09MXG5cblx0XHRcdGNhc2UgMHg4YjUzOlxuXHRcdFx0Y2FzZSAweDhiNTc6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYyaUFycmF5O1xuXHRcdFx0Ly8gX1ZFQzJcblxuXHRcdFx0Y2FzZSAweDhiNTQ6XG5cdFx0XHRjYXNlIDB4OGI1ODpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjNpQXJyYXk7XG5cdFx0XHQvLyBfVkVDM1xuXG5cdFx0XHRjYXNlIDB4OGI1NTpcblx0XHRcdGNhc2UgMHg4YjU5OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWNGlBcnJheTtcblx0XHRcdC8vIF9WRUM0XG5cblx0XHRcdGNhc2UgMHgxNDA1OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWMXVpQXJyYXk7XG5cdFx0XHQvLyBVSU5UXG5cblx0XHRcdGNhc2UgMHg4ZGM2OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWMnVpQXJyYXk7XG5cdFx0XHQvLyBfVkVDMlxuXG5cdFx0XHRjYXNlIDB4OGRjNzpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjN1aUFycmF5O1xuXHRcdFx0Ly8gX1ZFQzNcblxuXHRcdFx0Y2FzZSAweDhkYzg6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVY0dWlBcnJheTtcblx0XHRcdC8vIF9WRUM0XG5cblx0XHRcdGNhc2UgMHg4YjVlOiAvLyBTQU1QTEVSXzJEXG5cblx0XHRcdGNhc2UgMHg4ZDY2OiAvLyBTQU1QTEVSX0VYVEVSTkFMX09FU1xuXG5cdFx0XHRjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcblxuXHRcdFx0Y2FzZSAweDhkZDI6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEXG5cblx0XHRcdGNhc2UgMHg4YjYyOlxuXHRcdFx0XHQvLyBTQU1QTEVSXzJEX1NIQURPV1xuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVUMUFycmF5O1xuXG5cdFx0XHRjYXNlIDB4OGI2MDogLy8gU0FNUExFUl9DVUJFXG5cblx0XHRcdGNhc2UgMHg4ZGNjOiAvLyBJTlRfU0FNUExFUl9DVUJFXG5cblx0XHRcdGNhc2UgMHg4ZGQ0OiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl9DVUJFXG5cblx0XHRcdGNhc2UgMHg4ZGM1OlxuXHRcdFx0XHQvLyBTQU1QTEVSX0NVQkVfU0hBRE9XXG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVQ2QXJyYXk7XG5cdFx0fVxuXHR9IC8vIC0tLSBVbmlmb3JtIENsYXNzZXMgLS0tXG5cblxuXHRmdW5jdGlvbiBTaW5nbGVVbmlmb3JtKGlkLCBhY3RpdmVJbmZvLCBhZGRyKSB7XG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMuYWRkciA9IGFkZHI7XG5cdFx0dGhpcy5jYWNoZSA9IFtdO1xuXHRcdHRoaXMuc2V0VmFsdWUgPSBnZXRTaW5ndWxhclNldHRlcihhY3RpdmVJbmZvLnR5cGUpOyAvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXG5cdH1cblxuXHRmdW5jdGlvbiBQdXJlQXJyYXlVbmlmb3JtKGlkLCBhY3RpdmVJbmZvLCBhZGRyKSB7XG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMuYWRkciA9IGFkZHI7XG5cdFx0dGhpcy5jYWNoZSA9IFtdO1xuXHRcdHRoaXMuc2l6ZSA9IGFjdGl2ZUluZm8uc2l6ZTtcblx0XHR0aGlzLnNldFZhbHVlID0gZ2V0UHVyZUFycmF5U2V0dGVyKGFjdGl2ZUluZm8udHlwZSk7IC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcblx0fVxuXG5cdFB1cmVBcnJheVVuaWZvcm0ucHJvdG90eXBlLnVwZGF0ZUNhY2hlID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0XHRpZiAoZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSAmJiBjYWNoZS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmNhY2hlID0gbmV3IEZsb2F0MzJBcnJheShkYXRhLmxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0Y29weUFycmF5KGNhY2hlLCBkYXRhKTtcblx0fTtcblxuXHRmdW5jdGlvbiBTdHJ1Y3R1cmVkVW5pZm9ybShpZCkge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLnNlcSA9IFtdO1xuXHRcdHRoaXMubWFwID0ge307XG5cdH1cblxuXHRTdHJ1Y3R1cmVkVW5pZm9ybS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoZ2wsIHZhbHVlLCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IHNlcSA9IHRoaXMuc2VxO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IHUgPSBzZXFbaV07XG5cdFx0XHR1LnNldFZhbHVlKGdsLCB2YWx1ZVt1LmlkXSwgdGV4dHVyZXMpO1xuXHRcdH1cblx0fTsgLy8gLS0tIFRvcC1sZXZlbCAtLS1cblx0Ly8gUGFyc2VyIC0gYnVpbGRzIHVwIHRoZSBwcm9wZXJ0eSB0cmVlIGZyb20gdGhlIHBhdGggc3RyaW5nc1xuXG5cblx0Y29uc3QgUmVQYXRoUGFydCA9IC8oXFx3KykoXFxdKT8oXFxbfFxcLik/L2c7IC8vIGV4dHJhY3RzXG5cdC8vIFx0LSB0aGUgaWRlbnRpZmllciAobWVtYmVyIG5hbWUgb3IgYXJyYXkgaW5kZXgpXG5cdC8vXHQtIGZvbGxvd2VkIGJ5IGFuIG9wdGlvbmFsIHJpZ2h0IGJyYWNrZXQgKGZvdW5kIHdoZW4gYXJyYXkgaW5kZXgpXG5cdC8vXHQtIGZvbGxvd2VkIGJ5IGFuIG9wdGlvbmFsIGxlZnQgYnJhY2tldCBvciBkb3QgKHR5cGUgb2Ygc3Vic2NyaXB0KVxuXHQvL1xuXHQvLyBOb3RlOiBUaGVzZSBwb3J0aW9ucyBjYW4gYmUgcmVhZCBpbiBhIG5vbi1vdmVybGFwcGluZyBmYXNoaW9uIGFuZFxuXHQvLyBhbGxvdyBzdHJhaWdodGZvcndhcmQgcGFyc2luZyBvZiB0aGUgaGllcmFyY2h5IHRoYXQgV2ViR0wgZW5jb2Rlc1xuXHQvLyBpbiB0aGUgdW5pZm9ybSBuYW1lcy5cblxuXHRmdW5jdGlvbiBhZGRVbmlmb3JtKGNvbnRhaW5lciwgdW5pZm9ybU9iamVjdCkge1xuXHRcdGNvbnRhaW5lci5zZXEucHVzaCh1bmlmb3JtT2JqZWN0KTtcblx0XHRjb250YWluZXIubWFwW3VuaWZvcm1PYmplY3QuaWRdID0gdW5pZm9ybU9iamVjdDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlVW5pZm9ybShhY3RpdmVJbmZvLCBhZGRyLCBjb250YWluZXIpIHtcblx0XHRjb25zdCBwYXRoID0gYWN0aXZlSW5mby5uYW1lLFxuXHRcdFx0XHRcdHBhdGhMZW5ndGggPSBwYXRoLmxlbmd0aDsgLy8gcmVzZXQgUmVnRXhwIG9iamVjdCwgYmVjYXVzZSBvZiB0aGUgZWFybHkgZXhpdCBvZiBhIHByZXZpb3VzIHJ1blxuXG5cdFx0UmVQYXRoUGFydC5sYXN0SW5kZXggPSAwO1xuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGNvbnN0IG1hdGNoID0gUmVQYXRoUGFydC5leGVjKHBhdGgpLFxuXHRcdFx0XHRcdFx0bWF0Y2hFbmQgPSBSZVBhdGhQYXJ0Lmxhc3RJbmRleDtcblx0XHRcdGxldCBpZCA9IG1hdGNoWzFdO1xuXHRcdFx0Y29uc3QgaWRJc0luZGV4ID0gbWF0Y2hbMl0gPT09ICddJyxcblx0XHRcdFx0XHRcdHN1YnNjcmlwdCA9IG1hdGNoWzNdO1xuXHRcdFx0aWYgKGlkSXNJbmRleCkgaWQgPSBpZCB8IDA7IC8vIGNvbnZlcnQgdG8gaW50ZWdlclxuXG5cdFx0XHRpZiAoc3Vic2NyaXB0ID09PSB1bmRlZmluZWQgfHwgc3Vic2NyaXB0ID09PSAnWycgJiYgbWF0Y2hFbmQgKyAyID09PSBwYXRoTGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGJhcmUgbmFtZSBvciBcInB1cmVcIiBib3R0b20tbGV2ZWwgYXJyYXkgXCJbMF1cIiBzdWZmaXhcblx0XHRcdFx0YWRkVW5pZm9ybShjb250YWluZXIsIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkID8gbmV3IFNpbmdsZVVuaWZvcm0oaWQsIGFjdGl2ZUluZm8sIGFkZHIpIDogbmV3IFB1cmVBcnJheVVuaWZvcm0oaWQsIGFjdGl2ZUluZm8sIGFkZHIpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBzdGVwIGludG8gaW5uZXIgbm9kZSAvIGNyZWF0ZSBpdCBpbiBjYXNlIGl0IGRvZXNuJ3QgZXhpc3Rcblx0XHRcdFx0Y29uc3QgbWFwID0gY29udGFpbmVyLm1hcDtcblx0XHRcdFx0bGV0IG5leHQgPSBtYXBbaWRdO1xuXG5cdFx0XHRcdGlmIChuZXh0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRuZXh0ID0gbmV3IFN0cnVjdHVyZWRVbmlmb3JtKGlkKTtcblx0XHRcdFx0XHRhZGRVbmlmb3JtKGNvbnRhaW5lciwgbmV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250YWluZXIgPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSAvLyBSb290IENvbnRhaW5lclxuXG5cblx0ZnVuY3Rpb24gV2ViR0xVbmlmb3JtcyhnbCwgcHJvZ3JhbSkge1xuXHRcdHRoaXMuc2VxID0gW107XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0XHRjb25zdCBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcblx0XHRcdGNvbnN0IGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpLFxuXHRcdFx0XHRcdFx0YWRkciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpO1xuXHRcdFx0cGFyc2VVbmlmb3JtKGluZm8sIGFkZHIsIHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdFdlYkdMVW5pZm9ybXMucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKGdsLCBuYW1lLCB2YWx1ZSwgdGV4dHVyZXMpIHtcblx0XHRjb25zdCB1ID0gdGhpcy5tYXBbbmFtZV07XG5cdFx0aWYgKHUgIT09IHVuZGVmaW5lZCkgdS5zZXRWYWx1ZShnbCwgdmFsdWUsIHRleHR1cmVzKTtcblx0fTtcblxuXHRXZWJHTFVuaWZvcm1zLnByb3RvdHlwZS5zZXRPcHRpb25hbCA9IGZ1bmN0aW9uIChnbCwgb2JqZWN0LCBuYW1lKSB7XG5cdFx0Y29uc3QgdiA9IG9iamVjdFtuYW1lXTtcblx0XHRpZiAodiAhPT0gdW5kZWZpbmVkKSB0aGlzLnNldFZhbHVlKGdsLCBuYW1lLCB2KTtcblx0fTsgLy8gU3RhdGljIGludGVyZmFjZVxuXG5cblx0V2ViR0xVbmlmb3Jtcy51cGxvYWQgPSBmdW5jdGlvbiAoZ2wsIHNlcSwgdmFsdWVzLCB0ZXh0dXJlcykge1xuXHRcdGZvciAobGV0IGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRjb25zdCB1ID0gc2VxW2ldLFxuXHRcdFx0XHRcdFx0diA9IHZhbHVlc1t1LmlkXTtcblxuXHRcdFx0aWYgKHYubmVlZHNVcGRhdGUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdC8vIG5vdGU6IGFsd2F5cyB1cGRhdGluZyB3aGVuIC5uZWVkc1VwZGF0ZSBpcyB1bmRlZmluZWRcblx0XHRcdFx0dS5zZXRWYWx1ZShnbCwgdi52YWx1ZSwgdGV4dHVyZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZSA9IGZ1bmN0aW9uIChzZXEsIHZhbHVlcykge1xuXHRcdGNvbnN0IHIgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRjb25zdCB1ID0gc2VxW2ldO1xuXHRcdFx0aWYgKHUuaWQgaW4gdmFsdWVzKSByLnB1c2godSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHI7XG5cdH07XG5cblx0ZnVuY3Rpb24gV2ViR0xTaGFkZXIoZ2wsIHR5cGUsIHN0cmluZykge1xuXHRcdGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcblx0XHRnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzdHJpbmcpO1xuXHRcdGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblx0XHRyZXR1cm4gc2hhZGVyO1xuXHR9XG5cblx0bGV0IHByb2dyYW1JZENvdW50ID0gMDtcblxuXHRmdW5jdGlvbiBhZGRMaW5lTnVtYmVycyhzdHJpbmcpIHtcblx0XHRjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdCgnXFxuJyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsaW5lc1tpXSA9IGkgKyAxICsgJzogJyArIGxpbmVzW2ldO1xuXHRcdH1cblxuXHRcdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEVuY29kaW5nQ29tcG9uZW50cyhlbmNvZGluZykge1xuXHRcdHN3aXRjaCAoZW5jb2RpbmcpIHtcblx0XHRcdGNhc2UgTGluZWFyRW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbJ0xpbmVhcicsICcoIHZhbHVlICknXTtcblxuXHRcdFx0Y2FzZSBzUkdCRW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbJ3NSR0InLCAnKCB2YWx1ZSApJ107XG5cblx0XHRcdGNhc2UgUkdCRUVuY29kaW5nOlxuXHRcdFx0XHRyZXR1cm4gWydSR0JFJywgJyggdmFsdWUgKSddO1xuXG5cdFx0XHRjYXNlIFJHQk03RW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbJ1JHQk0nLCAnKCB2YWx1ZSwgNy4wICknXTtcblxuXHRcdFx0Y2FzZSBSR0JNMTZFbmNvZGluZzpcblx0XHRcdFx0cmV0dXJuIFsnUkdCTScsICcoIHZhbHVlLCAxNi4wICknXTtcblxuXHRcdFx0Y2FzZSBSR0JERW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbJ1JHQkQnLCAnKCB2YWx1ZSwgMjU2LjAgKSddO1xuXG5cdFx0XHRjYXNlIEdhbW1hRW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbJ0dhbW1hJywgJyggdmFsdWUsIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApJ107XG5cblx0XHRcdGNhc2UgTG9nTHV2RW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbJ0xvZ0x1dicsICcoIHZhbHVlICknXTtcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIGVuY29kaW5nOicsIGVuY29kaW5nKTtcblx0XHRcdFx0cmV0dXJuIFsnTGluZWFyJywgJyggdmFsdWUgKSddO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFNoYWRlckVycm9ycyhnbCwgc2hhZGVyLCB0eXBlKSB7XG5cdFx0Y29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXHRcdGNvbnN0IGxvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKS50cmltKCk7XG5cdFx0aWYgKHN0YXR1cyAmJiBsb2cgPT09ICcnKSByZXR1cm4gJyc7IC8vIC0tZW5hYmxlLXByaXZpbGVnZWQtd2ViZ2wtZXh0ZW5zaW9uXG5cdFx0Ly8gY29uc29sZS5sb2coICcqKicgKyB0eXBlICsgJyoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xuXG5cdFx0Y29uc3Qgc291cmNlID0gZ2wuZ2V0U2hhZGVyU291cmNlKHNoYWRlcik7XG5cdFx0cmV0dXJuICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpICcgKyB0eXBlICsgJ1xcbicgKyBsb2cgKyBhZGRMaW5lTnVtYmVycyhzb3VyY2UpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgZW5jb2RpbmcpIHtcblx0XHRjb25zdCBjb21wb25lbnRzID0gZ2V0RW5jb2RpbmdDb21wb25lbnRzKGVuY29kaW5nKTtcblx0XHRyZXR1cm4gJ3ZlYzQgJyArIGZ1bmN0aW9uTmFtZSArICcoIHZlYzQgdmFsdWUgKSB7IHJldHVybiAnICsgY29tcG9uZW50c1swXSArICdUb0xpbmVhcicgKyBjb21wb25lbnRzWzFdICsgJzsgfSc7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBlbmNvZGluZykge1xuXHRcdGNvbnN0IGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoZW5jb2RpbmcpO1xuXHRcdHJldHVybiAndmVjNCAnICsgZnVuY3Rpb25OYW1lICsgJyggdmVjNCB2YWx1ZSApIHsgcmV0dXJuIExpbmVhclRvJyArIGNvbXBvbmVudHNbMF0gKyBjb21wb25lbnRzWzFdICsgJzsgfSc7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgdG9uZU1hcHBpbmcpIHtcblx0XHRsZXQgdG9uZU1hcHBpbmdOYW1lO1xuXG5cdFx0c3dpdGNoICh0b25lTWFwcGluZykge1xuXHRcdFx0Y2FzZSBMaW5lYXJUb25lTWFwcGluZzpcblx0XHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ0xpbmVhcic7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFJlaW5oYXJkVG9uZU1hcHBpbmc6XG5cdFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdSZWluaGFyZCc7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIENpbmVvblRvbmVNYXBwaW5nOlxuXHRcdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnT3B0aW1pemVkQ2luZW9uJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nOlxuXHRcdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnQUNFU0ZpbG1pYyc7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIEN1c3RvbVRvbmVNYXBwaW5nOlxuXHRcdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnQ3VzdG9tJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xQcm9ncmFtOiBVbnN1cHBvcnRlZCB0b25lTWFwcGluZzonLCB0b25lTWFwcGluZyk7XG5cdFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdMaW5lYXInO1xuXHRcdH1cblxuXHRcdHJldHVybiAndmVjMyAnICsgZnVuY3Rpb25OYW1lICsgJyggdmVjMyBjb2xvciApIHsgcmV0dXJuICcgKyB0b25lTWFwcGluZ05hbWUgKyAnVG9uZU1hcHBpbmcoIGNvbG9yICk7IH0nO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVFeHRlbnNpb25zKHBhcmFtZXRlcnMpIHtcblx0XHRjb25zdCBjaHVua3MgPSBbcGFyYW1ldGVycy5leHRlbnNpb25EZXJpdmF0aXZlcyB8fCBwYXJhbWV0ZXJzLmVudk1hcEN1YmVVViB8fCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy50YW5nZW50U3BhY2VOb3JtYWxNYXAgfHwgcGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyB8fCBwYXJhbWV0ZXJzLnNoYWRlcklEID09PSAncGh5c2ljYWwnID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLCAocGFyYW1ldGVycy5leHRlbnNpb25GcmFnRGVwdGggfHwgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoID8gJyNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGUnIDogJycsIHBhcmFtZXRlcnMuZXh0ZW5zaW9uRHJhd0J1ZmZlcnMgJiYgcGFyYW1ldGVycy5yZW5kZXJlckV4dGVuc2lvbkRyYXdCdWZmZXJzID8gJyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmUnIDogJycsIChwYXJhbWV0ZXJzLmV4dGVuc2lvblNoYWRlclRleHR1cmVMT0QgfHwgcGFyYW1ldGVycy5lbnZNYXAgfHwgcGFyYW1ldGVycy50cmFuc21pc3Npb24gPiAwLjApICYmIHBhcmFtZXRlcnMucmVuZGVyZXJFeHRlbnNpb25TaGFkZXJUZXh0dXJlTG9kID8gJyNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCA6IGVuYWJsZScgOiAnJ107XG5cdFx0cmV0dXJuIGNodW5rcy5maWx0ZXIoZmlsdGVyRW1wdHlMaW5lKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyhkZWZpbmVzKSB7XG5cdFx0Y29uc3QgY2h1bmtzID0gW107XG5cblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gZGVmaW5lcykge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBkZWZpbmVzW25hbWVdO1xuXHRcdFx0aWYgKHZhbHVlID09PSBmYWxzZSkgY29udGludWU7XG5cdFx0XHRjaHVua3MucHVzaCgnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2h1bmtzLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoZ2wsIHByb2dyYW0pIHtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0ge307XG5cdFx0Y29uc3QgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdGNvbnN0IGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSk7XG5cdFx0XHRjb25zdCBuYW1lID0gaW5mby5uYW1lOyAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6JywgbmFtZSwgaSApO1xuXG5cdFx0XHRhdHRyaWJ1dGVzW25hbWVdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHN0cmluZyAhPT0gJyc7XG5cdH1cblxuXHRmdW5jdGlvbiByZXBsYWNlTGlnaHROdW1zKHN0cmluZywgcGFyYW1ldGVycykge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSgvTlVNX0RJUl9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1EaXJMaWdodHMpLnJlcGxhY2UoL05VTV9TUE9UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodHMpLnJlcGxhY2UoL05VTV9SRUNUX0FSRUFfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtUmVjdEFyZWFMaWdodHMpLnJlcGxhY2UoL05VTV9QT0lOVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0cykucmVwbGFjZSgvTlVNX0hFTUlfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtSGVtaUxpZ2h0cykucmVwbGFjZSgvTlVNX0RJUl9MSUdIVF9TSEFET1dTL2csIHBhcmFtZXRlcnMubnVtRGlyTGlnaHRTaGFkb3dzKS5yZXBsYWNlKC9OVU1fU1BPVF9MSUdIVF9TSEFET1dTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MvZywgcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0U2hhZG93cyk7XG5cdH1cblxuXHRmdW5jdGlvbiByZXBsYWNlQ2xpcHBpbmdQbGFuZU51bXMoc3RyaW5nLCBwYXJhbWV0ZXJzKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKC9OVU1fQ0xJUFBJTkdfUExBTkVTL2csIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMpLnJlcGxhY2UoL1VOSU9OX0NMSVBQSU5HX1BMQU5FUy9nLCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzIC0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uKTtcblx0fSAvLyBSZXNvbHZlIEluY2x1ZGVzXG5cblxuXHRjb25zdCBpbmNsdWRlUGF0dGVybiA9IC9eWyBcXHRdKiNpbmNsdWRlICs8KFtcXHdcXGQuL10rKT4vZ207XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZUluY2x1ZGVzKHN0cmluZykge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZShpbmNsdWRlUGF0dGVybiwgaW5jbHVkZVJlcGxhY2VyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluY2x1ZGVSZXBsYWNlcihtYXRjaCwgaW5jbHVkZSkge1xuXHRcdGNvbnN0IHN0cmluZyA9IFNoYWRlckNodW5rW2luY2x1ZGVdO1xuXG5cdFx0aWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8JyArIGluY2x1ZGUgKyAnPicpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXNvbHZlSW5jbHVkZXMoc3RyaW5nKTtcblx0fSAvLyBVbnJvbGwgTG9vcHNcblxuXG5cdGNvbnN0IGRlcHJlY2F0ZWRVbnJvbGxMb29wUGF0dGVybiA9IC8jcHJhZ21hIHVucm9sbF9sb29wW1xcc10rP2ZvciBcXCggaW50IGkgXFw9IChcXGQrKVxcOyBpIDwgKFxcZCspXFw7IGkgXFwrXFwrIFxcKSBcXHsoW1xcc1xcU10rPykoPz1cXH0pXFx9L2c7XG5cdGNvbnN0IHVucm9sbExvb3BQYXR0ZXJuID0gLyNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXHMrZm9yXFxzKlxcKFxccyppbnRcXHMraVxccyo9XFxzKihcXGQrKVxccyo7XFxzKmlcXHMqPFxccyooXFxkKylcXHMqO1xccyppXFxzKlxcK1xcK1xccypcXClcXHMqeyhbXFxzXFxTXSs/KX1cXHMrI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQvZztcblxuXHRmdW5jdGlvbiB1bnJvbGxMb29wcyhzdHJpbmcpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UodW5yb2xsTG9vcFBhdHRlcm4sIGxvb3BSZXBsYWNlcikucmVwbGFjZShkZXByZWNhdGVkVW5yb2xsTG9vcFBhdHRlcm4sIGRlcHJlY2F0ZWRMb29wUmVwbGFjZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVwcmVjYXRlZExvb3BSZXBsYWNlcihtYXRjaCwgc3RhcnQsIGVuZCwgc25pcHBldCkge1xuXHRcdGNvbnNvbGUud2FybignV2ViR0xQcm9ncmFtOiAjcHJhZ21hIHVucm9sbF9sb29wIHNoYWRlciBzeW50YXggaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0IHN5bnRheCBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBsb29wUmVwbGFjZXIobWF0Y2gsIHN0YXJ0LCBlbmQsIHNuaXBwZXQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9vcFJlcGxhY2VyKG1hdGNoLCBzdGFydCwgZW5kLCBzbmlwcGV0KSB7XG5cdFx0bGV0IHN0cmluZyA9ICcnO1xuXG5cdFx0Zm9yIChsZXQgaSA9IHBhcnNlSW50KHN0YXJ0KTsgaSA8IHBhcnNlSW50KGVuZCk7IGkrKykge1xuXHRcdFx0c3RyaW5nICs9IHNuaXBwZXQucmVwbGFjZSgvXFxbXFxzKmlcXHMqXFxdL2csICdbICcgKyBpICsgJyBdJykucmVwbGFjZSgvVU5ST0xMRURfTE9PUF9JTkRFWC9nLCBpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyaW5nO1xuXHR9IC8vXG5cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVByZWNpc2lvbihwYXJhbWV0ZXJzKSB7XG5cdFx0bGV0IHByZWNpc2lvbnN0cmluZyA9ICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDtcXG5wcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JztcblxuXHRcdGlmIChwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ2hpZ2hwJykge1xuXHRcdFx0cHJlY2lzaW9uc3RyaW5nICs9ICdcXG4jZGVmaW5lIEhJR0hfUFJFQ0lTSU9OJztcblx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlcnMucHJlY2lzaW9uID09PSAnbWVkaXVtcCcpIHtcblx0XHRcdHByZWNpc2lvbnN0cmluZyArPSAnXFxuI2RlZmluZSBNRURJVU1fUFJFQ0lTSU9OJztcblx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlcnMucHJlY2lzaW9uID09PSAnbG93cCcpIHtcblx0XHRcdHByZWNpc2lvbnN0cmluZyArPSAnXFxuI2RlZmluZSBMT1dfUFJFQ0lTSU9OJztcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJlY2lzaW9uc3RyaW5nO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVTaGFkb3dNYXBUeXBlRGVmaW5lKHBhcmFtZXRlcnMpIHtcblx0XHRsZXQgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cblx0XHRpZiAocGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBQQ0ZTaGFkb3dNYXApIHtcblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcblx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU29mdFNoYWRvd01hcCkge1xuXHRcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCc7XG5cdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFZTTVNoYWRvd01hcCkge1xuXHRcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9WU00nO1xuXHRcdH1cblxuXHRcdHJldHVybiBzaGFkb3dNYXBUeXBlRGVmaW5lO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVFbnZNYXBUeXBlRGVmaW5lKHBhcmFtZXRlcnMpIHtcblx0XHRsZXQgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcblxuXHRcdGlmIChwYXJhbWV0ZXJzLmVudk1hcCkge1xuXHRcdFx0c3dpdGNoIChwYXJhbWV0ZXJzLmVudk1hcE1vZGUpIHtcblx0XHRcdFx0Y2FzZSBDdWJlUmVmbGVjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzpcblx0XHRcdFx0Y2FzZSBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZzpcblx0XHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkVfVVYnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBlbnZNYXBUeXBlRGVmaW5lO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVFbnZNYXBNb2RlRGVmaW5lKHBhcmFtZXRlcnMpIHtcblx0XHRsZXQgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZMRUNUSU9OJztcblxuXHRcdGlmIChwYXJhbWV0ZXJzLmVudk1hcCkge1xuXHRcdFx0c3dpdGNoIChwYXJhbWV0ZXJzLmVudk1hcE1vZGUpIHtcblx0XHRcdFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGNhc2UgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdFx0ZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZSQUNUSU9OJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZW52TWFwTW9kZURlZmluZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRW52TWFwQmxlbmRpbmdEZWZpbmUocGFyYW1ldGVycykge1xuXHRcdGxldCBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTk9ORSc7XG5cblx0XHRpZiAocGFyYW1ldGVycy5lbnZNYXApIHtcblx0XHRcdHN3aXRjaCAocGFyYW1ldGVycy5jb21iaW5lKSB7XG5cdFx0XHRcdGNhc2UgTXVsdGlwbHlPcGVyYXRpb246XG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIE1peE9wZXJhdGlvbjpcblx0XHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEFkZE9wZXJhdGlvbjpcblx0XHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZW52TWFwQmxlbmRpbmdEZWZpbmU7XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTFByb2dyYW0ocmVuZGVyZXIsIGNhY2hlS2V5LCBwYXJhbWV0ZXJzLCBiaW5kaW5nU3RhdGVzKSB7XG5cdFx0Y29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG5cdFx0Y29uc3QgZGVmaW5lcyA9IHBhcmFtZXRlcnMuZGVmaW5lcztcblx0XHRsZXQgdmVydGV4U2hhZGVyID0gcGFyYW1ldGVycy52ZXJ0ZXhTaGFkZXI7XG5cdFx0bGV0IGZyYWdtZW50U2hhZGVyID0gcGFyYW1ldGVycy5mcmFnbWVudFNoYWRlcjtcblx0XHRjb25zdCBzaGFkb3dNYXBUeXBlRGVmaW5lID0gZ2VuZXJhdGVTaGFkb3dNYXBUeXBlRGVmaW5lKHBhcmFtZXRlcnMpO1xuXHRcdGNvbnN0IGVudk1hcFR5cGVEZWZpbmUgPSBnZW5lcmF0ZUVudk1hcFR5cGVEZWZpbmUocGFyYW1ldGVycyk7XG5cdFx0Y29uc3QgZW52TWFwTW9kZURlZmluZSA9IGdlbmVyYXRlRW52TWFwTW9kZURlZmluZShwYXJhbWV0ZXJzKTtcblx0XHRjb25zdCBlbnZNYXBCbGVuZGluZ0RlZmluZSA9IGdlbmVyYXRlRW52TWFwQmxlbmRpbmdEZWZpbmUocGFyYW1ldGVycyk7XG5cdFx0Y29uc3QgZ2FtbWFGYWN0b3JEZWZpbmUgPSByZW5kZXJlci5nYW1tYUZhY3RvciA+IDAgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcblx0XHRjb25zdCBjdXN0b21FeHRlbnNpb25zID0gcGFyYW1ldGVycy5pc1dlYkdMMiA/ICcnIDogZ2VuZXJhdGVFeHRlbnNpb25zKHBhcmFtZXRlcnMpO1xuXHRcdGNvbnN0IGN1c3RvbURlZmluZXMgPSBnZW5lcmF0ZURlZmluZXMoZGVmaW5lcyk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblx0XHRsZXQgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcblx0XHRsZXQgdmVyc2lvblN0cmluZyA9IHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPyAnI3ZlcnNpb24gJyArIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gKyAnXFxuJyA6ICcnO1xuXG5cdFx0aWYgKHBhcmFtZXRlcnMuaXNSYXdTaGFkZXJNYXRlcmlhbCkge1xuXHRcdFx0cHJlZml4VmVydGV4ID0gW2N1c3RvbURlZmluZXNdLmZpbHRlcihmaWx0ZXJFbXB0eUxpbmUpLmpvaW4oJ1xcbicpO1xuXG5cdFx0XHRpZiAocHJlZml4VmVydGV4Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0cHJlZml4VmVydGV4ICs9ICdcXG4nO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmVmaXhGcmFnbWVudCA9IFtjdXN0b21FeHRlbnNpb25zLCBjdXN0b21EZWZpbmVzXS5maWx0ZXIoZmlsdGVyRW1wdHlMaW5lKS5qb2luKCdcXG4nKTtcblxuXHRcdFx0aWYgKHByZWZpeEZyYWdtZW50Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0cHJlZml4RnJhZ21lbnQgKz0gJ1xcbic7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByZWZpeFZlcnRleCA9IFtnZW5lcmF0ZVByZWNpc2lvbihwYXJhbWV0ZXJzKSwgJyNkZWZpbmUgU0hBREVSX05BTUUgJyArIHBhcmFtZXRlcnMuc2hhZGVyTmFtZSwgY3VzdG9tRGVmaW5lcywgcGFyYW1ldGVycy5pbnN0YW5jaW5nID8gJyNkZWZpbmUgVVNFX0lOU1RBTkNJTkcnIDogJycsIHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yID8gJyNkZWZpbmUgVVNFX0lOU1RBTkNJTkdfQ09MT1InIDogJycsIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJywgJyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSwgJyNkZWZpbmUgTUFYX0JPTkVTICcgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwMiA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLCBwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJywgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLCBwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJywgcGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCAmJiBwYXJhbWV0ZXJzLm9iamVjdFNwYWNlTm9ybWFsTWFwID8gJyNkZWZpbmUgT0JKRUNUU1BBQ0VfTk9STUFMTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCAmJiBwYXJhbWV0ZXJzLnRhbmdlbnRTcGFjZU5vcm1hbE1hcCA/ICcjZGVmaW5lIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0TWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCcgOiAnJywgcGFyYW1ldGVycy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAgJiYgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVVNFX0RJU1BMQUNFTUVOVE1BUCcgOiAnJywgcGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJywgcGFyYW1ldGVycy5zcGVjdWxhckludGVuc2l0eU1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUklOVEVOU0lUWU1BUCcgOiAnJywgcGFyYW1ldGVycy5zcGVjdWxhclRpbnRNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJUSU5UTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJywgcGFyYW1ldGVycy50cmFuc21pc3Npb24gPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OJyA6ICcnLCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbk1hcCA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVAnIDogJycsIHBhcmFtZXRlcnMudGhpY2tuZXNzTWFwID8gJyNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhUYW5nZW50cyA/ICcjZGVmaW5lIFVTRV9UQU5HRU5UJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhBbHBoYXMgPyAnI2RlZmluZSBVU0VfQ09MT1JfQUxQSEEnIDogJycsIHBhcmFtZXRlcnMudmVydGV4VXZzID8gJyNkZWZpbmUgVVNFX1VWJyA6ICcnLCBwYXJhbWV0ZXJzLnV2c1ZlcnRleE9ubHkgPyAnI2RlZmluZSBVVlNfVkVSVEVYX09OTFknIDogJycsIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJywgcGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJywgcGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlID8gJyNkZWZpbmUgQk9ORV9URVhUVVJFJyA6ICcnLCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/ICcjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMnIDogJycsIHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX01PUlBITk9STUFMUycgOiAnJywgcGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJywgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLCBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLCBwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJywgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHBhcmFtZXRlcnMucmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGggPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLCAndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsICd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsICd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLCAndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JywgJ3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7JywgJ3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLCAndW5pZm9ybSBib29sIGlzT3J0aG9ncmFwaGljOycsICcjaWZkZWYgVVNFX0lOU1RBTkNJTkcnLCAnXHRhdHRyaWJ1dGUgbWF0NCBpbnN0YW5jZU1hdHJpeDsnLCAnI2VuZGlmJywgJyNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUicsICdcdGF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlQ29sb3I7JywgJyNlbmRpZicsICdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLCAnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsICdhdHRyaWJ1dGUgdmVjMiB1djsnLCAnI2lmZGVmIFVTRV9UQU5HRU5UJywgJ1x0YXR0cmlidXRlIHZlYzQgdGFuZ2VudDsnLCAnI2VuZGlmJywgJyNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKScsICdcdGF0dHJpYnV0ZSB2ZWM0IGNvbG9yOycsICcjZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKScsICdcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yOycsICcjZW5kaWYnLCAnI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFMnLCAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7JywgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLCAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7JywgJ1x0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLCAnXHQjZWxzZScsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsICdcdCNlbmRpZicsICcjZW5kaWYnLCAnI2lmZGVmIFVTRV9TS0lOTklORycsICdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsnLCAnXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OycsICcjZW5kaWYnLCAnXFxuJ10uZmlsdGVyKGZpbHRlckVtcHR5TGluZSkuam9pbignXFxuJyk7XG5cdFx0XHRwcmVmaXhGcmFnbWVudCA9IFtjdXN0b21FeHRlbnNpb25zLCBnZW5lcmF0ZVByZWNpc2lvbihwYXJhbWV0ZXJzKSwgJyNkZWZpbmUgU0hBREVSX05BTUUgJyArIHBhcmFtZXRlcnMuc2hhZGVyTmFtZSwgY3VzdG9tRGVmaW5lcywgcGFyYW1ldGVycy5hbHBoYVRlc3QgPyAnI2RlZmluZSBBTFBIQVRFU1QgJyArIHBhcmFtZXRlcnMuYWxwaGFUZXN0ICsgKHBhcmFtZXRlcnMuYWxwaGFUZXN0ICUgMSA/ICcnIDogJy4wJykgOiAnJywgLy8gYWRkICcuMCcgaWYgaW50ZWdlclxuXHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSwgcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cDIgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJywgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm1hdGNhcCA/ICcjZGVmaW5lIFVTRV9NQVRDQVAnIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJywgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwVHlwZURlZmluZSA6ICcnLCBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsIHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsIHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMubm9ybWFsTWFwICYmIHBhcmFtZXRlcnMub2JqZWN0U3BhY2VOb3JtYWxNYXAgPyAnI2RlZmluZSBPQkpFQ1RTUEFDRV9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMubm9ybWFsTWFwICYmIHBhcmFtZXRlcnMudGFuZ2VudFNwYWNlTm9ybWFsTWFwID8gJyNkZWZpbmUgVEFOR0VOVFNQQUNFX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5jbGVhcmNvYXRNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmNsZWFyY29hdFJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmNsZWFyY29hdE5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSSU5URU5TSVRZTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFyVGludE1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUlRJTlRNQVAnIDogJycsIHBhcmFtZXRlcnMucm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1JPVUdITkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNoZWVuID8gJyNkZWZpbmUgVVNFX1NIRUVOJyA6ICcnLCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbiA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT04nIDogJycsIHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uTWFwID8gJyNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTk1BUCcgOiAnJywgcGFyYW1ldGVycy50aGlja25lc3NNYXAgPyAnI2RlZmluZSBVU0VfVEhJQ0tORVNTTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleFRhbmdlbnRzID8gJyNkZWZpbmUgVVNFX1RBTkdFTlQnIDogJycsIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzIHx8IHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleEFscGhhcyA/ICcjZGVmaW5lIFVTRV9DT0xPUl9BTFBIQScgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhVdnMgPyAnI2RlZmluZSBVU0VfVVYnIDogJycsIHBhcmFtZXRlcnMudXZzVmVydGV4T25seSA/ICcjZGVmaW5lIFVWU19WRVJURVhfT05MWScgOiAnJywgcGFyYW1ldGVycy5ncmFkaWVudE1hcCA/ICcjZGVmaW5lIFVTRV9HUkFESUVOVE1BUCcgOiAnJywgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLCBwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLCBwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsIHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhID8gJyNkZWZpbmUgUFJFTVVMVElQTElFRF9BTFBIQScgOiAnJywgcGFyYW1ldGVycy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA/ICcjZGVmaW5lIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFMnIDogJycsIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJywgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHBhcmFtZXRlcnMucmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGggPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLCAocGFyYW1ldGVycy5leHRlbnNpb25TaGFkZXJUZXh0dXJlTE9EIHx8IHBhcmFtZXRlcnMuZW52TWFwKSAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxvZCA/ICcjZGVmaW5lIFRFWFRVUkVfTE9EX0VYVCcgOiAnJywgJ3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsICd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JywgJ3VuaWZvcm0gYm9vbCBpc09ydGhvZ3JhcGhpYzsnLCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nID8gJyNkZWZpbmUgVE9ORV9NQVBQSU5HJyA6ICcnLCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nID8gU2hhZGVyQ2h1bmtbJ3RvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQnXSA6ICcnLCAvLyB0aGlzIGNvZGUgaXMgcmVxdWlyZWQgaGVyZSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgdGhlIHRvbmVNYXBwaW5nKCkgZnVuY3Rpb24gZGVmaW5lZCBiZWxvd1xuXHRcdFx0cGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyA/IGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oJ3RvbmVNYXBwaW5nJywgcGFyYW1ldGVycy50b25lTWFwcGluZykgOiAnJywgcGFyYW1ldGVycy5kaXRoZXJpbmcgPyAnI2RlZmluZSBESVRIRVJJTkcnIDogJycsIFNoYWRlckNodW5rWydlbmNvZGluZ3NfcGFyc19mcmFnbWVudCddLCAvLyB0aGlzIGNvZGUgaXMgcmVxdWlyZWQgaGVyZSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgdGhlIHZhcmlvdXMgZW5jb2RpbmcvZGVjb2RpbmcgZnVuY3Rpb24gZGVmaW5lZCBiZWxvd1xuXHRcdFx0cGFyYW1ldGVycy5tYXAgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oJ21hcFRleGVsVG9MaW5lYXInLCBwYXJhbWV0ZXJzLm1hcEVuY29kaW5nKSA6ICcnLCBwYXJhbWV0ZXJzLm1hdGNhcCA/IGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbignbWF0Y2FwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMubWF0Y2FwRW5jb2RpbmcpIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCdlbnZNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZykgOiAnJywgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/IGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbignZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nKSA6ICcnLCBwYXJhbWV0ZXJzLnNwZWN1bGFyVGludE1hcCA/IGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbignc3BlY3VsYXJUaW50TWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMuc3BlY3VsYXJUaW50TWFwRW5jb2RpbmcpIDogJycsIHBhcmFtZXRlcnMubGlnaHRNYXAgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oJ2xpZ2h0TWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMubGlnaHRNYXBFbmNvZGluZykgOiAnJywgZ2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCdsaW5lYXJUb091dHB1dFRleGVsJywgcGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZyksIHBhcmFtZXRlcnMuZGVwdGhQYWNraW5nID8gJyNkZWZpbmUgREVQVEhfUEFDS0lORyAnICsgcGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgOiAnJywgJ1xcbiddLmZpbHRlcihmaWx0ZXJFbXB0eUxpbmUpLmpvaW4oJ1xcbicpO1xuXHRcdH1cblxuXHRcdHZlcnRleFNoYWRlciA9IHJlc29sdmVJbmNsdWRlcyh2ZXJ0ZXhTaGFkZXIpO1xuXHRcdHZlcnRleFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXModmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzKTtcblx0XHR2ZXJ0ZXhTaGFkZXIgPSByZXBsYWNlQ2xpcHBpbmdQbGFuZU51bXModmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzKTtcblx0XHRmcmFnbWVudFNoYWRlciA9IHJlc29sdmVJbmNsdWRlcyhmcmFnbWVudFNoYWRlcik7XG5cdFx0ZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKGZyYWdtZW50U2hhZGVyLCBwYXJhbWV0ZXJzKTtcblx0XHRmcmFnbWVudFNoYWRlciA9IHJlcGxhY2VDbGlwcGluZ1BsYW5lTnVtcyhmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyk7XG5cdFx0dmVydGV4U2hhZGVyID0gdW5yb2xsTG9vcHModmVydGV4U2hhZGVyKTtcblx0XHRmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKGZyYWdtZW50U2hhZGVyKTtcblxuXHRcdGlmIChwYXJhbWV0ZXJzLmlzV2ViR0wyICYmIHBhcmFtZXRlcnMuaXNSYXdTaGFkZXJNYXRlcmlhbCAhPT0gdHJ1ZSkge1xuXHRcdFx0Ly8gR0xTTCAzLjAgY29udmVyc2lvbiBmb3IgYnVpbHQtaW4gbWF0ZXJpYWxzIGFuZCBTaGFkZXJNYXRlcmlhbFxuXHRcdFx0dmVyc2lvblN0cmluZyA9ICcjdmVyc2lvbiAzMDAgZXNcXG4nO1xuXHRcdFx0cHJlZml4VmVydGV4ID0gWycjZGVmaW5lIGF0dHJpYnV0ZSBpbicsICcjZGVmaW5lIHZhcnlpbmcgb3V0JywgJyNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmUnXS5qb2luKCdcXG4nKSArICdcXG4nICsgcHJlZml4VmVydGV4O1xuXHRcdFx0cHJlZml4RnJhZ21lbnQgPSBbJyNkZWZpbmUgdmFyeWluZyBpbicsIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPT09IEdMU0wzID8gJycgOiAnb3V0IGhpZ2hwIHZlYzQgcGNfZnJhZ0NvbG9yOycsIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPT09IEdMU0wzID8gJycgOiAnI2RlZmluZSBnbF9GcmFnQ29sb3IgcGNfZnJhZ0NvbG9yJywgJyNkZWZpbmUgZ2xfRnJhZ0RlcHRoRVhUIGdsX0ZyYWdEZXB0aCcsICcjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlJywgJyNkZWZpbmUgdGV4dHVyZUN1YmUgdGV4dHVyZScsICcjZGVmaW5lIHRleHR1cmUyRFByb2ogdGV4dHVyZVByb2onLCAnI2RlZmluZSB0ZXh0dXJlMkRMb2RFWFQgdGV4dHVyZUxvZCcsICcjZGVmaW5lIHRleHR1cmUyRFByb2pMb2RFWFQgdGV4dHVyZVByb2pMb2QnLCAnI2RlZmluZSB0ZXh0dXJlQ3ViZUxvZEVYVCB0ZXh0dXJlTG9kJywgJyNkZWZpbmUgdGV4dHVyZTJER3JhZEVYVCB0ZXh0dXJlR3JhZCcsICcjZGVmaW5lIHRleHR1cmUyRFByb2pHcmFkRVhUIHRleHR1cmVQcm9qR3JhZCcsICcjZGVmaW5lIHRleHR1cmVDdWJlR3JhZEVYVCB0ZXh0dXJlR3JhZCddLmpvaW4oJ1xcbicpICsgJ1xcbicgKyBwcmVmaXhGcmFnbWVudDtcblx0XHR9XG5cblx0XHRjb25zdCB2ZXJ0ZXhHbHNsID0gdmVyc2lvblN0cmluZyArIHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcblx0XHRjb25zdCBmcmFnbWVudEdsc2wgPSB2ZXJzaW9uU3RyaW5nICsgcHJlZml4RnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlcjsgLy8gY29uc29sZS5sb2coICcqVkVSVEVYKicsIHZlcnRleEdsc2wgKTtcblx0XHQvLyBjb25zb2xlLmxvZyggJypGUkFHTUVOVConLCBmcmFnbWVudEdsc2wgKTtcblxuXHRcdGNvbnN0IGdsVmVydGV4U2hhZGVyID0gV2ViR0xTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wpO1xuXHRcdGNvbnN0IGdsRnJhZ21lbnRTaGFkZXIgPSBXZWJHTFNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBnbFZlcnRleFNoYWRlcik7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIpOyAvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXG5cblx0XHRpZiAocGFyYW1ldGVycy5pbmRleDBBdHRyaWJ1dGVOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAwLCBwYXJhbWV0ZXJzLmluZGV4MEF0dHJpYnV0ZU5hbWUpO1xuXHRcdH0gZWxzZSBpZiAocGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPT09IHRydWUpIHtcblx0XHRcdC8vIHByb2dyYW1zIHdpdGggbW9ycGhUYXJnZXRzIGRpc3BsYWNlIHBvc2l0aW9uIG91dCBvZiBhdHRyaWJ1dGUgMFxuXHRcdFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIDAsICdwb3NpdGlvbicpO1xuXHRcdH1cblxuXHRcdGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pOyAvLyBjaGVjayBmb3IgbGluayBlcnJvcnNcblxuXHRcdGlmIChyZW5kZXJlci5kZWJ1Zy5jaGVja1NoYWRlckVycm9ycykge1xuXHRcdFx0Y29uc3QgcHJvZ3JhbUxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pLnRyaW0oKTtcblx0XHRcdGNvbnN0IHZlcnRleExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coZ2xWZXJ0ZXhTaGFkZXIpLnRyaW0oKTtcblx0XHRcdGNvbnN0IGZyYWdtZW50TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhnbEZyYWdtZW50U2hhZGVyKS50cmltKCk7XG5cdFx0XHRsZXQgcnVubmFibGUgPSB0cnVlO1xuXHRcdFx0bGV0IGhhdmVEaWFnbm9zdGljcyA9IHRydWU7XG5cblx0XHRcdGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cnVubmFibGUgPSBmYWxzZTtcblx0XHRcdFx0Y29uc3QgdmVydGV4RXJyb3JzID0gZ2V0U2hhZGVyRXJyb3JzKGdsLCBnbFZlcnRleFNoYWRlciwgJ3ZlcnRleCcpO1xuXHRcdFx0XHRjb25zdCBmcmFnbWVudEVycm9ycyA9IGdldFNoYWRlckVycm9ycyhnbCwgZ2xGcmFnbWVudFNoYWRlciwgJ2ZyYWdtZW50Jyk7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUHJvZ3JhbTogc2hhZGVyIGVycm9yOiAnLCBnbC5nZXRFcnJvcigpLCAnZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nLCB2ZXJ0ZXhFcnJvcnMsIGZyYWdtZW50RXJyb3JzKTtcblx0XHRcdH0gZWxzZSBpZiAocHJvZ3JhbUxvZyAhPT0gJycpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nKTtcblx0XHRcdH0gZWxzZSBpZiAodmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycpIHtcblx0XHRcdFx0aGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXZlRGlhZ25vc3RpY3MpIHtcblx0XHRcdFx0dGhpcy5kaWFnbm9zdGljcyA9IHtcblx0XHRcdFx0XHRydW5uYWJsZTogcnVubmFibGUsXG5cdFx0XHRcdFx0cHJvZ3JhbUxvZzogcHJvZ3JhbUxvZyxcblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHtcblx0XHRcdFx0XHRcdGxvZzogdmVydGV4TG9nLFxuXHRcdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhWZXJ0ZXhcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiB7XG5cdFx0XHRcdFx0XHRsb2c6IGZyYWdtZW50TG9nLFxuXHRcdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhGcmFnbWVudFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9IC8vIENsZWFuIHVwXG5cdFx0Ly8gQ3Jhc2hlcyBpbiBpT1M5IGFuZCBpT1MxMC4gIzE4NDAyXG5cdFx0Ly8gZ2wuZGV0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xuXHRcdC8vIGdsLmRldGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xuXG5cblx0XHRnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0ZXhTaGFkZXIpO1xuXHRcdGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdtZW50U2hhZGVyKTsgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXG5cblx0XHRsZXQgY2FjaGVkVW5pZm9ybXM7XG5cblx0XHR0aGlzLmdldFVuaWZvcm1zID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FjaGVkVW5pZm9ybXMgPSBuZXcgV2ViR0xVbmlmb3JtcyhnbCwgcHJvZ3JhbSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjYWNoZWRVbmlmb3Jtcztcblx0XHR9OyAvLyBzZXQgdXAgY2FjaGluZyBmb3IgYXR0cmlidXRlIGxvY2F0aW9uc1xuXG5cblx0XHRsZXQgY2FjaGVkQXR0cmlidXRlcztcblxuXHRcdHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKGdsLCBwcm9ncmFtKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XG5cdFx0fTsgLy8gZnJlZSByZXNvdXJjZVxuXG5cblx0XHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRiaW5kaW5nU3RhdGVzLnJlbGVhc2VTdGF0ZXNPZlByb2dyYW0odGhpcyk7XG5cdFx0XHRnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuXHRcdFx0dGhpcy5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXHRcdH07IC8vXG5cblxuXHRcdHRoaXMubmFtZSA9IHBhcmFtZXRlcnMuc2hhZGVyTmFtZTtcblx0XHR0aGlzLmlkID0gcHJvZ3JhbUlkQ291bnQrKztcblx0XHR0aGlzLmNhY2hlS2V5ID0gY2FjaGVLZXk7XG5cdFx0dGhpcy51c2VkVGltZXMgPSAxO1xuXHRcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gZ2xGcmFnbWVudFNoYWRlcjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMUHJvZ3JhbXMocmVuZGVyZXIsIGN1YmVtYXBzLCBjdWJldXZtYXBzLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMsIGJpbmRpbmdTdGF0ZXMsIGNsaXBwaW5nKSB7XG5cdFx0Y29uc3QgcHJvZ3JhbXMgPSBbXTtcblx0XHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcblx0XHRjb25zdCBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI7XG5cdFx0Y29uc3QgZmxvYXRWZXJ0ZXhUZXh0dXJlcyA9IGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzO1xuXHRcdGNvbnN0IG1heFZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xuXHRcdGNvbnN0IHZlcnRleFRleHR1cmVzID0gY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuXHRcdGxldCBwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xuXHRcdGNvbnN0IHNoYWRlcklEcyA9IHtcblx0XHRcdE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuXHRcdFx0TWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuXHRcdFx0TWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcblx0XHRcdE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuXHRcdFx0TWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuXHRcdFx0TWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG5cdFx0XHRNZXNoVG9vbk1hdGVyaWFsOiAndG9vbicsXG5cdFx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcblx0XHRcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuXHRcdFx0TWVzaE1hdGNhcE1hdGVyaWFsOiAnbWF0Y2FwJyxcblx0XHRcdExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuXHRcdFx0TGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcblx0XHRcdFBvaW50c01hdGVyaWFsOiAncG9pbnRzJyxcblx0XHRcdFNoYWRvd01hdGVyaWFsOiAnc2hhZG93Jyxcblx0XHRcdFNwcml0ZU1hdGVyaWFsOiAnc3ByaXRlJ1xuXHRcdH07XG5cdFx0Y29uc3QgcGFyYW1ldGVyTmFtZXMgPSBbJ3ByZWNpc2lvbicsICdpc1dlYkdMMicsICdzdXBwb3J0c1ZlcnRleFRleHR1cmVzJywgJ291dHB1dEVuY29kaW5nJywgJ2luc3RhbmNpbmcnLCAnaW5zdGFuY2luZ0NvbG9yJywgJ21hcCcsICdtYXBFbmNvZGluZycsICdtYXRjYXAnLCAnbWF0Y2FwRW5jb2RpbmcnLCAnZW52TWFwJywgJ2Vudk1hcE1vZGUnLCAnZW52TWFwRW5jb2RpbmcnLCAnZW52TWFwQ3ViZVVWJywgJ2xpZ2h0TWFwJywgJ2xpZ2h0TWFwRW5jb2RpbmcnLCAnYW9NYXAnLCAnZW1pc3NpdmVNYXAnLCAnZW1pc3NpdmVNYXBFbmNvZGluZycsICdidW1wTWFwJywgJ25vcm1hbE1hcCcsICdvYmplY3RTcGFjZU5vcm1hbE1hcCcsICd0YW5nZW50U3BhY2VOb3JtYWxNYXAnLCAnY2xlYXJjb2F0TWFwJywgJ2NsZWFyY29hdFJvdWdobmVzc01hcCcsICdjbGVhcmNvYXROb3JtYWxNYXAnLCAnZGlzcGxhY2VtZW50TWFwJywgJ3NwZWN1bGFyTWFwJywgJ3NwZWN1bGFySW50ZW5zaXR5TWFwJywgJ3NwZWN1bGFyVGludE1hcCcsICdzcGVjdWxhclRpbnRNYXBFbmNvZGluZycsICdyb3VnaG5lc3NNYXAnLCAnbWV0YWxuZXNzTWFwJywgJ2dyYWRpZW50TWFwJywgJ2FscGhhTWFwJywgJ2NvbWJpbmUnLCAndmVydGV4Q29sb3JzJywgJ3ZlcnRleEFscGhhcycsICd2ZXJ0ZXhUYW5nZW50cycsICd2ZXJ0ZXhVdnMnLCAndXZzVmVydGV4T25seScsICdmb2cnLCAndXNlRm9nJywgJ2ZvZ0V4cDInLCAnZmxhdFNoYWRpbmcnLCAnc2l6ZUF0dGVudWF0aW9uJywgJ2xvZ2FyaXRobWljRGVwdGhCdWZmZXInLCAnc2tpbm5pbmcnLCAnbWF4Qm9uZXMnLCAndXNlVmVydGV4VGV4dHVyZScsICdtb3JwaFRhcmdldHMnLCAnbW9ycGhOb3JtYWxzJywgJ3ByZW11bHRpcGxpZWRBbHBoYScsICdudW1EaXJMaWdodHMnLCAnbnVtUG9pbnRMaWdodHMnLCAnbnVtU3BvdExpZ2h0cycsICdudW1IZW1pTGlnaHRzJywgJ251bVJlY3RBcmVhTGlnaHRzJywgJ251bURpckxpZ2h0U2hhZG93cycsICdudW1Qb2ludExpZ2h0U2hhZG93cycsICdudW1TcG90TGlnaHRTaGFkb3dzJywgJ3NoYWRvd01hcEVuYWJsZWQnLCAnc2hhZG93TWFwVHlwZScsICd0b25lTWFwcGluZycsICdwaHlzaWNhbGx5Q29ycmVjdExpZ2h0cycsICdhbHBoYVRlc3QnLCAnZG91YmxlU2lkZWQnLCAnZmxpcFNpZGVkJywgJ251bUNsaXBwaW5nUGxhbmVzJywgJ251bUNsaXBJbnRlcnNlY3Rpb24nLCAnZGVwdGhQYWNraW5nJywgJ2RpdGhlcmluZycsICdzaGVlbicsICd0cmFuc21pc3Npb24nLCAndHJhbnNtaXNzaW9uTWFwJywgJ3RoaWNrbmVzc01hcCddO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0TWF4Qm9uZXMob2JqZWN0KSB7XG5cdFx0XHRjb25zdCBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcblx0XHRcdGNvbnN0IGJvbmVzID0gc2tlbGV0b24uYm9uZXM7XG5cblx0XHRcdGlmIChmbG9hdFZlcnRleFRleHR1cmVzKSB7XG5cdFx0XHRcdHJldHVybiAxMDI0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0XHQvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly9cdC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcblx0XHRcdFx0Ly9cdC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXG5cdFx0XHRcdC8vXHRcdCh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcblx0XHRcdFx0Y29uc3QgblZlcnRleFVuaWZvcm1zID0gbWF4VmVydGV4VW5pZm9ybXM7XG5cdFx0XHRcdGNvbnN0IG5WZXJ0ZXhNYXRyaWNlcyA9IE1hdGguZmxvb3IoKG5WZXJ0ZXhVbmlmb3JtcyAtIDIwKSAvIDQpO1xuXHRcdFx0XHRjb25zdCBtYXhCb25lcyA9IE1hdGgubWluKG5WZXJ0ZXhNYXRyaWNlcywgYm9uZXMubGVuZ3RoKTtcblxuXHRcdFx0XHRpZiAobWF4Qm9uZXMgPCBib25lcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFNrZWxldG9uIGhhcyAnICsgYm9uZXMubGVuZ3RoICsgJyBib25lcy4gVGhpcyBHUFUgc3VwcG9ydHMgJyArIG1heEJvbmVzICsgJy4nKTtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXhCb25lcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKG1hcCkge1xuXHRcdFx0bGV0IGVuY29kaW5nO1xuXG5cdFx0XHRpZiAobWFwICYmIG1hcC5pc1RleHR1cmUpIHtcblx0XHRcdFx0ZW5jb2RpbmcgPSBtYXAuZW5jb2Rpbmc7XG5cdFx0XHR9IGVsc2UgaWYgKG1hcCAmJiBtYXAuaXNXZWJHTFJlbmRlclRhcmdldCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUHJvZ3JhbXMuZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcDogZG9uXFwndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRlbmNvZGluZyA9IG1hcC50ZXh0dXJlLmVuY29kaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVuY29kaW5nO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMobWF0ZXJpYWwsIGxpZ2h0cywgc2hhZG93cywgc2NlbmUsIG9iamVjdCkge1xuXHRcdFx0Y29uc3QgZm9nID0gc2NlbmUuZm9nO1xuXHRcdFx0Y29uc3QgZW52aXJvbm1lbnQgPSBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gc2NlbmUuZW52aXJvbm1lbnQgOiBudWxsO1xuXHRcdFx0Y29uc3QgZW52TWFwID0gKG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBjdWJldXZtYXBzIDogY3ViZW1hcHMpLmdldChtYXRlcmlhbC5lbnZNYXAgfHwgZW52aXJvbm1lbnQpO1xuXHRcdFx0Y29uc3Qgc2hhZGVySUQgPSBzaGFkZXJJRHNbbWF0ZXJpYWwudHlwZV07IC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXG5cdFx0XHQvLyAobm90IHRvIGJsb3cgb3ZlciBtYXhMaWdodHMgYnVkZ2V0KVxuXG5cdFx0XHRjb25zdCBtYXhCb25lcyA9IG9iamVjdC5pc1NraW5uZWRNZXNoID8gZ2V0TWF4Qm9uZXMob2JqZWN0KSA6IDA7XG5cblx0XHRcdGlmIChtYXRlcmlhbC5wcmVjaXNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0cHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbihtYXRlcmlhbC5wcmVjaXNpb24pO1xuXG5cdFx0XHRcdGlmIChwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbikge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xQcm9ncmFtLmdldFBhcmFtZXRlcnM6JywgbWF0ZXJpYWwucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBwcmVjaXNpb24sICdpbnN0ZWFkLicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxldCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyO1xuXG5cdFx0XHRpZiAoc2hhZGVySUQpIHtcblx0XHRcdFx0Y29uc3Qgc2hhZGVyID0gU2hhZGVyTGliW3NoYWRlcklEXTtcblx0XHRcdFx0dmVydGV4U2hhZGVyID0gc2hhZGVyLnZlcnRleFNoYWRlcjtcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXIuZnJhZ21lbnRTaGFkZXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXIgPSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXI7XG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXI7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdGlzV2ViR0wyOiBpc1dlYkdMMixcblx0XHRcdFx0c2hhZGVySUQ6IHNoYWRlcklELFxuXHRcdFx0XHRzaGFkZXJOYW1lOiBtYXRlcmlhbC50eXBlLFxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleFNoYWRlcixcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50U2hhZGVyLFxuXHRcdFx0XHRkZWZpbmVzOiBtYXRlcmlhbC5kZWZpbmVzLFxuXHRcdFx0XHRpc1Jhd1NoYWRlck1hdGVyaWFsOiBtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsID09PSB0cnVlLFxuXHRcdFx0XHRnbHNsVmVyc2lvbjogbWF0ZXJpYWwuZ2xzbFZlcnNpb24sXG5cdFx0XHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxuXHRcdFx0XHRpbnN0YW5jaW5nOiBvYmplY3QuaXNJbnN0YW5jZWRNZXNoID09PSB0cnVlLFxuXHRcdFx0XHRpbnN0YW5jaW5nQ29sb3I6IG9iamVjdC5pc0luc3RhbmNlZE1lc2ggPT09IHRydWUgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwsXG5cdFx0XHRcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IHZlcnRleFRleHR1cmVzLFxuXHRcdFx0XHRvdXRwdXRFbmNvZGluZzogY3VycmVudFJlbmRlclRhcmdldCAhPT0gbnVsbCA/IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoY3VycmVudFJlbmRlclRhcmdldC50ZXh0dXJlKSA6IHJlbmRlcmVyLm91dHB1dEVuY29kaW5nLFxuXHRcdFx0XHRtYXA6ICEhbWF0ZXJpYWwubWFwLFxuXHRcdFx0XHRtYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcChtYXRlcmlhbC5tYXApLFxuXHRcdFx0XHRtYXRjYXA6ICEhbWF0ZXJpYWwubWF0Y2FwLFxuXHRcdFx0XHRtYXRjYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcChtYXRlcmlhbC5tYXRjYXApLFxuXHRcdFx0XHRlbnZNYXA6ICEhZW52TWFwLFxuXHRcdFx0XHRlbnZNYXBNb2RlOiBlbnZNYXAgJiYgZW52TWFwLm1hcHBpbmcsXG5cdFx0XHRcdGVudk1hcEVuY29kaW5nOiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKGVudk1hcCksXG5cdFx0XHRcdGVudk1hcEN1YmVVVjogISFlbnZNYXAgJiYgKGVudk1hcC5tYXBwaW5nID09PSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyB8fCBlbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcpLFxuXHRcdFx0XHRsaWdodE1hcDogISFtYXRlcmlhbC5saWdodE1hcCxcblx0XHRcdFx0bGlnaHRNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcChtYXRlcmlhbC5saWdodE1hcCksXG5cdFx0XHRcdGFvTWFwOiAhIW1hdGVyaWFsLmFvTWFwLFxuXHRcdFx0XHRlbWlzc2l2ZU1hcDogISFtYXRlcmlhbC5lbWlzc2l2ZU1hcCxcblx0XHRcdFx0ZW1pc3NpdmVNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcChtYXRlcmlhbC5lbWlzc2l2ZU1hcCksXG5cdFx0XHRcdGJ1bXBNYXA6ICEhbWF0ZXJpYWwuYnVtcE1hcCxcblx0XHRcdFx0bm9ybWFsTWFwOiAhIW1hdGVyaWFsLm5vcm1hbE1hcCxcblx0XHRcdFx0b2JqZWN0U3BhY2VOb3JtYWxNYXA6IG1hdGVyaWFsLm5vcm1hbE1hcFR5cGUgPT09IE9iamVjdFNwYWNlTm9ybWFsTWFwLFxuXHRcdFx0XHR0YW5nZW50U3BhY2VOb3JtYWxNYXA6IG1hdGVyaWFsLm5vcm1hbE1hcFR5cGUgPT09IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCxcblx0XHRcdFx0Y2xlYXJjb2F0TWFwOiAhIW1hdGVyaWFsLmNsZWFyY29hdE1hcCxcblx0XHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzTWFwOiAhIW1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCxcblx0XHRcdFx0Y2xlYXJjb2F0Tm9ybWFsTWFwOiAhIW1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCxcblx0XHRcdFx0ZGlzcGxhY2VtZW50TWFwOiAhIW1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCxcblx0XHRcdFx0cm91Z2huZXNzTWFwOiAhIW1hdGVyaWFsLnJvdWdobmVzc01hcCxcblx0XHRcdFx0bWV0YWxuZXNzTWFwOiAhIW1hdGVyaWFsLm1ldGFsbmVzc01hcCxcblx0XHRcdFx0c3BlY3VsYXJNYXA6ICEhbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXG5cdFx0XHRcdHNwZWN1bGFySW50ZW5zaXR5TWFwOiAhIW1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwLFxuXHRcdFx0XHRzcGVjdWxhclRpbnRNYXA6ICEhbWF0ZXJpYWwuc3BlY3VsYXJUaW50TWFwLFxuXHRcdFx0XHRzcGVjdWxhclRpbnRNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcChtYXRlcmlhbC5zcGVjdWxhclRpbnRNYXApLFxuXHRcdFx0XHRhbHBoYU1hcDogISFtYXRlcmlhbC5hbHBoYU1hcCxcblx0XHRcdFx0Z3JhZGllbnRNYXA6ICEhbWF0ZXJpYWwuZ3JhZGllbnRNYXAsXG5cdFx0XHRcdHNoZWVuOiAhIW1hdGVyaWFsLnNoZWVuLFxuXHRcdFx0XHR0cmFuc21pc3Npb246ICEhbWF0ZXJpYWwudHJhbnNtaXNzaW9uLFxuXHRcdFx0XHR0cmFuc21pc3Npb25NYXA6ICEhbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwLFxuXHRcdFx0XHR0aGlja25lc3NNYXA6ICEhbWF0ZXJpYWwudGhpY2tuZXNzTWFwLFxuXHRcdFx0XHRjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxuXHRcdFx0XHR2ZXJ0ZXhUYW5nZW50czogISFtYXRlcmlhbC5ub3JtYWxNYXAgJiYgISFvYmplY3QuZ2VvbWV0cnkgJiYgISFvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50LFxuXHRcdFx0XHR2ZXJ0ZXhDb2xvcnM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyxcblx0XHRcdFx0dmVydGV4QWxwaGFzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPT09IHRydWUgJiYgISFvYmplY3QuZ2VvbWV0cnkgJiYgISFvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAmJiBvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZSA9PT0gNCxcblx0XHRcdFx0dmVydGV4VXZzOiAhIW1hdGVyaWFsLm1hcCB8fCAhIW1hdGVyaWFsLmJ1bXBNYXAgfHwgISFtYXRlcmlhbC5ub3JtYWxNYXAgfHwgISFtYXRlcmlhbC5zcGVjdWxhck1hcCB8fCAhIW1hdGVyaWFsLmFscGhhTWFwIHx8ICEhbWF0ZXJpYWwuZW1pc3NpdmVNYXAgfHwgISFtYXRlcmlhbC5yb3VnaG5lc3NNYXAgfHwgISFtYXRlcmlhbC5tZXRhbG5lc3NNYXAgfHwgISFtYXRlcmlhbC5jbGVhcmNvYXRNYXAgfHwgISFtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgfHwgISFtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAgfHwgISFtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgfHwgISFtYXRlcmlhbC50cmFuc21pc3Npb25NYXAgfHwgISFtYXRlcmlhbC50aGlja25lc3NNYXAgfHwgISFtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCB8fCAhIW1hdGVyaWFsLnNwZWN1bGFyVGludE1hcCxcblx0XHRcdFx0dXZzVmVydGV4T25seTogISghIW1hdGVyaWFsLm1hcCB8fCAhIW1hdGVyaWFsLmJ1bXBNYXAgfHwgISFtYXRlcmlhbC5ub3JtYWxNYXAgfHwgISFtYXRlcmlhbC5zcGVjdWxhck1hcCB8fCAhIW1hdGVyaWFsLmFscGhhTWFwIHx8ICEhbWF0ZXJpYWwuZW1pc3NpdmVNYXAgfHwgISFtYXRlcmlhbC5yb3VnaG5lc3NNYXAgfHwgISFtYXRlcmlhbC5tZXRhbG5lc3NNYXAgfHwgISFtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAgfHwgISFtYXRlcmlhbC50cmFuc21pc3Npb24gfHwgISFtYXRlcmlhbC50cmFuc21pc3Npb25NYXAgfHwgISFtYXRlcmlhbC50aGlja25lc3NNYXAgfHwgISFtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCB8fCAhIW1hdGVyaWFsLnNwZWN1bGFyVGludE1hcCkgJiYgISFtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXG5cdFx0XHRcdGZvZzogISFmb2csXG5cdFx0XHRcdHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxuXHRcdFx0XHRmb2dFeHAyOiBmb2cgJiYgZm9nLmlzRm9nRXhwMixcblx0XHRcdFx0ZmxhdFNoYWRpbmc6ICEhbWF0ZXJpYWwuZmxhdFNoYWRpbmcsXG5cdFx0XHRcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxuXHRcdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXHRcdFx0XHRza2lubmluZzogb2JqZWN0LmlzU2tpbm5lZE1lc2ggPT09IHRydWUgJiYgbWF4Qm9uZXMgPiAwLFxuXHRcdFx0XHRtYXhCb25lczogbWF4Qm9uZXMsXG5cdFx0XHRcdHVzZVZlcnRleFRleHR1cmU6IGZsb2F0VmVydGV4VGV4dHVyZXMsXG5cdFx0XHRcdG1vcnBoVGFyZ2V0czogISFvYmplY3QuZ2VvbWV0cnkgJiYgISFvYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLFxuXHRcdFx0XHRtb3JwaE5vcm1hbHM6ICEhb2JqZWN0Lmdlb21ldHJ5ICYmICEhb2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwsXG5cdFx0XHRcdG51bURpckxpZ2h0czogbGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCxcblx0XHRcdFx0bnVtUG9pbnRMaWdodHM6IGxpZ2h0cy5wb2ludC5sZW5ndGgsXG5cdFx0XHRcdG51bVNwb3RMaWdodHM6IGxpZ2h0cy5zcG90Lmxlbmd0aCxcblx0XHRcdFx0bnVtUmVjdEFyZWFMaWdodHM6IGxpZ2h0cy5yZWN0QXJlYS5sZW5ndGgsXG5cdFx0XHRcdG51bUhlbWlMaWdodHM6IGxpZ2h0cy5oZW1pLmxlbmd0aCxcblx0XHRcdFx0bnVtRGlyTGlnaHRTaGFkb3dzOiBsaWdodHMuZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoLFxuXHRcdFx0XHRudW1Qb2ludExpZ2h0U2hhZG93czogbGlnaHRzLnBvaW50U2hhZG93TWFwLmxlbmd0aCxcblx0XHRcdFx0bnVtU3BvdExpZ2h0U2hhZG93czogbGlnaHRzLnNwb3RTaGFkb3dNYXAubGVuZ3RoLFxuXHRcdFx0XHRudW1DbGlwcGluZ1BsYW5lczogY2xpcHBpbmcubnVtUGxhbmVzLFxuXHRcdFx0XHRudW1DbGlwSW50ZXJzZWN0aW9uOiBjbGlwcGluZy5udW1JbnRlcnNlY3Rpb24sXG5cdFx0XHRcdGRpdGhlcmluZzogbWF0ZXJpYWwuZGl0aGVyaW5nLFxuXHRcdFx0XHRzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBzaGFkb3dzLmxlbmd0aCA+IDAsXG5cdFx0XHRcdHNoYWRvd01hcFR5cGU6IHJlbmRlcmVyLnNoYWRvd01hcC50eXBlLFxuXHRcdFx0XHR0b25lTWFwcGluZzogbWF0ZXJpYWwudG9uZU1hcHBlZCA/IHJlbmRlcmVyLnRvbmVNYXBwaW5nIDogTm9Ub25lTWFwcGluZyxcblx0XHRcdFx0cGh5c2ljYWxseUNvcnJlY3RMaWdodHM6IHJlbmRlcmVyLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzLFxuXHRcdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSxcblx0XHRcdFx0YWxwaGFUZXN0OiBtYXRlcmlhbC5hbHBoYVRlc3QsXG5cdFx0XHRcdGRvdWJsZVNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlLFxuXHRcdFx0XHRmbGlwU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlLFxuXHRcdFx0XHRkZXB0aFBhY2tpbmc6IG1hdGVyaWFsLmRlcHRoUGFja2luZyAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwuZGVwdGhQYWNraW5nIDogZmFsc2UsXG5cdFx0XHRcdGluZGV4MEF0dHJpYnV0ZU5hbWU6IG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUsXG5cdFx0XHRcdGV4dGVuc2lvbkRlcml2YXRpdmVzOiBtYXRlcmlhbC5leHRlbnNpb25zICYmIG1hdGVyaWFsLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMsXG5cdFx0XHRcdGV4dGVuc2lvbkZyYWdEZXB0aDogbWF0ZXJpYWwuZXh0ZW5zaW9ucyAmJiBtYXRlcmlhbC5leHRlbnNpb25zLmZyYWdEZXB0aCxcblx0XHRcdFx0ZXh0ZW5zaW9uRHJhd0J1ZmZlcnM6IG1hdGVyaWFsLmV4dGVuc2lvbnMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5kcmF3QnVmZmVycyxcblx0XHRcdFx0ZXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxPRDogbWF0ZXJpYWwuZXh0ZW5zaW9ucyAmJiBtYXRlcmlhbC5leHRlbnNpb25zLnNoYWRlclRleHR1cmVMT0QsXG5cdFx0XHRcdHJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoOiBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcygnRVhUX2ZyYWdfZGVwdGgnKSxcblx0XHRcdFx0cmVuZGVyZXJFeHRlbnNpb25EcmF3QnVmZmVyczogaXNXZWJHTDIgfHwgZXh0ZW5zaW9ucy5oYXMoJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuXHRcdFx0XHRyZW5kZXJlckV4dGVuc2lvblNoYWRlclRleHR1cmVMb2Q6IGlzV2ViR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJyksXG5cdFx0XHRcdGN1c3RvbVByb2dyYW1DYWNoZUtleTogbWF0ZXJpYWwuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KClcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVycztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQcm9ncmFtQ2FjaGVLZXkocGFyYW1ldGVycykge1xuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0aWYgKHBhcmFtZXRlcnMuc2hhZGVySUQpIHtcblx0XHRcdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzLnNoYWRlcklEKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5mcmFnbWVudFNoYWRlcik7XG5cdFx0XHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy52ZXJ0ZXhTaGFkZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocGFyYW1ldGVycy5kZWZpbmVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Zm9yIChjb25zdCBuYW1lIGluIHBhcmFtZXRlcnMuZGVmaW5lcykge1xuXHRcdFx0XHRcdGFycmF5LnB1c2gobmFtZSk7XG5cdFx0XHRcdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzLmRlZmluZXNbbmFtZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRhcnJheS5wdXNoKHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZXNbaV1dKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFycmF5LnB1c2gocmVuZGVyZXIub3V0cHV0RW5jb2RpbmcpO1xuXHRcdFx0XHRhcnJheS5wdXNoKHJlbmRlcmVyLmdhbW1hRmFjdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzLmN1c3RvbVByb2dyYW1DYWNoZUtleSk7XG5cdFx0XHRyZXR1cm4gYXJyYXkuam9pbigpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFVuaWZvcm1zKG1hdGVyaWFsKSB7XG5cdFx0XHRjb25zdCBzaGFkZXJJRCA9IHNoYWRlcklEc1ttYXRlcmlhbC50eXBlXTtcblx0XHRcdGxldCB1bmlmb3JtcztcblxuXHRcdFx0aWYgKHNoYWRlcklEKSB7XG5cdFx0XHRcdGNvbnN0IHNoYWRlciA9IFNoYWRlckxpYltzaGFkZXJJRF07XG5cdFx0XHRcdHVuaWZvcm1zID0gVW5pZm9ybXNVdGlscy5jbG9uZShzaGFkZXIudW5pZm9ybXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3Jtcztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuaWZvcm1zO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFjcXVpcmVQcm9ncmFtKHBhcmFtZXRlcnMsIGNhY2hlS2V5KSB7XG5cdFx0XHRsZXQgcHJvZ3JhbTsgLy8gQ2hlY2sgaWYgY29kZSBoYXMgYmVlbiBhbHJlYWR5IGNvbXBpbGVkXG5cblx0XHRcdGZvciAobGV0IHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwKyspIHtcblx0XHRcdFx0Y29uc3QgcHJlZXhpc3RpbmdQcm9ncmFtID0gcHJvZ3JhbXNbcF07XG5cblx0XHRcdFx0aWYgKHByZWV4aXN0aW5nUHJvZ3JhbS5jYWNoZUtleSA9PT0gY2FjaGVLZXkpIHtcblx0XHRcdFx0XHRwcm9ncmFtID0gcHJlZXhpc3RpbmdQcm9ncmFtO1xuXHRcdFx0XHRcdCsrcHJvZ3JhbS51c2VkVGltZXM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHByb2dyYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwcm9ncmFtID0gbmV3IFdlYkdMUHJvZ3JhbShyZW5kZXJlciwgY2FjaGVLZXksIHBhcmFtZXRlcnMsIGJpbmRpbmdTdGF0ZXMpO1xuXHRcdFx0XHRwcm9ncmFtcy5wdXNoKHByb2dyYW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWxlYXNlUHJvZ3JhbShwcm9ncmFtKSB7XG5cdFx0XHRpZiAoLS1wcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCkge1xuXHRcdFx0XHQvLyBSZW1vdmUgZnJvbSB1bm9yZGVyZWQgc2V0XG5cdFx0XHRcdGNvbnN0IGkgPSBwcm9ncmFtcy5pbmRleE9mKHByb2dyYW0pO1xuXHRcdFx0XHRwcm9ncmFtc1tpXSA9IHByb2dyYW1zW3Byb2dyYW1zLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRwcm9ncmFtcy5wb3AoKTsgLy8gRnJlZSBXZWJHTCByZXNvdXJjZXNcblxuXHRcdFx0XHRwcm9ncmFtLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0UGFyYW1ldGVyczogZ2V0UGFyYW1ldGVycyxcblx0XHRcdGdldFByb2dyYW1DYWNoZUtleTogZ2V0UHJvZ3JhbUNhY2hlS2V5LFxuXHRcdFx0Z2V0VW5pZm9ybXM6IGdldFVuaWZvcm1zLFxuXHRcdFx0YWNxdWlyZVByb2dyYW06IGFjcXVpcmVQcm9ncmFtLFxuXHRcdFx0cmVsZWFzZVByb2dyYW06IHJlbGVhc2VQcm9ncmFtLFxuXHRcdFx0Ly8gRXhwb3NlZCBmb3IgcmVzb3VyY2UgbW9uaXRvcmluZyAmIGVycm9yIGZlZWRiYWNrIHZpYSByZW5kZXJlci5pbmZvOlxuXHRcdFx0cHJvZ3JhbXM6IHByb2dyYW1zXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMUHJvcGVydGllcygpIHtcblx0XHRsZXQgcHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHRmdW5jdGlvbiBnZXQob2JqZWN0KSB7XG5cdFx0XHRsZXQgbWFwID0gcHJvcGVydGllcy5nZXQob2JqZWN0KTtcblxuXHRcdFx0aWYgKG1hcCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG1hcCA9IHt9O1xuXHRcdFx0XHRwcm9wZXJ0aWVzLnNldChvYmplY3QsIG1hcCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlKG9iamVjdCkge1xuXHRcdFx0cHJvcGVydGllcy5kZWxldGUob2JqZWN0KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdFx0XHRwcm9wZXJ0aWVzLmdldChvYmplY3QpW2tleV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0cHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0cmVtb3ZlOiByZW1vdmUsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZSxcblx0XHRcdGRpc3Bvc2U6IGRpc3Bvc2Vcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoYSwgYikge1xuXHRcdGlmIChhLmdyb3VwT3JkZXIgIT09IGIuZ3JvdXBPcmRlcikge1xuXHRcdFx0cmV0dXJuIGEuZ3JvdXBPcmRlciAtIGIuZ3JvdXBPcmRlcjtcblx0XHR9IGVsc2UgaWYgKGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIpIHtcblx0XHRcdHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcblx0XHR9IGVsc2UgaWYgKGEucHJvZ3JhbSAhPT0gYi5wcm9ncmFtKSB7XG5cdFx0XHRyZXR1cm4gYS5wcm9ncmFtLmlkIC0gYi5wcm9ncmFtLmlkO1xuXHRcdH0gZWxzZSBpZiAoYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCkge1xuXHRcdFx0cmV0dXJuIGEubWF0ZXJpYWwuaWQgLSBiLm1hdGVyaWFsLmlkO1xuXHRcdH0gZWxzZSBpZiAoYS56ICE9PSBiLnopIHtcblx0XHRcdHJldHVybiBhLnogLSBiLno7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBhLmlkIC0gYi5pZDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUoYSwgYikge1xuXHRcdGlmIChhLmdyb3VwT3JkZXIgIT09IGIuZ3JvdXBPcmRlcikge1xuXHRcdFx0cmV0dXJuIGEuZ3JvdXBPcmRlciAtIGIuZ3JvdXBPcmRlcjtcblx0XHR9IGVsc2UgaWYgKGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIpIHtcblx0XHRcdHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcblx0XHR9IGVsc2UgaWYgKGEueiAhPT0gYi56KSB7XG5cdFx0XHRyZXR1cm4gYi56IC0gYS56O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJMaXN0KHByb3BlcnRpZXMpIHtcblx0XHRjb25zdCByZW5kZXJJdGVtcyA9IFtdO1xuXHRcdGxldCByZW5kZXJJdGVtc0luZGV4ID0gMDtcblx0XHRjb25zdCBvcGFxdWUgPSBbXTtcblx0XHRjb25zdCB0cmFuc21pc3NpdmUgPSBbXTtcblx0XHRjb25zdCB0cmFuc3BhcmVudCA9IFtdO1xuXHRcdGNvbnN0IGRlZmF1bHRQcm9ncmFtID0ge1xuXHRcdFx0aWQ6IC0xXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXQoKSB7XG5cdFx0XHRyZW5kZXJJdGVtc0luZGV4ID0gMDtcblx0XHRcdG9wYXF1ZS5sZW5ndGggPSAwO1xuXHRcdFx0dHJhbnNtaXNzaXZlLmxlbmd0aCA9IDA7XG5cdFx0XHR0cmFuc3BhcmVudC5sZW5ndGggPSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE5leHRSZW5kZXJJdGVtKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCkge1xuXHRcdFx0bGV0IHJlbmRlckl0ZW0gPSByZW5kZXJJdGVtc1tyZW5kZXJJdGVtc0luZGV4XTtcblx0XHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKTtcblxuXHRcdFx0aWYgKHJlbmRlckl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZW5kZXJJdGVtID0ge1xuXHRcdFx0XHRcdGlkOiBvYmplY3QuaWQsXG5cdFx0XHRcdFx0b2JqZWN0OiBvYmplY3QsXG5cdFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxuXHRcdFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbCxcblx0XHRcdFx0XHRwcm9ncmFtOiBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSB8fCBkZWZhdWx0UHJvZ3JhbSxcblx0XHRcdFx0XHRncm91cE9yZGVyOiBncm91cE9yZGVyLFxuXHRcdFx0XHRcdHJlbmRlck9yZGVyOiBvYmplY3QucmVuZGVyT3JkZXIsXG5cdFx0XHRcdFx0ejogeixcblx0XHRcdFx0XHRncm91cDogZ3JvdXBcblx0XHRcdFx0fTtcblx0XHRcdFx0cmVuZGVySXRlbXNbcmVuZGVySXRlbXNJbmRleF0gPSByZW5kZXJJdGVtO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVuZGVySXRlbS5pZCA9IG9iamVjdC5pZDtcblx0XHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBvYmplY3Q7XG5cdFx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHRcdFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXHRcdFx0XHRyZW5kZXJJdGVtLnByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSB8fCBkZWZhdWx0UHJvZ3JhbTtcblx0XHRcdFx0cmVuZGVySXRlbS5ncm91cE9yZGVyID0gZ3JvdXBPcmRlcjtcblx0XHRcdFx0cmVuZGVySXRlbS5yZW5kZXJPcmRlciA9IG9iamVjdC5yZW5kZXJPcmRlcjtcblx0XHRcdFx0cmVuZGVySXRlbS56ID0gejtcblx0XHRcdFx0cmVuZGVySXRlbS5ncm91cCA9IGdyb3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJJdGVtc0luZGV4Kys7XG5cdFx0XHRyZXR1cm4gcmVuZGVySXRlbTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwdXNoKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCkge1xuXHRcdFx0Y29uc3QgcmVuZGVySXRlbSA9IGdldE5leHRSZW5kZXJJdGVtKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCk7XG5cblx0XHRcdGlmIChtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwLjApIHtcblx0XHRcdFx0dHJhbnNtaXNzaXZlLnB1c2gocmVuZGVySXRlbSk7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlKSB7XG5cdFx0XHRcdHRyYW5zcGFyZW50LnB1c2gocmVuZGVySXRlbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcGFxdWUucHVzaChyZW5kZXJJdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnNoaWZ0KG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCkge1xuXHRcdFx0Y29uc3QgcmVuZGVySXRlbSA9IGdldE5leHRSZW5kZXJJdGVtKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCk7XG5cblx0XHRcdGlmIChtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwLjApIHtcblx0XHRcdFx0dHJhbnNtaXNzaXZlLnVuc2hpZnQocmVuZGVySXRlbSk7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlKSB7XG5cdFx0XHRcdHRyYW5zcGFyZW50LnVuc2hpZnQocmVuZGVySXRlbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcGFxdWUudW5zaGlmdChyZW5kZXJJdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzb3J0KGN1c3RvbU9wYXF1ZVNvcnQsIGN1c3RvbVRyYW5zcGFyZW50U29ydCkge1xuXHRcdFx0aWYgKG9wYXF1ZS5sZW5ndGggPiAxKSBvcGFxdWUuc29ydChjdXN0b21PcGFxdWVTb3J0IHx8IHBhaW50ZXJTb3J0U3RhYmxlKTtcblx0XHRcdGlmICh0cmFuc21pc3NpdmUubGVuZ3RoID4gMSkgdHJhbnNtaXNzaXZlLnNvcnQoY3VzdG9tVHJhbnNwYXJlbnRTb3J0IHx8IHJldmVyc2VQYWludGVyU29ydFN0YWJsZSk7XG5cdFx0XHRpZiAodHJhbnNwYXJlbnQubGVuZ3RoID4gMSkgdHJhbnNwYXJlbnQuc29ydChjdXN0b21UcmFuc3BhcmVudFNvcnQgfHwgcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5pc2goKSB7XG5cdFx0XHQvLyBDbGVhciByZWZlcmVuY2VzIGZyb20gaW5hY3RpdmUgcmVuZGVySXRlbXMgaW4gdGhlIGxpc3Rcblx0XHRcdGZvciAobGV0IGkgPSByZW5kZXJJdGVtc0luZGV4LCBpbCA9IHJlbmRlckl0ZW1zLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcmVuZGVySXRlbSA9IHJlbmRlckl0ZW1zW2ldO1xuXHRcdFx0XHRpZiAocmVuZGVySXRlbS5pZCA9PT0gbnVsbCkgYnJlYWs7XG5cdFx0XHRcdHJlbmRlckl0ZW0uaWQgPSBudWxsO1xuXHRcdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG51bGw7XG5cdFx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBudWxsO1xuXHRcdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbnVsbDtcblx0XHRcdFx0cmVuZGVySXRlbS5wcm9ncmFtID0gbnVsbDtcblx0XHRcdFx0cmVuZGVySXRlbS5ncm91cCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG9wYXF1ZTogb3BhcXVlLFxuXHRcdFx0dHJhbnNtaXNzaXZlOiB0cmFuc21pc3NpdmUsXG5cdFx0XHR0cmFuc3BhcmVudDogdHJhbnNwYXJlbnQsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cHVzaDogcHVzaCxcblx0XHRcdHVuc2hpZnQ6IHVuc2hpZnQsXG5cdFx0XHRmaW5pc2g6IGZpbmlzaCxcblx0XHRcdHNvcnQ6IHNvcnRcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJMaXN0cyhwcm9wZXJ0aWVzKSB7XG5cdFx0bGV0IGxpc3RzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdGZ1bmN0aW9uIGdldChzY2VuZSwgcmVuZGVyQ2FsbERlcHRoKSB7XG5cdFx0XHRsZXQgbGlzdDtcblxuXHRcdFx0aWYgKGxpc3RzLmhhcyhzY2VuZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGxpc3QgPSBuZXcgV2ViR0xSZW5kZXJMaXN0KHByb3BlcnRpZXMpO1xuXHRcdFx0XHRsaXN0cy5zZXQoc2NlbmUsIFtsaXN0XSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAocmVuZGVyQ2FsbERlcHRoID49IGxpc3RzLmdldChzY2VuZSkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG5ldyBXZWJHTFJlbmRlckxpc3QocHJvcGVydGllcyk7XG5cdFx0XHRcdFx0bGlzdHMuZ2V0KHNjZW5lKS5wdXNoKGxpc3QpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBsaXN0cy5nZXQoc2NlbmUpW3JlbmRlckNhbGxEZXB0aF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdGxpc3RzID0gbmV3IFdlYWtNYXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIFVuaWZvcm1zQ2FjaGUoKSB7XG5cdFx0Y29uc3QgbGlnaHRzID0ge307XG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKGxpZ2h0KSB7XG5cdFx0XHRcdGlmIChsaWdodHNbbGlnaHQuaWRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGlnaHRzW2xpZ2h0LmlkXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCB1bmlmb3JtcztcblxuXHRcdFx0XHRzd2l0Y2ggKGxpZ2h0LnR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0Jzpcblx0XHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0Jzpcblx0XHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRcdGRpc3RhbmNlOiAwLFxuXHRcdFx0XHRcdFx0XHRjb25lQ29zOiAwLFxuXHRcdFx0XHRcdFx0XHRwZW51bWJyYUNvczogMCxcblx0XHRcdFx0XHRcdFx0ZGVjYXk6IDBcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuXHRcdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRcdGRpc3RhbmNlOiAwLFxuXHRcdFx0XHRcdFx0XHRkZWNheTogMFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0Jzpcblx0XHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdHNreUNvbG9yOiBuZXcgQ29sb3IoKSxcblx0XHRcdFx0XHRcdFx0Z3JvdW5kQ29sb3I6IG5ldyBDb2xvcigpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdSZWN0QXJlYUxpZ2h0Jzpcblx0XHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRoYWxmV2lkdGg6IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdGhhbGZIZWlnaHQ6IG5ldyBWZWN0b3IzKClcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxpZ2h0c1tsaWdodC5pZF0gPSB1bmlmb3Jtcztcblx0XHRcdFx0cmV0dXJuIHVuaWZvcm1zO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBTaGFkb3dVbmlmb3Jtc0NhY2hlKCkge1xuXHRcdGNvbnN0IGxpZ2h0cyA9IHt9O1xuXHRcdHJldHVybiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIChsaWdodCkge1xuXHRcdFx0XHRpZiAobGlnaHRzW2xpZ2h0LmlkXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxpZ2h0c1tsaWdodC5pZF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgdW5pZm9ybXM7XG5cblx0XHRcdFx0c3dpdGNoIChsaWdodC50eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cdFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcblx0XHRcdFx0XHRcdFx0c2hhZG93Tm9ybWFsQmlhczogMCxcblx0XHRcdFx0XHRcdFx0c2hhZG93UmFkaXVzOiAxLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXHRcdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IDAsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcblx0XHRcdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG5cdFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcblx0XHRcdFx0XHRcdFx0c2hhZG93Tm9ybWFsQmlhczogMCxcblx0XHRcdFx0XHRcdFx0c2hhZG93UmFkaXVzOiAxLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmFOZWFyOiAxLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmFGYXI6IDEwMDBcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogc2V0IFJlY3RBcmVhTGlnaHQgc2hhZG93IHVuaWZvcm1zXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsaWdodHNbbGlnaHQuaWRdID0gdW5pZm9ybXM7XG5cdFx0XHRcdHJldHVybiB1bmlmb3Jtcztcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0bGV0IG5leHRWZXJzaW9uID0gMDtcblxuXHRmdW5jdGlvbiBzaGFkb3dDYXN0aW5nTGlnaHRzRmlyc3QobGlnaHRBLCBsaWdodEIpIHtcblx0XHRyZXR1cm4gKGxpZ2h0Qi5jYXN0U2hhZG93ID8gMSA6IDApIC0gKGxpZ2h0QS5jYXN0U2hhZG93ID8gMSA6IDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xMaWdodHMoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKSB7XG5cdFx0Y29uc3QgY2FjaGUgPSBuZXcgVW5pZm9ybXNDYWNoZSgpO1xuXHRcdGNvbnN0IHNoYWRvd0NhY2hlID0gU2hhZG93VW5pZm9ybXNDYWNoZSgpO1xuXHRcdGNvbnN0IHN0YXRlID0ge1xuXHRcdFx0dmVyc2lvbjogMCxcblx0XHRcdGhhc2g6IHtcblx0XHRcdFx0ZGlyZWN0aW9uYWxMZW5ndGg6IC0xLFxuXHRcdFx0XHRwb2ludExlbmd0aDogLTEsXG5cdFx0XHRcdHNwb3RMZW5ndGg6IC0xLFxuXHRcdFx0XHRyZWN0QXJlYUxlbmd0aDogLTEsXG5cdFx0XHRcdGhlbWlMZW5ndGg6IC0xLFxuXHRcdFx0XHRudW1EaXJlY3Rpb25hbFNoYWRvd3M6IC0xLFxuXHRcdFx0XHRudW1Qb2ludFNoYWRvd3M6IC0xLFxuXHRcdFx0XHRudW1TcG90U2hhZG93czogLTFcblx0XHRcdH0sXG5cdFx0XHRhbWJpZW50OiBbMCwgMCwgMF0sXG5cdFx0XHRwcm9iZTogW10sXG5cdFx0XHRkaXJlY3Rpb25hbDogW10sXG5cdFx0XHRkaXJlY3Rpb25hbFNoYWRvdzogW10sXG5cdFx0XHRkaXJlY3Rpb25hbFNoYWRvd01hcDogW10sXG5cdFx0XHRkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDogW10sXG5cdFx0XHRzcG90OiBbXSxcblx0XHRcdHNwb3RTaGFkb3c6IFtdLFxuXHRcdFx0c3BvdFNoYWRvd01hcDogW10sXG5cdFx0XHRzcG90U2hhZG93TWF0cml4OiBbXSxcblx0XHRcdHJlY3RBcmVhOiBbXSxcblx0XHRcdHJlY3RBcmVhTFRDMTogbnVsbCxcblx0XHRcdHJlY3RBcmVhTFRDMjogbnVsbCxcblx0XHRcdHBvaW50OiBbXSxcblx0XHRcdHBvaW50U2hhZG93OiBbXSxcblx0XHRcdHBvaW50U2hhZG93TWFwOiBbXSxcblx0XHRcdHBvaW50U2hhZG93TWF0cml4OiBbXSxcblx0XHRcdGhlbWk6IFtdXG5cdFx0fTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSBzdGF0ZS5wcm9iZS5wdXNoKG5ldyBWZWN0b3IzKCkpO1xuXG5cdFx0Y29uc3QgdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbWF0cml4NCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0Y29uc3QgbWF0cml4NDIgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0ZnVuY3Rpb24gc2V0dXAobGlnaHRzKSB7XG5cdFx0XHRsZXQgciA9IDAsXG5cdFx0XHRcdFx0ZyA9IDAsXG5cdFx0XHRcdFx0YiA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSBzdGF0ZS5wcm9iZVtpXS5zZXQoMCwgMCwgMCk7XG5cblx0XHRcdGxldCBkaXJlY3Rpb25hbExlbmd0aCA9IDA7XG5cdFx0XHRsZXQgcG9pbnRMZW5ndGggPSAwO1xuXHRcdFx0bGV0IHNwb3RMZW5ndGggPSAwO1xuXHRcdFx0bGV0IHJlY3RBcmVhTGVuZ3RoID0gMDtcblx0XHRcdGxldCBoZW1pTGVuZ3RoID0gMDtcblx0XHRcdGxldCBudW1EaXJlY3Rpb25hbFNoYWRvd3MgPSAwO1xuXHRcdFx0bGV0IG51bVBvaW50U2hhZG93cyA9IDA7XG5cdFx0XHRsZXQgbnVtU3BvdFNoYWRvd3MgPSAwO1xuXHRcdFx0bGlnaHRzLnNvcnQoc2hhZG93Q2FzdGluZ0xpZ2h0c0ZpcnN0KTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzW2ldO1xuXHRcdFx0XHRjb25zdCBjb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0XHRjb25zdCBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cdFx0XHRcdGNvbnN0IHNoYWRvd01hcCA9IGxpZ2h0LnNoYWRvdyAmJiBsaWdodC5zaGFkb3cubWFwID8gbGlnaHQuc2hhZG93Lm1hcC50ZXh0dXJlIDogbnVsbDtcblxuXHRcdFx0XHRpZiAobGlnaHQuaXNBbWJpZW50TGlnaHQpIHtcblx0XHRcdFx0XHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdFx0ZyArPSBjb2xvci5nICogaW50ZW5zaXR5O1xuXHRcdFx0XHRcdGIgKz0gY29sb3IuYiAqIGludGVuc2l0eTtcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc0xpZ2h0UHJvYmUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDk7IGorKykge1xuXHRcdFx0XHRcdFx0c3RhdGUucHJvYmVbal0uYWRkU2NhbGVkVmVjdG9yKGxpZ2h0LnNoLmNvZWZmaWNpZW50c1tqXSwgaW50ZW5zaXR5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNEaXJlY3Rpb25hbExpZ2h0KSB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQobGlnaHQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkobGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKGxpZ2h0LmludGVuc2l0eSk7XG5cblx0XHRcdFx0XHRpZiAobGlnaHQuY2FzdFNoYWRvdykge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2hhZG93VW5pZm9ybXMgPSBzaGFkb3dDYWNoZS5nZXQobGlnaHQpO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93QmlhcyA9IHNoYWRvdy5iaWFzO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93Tm9ybWFsQmlhcyA9IHNoYWRvdy5ub3JtYWxCaWFzO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcblx0XHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcblx0XHRcdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93W2RpcmVjdGlvbmFsTGVuZ3RoXSA9IHNoYWRvd1VuaWZvcm1zO1xuXHRcdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXBbZGlyZWN0aW9uYWxMZW5ndGhdID0gc2hhZG93TWFwO1xuXHRcdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbZGlyZWN0aW9uYWxMZW5ndGhdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcblx0XHRcdFx0XHRcdG51bURpcmVjdGlvbmFsU2hhZG93cysrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsW2RpcmVjdGlvbmFsTGVuZ3RoXSA9IHVuaWZvcm1zO1xuXHRcdFx0XHRcdGRpcmVjdGlvbmFsTGVuZ3RoKys7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNTcG90TGlnaHQpIHtcblx0XHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IGNhY2hlLmdldChsaWdodCk7XG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KGNvbG9yKS5tdWx0aXBseVNjYWxhcihpbnRlbnNpdHkpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0XHRcdFx0dW5pZm9ybXMuY29uZUNvcyA9IE1hdGguY29zKGxpZ2h0LmFuZ2xlKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5wZW51bWJyYUNvcyA9IE1hdGguY29zKGxpZ2h0LmFuZ2xlICogKDEgLSBsaWdodC5wZW51bWJyYSkpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRlY2F5ID0gbGlnaHQuZGVjYXk7XG5cblx0XHRcdFx0XHRpZiAobGlnaHQuY2FzdFNoYWRvdykge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2hhZG93VW5pZm9ybXMgPSBzaGFkb3dDYWNoZS5nZXQobGlnaHQpO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93QmlhcyA9IHNoYWRvdy5iaWFzO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93Tm9ybWFsQmlhcyA9IHNoYWRvdy5ub3JtYWxCaWFzO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcblx0XHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcblx0XHRcdFx0XHRcdHN0YXRlLnNwb3RTaGFkb3dbc3BvdExlbmd0aF0gPSBzaGFkb3dVbmlmb3Jtcztcblx0XHRcdFx0XHRcdHN0YXRlLnNwb3RTaGFkb3dNYXBbc3BvdExlbmd0aF0gPSBzaGFkb3dNYXA7XG5cdFx0XHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93TWF0cml4W3Nwb3RMZW5ndGhdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcblx0XHRcdFx0XHRcdG51bVNwb3RTaGFkb3dzKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUuc3BvdFtzcG90TGVuZ3RoXSA9IHVuaWZvcm1zO1xuXHRcdFx0XHRcdHNwb3RMZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc1JlY3RBcmVhTGlnaHQpIHtcblx0XHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IGNhY2hlLmdldChsaWdodCk7IC8vIChhKSBpbnRlbnNpdHkgaXMgdGhlIHRvdGFsIHZpc2libGUgbGlnaHQgZW1pdHRlZFxuXHRcdFx0XHRcdC8vdW5pZm9ybXMuY29sb3IuY29weSggY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5IC8gKCBsaWdodC53aWR0aCAqIGxpZ2h0LmhlaWdodCAqIE1hdGguUEkgKSApO1xuXHRcdFx0XHRcdC8vIChiKSBpbnRlbnNpdHkgaXMgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGxpZ2h0XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KGNvbG9yKS5tdWx0aXBseVNjYWxhcihpbnRlbnNpdHkpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmhhbGZXaWR0aC5zZXQobGlnaHQud2lkdGggKiAwLjUsIDAuMCwgMC4wKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LnNldCgwLjAsIGxpZ2h0LmhlaWdodCAqIDAuNSwgMC4wKTtcblx0XHRcdFx0XHRzdGF0ZS5yZWN0QXJlYVtyZWN0QXJlYUxlbmd0aF0gPSB1bmlmb3Jtcztcblx0XHRcdFx0XHRyZWN0QXJlYUxlbmd0aCsrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpZ2h0LmlzUG9pbnRMaWdodCkge1xuXHRcdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KGxpZ2h0KTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KGxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcihsaWdodC5pbnRlbnNpdHkpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSBsaWdodC5kZWNheTtcblxuXHRcdFx0XHRcdGlmIChsaWdodC5jYXN0U2hhZG93KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cdFx0XHRcdFx0XHRjb25zdCBzaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldChsaWdodCk7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93Q2FtZXJhTmVhciA9IHNoYWRvdy5jYW1lcmEubmVhcjtcblx0XHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0NhbWVyYUZhciA9IHNoYWRvdy5jYW1lcmEuZmFyO1xuXHRcdFx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3dbcG9pbnRMZW5ndGhdID0gc2hhZG93VW5pZm9ybXM7XG5cdFx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hcFtwb2ludExlbmd0aF0gPSBzaGFkb3dNYXA7XG5cdFx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hdHJpeFtwb2ludExlbmd0aF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xuXHRcdFx0XHRcdFx0bnVtUG9pbnRTaGFkb3dzKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUucG9pbnRbcG9pbnRMZW5ndGhdID0gdW5pZm9ybXM7XG5cdFx0XHRcdFx0cG9pbnRMZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc0hlbWlzcGhlcmVMaWdodCkge1xuXHRcdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KGxpZ2h0KTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5za3lDb2xvci5jb3B5KGxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcihpbnRlbnNpdHkpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmdyb3VuZENvbG9yLmNvcHkobGlnaHQuZ3JvdW5kQ29sb3IpLm11bHRpcGx5U2NhbGFyKGludGVuc2l0eSk7XG5cdFx0XHRcdFx0c3RhdGUuaGVtaVtoZW1pTGVuZ3RoXSA9IHVuaWZvcm1zO1xuXHRcdFx0XHRcdGhlbWlMZW5ndGgrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVjdEFyZWFMZW5ndGggPiAwKSB7XG5cdFx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHtcblx0XHRcdFx0XHQvLyBXZWJHTCAyXG5cdFx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMxID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzE7XG5cdFx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMyID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gV2ViR0wgMVxuXHRcdFx0XHRcdGlmIChleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJykgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdHN0YXRlLnJlY3RBcmVhTFRDMSA9IFVuaWZvcm1zTGliLkxUQ19GTE9BVF8xO1xuXHRcdFx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMyID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMxID0gVW5pZm9ybXNMaWIuTFRDX0hBTEZfMTtcblx0XHRcdFx0XHRcdHN0YXRlLnJlY3RBcmVhTFRDMiA9IFVuaWZvcm1zTGliLkxUQ19IQUxGXzI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVuYWJsZSB0byB1c2UgUmVjdEFyZWFMaWdodC4gTWlzc2luZyBXZWJHTCBleHRlbnNpb25zLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5hbWJpZW50WzBdID0gcjtcblx0XHRcdHN0YXRlLmFtYmllbnRbMV0gPSBnO1xuXHRcdFx0c3RhdGUuYW1iaWVudFsyXSA9IGI7XG5cdFx0XHRjb25zdCBoYXNoID0gc3RhdGUuaGFzaDtcblxuXHRcdFx0aWYgKGhhc2guZGlyZWN0aW9uYWxMZW5ndGggIT09IGRpcmVjdGlvbmFsTGVuZ3RoIHx8IGhhc2gucG9pbnRMZW5ndGggIT09IHBvaW50TGVuZ3RoIHx8IGhhc2guc3BvdExlbmd0aCAhPT0gc3BvdExlbmd0aCB8fCBoYXNoLnJlY3RBcmVhTGVuZ3RoICE9PSByZWN0QXJlYUxlbmd0aCB8fCBoYXNoLmhlbWlMZW5ndGggIT09IGhlbWlMZW5ndGggfHwgaGFzaC5udW1EaXJlY3Rpb25hbFNoYWRvd3MgIT09IG51bURpcmVjdGlvbmFsU2hhZG93cyB8fCBoYXNoLm51bVBvaW50U2hhZG93cyAhPT0gbnVtUG9pbnRTaGFkb3dzIHx8IGhhc2gubnVtU3BvdFNoYWRvd3MgIT09IG51bVNwb3RTaGFkb3dzKSB7XG5cdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsLmxlbmd0aCA9IGRpcmVjdGlvbmFsTGVuZ3RoO1xuXHRcdFx0XHRzdGF0ZS5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XG5cdFx0XHRcdHN0YXRlLnJlY3RBcmVhLmxlbmd0aCA9IHJlY3RBcmVhTGVuZ3RoO1xuXHRcdFx0XHRzdGF0ZS5wb2ludC5sZW5ndGggPSBwb2ludExlbmd0aDtcblx0XHRcdFx0c3RhdGUuaGVtaS5sZW5ndGggPSBoZW1pTGVuZ3RoO1xuXHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvdy5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwLmxlbmd0aCA9IG51bURpcmVjdGlvbmFsU2hhZG93cztcblx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3cubGVuZ3RoID0gbnVtUG9pbnRTaGFkb3dzO1xuXHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hcC5sZW5ndGggPSBudW1Qb2ludFNoYWRvd3M7XG5cdFx0XHRcdHN0YXRlLnNwb3RTaGFkb3cubGVuZ3RoID0gbnVtU3BvdFNoYWRvd3M7XG5cdFx0XHRcdHN0YXRlLnNwb3RTaGFkb3dNYXAubGVuZ3RoID0gbnVtU3BvdFNoYWRvd3M7XG5cdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4Lmxlbmd0aCA9IG51bURpcmVjdGlvbmFsU2hhZG93cztcblx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3dNYXRyaXgubGVuZ3RoID0gbnVtUG9pbnRTaGFkb3dzO1xuXHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93TWF0cml4Lmxlbmd0aCA9IG51bVNwb3RTaGFkb3dzO1xuXHRcdFx0XHRoYXNoLmRpcmVjdGlvbmFsTGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XG5cdFx0XHRcdGhhc2gucG9pbnRMZW5ndGggPSBwb2ludExlbmd0aDtcblx0XHRcdFx0aGFzaC5zcG90TGVuZ3RoID0gc3BvdExlbmd0aDtcblx0XHRcdFx0aGFzaC5yZWN0QXJlYUxlbmd0aCA9IHJlY3RBcmVhTGVuZ3RoO1xuXHRcdFx0XHRoYXNoLmhlbWlMZW5ndGggPSBoZW1pTGVuZ3RoO1xuXHRcdFx0XHRoYXNoLm51bURpcmVjdGlvbmFsU2hhZG93cyA9IG51bURpcmVjdGlvbmFsU2hhZG93cztcblx0XHRcdFx0aGFzaC5udW1Qb2ludFNoYWRvd3MgPSBudW1Qb2ludFNoYWRvd3M7XG5cdFx0XHRcdGhhc2gubnVtU3BvdFNoYWRvd3MgPSBudW1TcG90U2hhZG93cztcblx0XHRcdFx0c3RhdGUudmVyc2lvbiA9IG5leHRWZXJzaW9uKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBWaWV3KGxpZ2h0cywgY2FtZXJhKSB7XG5cdFx0XHRsZXQgZGlyZWN0aW9uYWxMZW5ndGggPSAwO1xuXHRcdFx0bGV0IHBvaW50TGVuZ3RoID0gMDtcblx0XHRcdGxldCBzcG90TGVuZ3RoID0gMDtcblx0XHRcdGxldCByZWN0QXJlYUxlbmd0aCA9IDA7XG5cdFx0XHRsZXQgaGVtaUxlbmd0aCA9IDA7XG5cdFx0XHRjb25zdCB2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzW2ldO1xuXG5cdFx0XHRcdGlmIChsaWdodC5pc0RpcmVjdGlvbmFsTGlnaHQpIHtcblx0XHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IHN0YXRlLmRpcmVjdGlvbmFsW2RpcmVjdGlvbmFsTGVuZ3RoXTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0XHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC50YXJnZXQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIodmVjdG9yMyk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih2aWV3TWF0cml4KTtcblx0XHRcdFx0XHRkaXJlY3Rpb25hbExlbmd0aCsrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpZ2h0LmlzU3BvdExpZ2h0KSB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5zcG90W3Nwb3RMZW5ndGhdO1xuXHRcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KHZpZXdNYXRyaXgpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdHZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1Yih2ZWN0b3IzKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKHZpZXdNYXRyaXgpO1xuXHRcdFx0XHRcdHNwb3RMZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc1JlY3RBcmVhTGlnaHQpIHtcblx0XHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IHN0YXRlLnJlY3RBcmVhW3JlY3RBcmVhTGVuZ3RoXTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCh2aWV3TWF0cml4KTsgLy8gZXh0cmFjdCBsb2NhbCByb3RhdGlvbiBvZiBsaWdodCB0byBkZXJpdmUgd2lkdGgvaGVpZ2h0IGhhbGYgdmVjdG9yc1xuXG5cdFx0XHRcdFx0bWF0cml4NDIuaWRlbnRpdHkoKTtcblx0XHRcdFx0XHRtYXRyaXg0LmNvcHkobGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdG1hdHJpeDQucHJlbXVsdGlwbHkodmlld01hdHJpeCk7XG5cdFx0XHRcdFx0bWF0cml4NDIuZXh0cmFjdFJvdGF0aW9uKG1hdHJpeDQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmhhbGZXaWR0aC5zZXQobGlnaHQud2lkdGggKiAwLjUsIDAuMCwgMC4wKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LnNldCgwLjAsIGxpZ2h0LmhlaWdodCAqIDAuNSwgMC4wKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KG1hdHJpeDQyKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LmFwcGx5TWF0cml4NChtYXRyaXg0Mik7XG5cdFx0XHRcdFx0cmVjdEFyZWFMZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc1BvaW50TGlnaHQpIHtcblx0XHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IHN0YXRlLnBvaW50W3BvaW50TGVuZ3RoXTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCh2aWV3TWF0cml4KTtcblx0XHRcdFx0XHRwb2ludExlbmd0aCsrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpZ2h0LmlzSGVtaXNwaGVyZUxpZ2h0KSB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5oZW1pW2hlbWlMZW5ndGhdO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24odmlld01hdHJpeCk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdGhlbWlMZW5ndGgrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRzZXR1cDogc2V0dXAsXG5cdFx0XHRzZXR1cFZpZXc6IHNldHVwVmlldyxcblx0XHRcdHN0YXRlOiBzdGF0ZVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlclN0YXRlKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcykge1xuXHRcdGNvbnN0IGxpZ2h0cyA9IG5ldyBXZWJHTExpZ2h0cyhleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpO1xuXHRcdGNvbnN0IGxpZ2h0c0FycmF5ID0gW107XG5cdFx0Y29uc3Qgc2hhZG93c0FycmF5ID0gW107XG5cblx0XHRmdW5jdGlvbiBpbml0KCkge1xuXHRcdFx0bGlnaHRzQXJyYXkubGVuZ3RoID0gMDtcblx0XHRcdHNoYWRvd3NBcnJheS5sZW5ndGggPSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHB1c2hMaWdodChsaWdodCkge1xuXHRcdFx0bGlnaHRzQXJyYXkucHVzaChsaWdodCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHVzaFNoYWRvdyhzaGFkb3dMaWdodCkge1xuXHRcdFx0c2hhZG93c0FycmF5LnB1c2goc2hhZG93TGlnaHQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldHVwTGlnaHRzKCkge1xuXHRcdFx0bGlnaHRzLnNldHVwKGxpZ2h0c0FycmF5KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXR1cExpZ2h0c1ZpZXcoY2FtZXJhKSB7XG5cdFx0XHRsaWdodHMuc2V0dXBWaWV3KGxpZ2h0c0FycmF5LCBjYW1lcmEpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHN0YXRlID0ge1xuXHRcdFx0bGlnaHRzQXJyYXk6IGxpZ2h0c0FycmF5LFxuXHRcdFx0c2hhZG93c0FycmF5OiBzaGFkb3dzQXJyYXksXG5cdFx0XHRsaWdodHM6IGxpZ2h0c1xuXHRcdH07XG5cdFx0cmV0dXJuIHtcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRzdGF0ZTogc3RhdGUsXG5cdFx0XHRzZXR1cExpZ2h0czogc2V0dXBMaWdodHMsXG5cdFx0XHRzZXR1cExpZ2h0c1ZpZXc6IHNldHVwTGlnaHRzVmlldyxcblx0XHRcdHB1c2hMaWdodDogcHVzaExpZ2h0LFxuXHRcdFx0cHVzaFNoYWRvdzogcHVzaFNoYWRvd1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlclN0YXRlcyhleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpIHtcblx0XHRsZXQgcmVuZGVyU3RhdGVzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdGZ1bmN0aW9uIGdldChzY2VuZSwgcmVuZGVyQ2FsbERlcHRoID0gMCkge1xuXHRcdFx0bGV0IHJlbmRlclN0YXRlO1xuXG5cdFx0XHRpZiAocmVuZGVyU3RhdGVzLmhhcyhzY2VuZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJlbmRlclN0YXRlID0gbmV3IFdlYkdMUmVuZGVyU3RhdGUoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcblx0XHRcdFx0cmVuZGVyU3RhdGVzLnNldChzY2VuZSwgW3JlbmRlclN0YXRlXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAocmVuZGVyQ2FsbERlcHRoID49IHJlbmRlclN0YXRlcy5nZXQoc2NlbmUpLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJlbmRlclN0YXRlID0gbmV3IFdlYkdMUmVuZGVyU3RhdGUoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcblx0XHRcdFx0XHRyZW5kZXJTdGF0ZXMuZ2V0KHNjZW5lKS5wdXNoKHJlbmRlclN0YXRlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlcy5nZXQoc2NlbmUpW3JlbmRlckNhbGxEZXB0aF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlbmRlclN0YXRlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRyZW5kZXJTdGF0ZXMgPSBuZXcgV2Vha01hcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdGRpc3Bvc2U6IGRpc3Bvc2Vcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXG5cdCAqXHRvcGFjaXR5OiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0bWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0YWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0Pixcblx0ICpcdGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHR3aXJlZnJhbWU6IDxib29sZWFuPixcblx0ICpcdHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hEZXB0aE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5kZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXHRcdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHRcdHRoaXMuZm9nID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5kZXB0aFBhY2tpbmcgPSBzb3VyY2UuZGVwdGhQYWNraW5nO1xuXHRcdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0TWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaERlcHRoTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlxuXHQgKlx0cmVmZXJlbmNlUG9zaXRpb246IDxmbG9hdD4sXG5cdCAqXHRuZWFyRGlzdGFuY2U6IDxmbG9hdD4sXG5cdCAqXHRmYXJEaXN0YW5jZTogPGZsb2F0Pixcblx0ICpcblx0ICpcdG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0ZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0ZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqXHRkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+XG5cdCAqXG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgTWVzaERpc3RhbmNlTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdNZXNoRGlzdGFuY2VNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLnJlZmVyZW5jZVBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHRoaXMubmVhckRpc3RhbmNlID0gMTtcblx0XHRcdHRoaXMuZmFyRGlzdGFuY2UgPSAxMDAwO1xuXHRcdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cdFx0XHR0aGlzLmZvZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMucmVmZXJlbmNlUG9zaXRpb24uY29weShzb3VyY2UucmVmZXJlbmNlUG9zaXRpb24pO1xuXHRcdFx0dGhpcy5uZWFyRGlzdGFuY2UgPSBzb3VyY2UubmVhckRpc3RhbmNlO1xuXHRcdFx0dGhpcy5mYXJEaXN0YW5jZSA9IHNvdXJjZS5mYXJEaXN0YW5jZTtcblx0XHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hEaXN0YW5jZU1hdGVyaWFsID0gdHJ1ZTtcblxuXHR2YXIgdnNtX2ZyYWcgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd19wYXNzO1xcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xcbiNpbmNsdWRlIDxwYWNraW5nPlxcbnZvaWQgbWFpbigpIHtcXG5cXHRmbG9hdCBtZWFuID0gMC4wO1xcblxcdGZsb2F0IHNxdWFyZWRfbWVhbiA9IDAuMDtcXG5cXHRmbG9hdCBkZXB0aCA9IHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSApIC8gcmVzb2x1dGlvbiApICk7XFxuXFx0Zm9yICggZmxvYXQgaSA9IC0xLjA7IGkgPCAxLjAgOyBpICs9IFNBTVBMRV9SQVRFKSB7XFxuXFx0XFx0I2lmZGVmIEhPUklaT05UQUxfUEFTU1xcblxcdFxcdFxcdHZlYzIgZGlzdHJpYnV0aW9uID0gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggaSwgMC4wICkgKiByYWRpdXMgKSAvIHJlc29sdXRpb24gKSApO1xcblxcdFxcdFxcdG1lYW4gKz0gZGlzdHJpYnV0aW9uLng7XFxuXFx0XFx0XFx0c3F1YXJlZF9tZWFuICs9IGRpc3RyaWJ1dGlvbi55ICogZGlzdHJpYnV0aW9uLnkgKyBkaXN0cmlidXRpb24ueCAqIGRpc3RyaWJ1dGlvbi54O1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0ZmxvYXQgZGVwdGggPSB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dfcGFzcywgKCBnbF9GcmFnQ29vcmQueHkgKyB2ZWMyKCAwLjAsIGkgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7XFxuXFx0XFx0XFx0bWVhbiArPSBkZXB0aDtcXG5cXHRcXHRcXHRzcXVhcmVkX21lYW4gKz0gZGVwdGggKiBkZXB0aDtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0bWVhbiA9IG1lYW4gKiBIQUxGX1NBTVBMRV9SQVRFO1xcblxcdHNxdWFyZWRfbWVhbiA9IHNxdWFyZWRfbWVhbiAqIEhBTEZfU0FNUExFX1JBVEU7XFxuXFx0ZmxvYXQgc3RkX2RldiA9IHNxcnQoIHNxdWFyZWRfbWVhbiAtIG1lYW4gKiBtZWFuICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gcGFjazJIYWxmVG9SR0JBKCB2ZWMyKCBtZWFuLCBzdGRfZGV2ICkgKTtcXG59XCI7XG5cblx0dmFyIHZzbV92ZXJ0ID0gXCJ2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufVwiO1xuXG5cdGZ1bmN0aW9uIFdlYkdMU2hhZG93TWFwKF9yZW5kZXJlciwgX29iamVjdHMsIF9jYXBhYmlsaXRpZXMpIHtcblx0XHRsZXQgX2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpO1xuXG5cdFx0Y29uc3QgX3NoYWRvd01hcFNpemUgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRcdF92aWV3cG9ydFNpemUgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRcdF92aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCksXG5cdFx0XHRcdFx0X2RlcHRoTWF0ZXJpYWwgPSBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoe1xuXHRcdFx0ZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nXG5cdFx0fSksXG5cdFx0XHRcdFx0X2Rpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgTWVzaERpc3RhbmNlTWF0ZXJpYWwoKSxcblx0XHRcdFx0XHRfbWF0ZXJpYWxDYWNoZSA9IHt9LFxuXHRcdFx0XHRcdF9tYXhUZXh0dXJlU2l6ZSA9IF9jYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemU7XG5cblx0XHRjb25zdCBzaGFkb3dTaWRlID0ge1xuXHRcdFx0MDogQmFja1NpZGUsXG5cdFx0XHQxOiBGcm9udFNpZGUsXG5cdFx0XHQyOiBEb3VibGVTaWRlXG5cdFx0fTtcblx0XHRjb25zdCBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsID0gbmV3IFNoYWRlck1hdGVyaWFsKHtcblx0XHRcdGRlZmluZXM6IHtcblx0XHRcdFx0U0FNUExFX1JBVEU6IDIuMCAvIDguMCxcblx0XHRcdFx0SEFMRl9TQU1QTEVfUkFURTogMS4wIC8gOC4wXG5cdFx0XHR9LFxuXHRcdFx0dW5pZm9ybXM6IHtcblx0XHRcdFx0c2hhZG93X3Bhc3M6IHtcblx0XHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNvbHV0aW9uOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBWZWN0b3IyKClcblx0XHRcdFx0fSxcblx0XHRcdFx0cmFkaXVzOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDQuMFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dmVydGV4U2hhZGVyOiB2c21fdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiB2c21fZnJhZ1xuXHRcdH0pO1xuXHRcdGNvbnN0IHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbCA9IHNoYWRvd01hdGVyaWFsVmVydGljYWwuY2xvbmUoKTtcblx0XHRzaGFkb3dNYXRlcmlhbEhvcml6b250YWwuZGVmaW5lcy5IT1JJWk9OVEFMX1BBU1MgPSAxO1xuXHRcdGNvbnN0IGZ1bGxTY3JlZW5UcmkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRmdWxsU2NyZWVuVHJpLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSwgMC41LCAzLCAtMSwgMC41LCAtMSwgMywgMC41XSksIDMpKTtcblx0XHRjb25zdCBmdWxsU2NyZWVuTWVzaCA9IG5ldyBNZXNoKGZ1bGxTY3JlZW5UcmksIHNoYWRvd01hdGVyaWFsVmVydGljYWwpO1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLnR5cGUgPSBQQ0ZTaGFkb3dNYXA7XG5cblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChsaWdodHMsIHNjZW5lLCBjYW1lcmEpIHtcblx0XHRcdGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0aWYgKHNjb3BlLmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNjb3BlLm5lZWRzVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0aWYgKGxpZ2h0cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuXHRcdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IF9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcblxuXHRcdFx0Y29uc3QgYWN0aXZlQ3ViZUZhY2UgPSBfcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKTtcblxuXHRcdFx0Y29uc3QgYWN0aXZlTWlwbWFwTGV2ZWwgPSBfcmVuZGVyZXIuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKTtcblxuXHRcdFx0Y29uc3QgX3N0YXRlID0gX3JlbmRlcmVyLnN0YXRlOyAvLyBTZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcC5cblxuXHRcdFx0X3N0YXRlLnNldEJsZW5kaW5nKE5vQmxlbmRpbmcpO1xuXG5cdFx0XHRfc3RhdGUuYnVmZmVycy5jb2xvci5zZXRDbGVhcigxLCAxLCAxLCAxKTtcblxuXHRcdFx0X3N0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCh0cnVlKTtcblxuXHRcdFx0X3N0YXRlLnNldFNjaXNzb3JUZXN0KGZhbHNlKTsgLy8gcmVuZGVyIGRlcHRoIG1hcFxuXG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzW2ldO1xuXHRcdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cblx0XHRcdFx0aWYgKHNoYWRvdyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFNoYWRvd01hcDonLCBsaWdodCwgJ2hhcyBubyBzaGFkb3cuJyk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc2hhZG93LmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNoYWRvdy5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdF9zaGFkb3dNYXBTaXplLmNvcHkoc2hhZG93Lm1hcFNpemUpO1xuXG5cdFx0XHRcdGNvbnN0IHNoYWRvd0ZyYW1lRXh0ZW50cyA9IHNoYWRvdy5nZXRGcmFtZUV4dGVudHMoKTtcblxuXHRcdFx0XHRfc2hhZG93TWFwU2l6ZS5tdWx0aXBseShzaGFkb3dGcmFtZUV4dGVudHMpO1xuXG5cdFx0XHRcdF92aWV3cG9ydFNpemUuY29weShzaGFkb3cubWFwU2l6ZSk7XG5cblx0XHRcdFx0aWYgKF9zaGFkb3dNYXBTaXplLnggPiBfbWF4VGV4dHVyZVNpemUgfHwgX3NoYWRvd01hcFNpemUueSA+IF9tYXhUZXh0dXJlU2l6ZSkge1xuXHRcdFx0XHRcdGlmIChfc2hhZG93TWFwU2l6ZS54ID4gX21heFRleHR1cmVTaXplKSB7XG5cdFx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnggPSBNYXRoLmZsb29yKF9tYXhUZXh0dXJlU2l6ZSAvIHNoYWRvd0ZyYW1lRXh0ZW50cy54KTtcblx0XHRcdFx0XHRcdF9zaGFkb3dNYXBTaXplLnggPSBfdmlld3BvcnRTaXplLnggKiBzaGFkb3dGcmFtZUV4dGVudHMueDtcblx0XHRcdFx0XHRcdHNoYWRvdy5tYXBTaXplLnggPSBfdmlld3BvcnRTaXplLng7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKF9zaGFkb3dNYXBTaXplLnkgPiBfbWF4VGV4dHVyZVNpemUpIHtcblx0XHRcdFx0XHRcdF92aWV3cG9ydFNpemUueSA9IE1hdGguZmxvb3IoX21heFRleHR1cmVTaXplIC8gc2hhZG93RnJhbWVFeHRlbnRzLnkpO1xuXHRcdFx0XHRcdFx0X3NoYWRvd01hcFNpemUueSA9IF92aWV3cG9ydFNpemUueSAqIHNoYWRvd0ZyYW1lRXh0ZW50cy55O1xuXHRcdFx0XHRcdFx0c2hhZG93Lm1hcFNpemUueSA9IF92aWV3cG9ydFNpemUueTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc2hhZG93Lm1hcCA9PT0gbnVsbCAmJiAhc2hhZG93LmlzUG9pbnRMaWdodFNoYWRvdyAmJiB0aGlzLnR5cGUgPT09IFZTTVNoYWRvd01hcCkge1xuXHRcdFx0XHRcdGNvbnN0IHBhcnMgPSB7XG5cdFx0XHRcdFx0XHRtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcblx0XHRcdFx0XHRcdG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRcdFx0XHRcdFx0Zm9ybWF0OiBSR0JBRm9ybWF0XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRzaGFkb3cubWFwID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KF9zaGFkb3dNYXBTaXplLngsIF9zaGFkb3dNYXBTaXplLnksIHBhcnMpO1xuXHRcdFx0XHRcdHNoYWRvdy5tYXAudGV4dHVyZS5uYW1lID0gbGlnaHQubmFtZSArICcuc2hhZG93TWFwJztcblx0XHRcdFx0XHRzaGFkb3cubWFwUGFzcyA9IG5ldyBXZWJHTFJlbmRlclRhcmdldChfc2hhZG93TWFwU2l6ZS54LCBfc2hhZG93TWFwU2l6ZS55LCBwYXJzKTtcblx0XHRcdFx0XHRzaGFkb3cuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzaGFkb3cubWFwID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc3QgcGFycyA9IHtcblx0XHRcdFx0XHRcdG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlcixcblx0XHRcdFx0XHRcdG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlcixcblx0XHRcdFx0XHRcdGZvcm1hdDogUkdCQUZvcm1hdFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0c2hhZG93Lm1hcCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldChfc2hhZG93TWFwU2l6ZS54LCBfc2hhZG93TWFwU2l6ZS55LCBwYXJzKTtcblx0XHRcdFx0XHRzaGFkb3cubWFwLnRleHR1cmUubmFtZSA9IGxpZ2h0Lm5hbWUgKyAnLnNoYWRvd01hcCc7XG5cdFx0XHRcdFx0c2hhZG93LmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHNoYWRvdy5tYXApO1xuXG5cdFx0XHRcdF9yZW5kZXJlci5jbGVhcigpO1xuXG5cdFx0XHRcdGNvbnN0IHZpZXdwb3J0Q291bnQgPSBzaGFkb3cuZ2V0Vmlld3BvcnRDb3VudCgpO1xuXG5cdFx0XHRcdGZvciAobGV0IHZwID0gMDsgdnAgPCB2aWV3cG9ydENvdW50OyB2cCsrKSB7XG5cdFx0XHRcdFx0Y29uc3Qgdmlld3BvcnQgPSBzaGFkb3cuZ2V0Vmlld3BvcnQodnApO1xuXG5cdFx0XHRcdFx0X3ZpZXdwb3J0LnNldChfdmlld3BvcnRTaXplLnggKiB2aWV3cG9ydC54LCBfdmlld3BvcnRTaXplLnkgKiB2aWV3cG9ydC55LCBfdmlld3BvcnRTaXplLnggKiB2aWV3cG9ydC56LCBfdmlld3BvcnRTaXplLnkgKiB2aWV3cG9ydC53KTtcblxuXHRcdFx0XHRcdF9zdGF0ZS52aWV3cG9ydChfdmlld3BvcnQpO1xuXG5cdFx0XHRcdFx0c2hhZG93LnVwZGF0ZU1hdHJpY2VzKGxpZ2h0LCB2cCk7XG5cdFx0XHRcdFx0X2ZydXN0dW0gPSBzaGFkb3cuZ2V0RnJ1c3R1bSgpO1xuXHRcdFx0XHRcdHJlbmRlck9iamVjdChzY2VuZSwgY2FtZXJhLCBzaGFkb3cuY2FtZXJhLCBsaWdodCwgdGhpcy50eXBlKTtcblx0XHRcdFx0fSAvLyBkbyBibHVyIHBhc3MgZm9yIFZTTVxuXG5cblx0XHRcdFx0aWYgKCFzaGFkb3cuaXNQb2ludExpZ2h0U2hhZG93ICYmIHRoaXMudHlwZSA9PT0gVlNNU2hhZG93TWFwKSB7XG5cdFx0XHRcdFx0VlNNUGFzcyhzaGFkb3csIGNhbWVyYSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaGFkb3cubmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0c2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChjdXJyZW50UmVuZGVyVGFyZ2V0LCBhY3RpdmVDdWJlRmFjZSwgYWN0aXZlTWlwbWFwTGV2ZWwpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBWU01QYXNzKHNoYWRvdywgY2FtZXJhKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IF9vYmplY3RzLnVwZGF0ZShmdWxsU2NyZWVuTWVzaCk7IC8vIHZlcnRpY2FsIHBhc3NcblxuXG5cdFx0XHRzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLnVuaWZvcm1zLnNoYWRvd19wYXNzLnZhbHVlID0gc2hhZG93Lm1hcC50ZXh0dXJlO1xuXHRcdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlID0gc2hhZG93Lm1hcFNpemU7XG5cdFx0XHRzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHNoYWRvdy5yYWRpdXM7XG5cblx0XHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoc2hhZG93Lm1hcFBhc3MpO1xuXG5cdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcblxuXHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdChjYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLCBmdWxsU2NyZWVuTWVzaCwgbnVsbCk7IC8vIGhvcml6b250YWwgcGFzc1xuXG5cblx0XHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZSA9IHNoYWRvdy5tYXBQYXNzLnRleHR1cmU7XG5cdFx0XHRzaGFkb3dNYXRlcmlhbEhvcml6b250YWwudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZSA9IHNoYWRvdy5tYXBTaXplO1xuXHRcdFx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHNoYWRvdy5yYWRpdXM7XG5cblx0XHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoc2hhZG93Lm1hcCk7XG5cblx0XHRcdF9yZW5kZXJlci5jbGVhcigpO1xuXG5cdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KGNhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbCwgZnVsbFNjcmVlbk1lc2gsIG51bGwpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERlcHRoTWF0ZXJpYWwob2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGxpZ2h0LCBzaGFkb3dDYW1lcmFOZWFyLCBzaGFkb3dDYW1lcmFGYXIsIHR5cGUpIHtcblx0XHRcdGxldCByZXN1bHQgPSBudWxsO1xuXHRcdFx0Y29uc3QgY3VzdG9tTWF0ZXJpYWwgPSBsaWdodC5pc1BvaW50TGlnaHQgPT09IHRydWUgPyBvYmplY3QuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCA6IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xuXG5cdFx0XHRpZiAoY3VzdG9tTWF0ZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXN1bHQgPSBjdXN0b21NYXRlcmlhbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCA9IGxpZ2h0LmlzUG9pbnRMaWdodCA9PT0gdHJ1ZSA/IF9kaXN0YW5jZU1hdGVyaWFsIDogX2RlcHRoTWF0ZXJpYWw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChfcmVuZGVyZXIubG9jYWxDbGlwcGluZ0VuYWJsZWQgJiYgbWF0ZXJpYWwuY2xpcFNoYWRvd3MgPT09IHRydWUgJiYgbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRcdC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIGEgdW5pcXVlIG1hdGVyaWFsIGluc3RhbmNlIHJlZmxlY3RpbmcgdGhlXG5cdFx0XHRcdC8vIGFwcHJvcHJpYXRlIHN0YXRlXG5cdFx0XHRcdGNvbnN0IGtleUEgPSByZXN1bHQudXVpZCxcblx0XHRcdFx0XHRcdFx0a2V5QiA9IG1hdGVyaWFsLnV1aWQ7XG5cdFx0XHRcdGxldCBtYXRlcmlhbHNGb3JWYXJpYW50ID0gX21hdGVyaWFsQ2FjaGVba2V5QV07XG5cblx0XHRcdFx0aWYgKG1hdGVyaWFsc0ZvclZhcmlhbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG1hdGVyaWFsc0ZvclZhcmlhbnQgPSB7fTtcblx0XHRcdFx0XHRfbWF0ZXJpYWxDYWNoZVtrZXlBXSA9IG1hdGVyaWFsc0ZvclZhcmlhbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgY2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbHNGb3JWYXJpYW50W2tleUJdO1xuXG5cdFx0XHRcdGlmIChjYWNoZWRNYXRlcmlhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y2FjaGVkTWF0ZXJpYWwgPSByZXN1bHQuY2xvbmUoKTtcblx0XHRcdFx0XHRtYXRlcmlhbHNGb3JWYXJpYW50W2tleUJdID0gY2FjaGVkTWF0ZXJpYWw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgPSBjYWNoZWRNYXRlcmlhbDtcblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0LnZpc2libGUgPSBtYXRlcmlhbC52aXNpYmxlO1xuXHRcdFx0cmVzdWx0LndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcblxuXHRcdFx0aWYgKHR5cGUgPT09IFZTTVNoYWRvd01hcCkge1xuXHRcdFx0XHRyZXN1bHQuc2lkZSA9IG1hdGVyaWFsLnNoYWRvd1NpZGUgIT09IG51bGwgPyBtYXRlcmlhbC5zaGFkb3dTaWRlIDogbWF0ZXJpYWwuc2lkZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdC5zaWRlID0gbWF0ZXJpYWwuc2hhZG93U2lkZSAhPT0gbnVsbCA/IG1hdGVyaWFsLnNoYWRvd1NpZGUgOiBzaGFkb3dTaWRlW21hdGVyaWFsLnNpZGVdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHQuY2xpcFNoYWRvd3MgPSBtYXRlcmlhbC5jbGlwU2hhZG93cztcblx0XHRcdHJlc3VsdC5jbGlwcGluZ1BsYW5lcyA9IG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzO1xuXHRcdFx0cmVzdWx0LmNsaXBJbnRlcnNlY3Rpb24gPSBtYXRlcmlhbC5jbGlwSW50ZXJzZWN0aW9uO1xuXHRcdFx0cmVzdWx0LndpcmVmcmFtZUxpbmV3aWR0aCA9IG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHJlc3VsdC5saW5ld2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XG5cblx0XHRcdGlmIChsaWdodC5pc1BvaW50TGlnaHQgPT09IHRydWUgJiYgcmVzdWx0LmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgPT09IHRydWUpIHtcblx0XHRcdFx0cmVzdWx0LnJlZmVyZW5jZVBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdHJlc3VsdC5uZWFyRGlzdGFuY2UgPSBzaGFkb3dDYW1lcmFOZWFyO1xuXHRcdFx0XHRyZXN1bHQuZmFyRGlzdGFuY2UgPSBzaGFkb3dDYW1lcmFGYXI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0KG9iamVjdCwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGxpZ2h0LCB0eXBlKSB7XG5cdFx0XHRpZiAob2JqZWN0LnZpc2libGUgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0XHRjb25zdCB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KGNhbWVyYS5sYXllcnMpO1xuXG5cdFx0XHRpZiAodmlzaWJsZSAmJiAob2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cykpIHtcblx0XHRcdFx0aWYgKChvYmplY3QuY2FzdFNoYWRvdyB8fCBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiB0eXBlID09PSBWU01TaGFkb3dNYXApICYmICghb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdChvYmplY3QpKSkge1xuXHRcdFx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQpO1xuXG5cdFx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUob2JqZWN0KTtcblxuXHRcdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGsgPSAwLCBrbCA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBrbDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW2tdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwob2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgbGlnaHQsIHNoYWRvd0NhbWVyYS5uZWFyLCBzaGFkb3dDYW1lcmEuZmFyLCB0eXBlKTtcblxuXHRcdFx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3Qoc2hhZG93Q2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBncm91cCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnZpc2libGUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBsaWdodCwgc2hhZG93Q2FtZXJhLm5lYXIsIHNoYWRvd0NhbWVyYS5mYXIsIHR5cGUpO1xuXG5cdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgbnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRyZW5kZXJPYmplY3QoY2hpbGRyZW5baV0sIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBsaWdodCwgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xTdGF0ZShnbCwgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKSB7XG5cdFx0Y29uc3QgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG5cblx0XHRmdW5jdGlvbiBDb2xvckJ1ZmZlcigpIHtcblx0XHRcdGxldCBsb2NrZWQgPSBmYWxzZTtcblx0XHRcdGNvbnN0IGNvbG9yID0gbmV3IFZlY3RvcjQoKTtcblx0XHRcdGxldCBjdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcblx0XHRcdGNvbnN0IGN1cnJlbnRDb2xvckNsZWFyID0gbmV3IFZlY3RvcjQoMCwgMCwgMCwgMCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoY29sb3JNYXNrKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRDb2xvck1hc2sgIT09IGNvbG9yTWFzayAmJiAhbG9ja2VkKSB7XG5cdFx0XHRcdFx0XHRnbC5jb2xvck1hc2soY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xvck1hc2sgPSBjb2xvck1hc2s7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uIChsb2NrKSB7XG5cdFx0XHRcdFx0bG9ja2VkID0gbG9jaztcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uIChyLCBnLCBiLCBhLCBwcmVtdWx0aXBsaWVkQWxwaGEpIHtcblx0XHRcdFx0XHRpZiAocHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRyICo9IGE7XG5cdFx0XHRcdFx0XHRnICo9IGE7XG5cdFx0XHRcdFx0XHRiICo9IGE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29sb3Iuc2V0KHIsIGcsIGIsIGEpO1xuXG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRDb2xvckNsZWFyLmVxdWFscyhjb2xvcikgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRnbC5jbGVhckNvbG9yKHIsIGcsIGIsIGEpO1xuXHRcdFx0XHRcdFx0Y3VycmVudENvbG9yQ2xlYXIuY29weShjb2xvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRDb2xvckNsZWFyLnNldCgtMSwgMCwgMCwgMCk7IC8vIHNldCB0byBpbnZhbGlkIHN0YXRlXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gRGVwdGhCdWZmZXIoKSB7XG5cdFx0XHRsZXQgbG9ja2VkID0gZmFsc2U7XG5cdFx0XHRsZXQgY3VycmVudERlcHRoTWFzayA9IG51bGw7XG5cdFx0XHRsZXQgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XG5cdFx0XHRsZXQgY3VycmVudERlcHRoQ2xlYXIgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2V0VGVzdDogZnVuY3Rpb24gKGRlcHRoVGVzdCkge1xuXHRcdFx0XHRcdGlmIChkZXB0aFRlc3QpIHtcblx0XHRcdFx0XHRcdGVuYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uIChkZXB0aE1hc2spIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudERlcHRoTWFzayAhPT0gZGVwdGhNYXNrICYmICFsb2NrZWQpIHtcblx0XHRcdFx0XHRcdGdsLmRlcHRoTWFzayhkZXB0aE1hc2spO1xuXHRcdFx0XHRcdFx0Y3VycmVudERlcHRoTWFzayA9IGRlcHRoTWFzaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldEZ1bmM6IGZ1bmN0aW9uIChkZXB0aEZ1bmMpIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudERlcHRoRnVuYyAhPT0gZGVwdGhGdW5jKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGVwdGhGdW5jKSB7XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoZGVwdGhGdW5jKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBOZXZlckRlcHRoOlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKGdsLk5FVkVSKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBBbHdheXNEZXB0aDpcblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5BTFdBWVMpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIExlc3NEZXB0aDpcblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5MRVNTKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBMZXNzRXF1YWxEZXB0aDpcblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIEVxdWFsRGVwdGg6XG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuRVFVQUwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJFcXVhbERlcHRoOlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKGdsLkdFUVVBTCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgR3JlYXRlckRlcHRoOlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKGdsLkdSRUFURVIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIE5vdEVxdWFsRGVwdGg6XG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuTk9URVFVQUwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKGdsLkxFUVVBTCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAobG9jaykge1xuXHRcdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoZGVwdGgpIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudERlcHRoQ2xlYXIgIT09IGRlcHRoKSB7XG5cdFx0XHRcdFx0XHRnbC5jbGVhckRlcHRoKGRlcHRoKTtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXB0aENsZWFyID0gZGVwdGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBTdGVuY2lsQnVmZmVyKCkge1xuXHRcdFx0bGV0IGxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0bGV0IGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XG5cdFx0XHRsZXQgY3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcblx0XHRcdGxldCBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XG5cdFx0XHRsZXQgY3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XG5cdFx0XHRsZXQgY3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcblx0XHRcdGxldCBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcblx0XHRcdGxldCBjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcblx0XHRcdGxldCBjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHNldFRlc3Q6IGZ1bmN0aW9uIChzdGVuY2lsVGVzdCkge1xuXHRcdFx0XHRcdGlmICghbG9ja2VkKSB7XG5cdFx0XHRcdFx0XHRpZiAoc3RlbmNpbFRlc3QpIHtcblx0XHRcdFx0XHRcdFx0ZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoc3RlbmNpbE1hc2spIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudFN0ZW5jaWxNYXNrICE9PSBzdGVuY2lsTWFzayAmJiAhbG9ja2VkKSB7XG5cdFx0XHRcdFx0XHRnbC5zdGVuY2lsTWFzayhzdGVuY2lsTWFzayk7XG5cdFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbE1hc2sgPSBzdGVuY2lsTWFzaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldEZ1bmM6IGZ1bmN0aW9uIChzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2spIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudFN0ZW5jaWxGdW5jICE9PSBzdGVuY2lsRnVuYyB8fCBjdXJyZW50U3RlbmNpbFJlZiAhPT0gc3RlbmNpbFJlZiB8fCBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrICE9PSBzdGVuY2lsTWFzaykge1xuXHRcdFx0XHRcdFx0Z2wuc3RlbmNpbEZ1bmMoc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xuXHRcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBzdGVuY2lsUmVmO1xuXHRcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IHN0ZW5jaWxNYXNrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0T3A6IGZ1bmN0aW9uIChzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MpIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudFN0ZW5jaWxGYWlsICE9PSBzdGVuY2lsRmFpbCB8fCBjdXJyZW50U3RlbmNpbFpGYWlsICE9PSBzdGVuY2lsWkZhaWwgfHwgY3VycmVudFN0ZW5jaWxaUGFzcyAhPT0gc3RlbmNpbFpQYXNzKSB7XG5cdFx0XHRcdFx0XHRnbC5zdGVuY2lsT3Aoc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IHN0ZW5jaWxGYWlsO1xuXHRcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaRmFpbCA9IHN0ZW5jaWxaRmFpbDtcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uIChsb2NrKSB7XG5cdFx0XHRcdFx0bG9ja2VkID0gbG9jaztcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uIChzdGVuY2lsKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRTdGVuY2lsQ2xlYXIgIT09IHN0ZW5jaWwpIHtcblx0XHRcdFx0XHRcdGdsLmNsZWFyU3RlbmNpbChzdGVuY2lsKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBzdGVuY2lsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbE1hc2sgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSAvL1xuXG5cblx0XHRjb25zdCBjb2xvckJ1ZmZlciA9IG5ldyBDb2xvckJ1ZmZlcigpO1xuXHRcdGNvbnN0IGRlcHRoQnVmZmVyID0gbmV3IERlcHRoQnVmZmVyKCk7XG5cdFx0Y29uc3Qgc3RlbmNpbEJ1ZmZlciA9IG5ldyBTdGVuY2lsQnVmZmVyKCk7XG5cdFx0bGV0IGVuYWJsZWRDYXBhYmlsaXRpZXMgPSB7fTtcblx0XHRsZXQgeHJGcmFtZWJ1ZmZlciA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVycyA9IHt9O1xuXHRcdGxldCBjdXJyZW50UHJvZ3JhbSA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPSBmYWxzZTtcblx0XHRsZXQgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcblx0XHRsZXQgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuXHRcdGxldCBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblx0XHRsZXQgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xuXHRcdGxldCBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblx0XHRsZXQgY3VycmVudEN1bGxGYWNlID0gbnVsbDtcblx0XHRsZXQgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cdFx0Y29uc3QgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuXHRcdGxldCBsaW5lV2lkdGhBdmFpbGFibGUgPSBmYWxzZTtcblx0XHRsZXQgdmVyc2lvbiA9IDA7XG5cdFx0Y29uc3QgZ2xWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlZFUlNJT04pO1xuXG5cdFx0aWYgKGdsVmVyc2lvbi5pbmRleE9mKCdXZWJHTCcpICE9PSAtMSkge1xuXHRcdFx0dmVyc2lvbiA9IHBhcnNlRmxvYXQoL15XZWJHTCAoXFxkKS8uZXhlYyhnbFZlcnNpb24pWzFdKTtcblx0XHRcdGxpbmVXaWR0aEF2YWlsYWJsZSA9IHZlcnNpb24gPj0gMS4wO1xuXHRcdH0gZWxzZSBpZiAoZ2xWZXJzaW9uLmluZGV4T2YoJ09wZW5HTCBFUycpICE9PSAtMSkge1xuXHRcdFx0dmVyc2lvbiA9IHBhcnNlRmxvYXQoL15PcGVuR0wgRVMgKFxcZCkvLmV4ZWMoZ2xWZXJzaW9uKVsxXSk7XG5cdFx0XHRsaW5lV2lkdGhBdmFpbGFibGUgPSB2ZXJzaW9uID49IDIuMDtcblx0XHR9XG5cblx0XHRsZXQgY3VycmVudFRleHR1cmVTbG90ID0gbnVsbDtcblx0XHRsZXQgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblx0XHRjb25zdCBzY2lzc29yUGFyYW0gPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuU0NJU1NPUl9CT1gpO1xuXHRcdGNvbnN0IHZpZXdwb3J0UGFyYW0gPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuVklFV1BPUlQpO1xuXHRcdGNvbnN0IGN1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkoc2Npc3NvclBhcmFtKTtcblx0XHRjb25zdCBjdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLmZyb21BcnJheSh2aWV3cG9ydFBhcmFtKTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUodHlwZSwgdGFyZ2V0LCBjb3VudCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KDQpOyAvLyA0IGlzIHJlcXVpcmVkIHRvIG1hdGNoIGRlZmF1bHQgdW5wYWNrIGFsaWdubWVudCBvZiA0LlxuXG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0Z2wuYmluZFRleHR1cmUodHlwZSwgdGV4dHVyZSk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKHR5cGUsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKHR5cGUsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldCArIGksIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHR9XG5cblx0XHRjb25zdCBlbXB0eVRleHR1cmVzID0ge307XG5cdFx0ZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFXzJEXSA9IGNyZWF0ZVRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV8yRCwgMSk7XG5cdFx0ZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFX0NVQkVfTUFQXSA9IGNyZWF0ZVRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCA2KTsgLy8gaW5pdFxuXG5cdFx0Y29sb3JCdWZmZXIuc2V0Q2xlYXIoMCwgMCwgMCwgMSk7XG5cdFx0ZGVwdGhCdWZmZXIuc2V0Q2xlYXIoMSk7XG5cdFx0c3RlbmNpbEJ1ZmZlci5zZXRDbGVhcigwKTtcblx0XHRlbmFibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0ZGVwdGhCdWZmZXIuc2V0RnVuYyhMZXNzRXF1YWxEZXB0aCk7XG5cdFx0c2V0RmxpcFNpZGVkKGZhbHNlKTtcblx0XHRzZXRDdWxsRmFjZShDdWxsRmFjZUJhY2spO1xuXHRcdGVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRcdHNldEJsZW5kaW5nKE5vQmxlbmRpbmcpOyAvL1xuXG5cdFx0ZnVuY3Rpb24gZW5hYmxlKGlkKSB7XG5cdFx0XHRpZiAoZW5hYmxlZENhcGFiaWxpdGllc1tpZF0gIT09IHRydWUpIHtcblx0XHRcdFx0Z2wuZW5hYmxlKGlkKTtcblx0XHRcdFx0ZW5hYmxlZENhcGFiaWxpdGllc1tpZF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc2FibGUoaWQpIHtcblx0XHRcdGlmIChlbmFibGVkQ2FwYWJpbGl0aWVzW2lkXSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Z2wuZGlzYWJsZShpZCk7XG5cdFx0XHRcdGVuYWJsZWRDYXBhYmlsaXRpZXNbaWRdID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYmluZFhSRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpIHtcblx0XHRcdGlmIChmcmFtZWJ1ZmZlciAhPT0geHJGcmFtZWJ1ZmZlcikge1xuXHRcdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblx0XHRcdFx0eHJGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZyYW1lYnVmZmVyKSB7XG5cdFx0XHRpZiAoZnJhbWVidWZmZXIgPT09IG51bGwgJiYgeHJGcmFtZWJ1ZmZlciAhPT0gbnVsbCkgZnJhbWVidWZmZXIgPSB4ckZyYW1lYnVmZmVyOyAvLyB1c2UgYWN0aXZlIFhSIGZyYW1lYnVmZmVyIGlmIGF2YWlsYWJsZVxuXG5cdFx0XHRpZiAoY3VycmVudEJvdW5kRnJhbWVidWZmZXJzW3RhcmdldF0gIT09IGZyYW1lYnVmZmVyKSB7XG5cdFx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZyYW1lYnVmZmVyKTtcblx0XHRcdFx0Y3VycmVudEJvdW5kRnJhbWVidWZmZXJzW3RhcmdldF0gPSBmcmFtZWJ1ZmZlcjtcblxuXHRcdFx0XHRpZiAoaXNXZWJHTDIpIHtcblx0XHRcdFx0XHQvLyBnbC5EUkFXX0ZSQU1FQlVGRkVSIGlzIGVxdWl2YWxlbnQgdG8gZ2wuRlJBTUVCVUZGRVJcblx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSBnbC5EUkFXX0ZSQU1FQlVGRkVSKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbZ2wuRlJBTUVCVUZGRVJdID0gZnJhbWVidWZmZXI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRhcmdldCA9PT0gZ2wuRlJBTUVCVUZGRVIpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1tnbC5EUkFXX0ZSQU1FQlVGRkVSXSA9IGZyYW1lYnVmZmVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXNlUHJvZ3JhbShwcm9ncmFtKSB7XG5cdFx0XHRpZiAoY3VycmVudFByb2dyYW0gIT09IHByb2dyYW0pIHtcblx0XHRcdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRcdFx0Y3VycmVudFByb2dyYW0gPSBwcm9ncmFtO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IGVxdWF0aW9uVG9HTCA9IHtcblx0XHRcdFtBZGRFcXVhdGlvbl06IGdsLkZVTkNfQURELFxuXHRcdFx0W1N1YnRyYWN0RXF1YXRpb25dOiBnbC5GVU5DX1NVQlRSQUNULFxuXHRcdFx0W1JldmVyc2VTdWJ0cmFjdEVxdWF0aW9uXTogZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUXG5cdFx0fTtcblxuXHRcdGlmIChpc1dlYkdMMikge1xuXHRcdFx0ZXF1YXRpb25Ub0dMW01pbkVxdWF0aW9uXSA9IGdsLk1JTjtcblx0XHRcdGVxdWF0aW9uVG9HTFtNYXhFcXVhdGlvbl0gPSBnbC5NQVg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdFWFRfYmxlbmRfbWlubWF4Jyk7XG5cblx0XHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0ZXF1YXRpb25Ub0dMW01pbkVxdWF0aW9uXSA9IGV4dGVuc2lvbi5NSU5fRVhUO1xuXHRcdFx0XHRlcXVhdGlvblRvR0xbTWF4RXF1YXRpb25dID0gZXh0ZW5zaW9uLk1BWF9FWFQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmFjdG9yVG9HTCA9IHtcblx0XHRcdFtaZXJvRmFjdG9yXTogZ2wuWkVSTyxcblx0XHRcdFtPbmVGYWN0b3JdOiBnbC5PTkUsXG5cdFx0XHRbU3JjQ29sb3JGYWN0b3JdOiBnbC5TUkNfQ09MT1IsXG5cdFx0XHRbU3JjQWxwaGFGYWN0b3JdOiBnbC5TUkNfQUxQSEEsXG5cdFx0XHRbU3JjQWxwaGFTYXR1cmF0ZUZhY3Rvcl06IGdsLlNSQ19BTFBIQV9TQVRVUkFURSxcblx0XHRcdFtEc3RDb2xvckZhY3Rvcl06IGdsLkRTVF9DT0xPUixcblx0XHRcdFtEc3RBbHBoYUZhY3Rvcl06IGdsLkRTVF9BTFBIQSxcblx0XHRcdFtPbmVNaW51c1NyY0NvbG9yRmFjdG9yXTogZ2wuT05FX01JTlVTX1NSQ19DT0xPUixcblx0XHRcdFtPbmVNaW51c1NyY0FscGhhRmFjdG9yXTogZ2wuT05FX01JTlVTX1NSQ19BTFBIQSxcblx0XHRcdFtPbmVNaW51c0RzdENvbG9yRmFjdG9yXTogZ2wuT05FX01JTlVTX0RTVF9DT0xPUixcblx0XHRcdFtPbmVNaW51c0RzdEFscGhhRmFjdG9yXTogZ2wuT05FX01JTlVTX0RTVF9BTFBIQVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBzZXRCbGVuZGluZyhibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSkge1xuXHRcdFx0aWYgKGJsZW5kaW5nID09PSBOb0JsZW5kaW5nKSB7XG5cdFx0XHRcdGlmIChjdXJyZW50QmxlbmRpbmdFbmFibGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0ZGlzYWJsZShnbC5CTEVORCk7XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0ZW5hYmxlKGdsLkJMRU5EKTtcblx0XHRcdFx0Y3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChibGVuZGluZyAhPT0gQ3VzdG9tQmxlbmRpbmcpIHtcblx0XHRcdFx0aWYgKGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgfHwgcHJlbXVsdGlwbGllZEFscGhhICE9PSBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEpIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudEJsZW5kRXF1YXRpb24gIT09IEFkZEVxdWF0aW9uIHx8IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgIT09IEFkZEVxdWF0aW9uKSB7XG5cdFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG5cdFx0XHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gQWRkRXF1YXRpb247XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHByZW11bHRpcGxpZWRBbHBoYSkge1xuXHRcdFx0XHRcdFx0c3dpdGNoIChibGVuZGluZykge1xuXHRcdFx0XHRcdFx0XHRjYXNlIE5vcm1hbEJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIEFkZGl0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuWkVSTywgZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlpFUk8sIGdsLlNSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuU1JDX0FMUEhBKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3dpdGNoIChibGVuZGluZykge1xuXHRcdFx0XHRcdFx0XHRjYXNlIE5vcm1hbEJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIEFkZGl0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgTXVsdGlwbHlCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoZ2wuWkVSTywgZ2wuU1JDX0NPTE9SKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcblx0XHRcdFx0XHRjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBwcmVtdWx0aXBsaWVkQWxwaGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IC8vIGN1c3RvbSBibGVuZGluZ1xuXG5cblx0XHRcdGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xuXHRcdFx0YmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XG5cdFx0XHRibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcblxuXHRcdFx0aWYgKGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSkge1xuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZXF1YXRpb25Ub0dMW2JsZW5kRXF1YXRpb25dLCBlcXVhdGlvblRvR0xbYmxlbmRFcXVhdGlvbkFscGhhXSk7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gYmxlbmRFcXVhdGlvbjtcblx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJsZW5kU3JjICE9PSBjdXJyZW50QmxlbmRTcmMgfHwgYmxlbmREc3QgIT09IGN1cnJlbnRCbGVuZERzdCB8fCBibGVuZFNyY0FscGhhICE9PSBjdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSBjdXJyZW50QmxlbmREc3RBbHBoYSkge1xuXHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZShmYWN0b3JUb0dMW2JsZW5kU3JjXSwgZmFjdG9yVG9HTFtibGVuZERzdF0sIGZhY3RvclRvR0xbYmxlbmRTcmNBbHBoYV0sIGZhY3RvclRvR0xbYmxlbmREc3RBbHBoYV0pO1xuXHRcdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcblx0XHRcdGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGZyb250RmFjZUNXKSB7XG5cdFx0XHRtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlID8gZGlzYWJsZShnbC5DVUxMX0ZBQ0UpIDogZW5hYmxlKGdsLkNVTExfRkFDRSk7XG5cdFx0XHRsZXQgZmxpcFNpZGVkID0gbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGU7XG5cdFx0XHRpZiAoZnJvbnRGYWNlQ1cpIGZsaXBTaWRlZCA9ICFmbGlwU2lkZWQ7XG5cdFx0XHRzZXRGbGlwU2lkZWQoZmxpcFNpZGVkKTtcblx0XHRcdG1hdGVyaWFsLmJsZW5kaW5nID09PSBOb3JtYWxCbGVuZGluZyAmJiBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gZmFsc2UgPyBzZXRCbGVuZGluZyhOb0JsZW5kaW5nKSA6IHNldEJsZW5kaW5nKG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSwgbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhKTtcblx0XHRcdGRlcHRoQnVmZmVyLnNldEZ1bmMobWF0ZXJpYWwuZGVwdGhGdW5jKTtcblx0XHRcdGRlcHRoQnVmZmVyLnNldFRlc3QobWF0ZXJpYWwuZGVwdGhUZXN0KTtcblx0XHRcdGRlcHRoQnVmZmVyLnNldE1hc2sobWF0ZXJpYWwuZGVwdGhXcml0ZSk7XG5cdFx0XHRjb2xvckJ1ZmZlci5zZXRNYXNrKG1hdGVyaWFsLmNvbG9yV3JpdGUpO1xuXHRcdFx0Y29uc3Qgc3RlbmNpbFdyaXRlID0gbWF0ZXJpYWwuc3RlbmNpbFdyaXRlO1xuXHRcdFx0c3RlbmNpbEJ1ZmZlci5zZXRUZXN0KHN0ZW5jaWxXcml0ZSk7XG5cblx0XHRcdGlmIChzdGVuY2lsV3JpdGUpIHtcblx0XHRcdFx0c3RlbmNpbEJ1ZmZlci5zZXRNYXNrKG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2spO1xuXHRcdFx0XHRzdGVuY2lsQnVmZmVyLnNldEZ1bmMobWF0ZXJpYWwuc3RlbmNpbEZ1bmMsIG1hdGVyaWFsLnN0ZW5jaWxSZWYsIG1hdGVyaWFsLnN0ZW5jaWxGdW5jTWFzayk7XG5cdFx0XHRcdHN0ZW5jaWxCdWZmZXIuc2V0T3AobWF0ZXJpYWwuc3RlbmNpbEZhaWwsIG1hdGVyaWFsLnN0ZW5jaWxaRmFpbCwgbWF0ZXJpYWwuc3RlbmNpbFpQYXNzKTtcblx0XHRcdH1cblxuXHRcdFx0c2V0UG9seWdvbk9mZnNldChtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMpO1xuXHRcdFx0bWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlID09PSB0cnVlID8gZW5hYmxlKGdsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSkgOiBkaXNhYmxlKGdsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSk7XG5cdFx0fSAvL1xuXG5cblx0XHRmdW5jdGlvbiBzZXRGbGlwU2lkZWQoZmxpcFNpZGVkKSB7XG5cdFx0XHRpZiAoY3VycmVudEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkKSB7XG5cdFx0XHRcdGlmIChmbGlwU2lkZWQpIHtcblx0XHRcdFx0XHRnbC5mcm9udEZhY2UoZ2wuQ1cpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdsLmZyb250RmFjZShnbC5DQ1cpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VycmVudEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRDdWxsRmFjZShjdWxsRmFjZSkge1xuXHRcdFx0aWYgKGN1bGxGYWNlICE9PSBDdWxsRmFjZU5vbmUpIHtcblx0XHRcdFx0ZW5hYmxlKGdsLkNVTExfRkFDRSk7XG5cblx0XHRcdFx0aWYgKGN1bGxGYWNlICE9PSBjdXJyZW50Q3VsbEZhY2UpIHtcblx0XHRcdFx0XHRpZiAoY3VsbEZhY2UgPT09IEN1bGxGYWNlQmFjaykge1xuXHRcdFx0XHRcdFx0Z2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdWxsRmFjZSA9PT0gQ3VsbEZhY2VGcm9udCkge1xuXHRcdFx0XHRcdFx0Z2wuY3VsbEZhY2UoZ2wuRlJPTlQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRnbC5jdWxsRmFjZShnbC5GUk9OVF9BTkRfQkFDSyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhYmxlKGdsLkNVTExfRkFDRSk7XG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRDdWxsRmFjZSA9IGN1bGxGYWNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldExpbmVXaWR0aCh3aWR0aCkge1xuXHRcdFx0aWYgKHdpZHRoICE9PSBjdXJyZW50TGluZVdpZHRoKSB7XG5cdFx0XHRcdGlmIChsaW5lV2lkdGhBdmFpbGFibGUpIGdsLmxpbmVXaWR0aCh3aWR0aCk7XG5cdFx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRQb2x5Z29uT2Zmc2V0KHBvbHlnb25PZmZzZXQsIGZhY3RvciwgdW5pdHMpIHtcblx0XHRcdGlmIChwb2x5Z29uT2Zmc2V0KSB7XG5cdFx0XHRcdGVuYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cykge1xuXHRcdFx0XHRcdGdsLnBvbHlnb25PZmZzZXQoZmFjdG9yLCB1bml0cyk7XG5cdFx0XHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG5cdFx0XHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IHVuaXRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldFNjaXNzb3JUZXN0KHNjaXNzb3JUZXN0KSB7XG5cdFx0XHRpZiAoc2Npc3NvclRlc3QpIHtcblx0XHRcdFx0ZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG5cdFx0XHR9XG5cdFx0fSAvLyB0ZXh0dXJlXG5cblxuXHRcdGZ1bmN0aW9uIGFjdGl2ZVRleHR1cmUod2ViZ2xTbG90KSB7XG5cdFx0XHRpZiAod2ViZ2xTbG90ID09PSB1bmRlZmluZWQpIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xuXG5cdFx0XHRpZiAoY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QpIHtcblx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZSh3ZWJnbFNsb3QpO1xuXHRcdFx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYmluZFRleHR1cmUod2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUpIHtcblx0XHRcdGlmIChjdXJyZW50VGV4dHVyZVNsb3QgPT09IG51bGwpIHtcblx0XHRcdFx0YWN0aXZlVGV4dHVyZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbY3VycmVudFRleHR1cmVTbG90XTtcblxuXHRcdFx0aWYgKGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGJvdW5kVGV4dHVyZSA9IHtcblx0XHRcdFx0XHR0eXBlOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0dGV4dHVyZTogdW5kZWZpbmVkXG5cdFx0XHRcdH07XG5cdFx0XHRcdGN1cnJlbnRCb3VuZFRleHR1cmVzW2N1cnJlbnRUZXh0dXJlU2xvdF0gPSBib3VuZFRleHR1cmU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUpIHtcblx0XHRcdFx0Z2wuYmluZFRleHR1cmUod2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgfHwgZW1wdHlUZXh0dXJlc1t3ZWJnbFR5cGVdKTtcblx0XHRcdFx0Ym91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XG5cdFx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuYmluZFRleHR1cmUoKSB7XG5cdFx0XHRjb25zdCBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1tjdXJyZW50VGV4dHVyZVNsb3RdO1xuXG5cdFx0XHRpZiAoYm91bmRUZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgYm91bmRUZXh0dXJlLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRnbC5iaW5kVGV4dHVyZShib3VuZFRleHR1cmUudHlwZSwgbnVsbCk7XG5cdFx0XHRcdGJvdW5kVGV4dHVyZS50eXBlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21wcmVzc2VkVGV4SW1hZ2UyRCgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGdsLmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGV4SW1hZ2UyRCgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGdsLnRleEltYWdlMkQuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0ZXhJbWFnZTNEKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Z2wudGV4SW1hZ2UzRC5hcHBseShnbCwgYXJndW1lbnRzKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0gLy9cblxuXG5cdFx0ZnVuY3Rpb24gc2Npc3NvcihzY2lzc29yKSB7XG5cdFx0XHRpZiAoY3VycmVudFNjaXNzb3IuZXF1YWxzKHNjaXNzb3IpID09PSBmYWxzZSkge1xuXHRcdFx0XHRnbC5zY2lzc29yKHNjaXNzb3IueCwgc2Npc3Nvci55LCBzY2lzc29yLnosIHNjaXNzb3Iudyk7XG5cdFx0XHRcdGN1cnJlbnRTY2lzc29yLmNvcHkoc2Npc3Nvcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdmlld3BvcnQodmlld3BvcnQpIHtcblx0XHRcdGlmIChjdXJyZW50Vmlld3BvcnQuZXF1YWxzKHZpZXdwb3J0KSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Z2wudmlld3BvcnQodmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQueiwgdmlld3BvcnQudyk7XG5cdFx0XHRcdGN1cnJlbnRWaWV3cG9ydC5jb3B5KHZpZXdwb3J0KTtcblx0XHRcdH1cblx0XHR9IC8vXG5cblxuXHRcdGZ1bmN0aW9uIHJlc2V0KCkge1xuXHRcdFx0Ly8gcmVzZXQgc3RhdGVcblx0XHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblx0XHRcdGdsLmRpc2FibGUoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSk7XG5cdFx0XHRnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcblx0XHRcdGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLlpFUk8pO1xuXHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuT05FLCBnbC5aRVJPLCBnbC5PTkUsIGdsLlpFUk8pO1xuXHRcdFx0Z2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuXHRcdFx0Z2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcblx0XHRcdGdsLmRlcHRoTWFzayh0cnVlKTtcblx0XHRcdGdsLmRlcHRoRnVuYyhnbC5MRVNTKTtcblx0XHRcdGdsLmNsZWFyRGVwdGgoMSk7XG5cdFx0XHRnbC5zdGVuY2lsTWFzaygweGZmZmZmZmZmKTtcblx0XHRcdGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywgMCwgMHhmZmZmZmZmZik7XG5cdFx0XHRnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG5cdFx0XHRnbC5jbGVhclN0ZW5jaWwoMCk7XG5cdFx0XHRnbC5jdWxsRmFjZShnbC5CQUNLKTtcblx0XHRcdGdsLmZyb250RmFjZShnbC5DQ1cpO1xuXHRcdFx0Z2wucG9seWdvbk9mZnNldCgwLCAwKTtcblx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdFx0aWYgKGlzV2ViR0wyID09PSB0cnVlKSB7XG5cdFx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCBudWxsKTtcblx0XHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdFx0fVxuXG5cdFx0XHRnbC51c2VQcm9ncmFtKG51bGwpO1xuXHRcdFx0Z2wubGluZVdpZHRoKDEpO1xuXHRcdFx0Z2wuc2Npc3NvcigwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuXHRcdFx0Z2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTsgLy8gcmVzZXQgaW50ZXJuYWxzXG5cblx0XHRcdGVuYWJsZWRDYXBhYmlsaXRpZXMgPSB7fTtcblx0XHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XG5cdFx0XHRjdXJyZW50Qm91bmRUZXh0dXJlcyA9IHt9O1xuXHRcdFx0eHJGcmFtZWJ1ZmZlciA9IG51bGw7XG5cdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnMgPSB7fTtcblx0XHRcdGN1cnJlbnRQcm9ncmFtID0gbnVsbDtcblx0XHRcdGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPSBmYWxzZTtcblx0XHRcdGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XG5cdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG5cdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcblx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXHRcdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XG5cdFx0XHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblx0XHRcdGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XG5cdFx0XHRjdXJyZW50TGluZVdpZHRoID0gbnVsbDtcblx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcblx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xuXHRcdFx0Y3VycmVudFNjaXNzb3Iuc2V0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG5cdFx0XHRjdXJyZW50Vmlld3BvcnQuc2V0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG5cdFx0XHRjb2xvckJ1ZmZlci5yZXNldCgpO1xuXHRcdFx0ZGVwdGhCdWZmZXIucmVzZXQoKTtcblx0XHRcdHN0ZW5jaWxCdWZmZXIucmVzZXQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YnVmZmVyczoge1xuXHRcdFx0XHRjb2xvcjogY29sb3JCdWZmZXIsXG5cdFx0XHRcdGRlcHRoOiBkZXB0aEJ1ZmZlcixcblx0XHRcdFx0c3RlbmNpbDogc3RlbmNpbEJ1ZmZlclxuXHRcdFx0fSxcblx0XHRcdGVuYWJsZTogZW5hYmxlLFxuXHRcdFx0ZGlzYWJsZTogZGlzYWJsZSxcblx0XHRcdGJpbmRGcmFtZWJ1ZmZlcjogYmluZEZyYW1lYnVmZmVyLFxuXHRcdFx0YmluZFhSRnJhbWVidWZmZXI6IGJpbmRYUkZyYW1lYnVmZmVyLFxuXHRcdFx0dXNlUHJvZ3JhbTogdXNlUHJvZ3JhbSxcblx0XHRcdHNldEJsZW5kaW5nOiBzZXRCbGVuZGluZyxcblx0XHRcdHNldE1hdGVyaWFsOiBzZXRNYXRlcmlhbCxcblx0XHRcdHNldEZsaXBTaWRlZDogc2V0RmxpcFNpZGVkLFxuXHRcdFx0c2V0Q3VsbEZhY2U6IHNldEN1bGxGYWNlLFxuXHRcdFx0c2V0TGluZVdpZHRoOiBzZXRMaW5lV2lkdGgsXG5cdFx0XHRzZXRQb2x5Z29uT2Zmc2V0OiBzZXRQb2x5Z29uT2Zmc2V0LFxuXHRcdFx0c2V0U2Npc3NvclRlc3Q6IHNldFNjaXNzb3JUZXN0LFxuXHRcdFx0YWN0aXZlVGV4dHVyZTogYWN0aXZlVGV4dHVyZSxcblx0XHRcdGJpbmRUZXh0dXJlOiBiaW5kVGV4dHVyZSxcblx0XHRcdHVuYmluZFRleHR1cmU6IHVuYmluZFRleHR1cmUsXG5cdFx0XHRjb21wcmVzc2VkVGV4SW1hZ2UyRDogY29tcHJlc3NlZFRleEltYWdlMkQsXG5cdFx0XHR0ZXhJbWFnZTJEOiB0ZXhJbWFnZTJELFxuXHRcdFx0dGV4SW1hZ2UzRDogdGV4SW1hZ2UzRCxcblx0XHRcdHNjaXNzb3I6IHNjaXNzb3IsXG5cdFx0XHR2aWV3cG9ydDogdmlld3BvcnQsXG5cdFx0XHRyZXNldDogcmVzZXRcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xUZXh0dXJlcyhfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHV0aWxzLCBpbmZvKSB7XG5cdFx0Y29uc3QgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG5cdFx0Y29uc3QgbWF4VGV4dHVyZXMgPSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXM7XG5cdFx0Y29uc3QgbWF4Q3ViZW1hcFNpemUgPSBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemU7XG5cdFx0Y29uc3QgbWF4VGV4dHVyZVNpemUgPSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemU7XG5cdFx0Y29uc3QgbWF4U2FtcGxlcyA9IGNhcGFiaWxpdGllcy5tYXhTYW1wbGVzO1xuXG5cdFx0Y29uc3QgX3ZpZGVvVGV4dHVyZXMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdFx0bGV0IF9jYW52YXM7IC8vIGNvcmRvdmEgaU9TIChhcyBvZiA1LjApIHN0aWxsIHVzZXMgVUlXZWJWaWV3LCB3aGljaCBwcm92aWRlcyBPZmZzY3JlZW5DYW52YXMsXG5cdFx0Ly8gYWxzbyBPZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpLCBidXQgbm90IE9mZnNjcmVlbkNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikhXG5cdFx0Ly8gU29tZSBpbXBsZW1lbnRhdGlvbnMgbWF5IG9ubHkgaW1wbGVtZW50IE9mZnNjcmVlbkNhbnZhcyBwYXJ0aWFsbHkgKGUuZy4gbGFja2luZyAyZCkuXG5cblxuXHRcdGxldCB1c2VPZmZzY3JlZW5DYW52YXMgPSBmYWxzZTtcblxuXHRcdHRyeSB7XG5cdFx0XHR1c2VPZmZzY3JlZW5DYW52YXMgPSB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpLmdldENvbnRleHQoJzJkJykgIT09IG51bGw7XG5cdFx0fSBjYXRjaCAoZXJyKSB7Ly8gSWdub3JlIGFueSBlcnJvcnNcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuXHRcdFx0Ly8gVXNlIE9mZnNjcmVlbkNhbnZhcyB3aGVuIGF2YWlsYWJsZS4gU3BlY2lhbGx5IG5lZWRlZCBpbiB3ZWIgd29ya2Vyc1xuXHRcdFx0cmV0dXJuIHVzZU9mZnNjcmVlbkNhbnZhcyA/IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzaXplSW1hZ2UoaW1hZ2UsIG5lZWRzUG93ZXJPZlR3bywgbmVlZHNOZXdDYW52YXMsIG1heFNpemUpIHtcblx0XHRcdGxldCBzY2FsZSA9IDE7IC8vIGhhbmRsZSBjYXNlIGlmIHRleHR1cmUgZXhjZWVkcyBtYXggc2l6ZVxuXG5cdFx0XHRpZiAoaW1hZ2Uud2lkdGggPiBtYXhTaXplIHx8IGltYWdlLmhlaWdodCA+IG1heFNpemUpIHtcblx0XHRcdFx0c2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG5cdFx0XHR9IC8vIG9ubHkgcGVyZm9ybSByZXNpemUgaWYgbmVjZXNzYXJ5XG5cblxuXHRcdFx0aWYgKHNjYWxlIDwgMSB8fCBuZWVkc1Bvd2VyT2ZUd28gPT09IHRydWUpIHtcblx0XHRcdFx0Ly8gb25seSBwZXJmb3JtIHJlc2l6ZSBmb3IgY2VydGFpbiBpbWFnZSB0eXBlc1xuXHRcdFx0XHRpZiAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHwgdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG5cdFx0XHRcdFx0Y29uc3QgZmxvb3IgPSBuZWVkc1Bvd2VyT2ZUd28gPyBmbG9vclBvd2VyT2ZUd28gOiBNYXRoLmZsb29yO1xuXHRcdFx0XHRcdGNvbnN0IHdpZHRoID0gZmxvb3Ioc2NhbGUgKiBpbWFnZS53aWR0aCk7XG5cdFx0XHRcdFx0Y29uc3QgaGVpZ2h0ID0gZmxvb3Ioc2NhbGUgKiBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0XHRcdGlmIChfY2FudmFzID09PSB1bmRlZmluZWQpIF9jYW52YXMgPSBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7IC8vIGN1YmUgdGV4dHVyZXMgY2FuJ3QgcmV1c2UgdGhlIHNhbWUgY2FudmFzXG5cblx0XHRcdFx0XHRjb25zdCBjYW52YXMgPSBuZWVkc05ld0NhbnZhcyA/IGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSA6IF9jYW52YXM7XG5cdFx0XHRcdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdFx0XHRjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBoYXMgYmVlbiByZXNpemVkIGZyb20gKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpIHRvICgnICsgd2lkdGggKyAneCcgKyBoZWlnaHQgKyAnKS4nKTtcblx0XHRcdFx0XHRyZXR1cm4gY2FudmFzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICgnZGF0YScgaW4gaW1hZ2UpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogSW1hZ2UgaW4gRGF0YVRleHR1cmUgaXMgdG9vIGJpZyAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGltYWdlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1Bvd2VyT2ZUd28kMShpbWFnZSkge1xuXHRcdFx0cmV0dXJuIGlzUG93ZXJPZlR3byhpbWFnZS53aWR0aCkgJiYgaXNQb3dlck9mVHdvKGltYWdlLmhlaWdodCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byh0ZXh0dXJlKSB7XG5cdFx0XHRpZiAoaXNXZWJHTDIpIHJldHVybiBmYWxzZTtcblx0XHRcdHJldHVybiB0ZXh0dXJlLndyYXBTICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlcjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHModGV4dHVyZSwgc3VwcG9ydHNNaXBzKSB7XG5cdFx0XHRyZXR1cm4gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgc3VwcG9ydHNNaXBzICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVNaXBtYXAodGFyZ2V0LCB0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCA9IDEpIHtcblx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuXG5cdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19tYXhNaXBMZXZlbCA9IE1hdGgubG9nMihNYXRoLm1heCh3aWR0aCwgaGVpZ2h0LCBkZXB0aCkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0TmFtZSwgZ2xGb3JtYXQsIGdsVHlwZSkge1xuXHRcdFx0aWYgKGlzV2ViR0wyID09PSBmYWxzZSkgcmV0dXJuIGdsRm9ybWF0O1xuXG5cdFx0XHRpZiAoaW50ZXJuYWxGb3JtYXROYW1lICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChfZ2xbaW50ZXJuYWxGb3JtYXROYW1lXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gX2dsW2ludGVybmFsRm9ybWF0TmFtZV07XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byB1c2Ugbm9uLWV4aXN0aW5nIFdlYkdMIGludGVybmFsIGZvcm1hdCBcXCcnICsgaW50ZXJuYWxGb3JtYXROYW1lICsgJ1xcJycpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaW50ZXJuYWxGb3JtYXQgPSBnbEZvcm1hdDtcblxuXHRcdFx0aWYgKGdsRm9ybWF0ID09PSBfZ2wuUkVEKSB7XG5cdFx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5GTE9BVCkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjMyRjtcblx0XHRcdFx0aWYgKGdsVHlwZSA9PT0gX2dsLkhBTEZfRkxPQVQpIGludGVybmFsRm9ybWF0ID0gX2dsLlIxNkY7XG5cdFx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SODtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGdsRm9ybWF0ID09PSBfZ2wuUkdCKSB7XG5cdFx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5GTE9BVCkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCMzJGO1xuXHRcdFx0XHRpZiAoZ2xUeXBlID09PSBfZ2wuSEFMRl9GTE9BVCkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCMTZGO1xuXHRcdFx0XHRpZiAoZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfQllURSkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCODtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGdsRm9ybWF0ID09PSBfZ2wuUkdCQSkge1xuXHRcdFx0XHRpZiAoZ2xUeXBlID09PSBfZ2wuRkxPQVQpIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkEzMkY7XG5cdFx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0JBMTZGO1xuXHRcdFx0XHRpZiAoZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfQllURSkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCQTg7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlIxNkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SMzJGIHx8IGludGVybmFsRm9ybWF0ID09PSBfZ2wuUkdCQTE2RiB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlJHQkEzMkYpIHtcblx0XHRcdFx0ZXh0ZW5zaW9ucy5nZXQoJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGludGVybmFsRm9ybWF0O1xuXHRcdH0gLy8gRmFsbGJhY2sgZmlsdGVycyBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcblxuXG5cdFx0ZnVuY3Rpb24gZmlsdGVyRmFsbGJhY2soZikge1xuXHRcdFx0aWYgKGYgPT09IE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcikge1xuXHRcdFx0XHRyZXR1cm4gX2dsLk5FQVJFU1Q7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBfZ2wuTElORUFSO1xuXHRcdH0gLy9cblxuXG5cdFx0ZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZShldmVudCkge1xuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcblx0XHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UpO1xuXHRcdFx0ZGVhbGxvY2F0ZVRleHR1cmUodGV4dHVyZSk7XG5cblx0XHRcdGlmICh0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlKSB7XG5cdFx0XHRcdF92aWRlb1RleHR1cmVzLmRlbGV0ZSh0ZXh0dXJlKTtcblx0XHRcdH1cblxuXHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMtLTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblJlbmRlclRhcmdldERpc3Bvc2UoZXZlbnQpIHtcblx0XHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlKTtcblx0XHRcdGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcblx0XHR9IC8vXG5cblxuXHRcdGZ1bmN0aW9uIGRlYWxsb2NhdGVUZXh0dXJlKHRleHR1cmUpIHtcblx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSk7XG5cdFx0XHRpZiAodGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKHRleHR1cmUpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSk7XG5cdFx0XHRpZiAoIXJlbmRlclRhcmdldCkgcmV0dXJuO1xuXG5cdFx0XHRpZiAodGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cblx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMtLTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUpIHtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbaV0pO1xuXG5cdFx0XHRcdFx0aWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyKTtcblxuXHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIpIF9nbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIpO1xuXHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpIF9nbC5kZWxldGVGcmFtZWJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcikgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcik7XG5cdFx0XHRcdGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlcikgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cykge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBhdHRhY2htZW50UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmVbaV0pO1xuXG5cdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKSB7XG5cdFx0XHRcdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZShhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cblx0XHRcdFx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzLS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cHJvcGVydGllcy5yZW1vdmUodGV4dHVyZVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cHJvcGVydGllcy5yZW1vdmUodGV4dHVyZSk7XG5cdFx0XHRwcm9wZXJ0aWVzLnJlbW92ZShyZW5kZXJUYXJnZXQpO1xuXHRcdH0gLy9cblxuXG5cdFx0bGV0IHRleHR1cmVVbml0cyA9IDA7XG5cblx0XHRmdW5jdGlvbiByZXNldFRleHR1cmVVbml0cygpIHtcblx0XHRcdHRleHR1cmVVbml0cyA9IDA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWxsb2NhdGVUZXh0dXJlVW5pdCgpIHtcblx0XHRcdGNvbnN0IHRleHR1cmVVbml0ID0gdGV4dHVyZVVuaXRzO1xuXG5cdFx0XHRpZiAodGV4dHVyZVVuaXQgPj0gbWF4VGV4dHVyZXMpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFRleHR1cmVzOiBUcnlpbmcgdG8gdXNlICcgKyB0ZXh0dXJlVW5pdCArICcgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICcgKyBtYXhUZXh0dXJlcyk7XG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmVVbml0cyArPSAxO1xuXHRcdFx0cmV0dXJuIHRleHR1cmVVbml0O1xuXHRcdH0gLy9cblxuXG5cdFx0ZnVuY3Rpb24gc2V0VGV4dHVyZTJEKHRleHR1cmUsIHNsb3QpIHtcblx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSk7XG5cdFx0XHRpZiAodGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSkgdXBkYXRlVmlkZW9UZXh0dXJlKHRleHR1cmUpO1xuXG5cdFx0XHRpZiAodGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbikge1xuXHRcdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cblx0XHRcdFx0aWYgKGltYWdlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZCcpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGltYWdlLmNvbXBsZXRlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVwbG9hZFRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKF9nbC5URVhUVVJFMCArIHNsb3QpO1xuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRUZXh0dXJlMkRBcnJheSh0ZXh0dXJlLCBzbG90KSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXG5cdFx0XHRpZiAodGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbikge1xuXHRcdFx0XHR1cGxvYWRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKF9nbC5URVhUVVJFMCArIHNsb3QpO1xuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoX2dsLlRFWFRVUkVfMkRfQVJSQVksIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRUZXh0dXJlM0QodGV4dHVyZSwgc2xvdCkge1xuXHRcdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKTtcblxuXHRcdFx0aWYgKHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24pIHtcblx0XHRcdFx0dXBsb2FkVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZShfZ2wuVEVYVFVSRTAgKyBzbG90KTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKF9nbC5URVhUVVJFXzNELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmUodGV4dHVyZSwgc2xvdCkge1xuXHRcdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKTtcblxuXHRcdFx0aWYgKHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24pIHtcblx0XHRcdFx0dXBsb2FkQ3ViZVRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoX2dsLlRFWFRVUkUwICsgc2xvdCk7XG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHdyYXBwaW5nVG9HTCA9IHtcblx0XHRcdFtSZXBlYXRXcmFwcGluZ106IF9nbC5SRVBFQVQsXG5cdFx0XHRbQ2xhbXBUb0VkZ2VXcmFwcGluZ106IF9nbC5DTEFNUF9UT19FREdFLFxuXHRcdFx0W01pcnJvcmVkUmVwZWF0V3JhcHBpbmddOiBfZ2wuTUlSUk9SRURfUkVQRUFUXG5cdFx0fTtcblx0XHRjb25zdCBmaWx0ZXJUb0dMID0ge1xuXHRcdFx0W05lYXJlc3RGaWx0ZXJdOiBfZ2wuTkVBUkVTVCxcblx0XHRcdFtOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcl06IF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNULFxuXHRcdFx0W05lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXJdOiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSLFxuXHRcdFx0W0xpbmVhckZpbHRlcl06IF9nbC5MSU5FQVIsXG5cdFx0XHRbTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcl06IF9nbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QsXG5cdFx0XHRbTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXTogX2dsLkxJTkVBUl9NSVBNQVBfTElORUFSXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMpIHtcblx0XHRcdGlmIChzdXBwb3J0c01pcHMpIHtcblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgd3JhcHBpbmdUb0dMW3RleHR1cmUud3JhcFNdKTtcblxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCB3cmFwcGluZ1RvR0xbdGV4dHVyZS53cmFwVF0pO1xuXG5cdFx0XHRcdGlmICh0ZXh0dXJlVHlwZSA9PT0gX2dsLlRFWFRVUkVfM0QgfHwgdGV4dHVyZVR5cGUgPT09IF9nbC5URVhUVVJFXzJEX0FSUkFZKSB7XG5cdFx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUiwgd3JhcHBpbmdUb0dMW3RleHR1cmUud3JhcFJdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJUb0dMW3RleHR1cmUubWFnRmlsdGVyXSk7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlclRvR0xbdGV4dHVyZS5taW5GaWx0ZXJdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFKTtcblxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSk7XG5cblx0XHRcdFx0aWYgKHRleHR1cmVUeXBlID09PSBfZ2wuVEVYVFVSRV8zRCB8fCB0ZXh0dXJlVHlwZSA9PT0gX2dsLlRFWFRVUkVfMkRfQVJSQVkpIHtcblx0XHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9SLCBfZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGV4dHVyZS53cmFwUyAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKHRleHR1cmUubWFnRmlsdGVyKSk7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKHRleHR1cmUubWluRmlsdGVyKSk7XG5cblx0XHRcdFx0aWYgKHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS5taW5GaWx0ZXIgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5OZWFyZXN0RmlsdGVyIG9yIFRIUkVFLkxpbmVhckZpbHRlci4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXh0ZW5zaW9ucy5oYXMoJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpID09PSB0cnVlKSB7XG5cdFx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKTtcblx0XHRcdFx0aWYgKHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuaGFzKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSA9PT0gZmFsc2UpIHJldHVybjsgLy8gdmVyaWZ5IGV4dGVuc2lvbiBmb3IgV2ViR0wgMSBhbmQgV2ViR0wgMlxuXG5cdFx0XHRcdGlmIChpc1dlYkdMMiA9PT0gZmFsc2UgJiYgdGV4dHVyZS50eXBlID09PSBIYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuaGFzKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicpID09PSBmYWxzZSkgcmV0dXJuOyAvLyB2ZXJpZnkgZXh0ZW5zaW9uIGZvciBXZWJHTCAxIG9ubHlcblxuXHRcdFx0XHRpZiAodGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKS5fX2N1cnJlbnRBbmlzb3Ryb3B5KSB7XG5cdFx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYodGV4dHVyZVR5cGUsIGV4dGVuc2lvbi5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4odGV4dHVyZS5hbmlzb3Ryb3B5LCBjYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpKSk7XG5cblx0XHRcdFx0XHRwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5pdFRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUpIHtcblx0XHRcdGlmICh0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcblx0XHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSk7XG5cdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGxvYWRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KSB7XG5cdFx0XHRsZXQgdGV4dHVyZVR5cGUgPSBfZ2wuVEVYVFVSRV8yRDtcblx0XHRcdGlmICh0ZXh0dXJlLmlzRGF0YVRleHR1cmUyREFycmF5KSB0ZXh0dXJlVHlwZSA9IF9nbC5URVhUVVJFXzJEX0FSUkFZO1xuXHRcdFx0aWYgKHRleHR1cmUuaXNEYXRhVGV4dHVyZTNEKSB0ZXh0dXJlVHlwZSA9IF9nbC5URVhUVVJFXzNEO1xuXHRcdFx0aW5pdFRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUpO1xuXHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZShfZ2wuVEVYVFVSRTAgKyBzbG90KTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKHRleHR1cmVUeXBlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50KTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBfZ2wuTk9ORSk7XG5cblx0XHRcdGNvbnN0IG5lZWRzUG93ZXJPZlR3byA9IHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28odGV4dHVyZSkgJiYgaXNQb3dlck9mVHdvJDEodGV4dHVyZS5pbWFnZSkgPT09IGZhbHNlO1xuXHRcdFx0Y29uc3QgaW1hZ2UgPSByZXNpemVJbWFnZSh0ZXh0dXJlLmltYWdlLCBuZWVkc1Bvd2VyT2ZUd28sIGZhbHNlLCBtYXhUZXh0dXJlU2l6ZSk7XG5cdFx0XHRjb25zdCBzdXBwb3J0c01pcHMgPSBpc1Bvd2VyT2ZUd28kMShpbWFnZSkgfHwgaXNXZWJHTDIsXG5cdFx0XHRcdFx0XHRnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS5mb3JtYXQpO1xuXHRcdFx0bGV0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKSxcblx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQodGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSk7XG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyh0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgc3VwcG9ydHNNaXBzKTtcblx0XHRcdGxldCBtaXBtYXA7XG5cdFx0XHRjb25zdCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xuXG5cdFx0XHRpZiAodGV4dHVyZS5pc0RlcHRoVGV4dHVyZSkge1xuXHRcdFx0XHQvLyBwb3B1bGF0ZSBkZXB0aCB0ZXh0dXJlIHdpdGggZHVtbXkgZGF0YVxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDtcblxuXHRcdFx0XHRpZiAoaXNXZWJHTDIpIHtcblx0XHRcdFx0XHRpZiAodGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUpIHtcblx0XHRcdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UMzJGO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGV4dHVyZS50eXBlID09PSBVbnNpZ25lZEludFR5cGUpIHtcblx0XHRcdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UMjQ7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0ZXh0dXJlLnR5cGUgPT09IFVuc2lnbmVkSW50MjQ4VHlwZSkge1xuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSDI0X1NURU5DSUw4O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDE2OyAvLyBXZWJHTDIgcmVxdWlyZXMgc2l6ZWQgaW50ZXJuYWxmb3JtYXQgZm9yIGdsVGV4SW1hZ2UyRFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1dlYkdMUmVuZGVyZXI6IEZsb2F0aW5nIHBvaW50IGRlcHRoIHRleHR1cmUgcmVxdWlyZXMgV2ViR0wyLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSAvLyB2YWxpZGF0aW9uIGNoZWNrcyBmb3IgV2ViR0wgMVxuXG5cblx0XHRcdFx0aWYgKHRleHR1cmUuZm9ybWF0ID09PSBEZXB0aEZvcm1hdCAmJiBnbEludGVybmFsRm9ybWF0ID09PSBfZ2wuREVQVEhfQ09NUE9ORU5UKSB7XG5cdFx0XHRcdFx0Ly8gVGhlIGVycm9yIElOVkFMSURfT1BFUkFUSU9OIGlzIGdlbmVyYXRlZCBieSB0ZXhJbWFnZTJEIGlmIGZvcm1hdCBhbmQgaW50ZXJuYWxmb3JtYXQgYXJlXG5cdFx0XHRcdFx0Ly8gREVQVEhfQ09NUE9ORU5UIGFuZCB0eXBlIGlzIG5vdCBVTlNJR05FRF9TSE9SVCBvciBVTlNJR05FRF9JTlRcblx0XHRcdFx0XHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcblx0XHRcdFx0XHRpZiAodGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZFNob3J0VHlwZSAmJiB0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkSW50VHlwZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVc2UgVW5zaWduZWRTaG9ydFR5cGUgb3IgVW5zaWduZWRJbnRUeXBlIGZvciBEZXB0aEZvcm1hdCBEZXB0aFRleHR1cmUuJyk7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZFNob3J0VHlwZTtcblx0XHRcdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGV4dHVyZS5mb3JtYXQgPT09IERlcHRoU3RlbmNpbEZvcm1hdCAmJiBnbEludGVybmFsRm9ybWF0ID09PSBfZ2wuREVQVEhfQ09NUE9ORU5UKSB7XG5cdFx0XHRcdFx0Ly8gRGVwdGggc3RlbmNpbCB0ZXh0dXJlcyBuZWVkIHRoZSBERVBUSF9TVEVOQ0lMIGludGVybmFsIGZvcm1hdFxuXHRcdFx0XHRcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxuXHRcdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfU1RFTkNJTDsgLy8gVGhlIGVycm9yIElOVkFMSURfT1BFUkFUSU9OIGlzIGdlbmVyYXRlZCBieSB0ZXhJbWFnZTJEIGlmIGZvcm1hdCBhbmQgaW50ZXJuYWxmb3JtYXQgYXJlXG5cdFx0XHRcdFx0Ly8gREVQVEhfU1RFTkNJTCBhbmQgdHlwZSBpcyBub3QgVU5TSUdORURfSU5UXzI0XzhfV0VCR0wuXG5cdFx0XHRcdFx0Ly8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXG5cblx0XHRcdFx0XHRpZiAodGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZEludDI0OFR5cGUpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkSW50MjQ4VHlwZSBmb3IgRGVwdGhTdGVuY2lsRm9ybWF0IERlcHRoVGV4dHVyZS4nKTtcblx0XHRcdFx0XHRcdHRleHR1cmUudHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcblx0XHRcdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy9cblxuXG5cdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwpO1xuXHRcdFx0fSBlbHNlIGlmICh0ZXh0dXJlLmlzRGF0YVRleHR1cmUpIHtcblx0XHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG5cdFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXHRcdFx0XHRpZiAobWlwbWFwcy5sZW5ndGggPiAwICYmIHN1cHBvcnRzTWlwcykge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1tpXTtcblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19tYXhNaXBMZXZlbCA9IG1pcG1hcHMubGVuZ3RoIC0gMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhKTtcblx0XHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX21heE1pcExldmVsID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1tpXTtcblxuXHRcdFx0XHRcdGlmICh0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCRm9ybWF0KSB7XG5cdFx0XHRcdFx0XHRpZiAoZ2xGb3JtYXQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fbWF4TWlwTGV2ZWwgPSBtaXBtYXBzLmxlbmd0aCAtIDE7XG5cdFx0XHR9IGVsc2UgaWYgKHRleHR1cmUuaXNEYXRhVGV4dHVyZTJEQXJyYXkpIHtcblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UzRChfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEpO1xuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX21heE1pcExldmVsID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodGV4dHVyZS5pc0RhdGFUZXh0dXJlM0QpIHtcblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UzRChfZ2wuVEVYVFVSRV8zRCwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEpO1xuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX21heE1pcExldmVsID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXG5cdFx0XHRcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuXHRcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblx0XHRcdFx0aWYgKG1pcG1hcHMubGVuZ3RoID4gMCAmJiBzdXBwb3J0c01pcHMpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbaV07XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBpLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19tYXhNaXBMZXZlbCA9IG1pcG1hcHMubGVuZ3RoIC0gMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSk7XG5cdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19tYXhNaXBMZXZlbCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyh0ZXh0dXJlLCBzdXBwb3J0c01pcHMpKSB7XG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xuXHRcdFx0aWYgKHRleHR1cmUub25VcGRhdGUpIHRleHR1cmUub25VcGRhdGUodGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBsb2FkQ3ViZVRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QpIHtcblx0XHRcdGlmICh0ZXh0dXJlLmltYWdlLmxlbmd0aCAhPT0gNikgcmV0dXJuO1xuXHRcdFx0aW5pdFRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUpO1xuXHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZShfZ2wuVEVYVFVSRTAgKyBzbG90KTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50KTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBfZ2wuTk9ORSk7XG5cblx0XHRcdGNvbnN0IGlzQ29tcHJlc3NlZCA9IHRleHR1cmUgJiYgKHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSB8fCB0ZXh0dXJlLmltYWdlWzBdLmlzQ29tcHJlc3NlZFRleHR1cmUpO1xuXHRcdFx0Y29uc3QgaXNEYXRhVGV4dHVyZSA9IHRleHR1cmUuaW1hZ2VbMF0gJiYgdGV4dHVyZS5pbWFnZVswXS5pc0RhdGFUZXh0dXJlO1xuXHRcdFx0Y29uc3QgY3ViZUltYWdlID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdGlmICghaXNDb21wcmVzc2VkICYmICFpc0RhdGFUZXh0dXJlKSB7XG5cdFx0XHRcdFx0Y3ViZUltYWdlW2ldID0gcmVzaXplSW1hZ2UodGV4dHVyZS5pbWFnZVtpXSwgZmFsc2UsIHRydWUsIG1heEN1YmVtYXBTaXplKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdWJlSW1hZ2VbaV0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVtpXS5pbWFnZSA6IHRleHR1cmUuaW1hZ2VbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBjdWJlSW1hZ2VbMF0sXG5cdFx0XHRcdFx0XHRzdXBwb3J0c01pcHMgPSBpc1Bvd2VyT2ZUd28kMShpbWFnZSkgfHwgaXNXZWJHTDIsXG5cdFx0XHRcdFx0XHRnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS5mb3JtYXQpLFxuXHRcdFx0XHRcdFx0Z2xUeXBlID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLnR5cGUpLFxuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRm9ybWF0KHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUpO1xuXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIHN1cHBvcnRzTWlwcyk7XG5cdFx0XHRsZXQgbWlwbWFwcztcblxuXHRcdFx0aWYgKGlzQ29tcHJlc3NlZCkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRcdG1pcG1hcHMgPSBjdWJlSW1hZ2VbaV0ubWlwbWFwcztcblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbWlwbWFwcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1tqXTtcblxuXHRcdFx0XHRcdFx0aWYgKHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JGb3JtYXQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGdsRm9ybWF0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldFRleHR1cmVDdWJlKCknKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19tYXhNaXBMZXZlbCA9IG1pcG1hcHMubGVuZ3RoIC0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaXNEYXRhVGV4dHVyZSkge1xuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgY3ViZUltYWdlW2ldLndpZHRoLCBjdWJlSW1hZ2VbaV0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbaV0uZGF0YSk7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbWlwbWFwcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtaXBtYXAgPSBtaXBtYXBzW2pdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtaXBtYXBJbWFnZSA9IG1pcG1hcC5pbWFnZVtpXS5pbWFnZTtcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcEltYWdlLndpZHRoLCBtaXBtYXBJbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcEltYWdlLmRhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbaV0pO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG1pcG1hcHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1tqXTtcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIGdsSW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5pbWFnZVtpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19tYXhNaXBMZXZlbCA9IG1pcG1hcHMubGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKHRleHR1cmUsIHN1cHBvcnRzTWlwcykpIHtcblx0XHRcdFx0Ly8gV2UgYXNzdW1lIGltYWdlcyBmb3IgY3ViZSBtYXAgaGF2ZSB0aGUgc2FtZSBzaXplLlxuXHRcdFx0XHRnZW5lcmF0ZU1pcG1hcChfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblx0XHRcdGlmICh0ZXh0dXJlLm9uVXBkYXRlKSB0ZXh0dXJlLm9uVXBkYXRlKHRleHR1cmUpO1xuXHRcdH0gLy8gUmVuZGVyIHRhcmdldHNcblx0XHQvLyBTZXR1cCBzdG9yYWdlIGZvciB0YXJnZXQgdGV4dHVyZSBhbmQgYmluZCBpdCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXG5cblxuXHRcdGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIHRleHR1cmUsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQpIHtcblx0XHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLmZvcm1hdCk7XG5cdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSk7XG5cdFx0XHRjb25zdCBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQodGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSk7XG5cblx0XHRcdGlmICh0ZXh0dXJlVGFyZ2V0ID09PSBfZ2wuVEVYVFVSRV8zRCB8fCB0ZXh0dXJlVGFyZ2V0ID09PSBfZ2wuVEVYVFVSRV8yRF9BUlJBWSkge1xuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTNEKHRleHR1cmVUYXJnZXQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgcmVuZGVyVGFyZ2V0LmRlcHRoLCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0YXRlLnRleEltYWdlMkQodGV4dHVyZVRhcmdldCwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoX2dsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSwgMCk7XG5cblx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdH0gLy8gU2V0dXAgc3RvcmFnZSBmb3IgaW50ZXJuYWwgZGVwdGgvc3RlbmNpbCBidWZmZXJzIGFuZCBiaW5kIHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcblxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBpc011bHRpc2FtcGxlKSB7XG5cdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlcihfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICFyZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlcikge1xuXHRcdFx0XHRsZXQgZ2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQxNjtcblxuXHRcdFx0XHRpZiAoaXNNdWx0aXNhbXBsZSkge1xuXHRcdFx0XHRcdGNvbnN0IGRlcHRoVGV4dHVyZSA9IHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmU7XG5cblx0XHRcdFx0XHRpZiAoZGVwdGhUZXh0dXJlICYmIGRlcHRoVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSkge1xuXHRcdFx0XHRcdFx0aWYgKGRlcHRoVGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUpIHtcblx0XHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQzMkY7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGRlcHRoVGV4dHVyZS50eXBlID09PSBVbnNpZ25lZEludFR5cGUpIHtcblx0XHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQyNDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKF9nbC5SRU5ERVJCVUZGRVIsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyKTtcblx0XHRcdH0gZWxzZSBpZiAocmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyKSB7XG5cdFx0XHRcdGlmIChpc011bHRpc2FtcGxlKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMocmVuZGVyVGFyZ2V0KTtcblxuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgX2dsLkRFUFRIMjRfU1RFTkNJTDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVXNlIHRoZSBmaXJzdCB0ZXh0dXJlIGZvciBNUlQgc28gZmFyXG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gdHJ1ZSA/IHJlbmRlclRhcmdldC50ZXh0dXJlWzBdIDogcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLmZvcm1hdCk7XG5cdFx0XHRcdGNvbnN0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKTtcblx0XHRcdFx0Y29uc3QgZ2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRm9ybWF0KHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUpO1xuXG5cdFx0XHRcdGlmIChpc011bHRpc2FtcGxlKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMocmVuZGVyVGFyZ2V0KTtcblxuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShfZ2wuUkVOREVSQlVGRkVSLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKF9nbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdH0gLy8gU2V0dXAgcmVzb3VyY2VzIGZvciBhIERlcHRoIFRleHR1cmUgZm9yIGEgRkJPIChuZWVkcyBhbiBleHRlbnNpb24pXG5cblxuXHRcdGZ1bmN0aW9uIHNldHVwRGVwdGhUZXh0dXJlKGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQpIHtcblx0XHRcdGNvbnN0IGlzQ3ViZSA9IHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQ7XG5cdFx0XHRpZiAoaXNDdWJlKSB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoIFRleHR1cmUgd2l0aCBjdWJlIHJlbmRlciB0YXJnZXRzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblxuXHRcdFx0aWYgKCEocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSAmJiByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUnKTtcblx0XHRcdH0gLy8gdXBsb2FkIGFuIGVtcHR5IGRlcHRoIHRleHR1cmUgd2l0aCBmcmFtZWJ1ZmZlciBzaXplXG5cblxuXHRcdFx0aWYgKCFwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSB8fCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoICE9PSByZW5kZXJUYXJnZXQud2lkdGggfHwgcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgIT09IHJlbmRlclRhcmdldC5oZWlnaHQpIHtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0c2V0VGV4dHVyZTJEKHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUsIDApO1xuXG5cdFx0XHRjb25zdCB3ZWJnbERlcHRoVGV4dHVyZSA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlO1xuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5mb3JtYXQgPT09IERlcHRoRm9ybWF0KSB7XG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDApO1xuXHRcdFx0fSBlbHNlIGlmIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0KSB7XG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGVwdGhUZXh0dXJlIGZvcm1hdCcpO1xuXHRcdFx0fVxuXHRcdH0gLy8gU2V0dXAgR0wgcmVzb3VyY2VzIGZvciBhIG5vbi10ZXh0dXJlIGRlcHRoIGJ1ZmZlclxuXG5cblx0XHRmdW5jdGlvbiBzZXR1cERlcHRoUmVuZGVyYnVmZmVyKHJlbmRlclRhcmdldCkge1xuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0XHRjb25zdCBpc0N1YmUgPSByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPT09IHRydWU7XG5cblx0XHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlKSB7XG5cdFx0XHRcdGlmIChpc0N1YmUpIHRocm93IG5ldyBFcnJvcigndGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMnKTtcblx0XHRcdFx0c2V0dXBEZXB0aFRleHR1cmUocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaXNDdWJlKSB7XG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcltpXSk7XG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcltpXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcltpXSwgcmVuZGVyVGFyZ2V0LCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyKTtcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIsIHJlbmRlclRhcmdldCwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdH0gLy8gU2V0IHVwIEdMIHJlc291cmNlcyBmb3IgdGhlIHJlbmRlciB0YXJnZXRcblxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSk7XG5cdFx0XHRyZW5kZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSk7XG5cblx0XHRcdGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyAhPT0gdHJ1ZSkge1xuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMrKztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaXNDdWJlID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID09PSB0cnVlO1xuXHRcdFx0Y29uc3QgaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gdHJ1ZTtcblx0XHRcdGNvbnN0IGlzTXVsdGlzYW1wbGUgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0ID09PSB0cnVlO1xuXHRcdFx0Y29uc3QgaXNSZW5kZXJUYXJnZXQzRCA9IHRleHR1cmUuaXNEYXRhVGV4dHVyZTNEIHx8IHRleHR1cmUuaXNEYXRhVGV4dHVyZTJEQXJyYXk7XG5cdFx0XHRjb25zdCBzdXBwb3J0c01pcHMgPSBpc1Bvd2VyT2ZUd28kMShyZW5kZXJUYXJnZXQpIHx8IGlzV2ViR0wyOyAvLyBIYW5kbGVzIFdlYkdMMiBSR0JGb3JtYXQgZmFsbGJhY2sgLSAjMTg4NThcblxuXHRcdFx0aWYgKGlzV2ViR0wyICYmIHRleHR1cmUuZm9ybWF0ID09PSBSR0JGb3JtYXQgJiYgKHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlIHx8IHRleHR1cmUudHlwZSA9PT0gSGFsZkZsb2F0VHlwZSkpIHtcblx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSBSR0JBRm9ybWF0O1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFJlbmRlcmluZyB0byB0ZXh0dXJlcyB3aXRoIFJHQiBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4gVXNpbmcgUkdCQSBmb3JtYXQgaW5zdGVhZC4nKTtcblx0XHRcdH0gLy8gU2V0dXAgZnJhbWVidWZmZXJcblxuXG5cdFx0XHRpZiAoaXNDdWJlKSB7XG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gW107XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcltpXSA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG5cdFx0XHRcdGlmIChpc011bHRpcGxlUmVuZGVyVGFyZ2V0cykge1xuXHRcdFx0XHRcdGlmIChjYXBhYmlsaXRpZXMuZHJhd0J1ZmZlcnMpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYXR0YWNobWVudFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlc1tpXSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0XHRcdFx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMrKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFdlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIgb3IgV0VCR0xfZHJhd19idWZmZXJzIGV4dGVuc2lvbi4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNNdWx0aXNhbXBsZSkge1xuXHRcdFx0XHRcdGlmIChpc1dlYkdMMikge1xuXHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG5cdFx0XHRcdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlcihfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcik7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLmZvcm1hdCk7XG5cdFx0XHRcdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSk7XG5cdFx0XHRcdFx0XHRjb25zdCBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQodGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSk7XG5cdFx0XHRcdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKF9nbC5SRU5ERVJCVUZGRVIsIHNhbXBsZXMsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cblx0XHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtcblxuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcik7XG5cblx0XHRcdFx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKF9nbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXG5cdFx0XHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyKSB7XG5cdFx0XHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdFx0XHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFdlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFdlYkdMMi4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gU2V0dXAgY29sb3IgYnVmZmVyXG5cblxuXHRcdFx0aWYgKGlzQ3ViZSkge1xuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyhfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgc3VwcG9ydHNNaXBzKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRcdHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyW2ldLCByZW5kZXJUYXJnZXQsIHRleHR1cmUsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyh0ZXh0dXJlLCBzdXBwb3J0c01pcHMpKSB7XG5cdFx0XHRcdFx0Z2VuZXJhdGVNaXBtYXAoX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG5cdFx0XHR9IGVsc2UgaWYgKGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzKSB7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGF0dGFjaG1lbnQgPSB0ZXh0dXJlc1tpXTtcblx0XHRcdFx0XHRjb25zdCBhdHRhY2htZW50UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KGF0dGFjaG1lbnQpO1xuXHRcdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKF9nbC5URVhUVVJFXzJELCBhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cdFx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoX2dsLlRFWFRVUkVfMkQsIGF0dGFjaG1lbnQsIHN1cHBvcnRzTWlwcyk7XG5cdFx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgYXR0YWNobWVudCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlRFWFRVUkVfMkQpO1xuXG5cdFx0XHRcdFx0aWYgKHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyhhdHRhY2htZW50LCBzdXBwb3J0c01pcHMpKSB7XG5cdFx0XHRcdFx0XHRnZW5lcmF0ZU1pcG1hcChfZ2wuVEVYVFVSRV8yRCwgYXR0YWNobWVudCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgZ2xUZXh0dXJlVHlwZSA9IF9nbC5URVhUVVJFXzJEO1xuXG5cdFx0XHRcdGlmIChpc1JlbmRlclRhcmdldDNEKSB7XG5cdFx0XHRcdFx0Ly8gUmVuZGVyIHRhcmdldHMgY29udGFpbmluZyBsYXllcnMsIGkuZTogVGV4dHVyZSAzRCBhbmQgMmQgYXJyYXlzXG5cdFx0XHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBpc1RleHR1cmUzRCA9IHRleHR1cmUuaXNEYXRhVGV4dHVyZTNEO1xuXHRcdFx0XHRcdFx0Z2xUZXh0dXJlVHlwZSA9IGlzVGV4dHVyZTNEID8gX2dsLlRFWFRVUkVfM0QgOiBfZ2wuVEVYVFVSRV8yRF9BUlJBWTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5EYXRhVGV4dHVyZTNEIGFuZCBUSFJFRS5EYXRhVGV4dHVyZTJEQXJyYXkgb25seSBzdXBwb3J0ZWQgd2l0aCBXZWJHTDIuJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyhnbFRleHR1cmVUeXBlLCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMpO1xuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsVGV4dHVyZVR5cGUpO1xuXG5cdFx0XHRcdGlmICh0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHModGV4dHVyZSwgc3VwcG9ydHNNaXBzKSkge1xuXHRcdFx0XHRcdGdlbmVyYXRlTWlwbWFwKGdsVGV4dHVyZVR5cGUsIHRleHR1cmUsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgcmVuZGVyVGFyZ2V0LmRlcHRoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKGdsVGV4dHVyZVR5cGUsIG51bGwpO1xuXHRcdFx0fSAvLyBTZXR1cCBkZXB0aCBhbmQgc3RlbmNpbCBidWZmZXJzXG5cblxuXHRcdFx0aWYgKHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlcikge1xuXHRcdFx0XHRzZXR1cERlcHRoUmVuZGVyYnVmZmVyKHJlbmRlclRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKHJlbmRlclRhcmdldCkge1xuXHRcdFx0Y29uc3Qgc3VwcG9ydHNNaXBzID0gaXNQb3dlck9mVHdvJDEocmVuZGVyVGFyZ2V0KSB8fCBpc1dlYkdMMjtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPT09IHRydWUgPyByZW5kZXJUYXJnZXQudGV4dHVyZSA6IFtyZW5kZXJUYXJnZXQudGV4dHVyZV07XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzW2ldO1xuXG5cdFx0XHRcdGlmICh0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHModGV4dHVyZSwgc3VwcG9ydHNNaXBzKSkge1xuXHRcdFx0XHRcdGNvbnN0IHRhcmdldCA9IHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA/IF9nbC5URVhUVVJFX0NVQkVfTUFQIDogX2dsLlRFWFRVUkVfMkQ7XG5cblx0XHRcdFx0XHRjb25zdCB3ZWJnbFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZTtcblxuXHRcdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKHRhcmdldCwgd2ViZ2xUZXh0dXJlKTtcblx0XHRcdFx0XHRnZW5lcmF0ZU1pcG1hcCh0YXJnZXQsIHRleHR1cmUsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUodGFyZ2V0LCBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuXHRcdFx0aWYgKHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0Y29uc3Qgd2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG5cdFx0XHRcdFx0Y29uc3QgaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcblx0XHRcdFx0XHRsZXQgbWFzayA9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuXHRcdFx0XHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIpIG1hc2sgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XG5cdFx0XHRcdFx0aWYgKHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyKSBtYXNrIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cdFx0XHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7XG5cblx0XHRcdFx0XHRfZ2wuYmxpdEZyYW1lYnVmZmVyKDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIG1hc2ssIF9nbC5ORUFSRVNUKTtcblxuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKHJlbmRlclRhcmdldCkge1xuXHRcdFx0cmV0dXJuIGlzV2ViR0wyICYmIHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQgPyBNYXRoLm1pbihtYXhTYW1wbGVzLCByZW5kZXJUYXJnZXQuc2FtcGxlcykgOiAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZVZpZGVvVGV4dHVyZSh0ZXh0dXJlKSB7XG5cdFx0XHRjb25zdCBmcmFtZSA9IGluZm8ucmVuZGVyLmZyYW1lOyAvLyBDaGVjayB0aGUgbGFzdCBmcmFtZSB3ZSB1cGRhdGVkIHRoZSBWaWRlb1RleHR1cmVcblxuXHRcdFx0aWYgKF92aWRlb1RleHR1cmVzLmdldCh0ZXh0dXJlKSAhPT0gZnJhbWUpIHtcblx0XHRcdFx0X3ZpZGVvVGV4dHVyZXMuc2V0KHRleHR1cmUsIGZyYW1lKTtcblxuXHRcdFx0XHR0ZXh0dXJlLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH0gLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuXG5cdFx0bGV0IHdhcm5lZFRleHR1cmUyRCA9IGZhbHNlO1xuXHRcdGxldCB3YXJuZWRUZXh0dXJlQ3ViZSA9IGZhbHNlO1xuXG5cdFx0ZnVuY3Rpb24gc2FmZVNldFRleHR1cmUyRCh0ZXh0dXJlLCBzbG90KSB7XG5cdFx0XHRpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzV2ViR0xSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0aWYgKHdhcm5lZFRleHR1cmUyRCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMVGV4dHVyZXMuc2FmZVNldFRleHR1cmUyRDogZG9uXFwndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRcdHdhcm5lZFRleHR1cmUyRCA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZS50ZXh0dXJlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRUZXh0dXJlMkQodGV4dHVyZSwgc2xvdCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2FmZVNldFRleHR1cmVDdWJlKHRleHR1cmUsIHNsb3QpIHtcblx0XHRcdGlmICh0ZXh0dXJlICYmIHRleHR1cmUuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0aWYgKHdhcm5lZFRleHR1cmVDdWJlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xUZXh0dXJlcy5zYWZlU2V0VGV4dHVyZUN1YmU6IGRvblxcJ3QgdXNlIGN1YmUgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRcdHdhcm5lZFRleHR1cmVDdWJlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlLnRleHR1cmU7XG5cdFx0XHR9XG5cblx0XHRcdHNldFRleHR1cmVDdWJlKHRleHR1cmUsIHNsb3QpO1xuXHRcdH0gLy9cblxuXG5cdFx0dGhpcy5hbGxvY2F0ZVRleHR1cmVVbml0ID0gYWxsb2NhdGVUZXh0dXJlVW5pdDtcblx0XHR0aGlzLnJlc2V0VGV4dHVyZVVuaXRzID0gcmVzZXRUZXh0dXJlVW5pdHM7XG5cdFx0dGhpcy5zZXRUZXh0dXJlMkQgPSBzZXRUZXh0dXJlMkQ7XG5cdFx0dGhpcy5zZXRUZXh0dXJlMkRBcnJheSA9IHNldFRleHR1cmUyREFycmF5O1xuXHRcdHRoaXMuc2V0VGV4dHVyZTNEID0gc2V0VGV4dHVyZTNEO1xuXHRcdHRoaXMuc2V0VGV4dHVyZUN1YmUgPSBzZXRUZXh0dXJlQ3ViZTtcblx0XHR0aGlzLnNldHVwUmVuZGVyVGFyZ2V0ID0gc2V0dXBSZW5kZXJUYXJnZXQ7XG5cdFx0dGhpcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAgPSB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXA7XG5cdFx0dGhpcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldCA9IHVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0O1xuXHRcdHRoaXMuc2FmZVNldFRleHR1cmUyRCA9IHNhZmVTZXRUZXh0dXJlMkQ7XG5cdFx0dGhpcy5zYWZlU2V0VGV4dHVyZUN1YmUgPSBzYWZlU2V0VGV4dHVyZUN1YmU7XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTFV0aWxzKGdsLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpIHtcblx0XHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcblxuXHRcdGZ1bmN0aW9uIGNvbnZlcnQocCkge1xuXHRcdFx0bGV0IGV4dGVuc2lvbjtcblx0XHRcdGlmIChwID09PSBVbnNpZ25lZEJ5dGVUeXBlKSByZXR1cm4gZ2wuVU5TSUdORURfQllURTtcblx0XHRcdGlmIChwID09PSBVbnNpZ25lZFNob3J0NDQ0NFR5cGUpIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xuXHRcdFx0aWYgKHAgPT09IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XG5cdFx0XHRpZiAocCA9PT0gVW5zaWduZWRTaG9ydDU2NVR5cGUpIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF81XzZfNTtcblx0XHRcdGlmIChwID09PSBCeXRlVHlwZSkgcmV0dXJuIGdsLkJZVEU7XG5cdFx0XHRpZiAocCA9PT0gU2hvcnRUeXBlKSByZXR1cm4gZ2wuU0hPUlQ7XG5cdFx0XHRpZiAocCA9PT0gVW5zaWduZWRTaG9ydFR5cGUpIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVDtcblx0XHRcdGlmIChwID09PSBJbnRUeXBlKSByZXR1cm4gZ2wuSU5UO1xuXHRcdFx0aWYgKHAgPT09IFVuc2lnbmVkSW50VHlwZSkgcmV0dXJuIGdsLlVOU0lHTkVEX0lOVDtcblx0XHRcdGlmIChwID09PSBGbG9hdFR5cGUpIHJldHVybiBnbC5GTE9BVDtcblxuXHRcdFx0aWYgKHAgPT09IEhhbGZGbG9hdFR5cGUpIHtcblx0XHRcdFx0aWYgKGlzV2ViR0wyKSByZXR1cm4gZ2wuSEFMRl9GTE9BVDtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnKTtcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5IQUxGX0ZMT0FUX09FUztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocCA9PT0gQWxwaGFGb3JtYXQpIHJldHVybiBnbC5BTFBIQTtcblx0XHRcdGlmIChwID09PSBSR0JGb3JtYXQpIHJldHVybiBnbC5SR0I7XG5cdFx0XHRpZiAocCA9PT0gUkdCQUZvcm1hdCkgcmV0dXJuIGdsLlJHQkE7XG5cdFx0XHRpZiAocCA9PT0gTHVtaW5hbmNlRm9ybWF0KSByZXR1cm4gZ2wuTFVNSU5BTkNFO1xuXHRcdFx0aWYgKHAgPT09IEx1bWluYW5jZUFscGhhRm9ybWF0KSByZXR1cm4gZ2wuTFVNSU5BTkNFX0FMUEhBO1xuXHRcdFx0aWYgKHAgPT09IERlcHRoRm9ybWF0KSByZXR1cm4gZ2wuREVQVEhfQ09NUE9ORU5UO1xuXHRcdFx0aWYgKHAgPT09IERlcHRoU3RlbmNpbEZvcm1hdCkgcmV0dXJuIGdsLkRFUFRIX1NURU5DSUw7XG5cdFx0XHRpZiAocCA9PT0gUmVkRm9ybWF0KSByZXR1cm4gZ2wuUkVEOyAvLyBXZWJHTDIgZm9ybWF0cy5cblxuXHRcdFx0aWYgKHAgPT09IFJlZEludGVnZXJGb3JtYXQpIHJldHVybiBnbC5SRURfSU5URUdFUjtcblx0XHRcdGlmIChwID09PSBSR0Zvcm1hdCkgcmV0dXJuIGdsLlJHO1xuXHRcdFx0aWYgKHAgPT09IFJHSW50ZWdlckZvcm1hdCkgcmV0dXJuIGdsLlJHX0lOVEVHRVI7XG5cdFx0XHRpZiAocCA9PT0gUkdCSW50ZWdlckZvcm1hdCkgcmV0dXJuIGdsLlJHQl9JTlRFR0VSO1xuXHRcdFx0aWYgKHAgPT09IFJHQkFJbnRlZ2VyRm9ybWF0KSByZXR1cm4gZ2wuUkdCQV9JTlRFR0VSO1xuXG5cdFx0XHRpZiAocCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQpIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyk7XG5cblx0XHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0XHRcdGlmIChwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0KSB7XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKTtcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwID09PSBSR0JfRVRDMV9Gb3JtYXQpIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyk7XG5cblx0XHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocCA9PT0gUkdCX0VUQzJfRm9ybWF0IHx8IHAgPT09IFJHQkFfRVRDMl9FQUNfRm9ybWF0KSB7XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjJyk7XG5cblx0XHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChwID09PSBSR0JfRVRDMl9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0I4X0VUQzI7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQkFfRVRDMl9FQUNfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHAgPT09IFJHQkFfQVNUQ180eDRfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ181eDRfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ181eDVfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ182eDVfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ182eDZfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ184eDVfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ184eDZfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ184eDhfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDhfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzR4NF9Gb3JtYXQgfHwgcCA9PT0gU1JHQjhfQUxQSEE4X0FTVENfNXg0X0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ181eDVfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzZ4NV9Gb3JtYXQgfHwgcCA9PT0gU1JHQjhfQUxQSEE4X0FTVENfNng2X0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ184eDVfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzh4Nl9Gb3JtYXQgfHwgcCA9PT0gU1JHQjhfQUxQSEE4X0FTVENfOHg4X0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ18xMHg1X0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ18xMHg2X0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ18xMHg4X0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ18xMHgxMF9Gb3JtYXQgfHwgcCA9PT0gU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTBfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzEyeDEyX0Zvcm1hdCkge1xuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGMnKTtcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gVE9ETyBDb21wbGV0ZT9cblx0XHRcdFx0XHRyZXR1cm4gcDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocCA9PT0gUkdCQV9CUFRDX0Zvcm1hdCkge1xuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnRVhUX3RleHR1cmVfY29tcHJlc3Npb25fYnB0YycpO1xuXG5cdFx0XHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0XHQvLyBUT0RPIENvbXBsZXRlP1xuXHRcdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwID09PSBVbnNpZ25lZEludDI0OFR5cGUpIHtcblx0XHRcdFx0aWYgKGlzV2ViR0wyKSByZXR1cm4gZ2wuVU5TSUdORURfSU5UXzI0Xzg7XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9kZXB0aF90ZXh0dXJlJyk7XG5cblx0XHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24uVU5TSUdORURfSU5UXzI0XzhfV0VCR0w7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Y29udmVydDogY29udmVydFxuXHRcdH07XG5cdH1cblxuXHRjbGFzcyBBcnJheUNhbWVyYSBleHRlbmRzIFBlcnNwZWN0aXZlQ2FtZXJhIHtcblx0XHRjb25zdHJ1Y3RvcihhcnJheSA9IFtdKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5jYW1lcmFzID0gYXJyYXk7XG5cdFx0fVxuXG5cdH1cblxuXHRBcnJheUNhbWVyYS5wcm90b3R5cGUuaXNBcnJheUNhbWVyYSA9IHRydWU7XG5cblx0Y2xhc3MgR3JvdXAgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0dyb3VwJztcblx0XHR9XG5cblx0fVxuXG5cdEdyb3VwLnByb3RvdHlwZS5pc0dyb3VwID0gdHJ1ZTtcblxuXHRjb25zdCBfbW92ZUV2ZW50ID0ge1xuXHRcdHR5cGU6ICdtb3ZlJ1xuXHR9O1xuXG5cdGNsYXNzIFdlYlhSQ29udHJvbGxlciB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHR0aGlzLl90YXJnZXRSYXkgPSBudWxsO1xuXHRcdFx0dGhpcy5fZ3JpcCA9IG51bGw7XG5cdFx0XHR0aGlzLl9oYW5kID0gbnVsbDtcblx0XHR9XG5cblx0XHRnZXRIYW5kU3BhY2UoKSB7XG5cdFx0XHRpZiAodGhpcy5faGFuZCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9oYW5kID0gbmV3IEdyb3VwKCk7XG5cdFx0XHRcdHRoaXMuX2hhbmQubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9oYW5kLnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5faGFuZC5qb2ludHMgPSB7fTtcblx0XHRcdFx0dGhpcy5faGFuZC5pbnB1dFN0YXRlID0ge1xuXHRcdFx0XHRcdHBpbmNoaW5nOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5faGFuZDtcblx0XHR9XG5cblx0XHRnZXRUYXJnZXRSYXlTcGFjZSgpIHtcblx0XHRcdGlmICh0aGlzLl90YXJnZXRSYXkgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0UmF5ID0gbmV3IEdyb3VwKCk7XG5cdFx0XHRcdHRoaXMuX3RhcmdldFJheS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX3RhcmdldFJheS52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX3RhcmdldFJheS5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl90YXJnZXRSYXkubGluZWFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHR0aGlzLl90YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX3RhcmdldFJheS5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5fdGFyZ2V0UmF5O1xuXHRcdH1cblxuXHRcdGdldEdyaXBTcGFjZSgpIHtcblx0XHRcdGlmICh0aGlzLl9ncmlwID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2dyaXAgPSBuZXcgR3JvdXAoKTtcblx0XHRcdFx0dGhpcy5fZ3JpcC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX2dyaXAudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9ncmlwLmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX2dyaXAubGluZWFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHR0aGlzLl9ncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9ncmlwLmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLl9ncmlwO1xuXHRcdH1cblxuXHRcdGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcblx0XHRcdGlmICh0aGlzLl90YXJnZXRSYXkgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0UmF5LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fZ3JpcCAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9ncmlwLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5faGFuZCAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9oYW5kLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRkaXNjb25uZWN0KGlucHV0U291cmNlKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHR0eXBlOiAnZGlzY29ubmVjdGVkJyxcblx0XHRcdFx0ZGF0YTogaW5wdXRTb3VyY2Vcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodGhpcy5fdGFyZ2V0UmF5ICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX3RhcmdldFJheS52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9ncmlwICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2dyaXAudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5faGFuZCAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9oYW5kLnZpc2libGUgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dXBkYXRlKGlucHV0U291cmNlLCBmcmFtZSwgcmVmZXJlbmNlU3BhY2UpIHtcblx0XHRcdGxldCBpbnB1dFBvc2UgPSBudWxsO1xuXHRcdFx0bGV0IGdyaXBQb3NlID0gbnVsbDtcblx0XHRcdGxldCBoYW5kUG9zZSA9IG51bGw7XG5cdFx0XHRjb25zdCB0YXJnZXRSYXkgPSB0aGlzLl90YXJnZXRSYXk7XG5cdFx0XHRjb25zdCBncmlwID0gdGhpcy5fZ3JpcDtcblx0XHRcdGNvbnN0IGhhbmQgPSB0aGlzLl9oYW5kO1xuXG5cdFx0XHRpZiAoaW5wdXRTb3VyY2UgJiYgZnJhbWUuc2Vzc2lvbi52aXNpYmlsaXR5U3RhdGUgIT09ICd2aXNpYmxlLWJsdXJyZWQnKSB7XG5cdFx0XHRcdGlmICh0YXJnZXRSYXkgIT09IG51bGwpIHtcblx0XHRcdFx0XHRpbnB1dFBvc2UgPSBmcmFtZS5nZXRQb3NlKGlucHV0U291cmNlLnRhcmdldFJheVNwYWNlLCByZWZlcmVuY2VTcGFjZSk7XG5cblx0XHRcdFx0XHRpZiAoaW5wdXRQb3NlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkubWF0cml4LmZyb21BcnJheShpbnB1dFBvc2UudHJhbnNmb3JtLm1hdHJpeCk7XG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkubWF0cml4LmRlY29tcG9zZSh0YXJnZXRSYXkucG9zaXRpb24sIHRhcmdldFJheS5yb3RhdGlvbiwgdGFyZ2V0UmF5LnNjYWxlKTtcblxuXHRcdFx0XHRcdFx0aWYgKGlucHV0UG9zZS5saW5lYXJWZWxvY2l0eSkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzTGluZWFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRSYXkubGluZWFyVmVsb2NpdHkuY29weShpbnB1dFBvc2UubGluZWFyVmVsb2NpdHkpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChpbnB1dFBvc2UuYW5ndWxhclZlbG9jaXR5KSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFJheS5oYXNBbmd1bGFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRSYXkuYW5ndWxhclZlbG9jaXR5LmNvcHkoaW5wdXRQb3NlLmFuZ3VsYXJWZWxvY2l0eSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChfbW92ZUV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaGFuZCAmJiBpbnB1dFNvdXJjZS5oYW5kKSB7XG5cdFx0XHRcdFx0aGFuZFBvc2UgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBpbnB1dGpvaW50IG9mIGlucHV0U291cmNlLmhhbmQudmFsdWVzKCkpIHtcblx0XHRcdFx0XHRcdC8vIFVwZGF0ZSB0aGUgam9pbnRzIGdyb3VwcyB3aXRoIHRoZSBYUkpvaW50IHBvc2VzXG5cdFx0XHRcdFx0XHRjb25zdCBqb2ludFBvc2UgPSBmcmFtZS5nZXRKb2ludFBvc2UoaW5wdXRqb2ludCwgcmVmZXJlbmNlU3BhY2UpO1xuXG5cdFx0XHRcdFx0XHRpZiAoaGFuZC5qb2ludHNbaW5wdXRqb2ludC5qb2ludE5hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gVGhlIHRyYW5zZm9ybSBvZiB0aGlzIGpvaW50IHdpbGwgYmUgdXBkYXRlZCB3aXRoIHRoZSBqb2ludCBwb3NlIG9uIGVhY2ggZnJhbWVcblx0XHRcdFx0XHRcdFx0Y29uc3Qgam9pbnQgPSBuZXcgR3JvdXAoKTtcblx0XHRcdFx0XHRcdFx0am9pbnQubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRqb2ludC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGhhbmQuam9pbnRzW2lucHV0am9pbnQuam9pbnROYW1lXSA9IGpvaW50OyAvLyA/P1xuXG5cdFx0XHRcdFx0XHRcdGhhbmQuYWRkKGpvaW50KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3Qgam9pbnQgPSBoYW5kLmpvaW50c1tpbnB1dGpvaW50LmpvaW50TmFtZV07XG5cblx0XHRcdFx0XHRcdGlmIChqb2ludFBvc2UgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0am9pbnQubWF0cml4LmZyb21BcnJheShqb2ludFBvc2UudHJhbnNmb3JtLm1hdHJpeCk7XG5cdFx0XHRcdFx0XHRcdGpvaW50Lm1hdHJpeC5kZWNvbXBvc2Uoam9pbnQucG9zaXRpb24sIGpvaW50LnJvdGF0aW9uLCBqb2ludC5zY2FsZSk7XG5cdFx0XHRcdFx0XHRcdGpvaW50LmpvaW50UmFkaXVzID0gam9pbnRQb3NlLnJhZGl1cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0am9pbnQudmlzaWJsZSA9IGpvaW50UG9zZSAhPT0gbnVsbDtcblx0XHRcdFx0XHR9IC8vIEN1c3RvbSBldmVudHNcblx0XHRcdFx0XHQvLyBDaGVjayBwaW5jaHpcblxuXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXhUaXAgPSBoYW5kLmpvaW50c1snaW5kZXgtZmluZ2VyLXRpcCddO1xuXHRcdFx0XHRcdGNvbnN0IHRodW1iVGlwID0gaGFuZC5qb2ludHNbJ3RodW1iLXRpcCddO1xuXHRcdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gaW5kZXhUaXAucG9zaXRpb24uZGlzdGFuY2VUbyh0aHVtYlRpcC5wb3NpdGlvbik7XG5cdFx0XHRcdFx0Y29uc3QgZGlzdGFuY2VUb1BpbmNoID0gMC4wMjtcblx0XHRcdFx0XHRjb25zdCB0aHJlc2hvbGQgPSAwLjAwNTtcblxuXHRcdFx0XHRcdGlmIChoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgJiYgZGlzdGFuY2UgPiBkaXN0YW5jZVRvUGluY2ggKyB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0XHRcdFx0dHlwZTogJ3BpbmNoZW5kJyxcblx0XHRcdFx0XHRcdFx0aGFuZGVkbmVzczogaW5wdXRTb3VyY2UuaGFuZGVkbmVzcyxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0OiB0aGlzXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgJiYgZGlzdGFuY2UgPD0gZGlzdGFuY2VUb1BpbmNoIC0gdGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHRoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0XHRcdFx0dHlwZTogJ3BpbmNoc3RhcnQnLFxuXHRcdFx0XHRcdFx0XHRoYW5kZWRuZXNzOiBpbnB1dFNvdXJjZS5oYW5kZWRuZXNzLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQ6IHRoaXNcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoZ3JpcCAhPT0gbnVsbCAmJiBpbnB1dFNvdXJjZS5ncmlwU3BhY2UpIHtcblx0XHRcdFx0XHRcdGdyaXBQb3NlID0gZnJhbWUuZ2V0UG9zZShpbnB1dFNvdXJjZS5ncmlwU3BhY2UsIHJlZmVyZW5jZVNwYWNlKTtcblxuXHRcdFx0XHRcdFx0aWYgKGdyaXBQb3NlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGdyaXAubWF0cml4LmZyb21BcnJheShncmlwUG9zZS50cmFuc2Zvcm0ubWF0cml4KTtcblx0XHRcdFx0XHRcdFx0Z3JpcC5tYXRyaXguZGVjb21wb3NlKGdyaXAucG9zaXRpb24sIGdyaXAucm90YXRpb24sIGdyaXAuc2NhbGUpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChncmlwUG9zZS5saW5lYXJWZWxvY2l0eSkge1xuXHRcdFx0XHRcdFx0XHRcdGdyaXAuaGFzTGluZWFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGdyaXAubGluZWFyVmVsb2NpdHkuY29weShncmlwUG9zZS5saW5lYXJWZWxvY2l0eSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Z3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGdyaXBQb3NlLmFuZ3VsYXJWZWxvY2l0eSkge1xuXHRcdFx0XHRcdFx0XHRcdGdyaXAuaGFzQW5ndWxhclZlbG9jaXR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRncmlwLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KGdyaXBQb3NlLmFuZ3VsYXJWZWxvY2l0eSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Z3JpcC5oYXNBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGFyZ2V0UmF5ICE9PSBudWxsKSB7XG5cdFx0XHRcdHRhcmdldFJheS52aXNpYmxlID0gaW5wdXRQb3NlICE9PSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ3JpcCAhPT0gbnVsbCkge1xuXHRcdFx0XHRncmlwLnZpc2libGUgPSBncmlwUG9zZSAhPT0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhhbmQgIT09IG51bGwpIHtcblx0XHRcdFx0aGFuZC52aXNpYmxlID0gaGFuZFBvc2UgIT09IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgV2ViWFJNYW5hZ2VyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRjb25zdHJ1Y3RvcihyZW5kZXJlciwgZ2wpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xuXHRcdFx0bGV0IHNlc3Npb24gPSBudWxsO1xuXHRcdFx0bGV0IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSAxLjA7XG5cdFx0XHRsZXQgcmVmZXJlbmNlU3BhY2UgPSBudWxsO1xuXHRcdFx0bGV0IHJlZmVyZW5jZVNwYWNlVHlwZSA9ICdsb2NhbC1mbG9vcic7XG5cdFx0XHRsZXQgcG9zZSA9IG51bGw7XG5cdFx0XHRsZXQgZ2xCaW5kaW5nID0gbnVsbDtcblx0XHRcdGxldCBnbEZyYW1lYnVmZmVyID0gbnVsbDtcblx0XHRcdGxldCBnbFByb2pMYXllciA9IG51bGw7XG5cdFx0XHRsZXQgZ2xCYXNlTGF5ZXIgPSBudWxsO1xuXHRcdFx0Y29uc3QgY29udHJvbGxlcnMgPSBbXTtcblx0XHRcdGNvbnN0IGlucHV0U291cmNlc01hcCA9IG5ldyBNYXAoKTsgLy9cblxuXHRcdFx0Y29uc3QgY2FtZXJhTCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHRcdFx0Y2FtZXJhTC5sYXllcnMuZW5hYmxlKDEpO1xuXHRcdFx0Y2FtZXJhTC52aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCk7XG5cdFx0XHRjb25zdCBjYW1lcmFSID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0XHRjYW1lcmFSLmxheWVycy5lbmFibGUoMik7XG5cdFx0XHRjYW1lcmFSLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcblx0XHRcdGNvbnN0IGNhbWVyYXMgPSBbY2FtZXJhTCwgY2FtZXJhUl07XG5cdFx0XHRjb25zdCBjYW1lcmFWUiA9IG5ldyBBcnJheUNhbWVyYSgpO1xuXHRcdFx0Y2FtZXJhVlIubGF5ZXJzLmVuYWJsZSgxKTtcblx0XHRcdGNhbWVyYVZSLmxheWVycy5lbmFibGUoMik7XG5cdFx0XHRsZXQgX2N1cnJlbnREZXB0aE5lYXIgPSBudWxsO1xuXHRcdFx0bGV0IF9jdXJyZW50RGVwdGhGYXIgPSBudWxsOyAvL1xuXG5cdFx0XHR0aGlzLmNhbWVyYUF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmlzUHJlc2VudGluZyA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRcdFx0bGV0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1tpbmRleF07XG5cblx0XHRcdFx0aWYgKGNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIgPSBuZXcgV2ViWFJDb250cm9sbGVyKCk7XG5cdFx0XHRcdFx0Y29udHJvbGxlcnNbaW5kZXhdID0gY29udHJvbGxlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjb250cm9sbGVyLmdldFRhcmdldFJheVNwYWNlKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmdldENvbnRyb2xsZXJHcmlwID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRcdGxldCBjb250cm9sbGVyID0gY29udHJvbGxlcnNbaW5kZXhdO1xuXG5cdFx0XHRcdGlmIChjb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb250cm9sbGVyID0gbmV3IFdlYlhSQ29udHJvbGxlcigpO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXJzW2luZGV4XSA9IGNvbnRyb2xsZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gY29udHJvbGxlci5nZXRHcmlwU3BhY2UoKTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZ2V0SGFuZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdFx0XHRsZXQgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzW2luZGV4XTtcblxuXHRcdFx0XHRpZiAoY29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcblx0XHRcdFx0XHRjb250cm9sbGVyc1tpbmRleF0gPSBjb250cm9sbGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGNvbnRyb2xsZXIuZ2V0SGFuZFNwYWNlKCk7XG5cdFx0XHR9OyAvL1xuXG5cblx0XHRcdGZ1bmN0aW9uIG9uU2Vzc2lvbkV2ZW50KGV2ZW50KSB7XG5cdFx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBpbnB1dFNvdXJjZXNNYXAuZ2V0KGV2ZW50LmlucHV0U291cmNlKTtcblxuXHRcdFx0XHRpZiAoY29udHJvbGxlcikge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHR0eXBlOiBldmVudC50eXBlLFxuXHRcdFx0XHRcdFx0ZGF0YTogZXZlbnQuaW5wdXRTb3VyY2Vcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBvblNlc3Npb25FbmQoKSB7XG5cdFx0XHRcdGlucHV0U291cmNlc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyLCBpbnB1dFNvdXJjZSkge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuZGlzY29ubmVjdChpbnB1dFNvdXJjZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpbnB1dFNvdXJjZXNNYXAuY2xlYXIoKTtcblx0XHRcdFx0X2N1cnJlbnREZXB0aE5lYXIgPSBudWxsO1xuXHRcdFx0XHRfY3VycmVudERlcHRoRmFyID0gbnVsbDsgLy8gcmVzdG9yZSBmcmFtZWJ1ZmZlci9yZW5kZXJpbmcgc3RhdGVcblxuXHRcdFx0XHRzdGF0ZS5iaW5kWFJGcmFtZWJ1ZmZlcihudWxsKTtcblx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpKTsgLy9cblxuXHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuXHRcdFx0XHRzY29wZS5pc1ByZXNlbnRpbmcgPSBmYWxzZTtcblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0dHlwZTogJ3Nlc3Npb25lbmQnXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldEZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0ZnJhbWVidWZmZXJTY2FsZUZhY3RvciA9IHZhbHVlO1xuXG5cdFx0XHRcdGlmIChzY29wZS5pc1ByZXNlbnRpbmcgPT09IHRydWUpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSBmcmFtZWJ1ZmZlciBzY2FsZSB3aGlsZSBwcmVzZW50aW5nLicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnNldFJlZmVyZW5jZVNwYWNlVHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRyZWZlcmVuY2VTcGFjZVR5cGUgPSB2YWx1ZTtcblxuXHRcdFx0XHRpZiAoc2NvcGUuaXNQcmVzZW50aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJYUk1hbmFnZXI6IENhbm5vdCBjaGFuZ2UgcmVmZXJlbmNlIHNwYWNlIHR5cGUgd2hpbGUgcHJlc2VudGluZy4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5nZXRSZWZlcmVuY2VTcGFjZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHJlZmVyZW5jZVNwYWNlO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5nZXRTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gc2Vzc2lvbjtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2V0U2Vzc2lvbiA9IGFzeW5jIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRzZXNzaW9uID0gdmFsdWU7XG5cblx0XHRcdFx0aWYgKHNlc3Npb24gIT09IG51bGwpIHtcblx0XHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdCcsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0Jywgb25TZXNzaW9uRXZlbnQpO1xuXHRcdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0ZW5kJywgb25TZXNzaW9uRXZlbnQpO1xuXHRcdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignc3F1ZWV6ZScsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NxdWVlemVzdGFydCcsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NxdWVlemVlbmQnLCBvblNlc3Npb25FdmVudCk7XG5cdFx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCBvblNlc3Npb25FbmQpO1xuXHRcdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXRzb3VyY2VzY2hhbmdlJywgb25JbnB1dFNvdXJjZXNDaGFuZ2UpO1xuXHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXG5cdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZXMueHJDb21wYXRpYmxlICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCBnbC5tYWtlWFJDb21wYXRpYmxlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHNlc3Npb24ucmVuZGVyU3RhdGUubGF5ZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxheWVySW5pdCA9IHtcblx0XHRcdFx0XHRcdFx0YW50aWFsaWFzOiBhdHRyaWJ1dGVzLmFudGlhbGlhcyxcblx0XHRcdFx0XHRcdFx0YWxwaGE6IGF0dHJpYnV0ZXMuYWxwaGEsXG5cdFx0XHRcdFx0XHRcdGRlcHRoOiBhdHRyaWJ1dGVzLmRlcHRoLFxuXHRcdFx0XHRcdFx0XHRzdGVuY2lsOiBhdHRyaWJ1dGVzLnN0ZW5jaWwsXG5cdFx0XHRcdFx0XHRcdGZyYW1lYnVmZmVyU2NhbGVGYWN0b3I6IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3Jcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRnbEJhc2VMYXllciA9IG5ldyBYUldlYkdMTGF5ZXIoc2Vzc2lvbiwgZ2wsIGxheWVySW5pdCk7XG5cdFx0XHRcdFx0XHRzZXNzaW9uLnVwZGF0ZVJlbmRlclN0YXRlKHtcblx0XHRcdFx0XHRcdFx0YmFzZUxheWVyOiBnbEJhc2VMYXllclxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxldCBkZXB0aEZvcm1hdCA9IDA7IC8vIGZvciBhbnRpLWFsaWFzZWQgb3V0cHV0LCB1c2UgY2xhc3NpYyB3ZWJnbGxheWVyIGZvciBub3dcblxuXHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZXMuYW50aWFsaWFzKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGxheWVySW5pdCA9IHtcblx0XHRcdFx0XHRcdFx0XHRhbnRpYWxpYXM6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0YWxwaGE6IGF0dHJpYnV0ZXMuYWxwaGEsXG5cdFx0XHRcdFx0XHRcdFx0ZGVwdGg6IGF0dHJpYnV0ZXMuZGVwdGgsXG5cdFx0XHRcdFx0XHRcdFx0c3RlbmNpbDogYXR0cmlidXRlcy5zdGVuY2lsLFxuXHRcdFx0XHRcdFx0XHRcdGZyYW1lYnVmZmVyU2NhbGVGYWN0b3I6IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3Jcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0Z2xCYXNlTGF5ZXIgPSBuZXcgWFJXZWJHTExheWVyKHNlc3Npb24sIGdsLCBsYXllckluaXQpO1xuXHRcdFx0XHRcdFx0XHRzZXNzaW9uLnVwZGF0ZVJlbmRlclN0YXRlKHtcblx0XHRcdFx0XHRcdFx0XHRsYXllcnM6IFtnbEJhc2VMYXllcl1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0cmlidXRlcy5kZXB0aCkge1xuXHRcdFx0XHRcdFx0XHRcdGRlcHRoRm9ybWF0ID0gYXR0cmlidXRlcy5zdGVuY2lsID8gZ2wuREVQVEhfU1RFTkNJTCA6IGdsLkRFUFRIX0NPTVBPTkVOVDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHByb2plY3Rpb25sYXllckluaXQgPSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29sb3JGb3JtYXQ6IGF0dHJpYnV0ZXMuYWxwaGEgPyBnbC5SR0JBIDogZ2wuUkdCLFxuXHRcdFx0XHRcdFx0XHRcdGRlcHRoRm9ybWF0OiBkZXB0aEZvcm1hdCxcblx0XHRcdFx0XHRcdFx0XHRzY2FsZUZhY3RvcjogZnJhbWVidWZmZXJTY2FsZUZhY3RvclxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRnbEJpbmRpbmcgPSBuZXcgWFJXZWJHTEJpbmRpbmcoc2Vzc2lvbiwgZ2wpO1xuXHRcdFx0XHRcdFx0XHRnbFByb2pMYXllciA9IGdsQmluZGluZy5jcmVhdGVQcm9qZWN0aW9uTGF5ZXIocHJvamVjdGlvbmxheWVySW5pdCk7XG5cdFx0XHRcdFx0XHRcdGdsRnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0XHRcdFx0XHRzZXNzaW9uLnVwZGF0ZVJlbmRlclN0YXRlKHtcblx0XHRcdFx0XHRcdFx0XHRsYXllcnM6IFtnbFByb2pMYXllcl1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVmZXJlbmNlU3BhY2UgPSBhd2FpdCBzZXNzaW9uLnJlcXVlc3RSZWZlcmVuY2VTcGFjZShyZWZlcmVuY2VTcGFjZVR5cGUpO1xuXHRcdFx0XHRcdGFuaW1hdGlvbi5zZXRDb250ZXh0KHNlc3Npb24pO1xuXHRcdFx0XHRcdGFuaW1hdGlvbi5zdGFydCgpO1xuXHRcdFx0XHRcdHNjb3BlLmlzUHJlc2VudGluZyA9IHRydWU7XG5cdFx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHR0eXBlOiAnc2Vzc2lvbnN0YXJ0J1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRmdW5jdGlvbiBvbklucHV0U291cmNlc0NoYW5nZShldmVudCkge1xuXHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZXMgPSBzZXNzaW9uLmlucHV0U291cmNlczsgLy8gQXNzaWduIGlucHV0U291cmNlcyB0byBhdmFpbGFibGUgY29udHJvbGxlcnNcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aW5wdXRTb3VyY2VzTWFwLnNldChpbnB1dFNvdXJjZXNbaV0sIGNvbnRyb2xsZXJzW2ldKTtcblx0XHRcdFx0fSAvLyBOb3RpZnkgZGlzY29ubmVjdGVkXG5cblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LnJlbW92ZWQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZSA9IGV2ZW50LnJlbW92ZWRbaV07XG5cdFx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGlucHV0U291cmNlc01hcC5nZXQoaW5wdXRTb3VyY2UpO1xuXG5cdFx0XHRcdFx0aWYgKGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdkaXNjb25uZWN0ZWQnLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiBpbnB1dFNvdXJjZVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRpbnB1dFNvdXJjZXNNYXAuZGVsZXRlKGlucHV0U291cmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gTm90aWZ5IGNvbm5lY3RlZFxuXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBldmVudC5hZGRlZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gZXZlbnQuYWRkZWRbaV07XG5cdFx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGlucHV0U291cmNlc01hcC5nZXQoaW5wdXRTb3VyY2UpO1xuXG5cdFx0XHRcdFx0aWYgKGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdjb25uZWN0ZWQnLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiBpbnB1dFNvdXJjZVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0Y29uc3QgY2FtZXJhTFBvcyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjYW1lcmFSUG9zID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogQXNzdW1lcyAyIGNhbWVyYXMgdGhhdCBhcmUgcGFyYWxsZWwgYW5kIHNoYXJlIGFuIFgtYXhpcywgYW5kIHRoYXRcblx0XHRcdCAqIHRoZSBjYW1lcmFzJyBwcm9qZWN0aW9uIGFuZCB3b3JsZCBtYXRyaWNlcyBoYXZlIGFscmVhZHkgYmVlbiBzZXQuXG5cdFx0XHQgKiBBbmQgdGhhdCBuZWFyIGFuZCBmYXIgcGxhbmVzIGFyZSBpZGVudGljYWwgZm9yIGJvdGggY2FtZXJhcy5cblx0XHRcdCAqIFZpc3VhbGl6YXRpb24gb2YgdGhpcyB0ZWNobmlxdWU6IGh0dHBzOi8vY29tcHV0ZXJncmFwaGljcy5zdGFja2V4Y2hhbmdlLmNvbS9hLzQ3NjVcblx0XHRcdCAqL1xuXG5cdFx0XHRmdW5jdGlvbiBzZXRQcm9qZWN0aW9uRnJvbVVuaW9uKGNhbWVyYSwgY2FtZXJhTCwgY2FtZXJhUikge1xuXHRcdFx0XHRjYW1lcmFMUG9zLnNldEZyb21NYXRyaXhQb3NpdGlvbihjYW1lcmFMLm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0Y2FtZXJhUlBvcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhUi5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdGNvbnN0IGlwZCA9IGNhbWVyYUxQb3MuZGlzdGFuY2VUbyhjYW1lcmFSUG9zKTtcblx0XHRcdFx0Y29uc3QgcHJvakwgPSBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG5cdFx0XHRcdGNvbnN0IHByb2pSID0gY2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzOyAvLyBWUiBzeXN0ZW1zIHdpbGwgaGF2ZSBpZGVudGljYWwgZmFyIGFuZCBuZWFyIHBsYW5lcywgYW5kXG5cdFx0XHRcdC8vIG1vc3QgbGlrZWx5IGlkZW50aWNhbCB0b3AgYW5kIGJvdHRvbSBmcnVzdHVtIGV4dGVudHMuXG5cdFx0XHRcdC8vIFVzZSB0aGUgbGVmdCBjYW1lcmEgZm9yIHRoZXNlIHZhbHVlcy5cblxuXHRcdFx0XHRjb25zdCBuZWFyID0gcHJvakxbMTRdIC8gKHByb2pMWzEwXSAtIDEpO1xuXHRcdFx0XHRjb25zdCBmYXIgPSBwcm9qTFsxNF0gLyAocHJvakxbMTBdICsgMSk7XG5cdFx0XHRcdGNvbnN0IHRvcEZvdiA9IChwcm9qTFs5XSArIDEpIC8gcHJvakxbNV07XG5cdFx0XHRcdGNvbnN0IGJvdHRvbUZvdiA9IChwcm9qTFs5XSAtIDEpIC8gcHJvakxbNV07XG5cdFx0XHRcdGNvbnN0IGxlZnRGb3YgPSAocHJvakxbOF0gLSAxKSAvIHByb2pMWzBdO1xuXHRcdFx0XHRjb25zdCByaWdodEZvdiA9IChwcm9qUls4XSArIDEpIC8gcHJvalJbMF07XG5cdFx0XHRcdGNvbnN0IGxlZnQgPSBuZWFyICogbGVmdEZvdjtcblx0XHRcdFx0Y29uc3QgcmlnaHQgPSBuZWFyICogcmlnaHRGb3Y7IC8vIENhbGN1bGF0ZSB0aGUgbmV3IGNhbWVyYSdzIHBvc2l0aW9uIG9mZnNldCBmcm9tIHRoZVxuXHRcdFx0XHQvLyBsZWZ0IGNhbWVyYS4geE9mZnNldCBzaG91bGQgYmUgcm91Z2hseSBoYWxmIGBpcGRgLlxuXG5cdFx0XHRcdGNvbnN0IHpPZmZzZXQgPSBpcGQgLyAoLWxlZnRGb3YgKyByaWdodEZvdik7XG5cdFx0XHRcdGNvbnN0IHhPZmZzZXQgPSB6T2Zmc2V0ICogLWxlZnRGb3Y7IC8vIFRPRE86IEJldHRlciB3YXkgdG8gYXBwbHkgdGhpcyBvZmZzZXQ/XG5cblx0XHRcdFx0Y2FtZXJhTC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoY2FtZXJhLnBvc2l0aW9uLCBjYW1lcmEucXVhdGVybmlvbiwgY2FtZXJhLnNjYWxlKTtcblx0XHRcdFx0Y2FtZXJhLnRyYW5zbGF0ZVgoeE9mZnNldCk7XG5cdFx0XHRcdGNhbWVyYS50cmFuc2xhdGVaKHpPZmZzZXQpO1xuXHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGQuY29tcG9zZShjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUpO1xuXHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoY2FtZXJhLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTsgLy8gRmluZCB0aGUgdW5pb24gb2YgdGhlIGZydXN0dW0gdmFsdWVzIG9mIHRoZSBjYW1lcmFzIGFuZCBzY2FsZVxuXHRcdFx0XHQvLyB0aGUgdmFsdWVzIHNvIHRoYXQgdGhlIG5lYXIgcGxhbmUncyBwb3NpdGlvbiBkb2VzIG5vdCBjaGFuZ2UgaW4gd29ybGQgc3BhY2UsXG5cdFx0XHRcdC8vIGFsdGhvdWdoIG11c3Qgbm93IGJlIHJlbGF0aXZlIHRvIHRoZSBuZXcgdW5pb24gY2FtZXJhLlxuXG5cdFx0XHRcdGNvbnN0IG5lYXIyID0gbmVhciArIHpPZmZzZXQ7XG5cdFx0XHRcdGNvbnN0IGZhcjIgPSBmYXIgKyB6T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBsZWZ0MiA9IGxlZnQgLSB4T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCByaWdodDIgPSByaWdodCArIChpcGQgLSB4T2Zmc2V0KTtcblx0XHRcdFx0Y29uc3QgdG9wMiA9IHRvcEZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcblx0XHRcdFx0Y29uc3QgYm90dG9tMiA9IGJvdHRvbUZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcblx0XHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKGxlZnQyLCByaWdodDIsIHRvcDIsIGJvdHRvbTIsIG5lYXIyLCBmYXIyKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgcGFyZW50KSB7XG5cdFx0XHRcdGlmIChwYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGQuY29weShjYW1lcmEubWF0cml4KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyhwYXJlbnQubWF0cml4V29ybGQsIGNhbWVyYS5tYXRyaXgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KGNhbWVyYS5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudXBkYXRlQ2FtZXJhID0gZnVuY3Rpb24gKGNhbWVyYSkge1xuXHRcdFx0XHRpZiAoc2Vzc2lvbiA9PT0gbnVsbCkgcmV0dXJuO1xuXHRcdFx0XHRjYW1lcmFWUi5uZWFyID0gY2FtZXJhUi5uZWFyID0gY2FtZXJhTC5uZWFyID0gY2FtZXJhLm5lYXI7XG5cdFx0XHRcdGNhbWVyYVZSLmZhciA9IGNhbWVyYVIuZmFyID0gY2FtZXJhTC5mYXIgPSBjYW1lcmEuZmFyO1xuXG5cdFx0XHRcdGlmIChfY3VycmVudERlcHRoTmVhciAhPT0gY2FtZXJhVlIubmVhciB8fCBfY3VycmVudERlcHRoRmFyICE9PSBjYW1lcmFWUi5mYXIpIHtcblx0XHRcdFx0XHQvLyBOb3RlIHRoYXQgdGhlIG5ldyByZW5kZXJTdGF0ZSB3b24ndCBhcHBseSB1bnRpbCB0aGUgbmV4dCBmcmFtZS4gU2VlICMxODMyMFxuXHRcdFx0XHRcdHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoe1xuXHRcdFx0XHRcdFx0ZGVwdGhOZWFyOiBjYW1lcmFWUi5uZWFyLFxuXHRcdFx0XHRcdFx0ZGVwdGhGYXI6IGNhbWVyYVZSLmZhclxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdF9jdXJyZW50RGVwdGhOZWFyID0gY2FtZXJhVlIubmVhcjtcblx0XHRcdFx0XHRfY3VycmVudERlcHRoRmFyID0gY2FtZXJhVlIuZmFyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcGFyZW50ID0gY2FtZXJhLnBhcmVudDtcblx0XHRcdFx0Y29uc3QgY2FtZXJhcyA9IGNhbWVyYVZSLmNhbWVyYXM7XG5cdFx0XHRcdHVwZGF0ZUNhbWVyYShjYW1lcmFWUiwgcGFyZW50KTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNhbWVyYXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR1cGRhdGVDYW1lcmEoY2FtZXJhc1tpXSwgcGFyZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbWVyYVZSLm1hdHJpeFdvcmxkLmRlY29tcG9zZShjYW1lcmFWUi5wb3NpdGlvbiwgY2FtZXJhVlIucXVhdGVybmlvbiwgY2FtZXJhVlIuc2NhbGUpOyAvLyB1cGRhdGUgdXNlciBjYW1lcmEgYW5kIGl0cyBjaGlsZHJlblxuXG5cdFx0XHRcdGNhbWVyYS5wb3NpdGlvbi5jb3B5KGNhbWVyYVZSLnBvc2l0aW9uKTtcblx0XHRcdFx0Y2FtZXJhLnF1YXRlcm5pb24uY29weShjYW1lcmFWUi5xdWF0ZXJuaW9uKTtcblx0XHRcdFx0Y2FtZXJhLnNjYWxlLmNvcHkoY2FtZXJhVlIuc2NhbGUpO1xuXHRcdFx0XHRjYW1lcmEubWF0cml4LmNvcHkoY2FtZXJhVlIubWF0cml4KTtcblx0XHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkLmNvcHkoY2FtZXJhVlIubWF0cml4V29ybGQpO1xuXHRcdFx0XHRjb25zdCBjaGlsZHJlbiA9IGNhbWVyYS5jaGlsZHJlbjtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNoaWxkcmVuW2ldLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuXHRcdFx0XHR9IC8vIHVwZGF0ZSBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgcHJvcGVyIHZpZXcgZnJ1c3R1bSBjdWxsaW5nXG5cblxuXHRcdFx0XHRpZiAoY2FtZXJhcy5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0XHRzZXRQcm9qZWN0aW9uRnJvbVVuaW9uKGNhbWVyYVZSLCBjYW1lcmFMLCBjYW1lcmFSKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBhc3N1bWUgc2luZ2xlIGNhbWVyYSBzZXR1cCAoQVIpXG5cdFx0XHRcdFx0Y2FtZXJhVlIucHJvamVjdGlvbk1hdHJpeC5jb3B5KGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZ2V0Q2FtZXJhID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gY2FtZXJhVlI7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmdldEZvdmVhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKGdsUHJvakxheWVyICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdsUHJvakxheWVyLmZpeGVkRm92ZWF0aW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGdsQmFzZUxheWVyICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdsQmFzZUxheWVyLmZpeGVkRm92ZWF0aW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2V0Rm92ZWF0aW9uID0gZnVuY3Rpb24gKGZvdmVhdGlvbikge1xuXHRcdFx0XHQvLyAwID0gbm8gZm92ZWF0aW9uID0gZnVsbCByZXNvbHV0aW9uXG5cdFx0XHRcdC8vIDEgPSBtYXhpbXVtIGZvdmVhdGlvbiA9IHRoZSBlZGdlcyByZW5kZXIgYXQgbG93ZXIgcmVzb2x1dGlvblxuXHRcdFx0XHRpZiAoZ2xQcm9qTGF5ZXIgIT09IG51bGwpIHtcblx0XHRcdFx0XHRnbFByb2pMYXllci5maXhlZEZvdmVhdGlvbiA9IGZvdmVhdGlvbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChnbEJhc2VMYXllciAhPT0gbnVsbCAmJiBnbEJhc2VMYXllci5maXhlZEZvdmVhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Z2xCYXNlTGF5ZXIuZml4ZWRGb3ZlYXRpb24gPSBmb3ZlYXRpb247XG5cdFx0XHRcdH1cblx0XHRcdH07IC8vIEFuaW1hdGlvbiBMb29wXG5cblxuXHRcdFx0bGV0IG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IG51bGw7XG5cblx0XHRcdGZ1bmN0aW9uIG9uQW5pbWF0aW9uRnJhbWUodGltZSwgZnJhbWUpIHtcblx0XHRcdFx0cG9zZSA9IGZyYW1lLmdldFZpZXdlclBvc2UocmVmZXJlbmNlU3BhY2UpO1xuXG5cdFx0XHRcdGlmIChwb3NlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc3Qgdmlld3MgPSBwb3NlLnZpZXdzO1xuXG5cdFx0XHRcdFx0aWYgKGdsQmFzZUxheWVyICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS5iaW5kWFJGcmFtZWJ1ZmZlcihnbEJhc2VMYXllci5mcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGNhbWVyYVZSTmVlZHNVcGRhdGUgPSBmYWxzZTsgLy8gY2hlY2sgaWYgaXQncyBuZWNlc3NhcnkgdG8gcmVidWlsZCBjYW1lcmFWUidzIGNhbWVyYSBsaXN0XG5cblx0XHRcdFx0XHRpZiAodmlld3MubGVuZ3RoICE9PSBjYW1lcmFWUi5jYW1lcmFzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y2FtZXJhVlIuY2FtZXJhcy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0Y2FtZXJhVlJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmlldyA9IHZpZXdzW2ldO1xuXHRcdFx0XHRcdFx0bGV0IHZpZXdwb3J0ID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0aWYgKGdsQmFzZUxheWVyICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZpZXdwb3J0ID0gZ2xCYXNlTGF5ZXIuZ2V0Vmlld3BvcnQodmlldyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBnbFN1YkltYWdlID0gZ2xCaW5kaW5nLmdldFZpZXdTdWJJbWFnZShnbFByb2pMYXllciwgdmlldyk7XG5cdFx0XHRcdFx0XHRcdHN0YXRlLmJpbmRYUkZyYW1lYnVmZmVyKGdsRnJhbWVidWZmZXIpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChnbFN1YkltYWdlLmRlcHRoU3RlbmNpbFRleHR1cmUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5URVhUVVJFXzJELCBnbFN1YkltYWdlLmRlcHRoU3RlbmNpbFRleHR1cmUsIDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBnbFN1YkltYWdlLmNvbG9yVGV4dHVyZSwgMCk7XG5cdFx0XHRcdFx0XHRcdHZpZXdwb3J0ID0gZ2xTdWJJbWFnZS52aWV3cG9ydDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgY2FtZXJhID0gY2FtZXJhc1tpXTtcblx0XHRcdFx0XHRcdGNhbWVyYS5tYXRyaXguZnJvbUFycmF5KHZpZXcudHJhbnNmb3JtLm1hdHJpeCk7XG5cdFx0XHRcdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5mcm9tQXJyYXkodmlldy5wcm9qZWN0aW9uTWF0cml4KTtcblx0XHRcdFx0XHRcdGNhbWVyYS52aWV3cG9ydC5zZXQodmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCk7XG5cblx0XHRcdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGNhbWVyYVZSLm1hdHJpeC5jb3B5KGNhbWVyYS5tYXRyaXgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoY2FtZXJhVlJOZWVkc1VwZGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRjYW1lcmFWUi5jYW1lcmFzLnB1c2goY2FtZXJhKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy9cblxuXG5cdFx0XHRcdGNvbnN0IGlucHV0U291cmNlcyA9IHNlc3Npb24uaW5wdXRTb3VyY2VzO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbGxlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBjb250cm9sbGVyID0gY29udHJvbGxlcnNbaV07XG5cdFx0XHRcdFx0Y29uc3QgaW5wdXRTb3VyY2UgPSBpbnB1dFNvdXJjZXNbaV07XG5cdFx0XHRcdFx0Y29udHJvbGxlci51cGRhdGUoaW5wdXRTb3VyY2UsIGZyYW1lLCByZWZlcmVuY2VTcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob25BbmltYXRpb25GcmFtZUNhbGxiYWNrKSBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sodGltZSwgZnJhbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhbmltYXRpb24gPSBuZXcgV2ViR0xBbmltYXRpb24oKTtcblx0XHRcdGFuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKG9uQW5pbWF0aW9uRnJhbWUpO1xuXG5cdFx0XHR0aGlzLnNldEFuaW1hdGlvbkxvb3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdFx0b25BbmltYXRpb25GcmFtZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMTWF0ZXJpYWxzKHByb3BlcnRpZXMpIHtcblx0XHRmdW5jdGlvbiByZWZyZXNoRm9nVW5pZm9ybXModW5pZm9ybXMsIGZvZykge1xuXHRcdFx0dW5pZm9ybXMuZm9nQ29sb3IudmFsdWUuY29weShmb2cuY29sb3IpO1xuXG5cdFx0XHRpZiAoZm9nLmlzRm9nKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcblx0XHRcdFx0dW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcblx0XHRcdH0gZWxzZSBpZiAoZm9nLmlzRm9nRXhwMikge1xuXHRcdFx0XHR1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaE1hdGVyaWFsVW5pZm9ybXModW5pZm9ybXMsIG1hdGVyaWFsLCBwaXhlbFJhdGlvLCBoZWlnaHQsIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCkge1xuXHRcdFx0aWYgKG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwpIHtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGFtYmVydCh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwpIHtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Rvb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcodW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblxuXHRcdFx0XHRpZiAobWF0ZXJpYWwuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCkge1xuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKHVuaWZvcm1zLCBtYXRlcmlhbCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTWVzaE1hdGNhcE1hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNNYXRjYXAodW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoRGVwdGhNYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGVwdGgodW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGlzdGFuY2UodW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoTm9ybWFsTWF0ZXJpYWwpIHtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc05vcm1hbCh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc0xpbmVCYXNpY01hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpbmUodW5pZm9ybXMsIG1hdGVyaWFsKTtcblxuXHRcdFx0XHRpZiAobWF0ZXJpYWwuaXNMaW5lRGFzaGVkTWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNEYXNoKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNQb2ludHNNYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQb2ludHModW5pZm9ybXMsIG1hdGVyaWFsLCBwaXhlbFJhdGlvLCBoZWlnaHQpO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc1Nwcml0ZU1hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Nwcml0ZXModW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNTaGFkb3dNYXRlcmlhbCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci52YWx1ZS5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcblx0XHRcdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwpIHtcblx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7IC8vICMxNTU4MVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwuY29sb3IpIHtcblx0XHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZS5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmVtaXNzaXZlKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHkobWF0ZXJpYWwuZW1pc3NpdmUpLm11bHRpcGx5U2NhbGFyKG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLm1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5hbHBoYU1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuc3BlY3VsYXJNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZW52TWFwID0gcHJvcGVydGllcy5nZXQobWF0ZXJpYWwpLmVudk1hcDtcblxuXHRcdFx0aWYgKGVudk1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBlbnZNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSBlbnZNYXAuaXNDdWJlVGV4dHVyZSAmJiBlbnZNYXAuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSA/IC0xIDogMTtcblx0XHRcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuXHRcdFx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHRcdFx0Y29uc3QgbWF4TWlwTGV2ZWwgPSBwcm9wZXJ0aWVzLmdldChlbnZNYXApLl9fbWF4TWlwTGV2ZWw7XG5cblx0XHRcdFx0aWYgKG1heE1pcExldmVsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR1bmlmb3Jtcy5tYXhNaXBMZXZlbC52YWx1ZSA9IG1heE1pcExldmVsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5saWdodE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuYW9NYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuYW9NYXAudmFsdWUgPSBtYXRlcmlhbC5hb01hcDtcblx0XHRcdFx0dW5pZm9ybXMuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5hb01hcEludGVuc2l0eTtcblx0XHRcdH0gLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG5cdFx0XHQvLyAxLiBjb2xvciBtYXBcblx0XHRcdC8vIDIuIHNwZWN1bGFyIG1hcFxuXHRcdFx0Ly8gMy4gZGlzcGxhY2VtZW50TWFwIG1hcFxuXHRcdFx0Ly8gNC4gbm9ybWFsIG1hcFxuXHRcdFx0Ly8gNS4gYnVtcCBtYXBcblx0XHRcdC8vIDYuIHJvdWdobmVzc01hcCBtYXBcblx0XHRcdC8vIDcuIG1ldGFsbmVzc01hcCBtYXBcblx0XHRcdC8vIDguIGFscGhhTWFwIG1hcFxuXHRcdFx0Ly8gOS4gZW1pc3NpdmVNYXAgbWFwXG5cdFx0XHQvLyAxMC4gY2xlYXJjb2F0IG1hcFxuXHRcdFx0Ly8gMTEuIGNsZWFyY29hdCBub3JtYWwgbWFwXG5cdFx0XHQvLyAxMi4gY2xlYXJjb2F0IHJvdWdobmVzc01hcCBtYXBcblx0XHRcdC8vIDEzLiBzcGVjdWxhciBpbnRlbnNpdHkgbWFwXG5cdFx0XHQvLyAxNC4gc3BlY3VsYXIgdGludCBtYXBcblxuXG5cdFx0XHRsZXQgdXZTY2FsZU1hcDtcblxuXHRcdFx0aWYgKG1hdGVyaWFsLm1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5zcGVjdWxhck1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5ub3JtYWxNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuYnVtcE1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwucm91Z2huZXNzTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLm1ldGFsbmVzc01hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5hbHBoYU1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmVtaXNzaXZlTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuY2xlYXJjb2F0TWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5jbGVhcmNvYXRNYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5zcGVjdWxhclRpbnRNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyVGludE1hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRpZiAodXZTY2FsZU1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdFx0dXZTY2FsZU1hcCA9IHV2U2NhbGVNYXAudGV4dHVyZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh1dlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdFx0XHR1dlNjYWxlTWFwLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weSh1dlNjYWxlTWFwLm1hdHJpeCk7XG5cdFx0XHR9IC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllcyBmb3IgdXYyXG5cdFx0XHQvLyAxLiBhbyBtYXBcblx0XHRcdC8vIDIuIGxpZ2h0IG1hcFxuXG5cblx0XHRcdGxldCB1djJTY2FsZU1hcDtcblxuXHRcdFx0aWYgKG1hdGVyaWFsLmFvTWFwKSB7XG5cdFx0XHRcdHV2MlNjYWxlTWFwID0gbWF0ZXJpYWwuYW9NYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmxpZ2h0TWFwKSB7XG5cdFx0XHRcdHV2MlNjYWxlTWFwID0gbWF0ZXJpYWwubGlnaHRNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1djJTY2FsZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdGlmICh1djJTY2FsZU1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdFx0dXYyU2NhbGVNYXAgPSB1djJTY2FsZU1hcC50ZXh0dXJlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHV2MlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdFx0XHR1djJTY2FsZU1hcC51cGRhdGVNYXRyaXgoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVuaWZvcm1zLnV2MlRyYW5zZm9ybS52YWx1ZS5jb3B5KHV2MlNjYWxlTWFwLm1hdHJpeCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weShtYXRlcmlhbC5jb2xvcik7XG5cdFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdFx0dW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcblx0XHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcblx0XHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUG9pbnRzKHVuaWZvcm1zLCBtYXRlcmlhbCwgcGl4ZWxSYXRpbywgaGVpZ2h0KSB7XG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuXHRcdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cdFx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZSAqIHBpeGVsUmF0aW87XG5cdFx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IGhlaWdodCAqIDAuNTtcblxuXHRcdFx0aWYgKG1hdGVyaWFsLm1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5hbHBoYU1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXHRcdFx0fSAvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcblx0XHRcdC8vIDEuIGNvbG9yIG1hcFxuXHRcdFx0Ly8gMi4gYWxwaGEgbWFwXG5cblxuXHRcdFx0bGV0IHV2U2NhbGVNYXA7XG5cblx0XHRcdGlmIChtYXRlcmlhbC5tYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuYWxwaGFNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh1dlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdFx0XHR1dlNjYWxlTWFwLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weSh1dlNjYWxlTWFwLm1hdHJpeCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3ByaXRlcyh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weShtYXRlcmlhbC5jb2xvcik7XG5cdFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHRcdHVuaWZvcm1zLnJvdGF0aW9uLnZhbHVlID0gbWF0ZXJpYWwucm90YXRpb247XG5cblx0XHRcdGlmIChtYXRlcmlhbC5tYXApIHtcblx0XHRcdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuYWxwaGFNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblx0XHRcdH0gLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG5cdFx0XHQvLyAxLiBjb2xvciBtYXBcblx0XHRcdC8vIDIuIGFscGhhIG1hcFxuXG5cblx0XHRcdGxldCB1dlNjYWxlTWFwO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAodXZTY2FsZU1hcC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dXZTY2FsZU1hcC51cGRhdGVNYXRyaXgoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkodXZTY2FsZU1hcC5tYXRyaXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHRpZiAobWF0ZXJpYWwuZW1pc3NpdmVNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlLmNvcHkobWF0ZXJpYWwuc3BlY3VsYXIpO1xuXHRcdFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgobWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00KTsgLy8gdG8gcHJldmVudCBwb3coIDAuMCwgMC4wIClcblxuXHRcdFx0aWYgKG1hdGVyaWFsLmVtaXNzaXZlTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5idW1wTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cdFx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlICo9IC0xO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwubm9ybWFsTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weShtYXRlcmlhbC5ub3JtYWxTY2FsZSk7XG5cdFx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNUb29uKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdFx0aWYgKG1hdGVyaWFsLmdyYWRpZW50TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmdyYWRpZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZ3JhZGllbnRNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5lbWlzc2l2ZU1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuYnVtcE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXHRcdFx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSAqPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLm5vcm1hbE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkobWF0ZXJpYWwubm9ybWFsU2NhbGUpO1xuXHRcdFx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XG5cdFx0XHR1bmlmb3Jtcy5tZXRhbG5lc3MudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3M7XG5cblx0XHRcdGlmIChtYXRlcmlhbC5yb3VnaG5lc3NNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMucm91Z2huZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwubWV0YWxuZXNzTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm1ldGFsbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmVtaXNzaXZlTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5idW1wTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cdFx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlICo9IC0xO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwubm9ybWFsTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weShtYXRlcmlhbC5ub3JtYWxTY2FsZSk7XG5cdFx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZW52TWFwID0gcHJvcGVydGllcy5nZXQobWF0ZXJpYWwpLmVudk1hcDtcblxuXHRcdFx0aWYgKGVudk1hcCkge1xuXHRcdFx0XHQvL3VuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDsgLy8gcGFydCBvZiB1bmlmb3JtcyBjb21tb25cblx0XHRcdFx0dW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKHVuaWZvcm1zLCBtYXRlcmlhbCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5OyAvLyBhbHNvIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXG5cblx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdDtcblx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdFJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcztcblx0XHRcdGlmIChtYXRlcmlhbC5zaGVlbikgdW5pZm9ybXMuc2hlZW4udmFsdWUuY29weShtYXRlcmlhbC5zaGVlbik7XG5cblx0XHRcdGlmIChtYXRlcmlhbC5jbGVhcmNvYXRNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0TWFwLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0TWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdFJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXROb3JtYWxTY2FsZS52YWx1ZS5jb3B5KG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlKTtcblx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwO1xuXG5cdFx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkge1xuXHRcdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHVuaWZvcm1zLnRyYW5zbWlzc2lvbi52YWx1ZSA9IG1hdGVyaWFsLnRyYW5zbWlzc2lvbjtcblxuXHRcdFx0aWYgKG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb25NYXAudmFsdWUgPSBtYXRlcmlhbC50cmFuc21pc3Npb25NYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwLjApIHtcblx0XHRcdFx0dW5pZm9ybXMudHJhbnNtaXNzaW9uU2FtcGxlck1hcC52YWx1ZSA9IHRyYW5zbWlzc2lvblJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb25TYW1wbGVyU2l6ZS52YWx1ZS5zZXQodHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LndpZHRoLCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdH1cblxuXHRcdFx0dW5pZm9ybXMudGhpY2tuZXNzLnZhbHVlID0gbWF0ZXJpYWwudGhpY2tuZXNzO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwudGhpY2tuZXNzTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLnRoaWNrbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnRoaWNrbmVzc01hcDtcblx0XHRcdH1cblxuXHRcdFx0dW5pZm9ybXMuYXR0ZW51YXRpb25EaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0XHR1bmlmb3Jtcy5hdHRlbnVhdGlvblRpbnQudmFsdWUuY29weShtYXRlcmlhbC5hdHRlbnVhdGlvblRpbnQpO1xuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eTtcblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyVGludC52YWx1ZS5jb3B5KG1hdGVyaWFsLnNwZWN1bGFyVGludCk7XG5cblx0XHRcdGlmIChtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5zcGVjdWxhckludGVuc2l0eU1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuc3BlY3VsYXJUaW50TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyVGludE1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyVGludE1hcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNNYXRjYXAodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHRpZiAobWF0ZXJpYWwubWF0Y2FwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm1hdGNhcC52YWx1ZSA9IG1hdGVyaWFsLm1hdGNhcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmJ1bXBNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblx0XHRcdFx0aWYgKG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlKSB1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgKj0gLTE7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5ub3JtYWxNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KG1hdGVyaWFsLm5vcm1hbFNjYWxlKTtcblx0XHRcdFx0aWYgKG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlKSB1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5uZWdhdGUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0RlcHRoKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdFx0aWYgKG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rpc3RhbmNlKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdFx0aWYgKG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0fVxuXG5cdFx0XHR1bmlmb3Jtcy5yZWZlcmVuY2VQb3NpdGlvbi52YWx1ZS5jb3B5KG1hdGVyaWFsLnJlZmVyZW5jZVBvc2l0aW9uKTtcblx0XHRcdHVuaWZvcm1zLm5lYXJEaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLm5lYXJEaXN0YW5jZTtcblx0XHRcdHVuaWZvcm1zLmZhckRpc3RhbmNlLnZhbHVlID0gbWF0ZXJpYWwuZmFyRGlzdGFuY2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTm9ybWFsKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdFx0aWYgKG1hdGVyaWFsLmJ1bXBNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblx0XHRcdFx0aWYgKG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlKSB1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgKj0gLTE7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5ub3JtYWxNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KG1hdGVyaWFsLm5vcm1hbFNjYWxlKTtcblx0XHRcdFx0aWYgKG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlKSB1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5uZWdhdGUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRyZWZyZXNoRm9nVW5pZm9ybXM6IHJlZnJlc2hGb2dVbmlmb3Jtcyxcblx0XHRcdHJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zOiByZWZyZXNoTWF0ZXJpYWxVbmlmb3Jtc1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDYW52YXNFbGVtZW50KCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnKTtcblx0XHRjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIocGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0Y29uc3QgX2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNhbnZhcyA6IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcblx0XHRcdFx0XHRfY29udGV4dCA9IHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jb250ZXh0IDogbnVsbCxcblx0XHRcdFx0XHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXG5cdFx0XHRcdFx0X2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXG5cdFx0XHRcdFx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG5cdFx0XHRcdFx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxuXHRcdFx0XHRcdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxuXHRcdFx0XHRcdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcblx0XHRcdFx0XHRfcG93ZXJQcmVmZXJlbmNlID0gcGFyYW1ldGVycy5wb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucG93ZXJQcmVmZXJlbmNlIDogJ2RlZmF1bHQnLFxuXHRcdFx0XHRcdF9mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ID0gcGFyYW1ldGVycy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgOiBmYWxzZTtcblxuXHRcdGxldCBjdXJyZW50UmVuZGVyTGlzdCA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRSZW5kZXJTdGF0ZSA9IG51bGw7IC8vIHJlbmRlcigpIGNhbiBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBjYWxsYmFjayB0cmlnZ2VyZWQgYnkgYW5vdGhlciByZW5kZXIuXG5cdFx0Ly8gV2UgdHJhY2sgdGhpcyBzbyB0aGF0IHRoZSBuZXN0ZWQgcmVuZGVyIGNhbGwgZ2V0cyBpdHMgbGlzdCBhbmQgc3RhdGUgaXNvbGF0ZWQgZnJvbSB0aGUgcGFyZW50IHJlbmRlciBjYWxsLlxuXG5cdFx0Y29uc3QgcmVuZGVyTGlzdFN0YWNrID0gW107XG5cdFx0Y29uc3QgcmVuZGVyU3RhdGVTdGFjayA9IFtdOyAvLyBwdWJsaWMgcHJvcGVydGllc1xuXG5cdFx0dGhpcy5kb21FbGVtZW50ID0gX2NhbnZhczsgLy8gRGVidWcgY29uZmlndXJhdGlvbiBjb250YWluZXJcblxuXHRcdHRoaXMuZGVidWcgPSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZXMgZXJyb3IgY2hlY2tpbmcgYW5kIHJlcG9ydGluZyB3aGVuIHNoYWRlciBwcm9ncmFtcyBhcmUgYmVpbmcgY29tcGlsZWRcblx0XHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRjaGVja1NoYWRlckVycm9yczogdHJ1ZVxuXHRcdH07IC8vIGNsZWFyaW5nXG5cblx0XHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTsgLy8gc2NlbmUgZ3JhcGhcblxuXHRcdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlOyAvLyB1c2VyLWRlZmluZWQgY2xpcHBpbmdcblxuXHRcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBbXTtcblx0XHR0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2U7IC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xuXG5cdFx0dGhpcy5nYW1tYUZhY3RvciA9IDIuMDsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblx0XHR0aGlzLm91dHB1dEVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7IC8vIHBoeXNpY2FsIGxpZ2h0c1xuXG5cdFx0dGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA9IGZhbHNlOyAvLyB0b25lIG1hcHBpbmdcblxuXHRcdHRoaXMudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDEuMDsgLy8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG5cdFx0Y29uc3QgX3RoaXMgPSB0aGlzO1xuXG5cdFx0bGV0IF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7IC8vIGludGVybmFsIHN0YXRlIGNhY2hlXG5cblx0XHRsZXQgX2N1cnJlbnRBY3RpdmVDdWJlRmFjZSA9IDA7XG5cdFx0bGV0IF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPSAwO1xuXHRcdGxldCBfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG5cblx0XHRsZXQgX2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XG5cblx0XHRsZXQgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG5cdFx0Y29uc3QgX2N1cnJlbnRWaWV3cG9ydCA9IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRjb25zdCBfY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0bGV0IF9jdXJyZW50U2Npc3NvclRlc3QgPSBudWxsOyAvL1xuXG5cdFx0bGV0IF93aWR0aCA9IF9jYW52YXMud2lkdGg7XG5cdFx0bGV0IF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodDtcblx0XHRsZXQgX3BpeGVsUmF0aW8gPSAxO1xuXHRcdGxldCBfb3BhcXVlU29ydCA9IG51bGw7XG5cdFx0bGV0IF90cmFuc3BhcmVudFNvcnQgPSBudWxsO1xuXG5cdFx0Y29uc3QgX3ZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoMCwgMCwgX3dpZHRoLCBfaGVpZ2h0KTtcblxuXHRcdGNvbnN0IF9zY2lzc29yID0gbmV3IFZlY3RvcjQoMCwgMCwgX3dpZHRoLCBfaGVpZ2h0KTtcblxuXHRcdGxldCBfc2Npc3NvclRlc3QgPSBmYWxzZTsgLy9cblxuXHRcdGNvbnN0IF9jdXJyZW50RHJhd0J1ZmZlcnMgPSBbXTsgLy8gZnJ1c3R1bVxuXG5cdFx0Y29uc3QgX2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpOyAvLyBjbGlwcGluZ1xuXG5cblx0XHRsZXQgX2NsaXBwaW5nRW5hYmxlZCA9IGZhbHNlO1xuXHRcdGxldCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZTsgLy8gdHJhbnNtaXNzaW9uXG5cblx0XHRsZXQgX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9IG51bGw7IC8vIGNhbWVyYSBtYXRyaWNlcyBjYWNoZVxuXG5cdFx0Y29uc3QgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0Y29uc3QgX3ZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Y29uc3QgX2VtcHR5U2NlbmUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kOiBudWxsLFxuXHRcdFx0Zm9nOiBudWxsLFxuXHRcdFx0ZW52aXJvbm1lbnQ6IG51bGwsXG5cdFx0XHRvdmVycmlkZU1hdGVyaWFsOiBudWxsLFxuXHRcdFx0aXNTY2VuZTogdHJ1ZVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkge1xuXHRcdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xuXHRcdH0gLy8gaW5pdGlhbGl6ZVxuXG5cblx0XHRsZXQgX2dsID0gX2NvbnRleHQ7XG5cblx0XHRmdW5jdGlvbiBnZXRDb250ZXh0KGNvbnRleHROYW1lcywgY29udGV4dEF0dHJpYnV0ZXMpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29udGV4dE5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNvbnRleHROYW1lID0gY29udGV4dE5hbWVzW2ldO1xuXG5cdFx0XHRcdGNvbnN0IGNvbnRleHQgPSBfY2FudmFzLmdldENvbnRleHQoY29udGV4dE5hbWUsIGNvbnRleHRBdHRyaWJ1dGVzKTtcblxuXHRcdFx0XHRpZiAoY29udGV4dCAhPT0gbnVsbCkgcmV0dXJuIGNvbnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IHtcblx0XHRcdFx0YWxwaGE6IF9hbHBoYSxcblx0XHRcdFx0ZGVwdGg6IF9kZXB0aCxcblx0XHRcdFx0c3RlbmNpbDogX3N0ZW5jaWwsXG5cdFx0XHRcdGFudGlhbGlhczogX2FudGlhbGlhcyxcblx0XHRcdFx0cHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuXHRcdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG5cdFx0XHRcdHBvd2VyUHJlZmVyZW5jZTogX3Bvd2VyUHJlZmVyZW5jZSxcblx0XHRcdFx0ZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogX2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXRcblx0XHRcdH07IC8vIGV2ZW50IGxpc3RlbmVycyBtdXN0IGJlIHJlZ2lzdGVyZWQgYmVmb3JlIFdlYkdMIGNvbnRleHQgaXMgY3JlYXRlZCwgc2VlICMxMjc1M1xuXG5cdFx0XHRfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSk7XG5cblx0XHRcdF9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBvbkNvbnRleHRSZXN0b3JlLCBmYWxzZSk7XG5cblx0XHRcdGlmIChfZ2wgPT09IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgY29udGV4dE5hbWVzID0gWyd3ZWJnbDInLCAnd2ViZ2wnLCAnZXhwZXJpbWVudGFsLXdlYmdsJ107XG5cblx0XHRcdFx0aWYgKF90aGlzLmlzV2ViR0wxUmVuZGVyZXIgPT09IHRydWUpIHtcblx0XHRcdFx0XHRjb250ZXh0TmFtZXMuc2hpZnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbCA9IGdldENvbnRleHQoY29udGV4dE5hbWVzLCBjb250ZXh0QXR0cmlidXRlcyk7XG5cblx0XHRcdFx0aWYgKF9nbCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChnZXRDb250ZXh0KGNvbnRleHROYW1lcykpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dCB3aXRoIHlvdXIgc2VsZWN0ZWQgYXR0cmlidXRlcy4nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0LicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBTb21lIGV4cGVyaW1lbnRhbC13ZWJnbCBpbXBsZW1lbnRhdGlvbnMgZG8gbm90IGhhdmUgZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0XG5cblxuXHRcdFx0aWYgKF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHQncmFuZ2VNaW4nOiAxLFxuXHRcdFx0XHRcdFx0J3JhbmdlTWF4JzogMSxcblx0XHRcdFx0XHRcdCdwcmVjaXNpb24nOiAxXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yLm1lc3NhZ2UpO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXG5cdFx0bGV0IGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgc3RhdGUsIGluZm87XG5cdFx0bGV0IHByb3BlcnRpZXMsIHRleHR1cmVzLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgYXR0cmlidXRlcywgZ2VvbWV0cmllcywgb2JqZWN0cztcblx0XHRsZXQgcHJvZ3JhbUNhY2hlLCBtYXRlcmlhbHMsIHJlbmRlckxpc3RzLCByZW5kZXJTdGF0ZXMsIGNsaXBwaW5nLCBzaGFkb3dNYXA7XG5cdFx0bGV0IGJhY2tncm91bmQsIG1vcnBodGFyZ2V0cywgYnVmZmVyUmVuZGVyZXIsIGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcblx0XHRsZXQgdXRpbHMsIGJpbmRpbmdTdGF0ZXM7XG5cblx0XHRmdW5jdGlvbiBpbml0R0xDb250ZXh0KCkge1xuXHRcdFx0ZXh0ZW5zaW9ucyA9IG5ldyBXZWJHTEV4dGVuc2lvbnMoX2dsKTtcblx0XHRcdGNhcGFiaWxpdGllcyA9IG5ldyBXZWJHTENhcGFiaWxpdGllcyhfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMpO1xuXHRcdFx0ZXh0ZW5zaW9ucy5pbml0KGNhcGFiaWxpdGllcyk7XG5cdFx0XHR1dGlscyA9IG5ldyBXZWJHTFV0aWxzKF9nbCwgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcblx0XHRcdHN0YXRlID0gbmV3IFdlYkdMU3RhdGUoX2dsLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpO1xuXHRcdFx0X2N1cnJlbnREcmF3QnVmZmVyc1swXSA9IF9nbC5CQUNLO1xuXHRcdFx0aW5mbyA9IG5ldyBXZWJHTEluZm8oX2dsKTtcblx0XHRcdHByb3BlcnRpZXMgPSBuZXcgV2ViR0xQcm9wZXJ0aWVzKCk7XG5cdFx0XHR0ZXh0dXJlcyA9IG5ldyBXZWJHTFRleHR1cmVzKF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgdXRpbHMsIGluZm8pO1xuXHRcdFx0Y3ViZW1hcHMgPSBuZXcgV2ViR0xDdWJlTWFwcyhfdGhpcyk7XG5cdFx0XHRjdWJldXZtYXBzID0gbmV3IFdlYkdMQ3ViZVVWTWFwcyhfdGhpcyk7XG5cdFx0XHRhdHRyaWJ1dGVzID0gbmV3IFdlYkdMQXR0cmlidXRlcyhfZ2wsIGNhcGFiaWxpdGllcyk7XG5cdFx0XHRiaW5kaW5nU3RhdGVzID0gbmV3IFdlYkdMQmluZGluZ1N0YXRlcyhfZ2wsIGV4dGVuc2lvbnMsIGF0dHJpYnV0ZXMsIGNhcGFiaWxpdGllcyk7XG5cdFx0XHRnZW9tZXRyaWVzID0gbmV3IFdlYkdMR2VvbWV0cmllcyhfZ2wsIGF0dHJpYnV0ZXMsIGluZm8sIGJpbmRpbmdTdGF0ZXMpO1xuXHRcdFx0b2JqZWN0cyA9IG5ldyBXZWJHTE9iamVjdHMoX2dsLCBnZW9tZXRyaWVzLCBhdHRyaWJ1dGVzLCBpbmZvKTtcblx0XHRcdG1vcnBodGFyZ2V0cyA9IG5ldyBXZWJHTE1vcnBodGFyZ2V0cyhfZ2wpO1xuXHRcdFx0Y2xpcHBpbmcgPSBuZXcgV2ViR0xDbGlwcGluZyhwcm9wZXJ0aWVzKTtcblx0XHRcdHByb2dyYW1DYWNoZSA9IG5ldyBXZWJHTFByb2dyYW1zKF90aGlzLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzLCBiaW5kaW5nU3RhdGVzLCBjbGlwcGluZyk7XG5cdFx0XHRtYXRlcmlhbHMgPSBuZXcgV2ViR0xNYXRlcmlhbHMocHJvcGVydGllcyk7XG5cdFx0XHRyZW5kZXJMaXN0cyA9IG5ldyBXZWJHTFJlbmRlckxpc3RzKHByb3BlcnRpZXMpO1xuXHRcdFx0cmVuZGVyU3RhdGVzID0gbmV3IFdlYkdMUmVuZGVyU3RhdGVzKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyk7XG5cdFx0XHRiYWNrZ3JvdW5kID0gbmV3IFdlYkdMQmFja2dyb3VuZChfdGhpcywgY3ViZW1hcHMsIHN0YXRlLCBvYmplY3RzLCBfcHJlbXVsdGlwbGllZEFscGhhKTtcblx0XHRcdHNoYWRvd01hcCA9IG5ldyBXZWJHTFNoYWRvd01hcChfdGhpcywgb2JqZWN0cywgY2FwYWJpbGl0aWVzKTtcblx0XHRcdGJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMQnVmZmVyUmVuZGVyZXIoX2dsLCBleHRlbnNpb25zLCBpbmZvLCBjYXBhYmlsaXRpZXMpO1xuXHRcdFx0aW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKF9nbCwgZXh0ZW5zaW9ucywgaW5mbywgY2FwYWJpbGl0aWVzKTtcblx0XHRcdGluZm8ucHJvZ3JhbXMgPSBwcm9ncmFtQ2FjaGUucHJvZ3JhbXM7XG5cdFx0XHRfdGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XG5cdFx0XHRfdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcblx0XHRcdF90aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuXHRcdFx0X3RoaXMucmVuZGVyTGlzdHMgPSByZW5kZXJMaXN0cztcblx0XHRcdF90aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcblx0XHRcdF90aGlzLnN0YXRlID0gc3RhdGU7XG5cdFx0XHRfdGhpcy5pbmZvID0gaW5mbztcblx0XHR9XG5cblx0XHRpbml0R0xDb250ZXh0KCk7IC8vIHhyXG5cblx0XHRjb25zdCB4ciA9IG5ldyBXZWJYUk1hbmFnZXIoX3RoaXMsIF9nbCk7XG5cdFx0dGhpcy54ciA9IHhyOyAvLyBBUElcblxuXHRcdHRoaXMuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfZ2w7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gX2dsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9sb3NlX2NvbnRleHQnKTtcblx0XHRcdGlmIChleHRlbnNpb24pIGV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuXHRcdH07XG5cblx0XHR0aGlzLmZvcmNlQ29udGV4dFJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG5cdFx0XHRpZiAoZXh0ZW5zaW9uKSBleHRlbnNpb24ucmVzdG9yZUNvbnRleHQoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9waXhlbFJhdGlvO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdFx0XHRfcGl4ZWxSYXRpbyA9IHZhbHVlO1xuXHRcdFx0dGhpcy5zZXRTaXplKF93aWR0aCwgX2hlaWdodCwgZmFsc2UpO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnNldChfd2lkdGgsIF9oZWlnaHQpO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUpIHtcblx0XHRcdGlmICh4ci5pc1ByZXNlbnRpbmcpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBDYW5cXCd0IGNoYW5nZSBzaXplIHdoaWxlIFZSIGRldmljZSBpcyBwcmVzZW50aW5nLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdF93aWR0aCA9IHdpZHRoO1xuXHRcdFx0X2hlaWdodCA9IGhlaWdodDtcblx0XHRcdF9jYW52YXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogX3BpeGVsUmF0aW8pO1xuXHRcdFx0X2NhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAqIF9waXhlbFJhdGlvKTtcblxuXHRcdFx0aWYgKHVwZGF0ZVN0eWxlICE9PSBmYWxzZSkge1xuXHRcdFx0XHRfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdFx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0Vmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnNldChfd2lkdGggKiBfcGl4ZWxSYXRpbywgX2hlaWdodCAqIF9waXhlbFJhdGlvKS5mbG9vcigpO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldERyYXdpbmdCdWZmZXJTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8pIHtcblx0XHRcdF93aWR0aCA9IHdpZHRoO1xuXHRcdFx0X2hlaWdodCA9IGhlaWdodDtcblx0XHRcdF9waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblx0XHRcdF9jYW52YXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogcGl4ZWxSYXRpbyk7XG5cdFx0XHRfY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG5cdFx0XHR0aGlzLnNldFZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldEN1cnJlbnRWaWV3cG9ydCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0YXJnZXQuY29weShfY3VycmVudFZpZXdwb3J0KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0YXJnZXQuY29weShfdmlld3BvcnQpO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRcdGlmICh4LmlzVmVjdG9yNCkge1xuXHRcdFx0XHRfdmlld3BvcnQuc2V0KHgueCwgeC55LCB4LnosIHgudyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfdmlld3BvcnQuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS52aWV3cG9ydChfY3VycmVudFZpZXdwb3J0LmNvcHkoX3ZpZXdwb3J0KS5tdWx0aXBseVNjYWxhcihfcGl4ZWxSYXRpbykuZmxvb3IoKSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0U2Npc3NvciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0YXJnZXQuY29weShfc2Npc3Nvcik7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0XHRpZiAoeC5pc1ZlY3RvcjQpIHtcblx0XHRcdFx0X3NjaXNzb3Iuc2V0KHgueCwgeC55LCB4LnosIHgudyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfc2Npc3Nvci5zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLnNjaXNzb3IoX2N1cnJlbnRTY2lzc29yLmNvcHkoX3NjaXNzb3IpLm11bHRpcGx5U2NhbGFyKF9waXhlbFJhdGlvKS5mbG9vcigpKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfc2Npc3NvclRlc3Q7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoYm9vbGVhbikge1xuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoX3NjaXNzb3JUZXN0ID0gYm9vbGVhbik7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0T3BhcXVlU29ydCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcblx0XHRcdF9vcGFxdWVTb3J0ID0gbWV0aG9kO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFRyYW5zcGFyZW50U29ydCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcblx0XHRcdF90cmFuc3BhcmVudFNvcnQgPSBtZXRob2Q7XG5cdFx0fTsgLy8gQ2xlYXJpbmdcblxuXG5cdFx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KGJhY2tncm91bmQuZ2V0Q2xlYXJDb2xvcigpKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0YmFja2dyb3VuZC5zZXRDbGVhckNvbG9yLmFwcGx5KGJhY2tncm91bmQsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBiYWNrZ3JvdW5kLmdldENsZWFyQWxwaGEoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0YmFja2dyb3VuZC5zZXRDbGVhckFscGhhLmFwcGx5KGJhY2tncm91bmQsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoY29sb3IsIGRlcHRoLCBzdGVuY2lsKSB7XG5cdFx0XHRsZXQgYml0cyA9IDA7XG5cdFx0XHRpZiAoY29sb3IgPT09IHVuZGVmaW5lZCB8fCBjb2xvcikgYml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcblx0XHRcdGlmIChkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoKSBiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xuXHRcdFx0aWYgKHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cblx0XHRcdF9nbC5jbGVhcihiaXRzKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5jbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5jbGVhcih0cnVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmNsZWFyKGZhbHNlLCB0cnVlLCBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5jbGVhcihmYWxzZSwgZmFsc2UsIHRydWUpO1xuXHRcdH07IC8vXG5cblxuXHRcdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlKTtcblxuXHRcdFx0X2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIG9uQ29udGV4dFJlc3RvcmUsIGZhbHNlKTtcblxuXHRcdFx0cmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xuXHRcdFx0cmVuZGVyU3RhdGVzLmRpc3Bvc2UoKTtcblx0XHRcdHByb3BlcnRpZXMuZGlzcG9zZSgpO1xuXHRcdFx0Y3ViZW1hcHMuZGlzcG9zZSgpO1xuXHRcdFx0Y3ViZXV2bWFwcy5kaXNwb3NlKCk7XG5cdFx0XHRvYmplY3RzLmRpc3Bvc2UoKTtcblx0XHRcdGJpbmRpbmdTdGF0ZXMuZGlzcG9zZSgpO1xuXHRcdFx0eHIuZGlzcG9zZSgpO1xuXHRcdFx0eHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0Jywgb25YUlNlc3Npb25TdGFydCk7XG5cdFx0XHR4ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgb25YUlNlc3Npb25FbmQpO1xuXG5cdFx0XHRpZiAoX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCkge1xuXHRcdFx0XHRfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcblxuXHRcdFx0XHRfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHR9OyAvLyBFdmVudHNcblxuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdChldmVudCkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGNvbnNvbGUubG9nKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBDb250ZXh0IExvc3QuJyk7XG5cdFx0XHRfaXNDb250ZXh0TG9zdCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0UmVzdG9yZSgpXG5cdFx0LyogZXZlbnQgKi9cblx0XHR7XG5cdFx0XHRjb25zb2xlLmxvZygnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4nKTtcblx0XHRcdF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7XG5cdFx0XHRjb25zdCBpbmZvQXV0b1Jlc2V0ID0gaW5mby5hdXRvUmVzZXQ7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXBFbmFibGVkID0gc2hhZG93TWFwLmVuYWJsZWQ7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXBBdXRvVXBkYXRlID0gc2hhZG93TWFwLmF1dG9VcGRhdGU7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXBOZWVkc1VwZGF0ZSA9IHNoYWRvd01hcC5uZWVkc1VwZGF0ZTtcblx0XHRcdGNvbnN0IHNoYWRvd01hcFR5cGUgPSBzaGFkb3dNYXAudHlwZTtcblx0XHRcdGluaXRHTENvbnRleHQoKTtcblx0XHRcdGluZm8uYXV0b1Jlc2V0ID0gaW5mb0F1dG9SZXNldDtcblx0XHRcdHNoYWRvd01hcC5lbmFibGVkID0gc2hhZG93TWFwRW5hYmxlZDtcblx0XHRcdHNoYWRvd01hcC5hdXRvVXBkYXRlID0gc2hhZG93TWFwQXV0b1VwZGF0ZTtcblx0XHRcdHNoYWRvd01hcC5uZWVkc1VwZGF0ZSA9IHNoYWRvd01hcE5lZWRzVXBkYXRlO1xuXHRcdFx0c2hhZG93TWFwLnR5cGUgPSBzaGFkb3dNYXBUeXBlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTWF0ZXJpYWxEaXNwb3NlKGV2ZW50KSB7XG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSk7XG5cdFx0XHRkZWFsbG9jYXRlTWF0ZXJpYWwobWF0ZXJpYWwpO1xuXHRcdH0gLy8gQnVmZmVyIGRlYWxsb2NhdGlvblxuXG5cblx0XHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwobWF0ZXJpYWwpIHtcblx0XHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2VzKG1hdGVyaWFsKTtcblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKG1hdGVyaWFsKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlcyhtYXRlcmlhbCkge1xuXHRcdFx0Y29uc3QgcHJvZ3JhbXMgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCkucHJvZ3JhbXM7XG5cblx0XHRcdGlmIChwcm9ncmFtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcblx0XHRcdFx0XHRwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0ocHJvZ3JhbSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gLy8gQnVmZmVyIHJlbmRlcmluZ1xuXG5cblx0XHRmdW5jdGlvbiByZW5kZXJPYmplY3RJbW1lZGlhdGUob2JqZWN0LCBwcm9ncmFtKSB7XG5cdFx0XHRvYmplY3QucmVuZGVyKGZ1bmN0aW9uIChvYmplY3QpIHtcblx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlKG9iamVjdCwgcHJvZ3JhbSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSA9IGZ1bmN0aW9uIChvYmplY3QsIHByb2dyYW0pIHtcblx0XHRcdGJpbmRpbmdTdGF0ZXMuaW5pdEF0dHJpYnV0ZXMoKTtcblx0XHRcdGNvbnN0IGJ1ZmZlcnMgPSBwcm9wZXJ0aWVzLmdldChvYmplY3QpO1xuXHRcdFx0aWYgKG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgIWJ1ZmZlcnMucG9zaXRpb24pIGJ1ZmZlcnMucG9zaXRpb24gPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRpZiAob2JqZWN0Lmhhc05vcm1hbHMgJiYgIWJ1ZmZlcnMubm9ybWFsKSBidWZmZXJzLm5vcm1hbCA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRcdGlmIChvYmplY3QuaGFzVXZzICYmICFidWZmZXJzLnV2KSBidWZmZXJzLnV2ID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0aWYgKG9iamVjdC5oYXNDb2xvcnMgJiYgIWJ1ZmZlcnMuY29sb3IpIGJ1ZmZlcnMuY29sb3IgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0XHRpZiAob2JqZWN0Lmhhc1Bvc2l0aW9ucykge1xuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlcihfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnBvc2l0aW9uKTtcblxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YShfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyk7XG5cblx0XHRcdFx0YmluZGluZ1N0YXRlcy5lbmFibGVBdHRyaWJ1dGUocHJvZ3JhbUF0dHJpYnV0ZXMucG9zaXRpb24pO1xuXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW1BdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9iamVjdC5oYXNOb3JtYWxzKSB7XG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMubm9ybWFsKTtcblxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YShfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcpO1xuXG5cdFx0XHRcdGJpbmRpbmdTdGF0ZXMuZW5hYmxlQXR0cmlidXRlKHByb2dyYW1BdHRyaWJ1dGVzLm5vcm1hbCk7XG5cblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbUF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9iamVjdC5oYXNVdnMpIHtcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy51dik7XG5cblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcpO1xuXG5cdFx0XHRcdGJpbmRpbmdTdGF0ZXMuZW5hYmxlQXR0cmlidXRlKHByb2dyYW1BdHRyaWJ1dGVzLnV2KTtcblxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtQXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvYmplY3QuaGFzQ29sb3JzKSB7XG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMuY29sb3IpO1xuXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXKTtcblxuXHRcdFx0XHRiaW5kaW5nU3RhdGVzLmVuYWJsZUF0dHJpYnV0ZShwcm9ncmFtQXR0cmlidXRlcy5jb2xvcik7XG5cblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbUF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXHRcdFx0fVxuXG5cdFx0XHRiaW5kaW5nU3RhdGVzLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdF9nbC5kcmF3QXJyYXlzKF9nbC5UUklBTkdMRVMsIDAsIG9iamVjdC5jb3VudCk7XG5cblx0XHRcdG9iamVjdC5jb3VudCA9IDA7XG5cdFx0fTtcblxuXHRcdHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCkge1xuXHRcdFx0aWYgKHNjZW5lID09PSBudWxsKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyByZW5kZXJCdWZmZXJEaXJlY3Qgc2Vjb25kIHBhcmFtZXRlciB1c2VkIHRvIGJlIGZvZyAoY291bGQgYmUgbnVsbClcblxuXHRcdFx0Y29uc3QgZnJvbnRGYWNlQ1cgPSBvYmplY3QuaXNNZXNoICYmIG9iamVjdC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpIDwgMDtcblx0XHRcdGNvbnN0IHByb2dyYW0gPSBzZXRQcm9ncmFtKGNhbWVyYSwgc2NlbmUsIG1hdGVyaWFsLCBvYmplY3QpO1xuXHRcdFx0c3RhdGUuc2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGZyb250RmFjZUNXKTsgLy9cblxuXHRcdFx0bGV0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247IC8vXG5cblx0XHRcdGlmIChpbmRleCA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbi5jb3VudCA9PT0gMCkgcmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmIChpbmRleC5jb3VudCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0bGV0IHJhbmdlRmFjdG9yID0gMTtcblxuXHRcdFx0aWYgKG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRpbmRleCA9IGdlb21ldHJpZXMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KTtcblx0XHRcdFx0cmFuZ2VGYWN0b3IgPSAyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG1vcnBodGFyZ2V0cy51cGRhdGUob2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHByb2dyYW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRiaW5kaW5nU3RhdGVzLnNldHVwKG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBpbmRleCk7XG5cdFx0XHRsZXQgYXR0cmlidXRlO1xuXHRcdFx0bGV0IHJlbmRlcmVyID0gYnVmZmVyUmVuZGVyZXI7XG5cblx0XHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldChpbmRleCk7XG5cdFx0XHRcdHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuXHRcdFx0XHRyZW5kZXJlci5zZXRJbmRleChhdHRyaWJ1dGUpO1xuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGNvbnN0IGRhdGFDb3VudCA9IGluZGV4ICE9PSBudWxsID8gaW5kZXguY291bnQgOiBwb3NpdGlvbi5jb3VudDtcblx0XHRcdGNvbnN0IHJhbmdlU3RhcnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQgKiByYW5nZUZhY3Rvcjtcblx0XHRcdGNvbnN0IHJhbmdlQ291bnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQgKiByYW5nZUZhY3Rvcjtcblx0XHRcdGNvbnN0IGdyb3VwU3RhcnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLnN0YXJ0ICogcmFuZ2VGYWN0b3IgOiAwO1xuXHRcdFx0Y29uc3QgZ3JvdXBDb3VudCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuY291bnQgKiByYW5nZUZhY3RvciA6IEluZmluaXR5O1xuXHRcdFx0Y29uc3QgZHJhd1N0YXJ0ID0gTWF0aC5tYXgocmFuZ2VTdGFydCwgZ3JvdXBTdGFydCk7XG5cdFx0XHRjb25zdCBkcmF3RW5kID0gTWF0aC5taW4oZGF0YUNvdW50LCByYW5nZVN0YXJ0ICsgcmFuZ2VDb3VudCwgZ3JvdXBTdGFydCArIGdyb3VwQ291bnQpIC0gMTtcblx0XHRcdGNvbnN0IGRyYXdDb3VudCA9IE1hdGgubWF4KDAsIGRyYXdFbmQgLSBkcmF3U3RhcnQgKyAxKTtcblx0XHRcdGlmIChkcmF3Q291bnQgPT09IDApIHJldHVybjsgLy9cblxuXHRcdFx0aWYgKG9iamVjdC5pc01lc2gpIHtcblx0XHRcdFx0aWYgKG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aChtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkpO1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLkxJTkVTKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKF9nbC5UUklBTkdMRVMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKG9iamVjdC5pc0xpbmUpIHtcblx0XHRcdFx0bGV0IGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcblx0XHRcdFx0aWYgKGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxuXG5cdFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aChsaW5lV2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkpO1xuXG5cdFx0XHRcdGlmIChvYmplY3QuaXNMaW5lU2VnbWVudHMpIHtcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKF9nbC5MSU5FUyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzTGluZUxvb3ApIHtcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKF9nbC5MSU5FX0xPT1ApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLkxJTkVfU1RSSVApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKG9iamVjdC5pc1BvaW50cykge1xuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKF9nbC5QT0lOVFMpO1xuXHRcdFx0fSBlbHNlIGlmIChvYmplY3QuaXNTcHJpdGUpIHtcblx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZShfZ2wuVFJJQU5HTEVTKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9iamVjdC5pc0luc3RhbmNlZE1lc2gpIHtcblx0XHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKGRyYXdTdGFydCwgZHJhd0NvdW50LCBvYmplY3QuY291bnQpO1xuXHRcdFx0fSBlbHNlIGlmIChnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnN0IGluc3RhbmNlQ291bnQgPSBNYXRoLm1pbihnZW9tZXRyeS5pbnN0YW5jZUNvdW50LCBnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCk7XG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyhkcmF3U3RhcnQsIGRyYXdDb3VudCwgaW5zdGFuY2VDb3VudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZW5kZXJlci5yZW5kZXIoZHJhd1N0YXJ0LCBkcmF3Q291bnQpO1xuXHRcdFx0fVxuXHRcdH07IC8vIENvbXBpbGVcblxuXG5cdFx0dGhpcy5jb21waWxlID0gZnVuY3Rpb24gKHNjZW5lLCBjYW1lcmEpIHtcblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlcy5nZXQoc2NlbmUpO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLmluaXQoKTtcblx0XHRcdHJlbmRlclN0YXRlU3RhY2sucHVzaChjdXJyZW50UmVuZGVyU3RhdGUpO1xuXHRcdFx0c2NlbmUudHJhdmVyc2VWaXNpYmxlKGZ1bmN0aW9uIChvYmplY3QpIHtcblx0XHRcdFx0aWYgKG9iamVjdC5pc0xpZ2h0ICYmIG9iamVjdC5sYXllcnMudGVzdChjYW1lcmEubGF5ZXJzKSkge1xuXHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoTGlnaHQob2JqZWN0KTtcblxuXHRcdFx0XHRcdGlmIChvYmplY3QuY2FzdFNoYWRvdykge1xuXHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3cob2JqZWN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnNldHVwTGlnaHRzKCk7XG5cdFx0XHRzY2VuZS50cmF2ZXJzZShmdW5jdGlvbiAob2JqZWN0KSB7XG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdGlmIChtYXRlcmlhbCkge1xuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtYXRlcmlhbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbDIgPSBtYXRlcmlhbFtpXTtcblx0XHRcdFx0XHRcdFx0Z2V0UHJvZ3JhbShtYXRlcmlhbDIsIHNjZW5lLCBvYmplY3QpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRnZXRQcm9ncmFtKG1hdGVyaWFsLCBzY2VuZSwgb2JqZWN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmVuZGVyU3RhdGVTdGFjay5wb3AoKTtcblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IG51bGw7XG5cdFx0fTsgLy8gQW5pbWF0aW9uIExvb3BcblxuXG5cdFx0bGV0IG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiBvbkFuaW1hdGlvbkZyYW1lKHRpbWUpIHtcblx0XHRcdGlmIChvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2spIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayh0aW1lKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblhSU2Vzc2lvblN0YXJ0KCkge1xuXHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblhSU2Vzc2lvbkVuZCgpIHtcblx0XHRcdGFuaW1hdGlvbi5zdGFydCgpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBXZWJHTEFuaW1hdGlvbigpO1xuXHRcdGFuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKG9uQW5pbWF0aW9uRnJhbWUpO1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgYW5pbWF0aW9uLnNldENvbnRleHQod2luZG93KTtcblxuXHRcdHRoaXMuc2V0QW5pbWF0aW9uTG9vcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0b25BbmltYXRpb25GcmFtZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR4ci5zZXRBbmltYXRpb25Mb29wKGNhbGxiYWNrKTtcblx0XHRcdGNhbGxiYWNrID09PSBudWxsID8gYW5pbWF0aW9uLnN0b3AoKSA6IGFuaW1hdGlvbi5zdGFydCgpO1xuXHRcdH07XG5cblx0XHR4ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBvblhSU2Vzc2lvblN0YXJ0KTtcblx0XHR4ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgb25YUlNlc3Npb25FbmQpOyAvLyBSZW5kZXJpbmdcblxuXHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKHNjZW5lLCBjYW1lcmEpIHtcblx0XHRcdGlmIChjYW1lcmEgIT09IHVuZGVmaW5lZCAmJiBjYW1lcmEuaXNDYW1lcmEgIT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChfaXNDb250ZXh0TG9zdCA9PT0gdHJ1ZSkgcmV0dXJuOyAvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuXHRcdFx0aWYgKHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUpIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7IC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuXHRcdFx0aWYgKGNhbWVyYS5wYXJlbnQgPT09IG51bGwpIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHRpZiAoeHIuZW5hYmxlZCA9PT0gdHJ1ZSAmJiB4ci5pc1ByZXNlbnRpbmcgPT09IHRydWUpIHtcblx0XHRcdFx0aWYgKHhyLmNhbWVyYUF1dG9VcGRhdGUgPT09IHRydWUpIHhyLnVwZGF0ZUNhbWVyYShjYW1lcmEpO1xuXHRcdFx0XHRjYW1lcmEgPSB4ci5nZXRDYW1lcmEoKTsgLy8gdXNlIFhSIGNhbWVyYSBmb3IgcmVuZGVyaW5nXG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0aWYgKHNjZW5lLmlzU2NlbmUgPT09IHRydWUpIHNjZW5lLm9uQmVmb3JlUmVuZGVyKF90aGlzLCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFJlbmRlclRhcmdldCk7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZXMuZ2V0KHNjZW5lLCByZW5kZXJTdGF0ZVN0YWNrLmxlbmd0aCk7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuaW5pdCgpO1xuXHRcdFx0cmVuZGVyU3RhdGVTdGFjay5wdXNoKGN1cnJlbnRSZW5kZXJTdGF0ZSk7XG5cblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuXG5cdFx0XHRfZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChfcHJvalNjcmVlbk1hdHJpeCk7XG5cblx0XHRcdF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9IHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQ7XG5cdFx0XHRfY2xpcHBpbmdFbmFibGVkID0gY2xpcHBpbmcuaW5pdCh0aGlzLmNsaXBwaW5nUGxhbmVzLCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQsIGNhbWVyYSk7XG5cdFx0XHRjdXJyZW50UmVuZGVyTGlzdCA9IHJlbmRlckxpc3RzLmdldChzY2VuZSwgcmVuZGVyTGlzdFN0YWNrLmxlbmd0aCk7XG5cdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5pbml0KCk7XG5cdFx0XHRyZW5kZXJMaXN0U3RhY2sucHVzaChjdXJyZW50UmVuZGVyTGlzdCk7XG5cdFx0XHRwcm9qZWN0T2JqZWN0KHNjZW5lLCBjYW1lcmEsIDAsIF90aGlzLnNvcnRPYmplY3RzKTtcblx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LmZpbmlzaCgpO1xuXG5cdFx0XHRpZiAoX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUpIHtcblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3Quc29ydChfb3BhcXVlU29ydCwgX3RyYW5zcGFyZW50U29ydCk7XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0aWYgKF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUpIGNsaXBwaW5nLmJlZ2luU2hhZG93cygpO1xuXHRcdFx0Y29uc3Qgc2hhZG93c0FycmF5ID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLnNoYWRvd3NBcnJheTtcblx0XHRcdHNoYWRvd01hcC5yZW5kZXIoc2hhZG93c0FycmF5LCBzY2VuZSwgY2FtZXJhKTtcblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cygpO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnNldHVwTGlnaHRzVmlldyhjYW1lcmEpO1xuXHRcdFx0aWYgKF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUpIGNsaXBwaW5nLmVuZFNoYWRvd3MoKTsgLy9cblxuXHRcdFx0aWYgKHRoaXMuaW5mby5hdXRvUmVzZXQgPT09IHRydWUpIHRoaXMuaW5mby5yZXNldCgpOyAvL1xuXG5cdFx0XHRiYWNrZ3JvdW5kLnJlbmRlcihjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUpOyAvLyByZW5kZXIgc2NlbmVcblxuXHRcdFx0Y29uc3Qgb3BhcXVlT2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0Lm9wYXF1ZTtcblx0XHRcdGNvbnN0IHRyYW5zbWlzc2l2ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc21pc3NpdmU7XG5cdFx0XHRjb25zdCB0cmFuc3BhcmVudE9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc3BhcmVudDtcblx0XHRcdGlmIChvcGFxdWVPYmplY3RzLmxlbmd0aCA+IDApIHJlbmRlck9iamVjdHMob3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSk7XG5cdFx0XHRpZiAodHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwKSByZW5kZXJUcmFuc21pc3NpdmVPYmplY3RzKG9wYXF1ZU9iamVjdHMsIHRyYW5zbWlzc2l2ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEpO1xuXHRcdFx0aWYgKHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggPiAwKSByZW5kZXJPYmplY3RzKHRyYW5zcGFyZW50T2JqZWN0cywgc2NlbmUsIGNhbWVyYSk7IC8vXG5cblx0XHRcdGlmIChfY3VycmVudFJlbmRlclRhcmdldCAhPT0gbnVsbCkge1xuXHRcdFx0XHQvLyByZXNvbHZlIG11bHRpc2FtcGxlIHJlbmRlcmJ1ZmZlcnMgdG8gYSBzaW5nbGUtc2FtcGxlIHRleHR1cmUgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdHRleHR1cmVzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KF9jdXJyZW50UmVuZGVyVGFyZ2V0KTsgLy8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcblxuXHRcdFx0XHR0ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoX2N1cnJlbnRSZW5kZXJUYXJnZXQpO1xuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGlmIChzY2VuZS5pc1NjZW5lID09PSB0cnVlKSBzY2VuZS5vbkFmdGVyUmVuZGVyKF90aGlzLCBzY2VuZSwgY2FtZXJhKTsgLy8gRW5zdXJlIGRlcHRoIGJ1ZmZlciB3cml0aW5nIGlzIGVuYWJsZWQgc28gaXQgY2FuIGJlIGNsZWFyZWQgb24gbmV4dCByZW5kZXJcblxuXHRcdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KHRydWUpO1xuXHRcdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKHRydWUpO1xuXHRcdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRNYXNrKHRydWUpO1xuXHRcdFx0c3RhdGUuc2V0UG9seWdvbk9mZnNldChmYWxzZSk7IC8vIF9nbC5maW5pc2goKTtcblxuXHRcdFx0YmluZGluZ1N0YXRlcy5yZXNldERlZmF1bHRTdGF0ZSgpO1xuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XG5cdFx0XHRfY3VycmVudENhbWVyYSA9IG51bGw7XG5cdFx0XHRyZW5kZXJTdGF0ZVN0YWNrLnBvcCgpO1xuXG5cdFx0XHRpZiAocmVuZGVyU3RhdGVTdGFjay5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlU3RhY2tbcmVuZGVyU3RhdGVTdGFjay5sZW5ndGggLSAxXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJlbmRlckxpc3RTdGFjay5wb3AoKTtcblxuXHRcdFx0aWYgKHJlbmRlckxpc3RTdGFjay5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0ID0gcmVuZGVyTGlzdFN0YWNrW3JlbmRlckxpc3RTdGFjay5sZW5ndGggLSAxXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJvamVjdE9iamVjdChvYmplY3QsIGNhbWVyYSwgZ3JvdXBPcmRlciwgc29ydE9iamVjdHMpIHtcblx0XHRcdGlmIChvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRcdGNvbnN0IHZpc2libGUgPSBvYmplY3QubGF5ZXJzLnRlc3QoY2FtZXJhLmxheWVycyk7XG5cblx0XHRcdGlmICh2aXNpYmxlKSB7XG5cdFx0XHRcdGlmIChvYmplY3QuaXNHcm91cCkge1xuXHRcdFx0XHRcdGdyb3VwT3JkZXIgPSBvYmplY3QucmVuZGVyT3JkZXI7XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzTE9EKSB7XG5cdFx0XHRcdFx0aWYgKG9iamVjdC5hdXRvVXBkYXRlID09PSB0cnVlKSBvYmplY3QudXBkYXRlKGNhbWVyYSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzTGlnaHQpIHtcblx0XHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUucHVzaExpZ2h0KG9iamVjdCk7XG5cblx0XHRcdFx0XHRpZiAob2JqZWN0LmNhc3RTaGFkb3cpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoU2hhZG93KG9iamVjdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKG9iamVjdC5pc1Nwcml0ZSkge1xuXHRcdFx0XHRcdGlmICghb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c1Nwcml0ZShvYmplY3QpKSB7XG5cdFx0XHRcdFx0XHRpZiAoc29ydE9iamVjdHMpIHtcblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKG9iamVjdC5tYXRyaXhXb3JsZCkuYXBwbHlNYXRyaXg0KF9wcm9qU2NyZWVuTWF0cml4KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZShvYmplY3QpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRcdGlmIChtYXRlcmlhbC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2gob2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIF92ZWN0b3IzLnosIG51bGwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QpIHtcblx0XHRcdFx0XHRpZiAoc29ydE9iamVjdHMpIHtcblx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbihvYmplY3QubWF0cml4V29ybGQpLmFwcGx5TWF0cml4NChfcHJvalNjcmVlbk1hdHJpeCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QucHVzaChvYmplY3QsIG51bGwsIG9iamVjdC5tYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgbnVsbCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cykge1xuXHRcdFx0XHRcdGlmIChvYmplY3QuaXNTa2lubmVkTWVzaCkge1xuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHNrZWxldG9uIG9ubHkgb25jZSBpbiBhIGZyYW1lXG5cdFx0XHRcdFx0XHRpZiAob2JqZWN0LnNrZWxldG9uLmZyYW1lICE9PSBpbmZvLnJlbmRlci5mcmFtZSkge1xuXHRcdFx0XHRcdFx0XHRvYmplY3Quc2tlbGV0b24udXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRcdG9iamVjdC5za2VsZXRvbi5mcmFtZSA9IGluZm8ucmVuZGVyLmZyYW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdChvYmplY3QpKSB7XG5cdFx0XHRcdFx0XHRpZiAoc29ydE9iamVjdHMpIHtcblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKG9iamVjdC5tYXRyaXhXb3JsZCkuYXBwbHlNYXRyaXg0KF9wcm9qU2NyZWVuTWF0cml4KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZShvYmplY3QpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKG9iamVjdCwgZ2VvbWV0cnksIGdyb3VwTWF0ZXJpYWwsIGdyb3VwT3JkZXIsIF92ZWN0b3IzLnosIGdyb3VwKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwudmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCBfdmVjdG9yMy56LCBudWxsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHByb2plY3RPYmplY3QoY2hpbGRyZW5baV0sIGNhbWVyYSwgZ3JvdXBPcmRlciwgc29ydE9iamVjdHMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlclRyYW5zbWlzc2l2ZU9iamVjdHMob3BhcXVlT2JqZWN0cywgdHJhbnNtaXNzaXZlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSkge1xuXHRcdFx0aWYgKF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQgPT09IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgbmVlZHNBbnRpYWxpYXMgPSBfYW50aWFsaWFzID09PSB0cnVlICYmIGNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gdHJ1ZTtcblx0XHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0VHlwZSA9IG5lZWRzQW50aWFsaWFzID8gV2ViR0xNdWx0aXNhbXBsZVJlbmRlclRhcmdldCA6IFdlYkdMUmVuZGVyVGFyZ2V0O1xuXHRcdFx0XHRfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ID0gbmV3IHJlbmRlclRhcmdldFR5cGUoMTAyNCwgMTAyNCwge1xuXHRcdFx0XHRcdGdlbmVyYXRlTWlwbWFwczogdHJ1ZSxcblx0XHRcdFx0XHR0eXBlOiB1dGlscy5jb252ZXJ0KEhhbGZGbG9hdFR5cGUpICE9PSBudWxsID8gSGFsZkZsb2F0VHlwZSA6IFVuc2lnbmVkQnl0ZVR5cGUsXG5cdFx0XHRcdFx0bWluRmlsdGVyOiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRcdFx0bWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuXHRcdFx0XHRcdHdyYXBTOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuXHRcdFx0XHRcdHdyYXBUOiBDbGFtcFRvRWRnZVdyYXBwaW5nXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gX3RoaXMuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cblx0XHRcdF90aGlzLnNldFJlbmRlclRhcmdldChfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcblxuXHRcdFx0X3RoaXMuY2xlYXIoKTsgLy8gVHVybiBvZmYgdGhlIGZlYXR1cmVzIHdoaWNoIGNhbiBhZmZlY3QgdGhlIGZyYWcgY29sb3IgZm9yIG9wYXF1ZSBvYmplY3RzIHBhc3MuXG5cdFx0XHQvLyBPdGhlcndpc2UgdGhleSBhcmUgYXBwbGllZCB0d2ljZSBpbiBvcGFxdWUgb2JqZWN0cyBwYXNzIGFuZCB0cmFuc21pc3Npb24gb2JqZWN0cyBwYXNzLlxuXG5cblx0XHRcdGNvbnN0IGN1cnJlbnRUb25lTWFwcGluZyA9IF90aGlzLnRvbmVNYXBwaW5nO1xuXHRcdFx0X3RoaXMudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdFx0cmVuZGVyT2JqZWN0cyhvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhKTtcblx0XHRcdF90aGlzLnRvbmVNYXBwaW5nID0gY3VycmVudFRvbmVNYXBwaW5nO1xuXHRcdFx0dGV4dHVyZXMudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCk7XG5cdFx0XHR0ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCk7XG5cblx0XHRcdF90aGlzLnNldFJlbmRlclRhcmdldChjdXJyZW50UmVuZGVyVGFyZ2V0KTtcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyh0cmFuc21pc3NpdmVPYmplY3RzLCBzY2VuZSwgY2FtZXJhKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXJPYmplY3RzKHJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEpIHtcblx0XHRcdGNvbnN0IG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA6IG51bGw7XG5cblx0XHRcdGlmIChjYW1lcmEuaXNBcnJheUNhbWVyYSkge1xuXHRcdFx0XHRjb25zdCBjYW1lcmFzID0gY2FtZXJhLmNhbWVyYXM7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjYW1lcmFzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGNhbWVyYTIgPSBjYW1lcmFzW2ldO1xuXHRcdFx0XHRcdHN0YXRlLnZpZXdwb3J0KF9jdXJyZW50Vmlld3BvcnQuY29weShjYW1lcmEyLnZpZXdwb3J0KSk7XG5cdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnNldHVwTGlnaHRzVmlldyhjYW1lcmEyKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGorKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVuZGVySXRlbSA9IHJlbmRlckxpc3Rbal07XG5cdFx0XHRcdFx0XHRjb25zdCBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcblx0XHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gbnVsbCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xuXG5cdFx0XHRcdFx0XHRpZiAob2JqZWN0LmxheWVycy50ZXN0KGNhbWVyYTIubGF5ZXJzKSkge1xuXHRcdFx0XHRcdFx0XHRyZW5kZXJPYmplY3Qob2JqZWN0LCBzY2VuZSwgY2FtZXJhMiwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMCwgamwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcblx0XHRcdFx0XHRjb25zdCByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFtqXTtcblx0XHRcdFx0XHRjb25zdCBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcblx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XG5cdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSBudWxsID8gcmVuZGVySXRlbS5tYXRlcmlhbCA6IG92ZXJyaWRlTWF0ZXJpYWw7XG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xuXHRcdFx0XHRcdHJlbmRlck9iamVjdChvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0KG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCkge1xuXHRcdFx0b2JqZWN0Lm9uQmVmb3JlUmVuZGVyKF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKTtcblx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQpO1xuXHRcdFx0b2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgob2JqZWN0Lm1vZGVsVmlld01hdHJpeCk7XG5cblx0XHRcdGlmIChvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QpIHtcblx0XHRcdFx0Y29uc3QgcHJvZ3JhbSA9IHNldFByb2dyYW0oY2FtZXJhLCBzY2VuZSwgbWF0ZXJpYWwsIG9iamVjdCk7XG5cdFx0XHRcdHN0YXRlLnNldE1hdGVyaWFsKG1hdGVyaWFsKTtcblx0XHRcdFx0YmluZGluZ1N0YXRlcy5yZXNldCgpO1xuXHRcdFx0XHRyZW5kZXJPYmplY3RJbW1lZGlhdGUob2JqZWN0LCBwcm9ncmFtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSAmJiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlKSB7XG5cdFx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IEJhY2tTaWRlO1xuXHRcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdChjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXApO1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IEZyb250U2lkZTtcblx0XHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoY2FtZXJhLCBzY2VuZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwKTtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBEb3VibGVTaWRlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdChjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5vbkFmdGVyUmVuZGVyKF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQcm9ncmFtKG1hdGVyaWFsLCBzY2VuZSwgb2JqZWN0KSB7XG5cdFx0XHRpZiAoc2NlbmUuaXNTY2VuZSAhPT0gdHJ1ZSkgc2NlbmUgPSBfZW1wdHlTY2VuZTsgLy8gc2NlbmUgY291bGQgYmUgYSBNZXNoLCBMaW5lLCBQb2ludHMsIC4uLlxuXG5cdFx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCk7XG5cdFx0XHRjb25zdCBsaWdodHMgPSBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUubGlnaHRzO1xuXHRcdFx0Y29uc3Qgc2hhZG93c0FycmF5ID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLnNoYWRvd3NBcnJheTtcblx0XHRcdGNvbnN0IGxpZ2h0c1N0YXRlVmVyc2lvbiA9IGxpZ2h0cy5zdGF0ZS52ZXJzaW9uO1xuXHRcdFx0Y29uc3QgcGFyYW1ldGVycyA9IHByb2dyYW1DYWNoZS5nZXRQYXJhbWV0ZXJzKG1hdGVyaWFsLCBsaWdodHMuc3RhdGUsIHNoYWRvd3NBcnJheSwgc2NlbmUsIG9iamVjdCk7XG5cdFx0XHRjb25zdCBwcm9ncmFtQ2FjaGVLZXkgPSBwcm9ncmFtQ2FjaGUuZ2V0UHJvZ3JhbUNhY2hlS2V5KHBhcmFtZXRlcnMpO1xuXHRcdFx0bGV0IHByb2dyYW1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW1zOyAvLyBhbHdheXMgdXBkYXRlIGVudmlyb25tZW50IGFuZCBmb2cgLSBjaGFuZ2luZyB0aGVzZSB0cmlnZ2VyIGFuIGdldFByb2dyYW0gY2FsbCwgYnV0IGl0J3MgcG9zc2libGUgdGhhdCB0aGUgcHJvZ3JhbSBkb2Vzbid0IGNoYW5nZVxuXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZW52aXJvbm1lbnQgPSBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gc2NlbmUuZW52aXJvbm1lbnQgOiBudWxsO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyA9IHNjZW5lLmZvZztcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5lbnZNYXAgPSAobWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcykuZ2V0KG1hdGVyaWFsLmVudk1hcCB8fCBtYXRlcmlhbFByb3BlcnRpZXMuZW52aXJvbm1lbnQpO1xuXG5cdFx0XHRpZiAocHJvZ3JhbXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBuZXcgbWF0ZXJpYWxcblx0XHRcdFx0bWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlKTtcblx0XHRcdFx0cHJvZ3JhbXMgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtcyA9IHByb2dyYW1zO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcHJvZ3JhbSA9IHByb2dyYW1zLmdldChwcm9ncmFtQ2FjaGVLZXkpO1xuXG5cdFx0XHRpZiAocHJvZ3JhbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIGVhcmx5IG91dCBpZiBwcm9ncmFtIGFuZCBsaWdodCBzdGF0ZSBpcyBpZGVudGljYWxcblx0XHRcdFx0aWYgKG1hdGVyaWFsUHJvcGVydGllcy5jdXJyZW50UHJvZ3JhbSA9PT0gcHJvZ3JhbSAmJiBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzU3RhdGVWZXJzaW9uID09PSBsaWdodHNTdGF0ZVZlcnNpb24pIHtcblx0XHRcdFx0XHR1cGRhdGVDb21tb25NYXRlcmlhbFByb3BlcnRpZXMobWF0ZXJpYWwsIHBhcmFtZXRlcnMpO1xuXHRcdFx0XHRcdHJldHVybiBwcm9ncmFtO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXJhbWV0ZXJzLnVuaWZvcm1zID0gcHJvZ3JhbUNhY2hlLmdldFVuaWZvcm1zKG1hdGVyaWFsKTtcblx0XHRcdFx0bWF0ZXJpYWwub25CdWlsZChwYXJhbWV0ZXJzLCBfdGhpcyk7XG5cdFx0XHRcdG1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZShwYXJhbWV0ZXJzLCBfdGhpcyk7XG5cdFx0XHRcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0ocGFyYW1ldGVycywgcHJvZ3JhbUNhY2hlS2V5KTtcblx0XHRcdFx0cHJvZ3JhbXMuc2V0KHByb2dyYW1DYWNoZUtleSwgcHJvZ3JhbSk7XG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3JtcyA9IHBhcmFtZXRlcnMudW5pZm9ybXM7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zO1xuXG5cdFx0XHRpZiAoIW1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgIW1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuY2xpcHBpbmcgPT09IHRydWUpIHtcblx0XHRcdFx0dW5pZm9ybXMuY2xpcHBpbmdQbGFuZXMgPSBjbGlwcGluZy51bmlmb3JtO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGVDb21tb25NYXRlcmlhbFByb3BlcnRpZXMobWF0ZXJpYWwsIHBhcmFtZXRlcnMpOyAvLyBzdG9yZSB0aGUgbGlnaHQgc2V0dXAgaXQgd2FzIGNyZWF0ZWQgZm9yXG5cblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyA9IG1hdGVyaWFsTmVlZHNMaWdodHMobWF0ZXJpYWwpO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiA9IGxpZ2h0c1N0YXRlVmVyc2lvbjtcblxuXHRcdFx0aWYgKG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cykge1xuXHRcdFx0XHQvLyB3aXJlIHVwIHRoZSBtYXRlcmlhbCB0byB0aGlzIHJlbmRlcmVyJ3MgbGlnaHRpbmcgc3RhdGVcblx0XHRcdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuc3RhdGUuYW1iaWVudDtcblx0XHRcdFx0dW5pZm9ybXMubGlnaHRQcm9iZS52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wcm9iZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWw7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93O1xuXHRcdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3Q7XG5cdFx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvdztcblx0XHRcdFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWE7XG5cdFx0XHRcdHVuaWZvcm1zLmx0Y18xLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhTFRDMTtcblx0XHRcdFx0dW5pZm9ybXMubHRjXzIudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWFMVEMyO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludDtcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3c7XG5cdFx0XHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuaGVtaTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4O1xuXHRcdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3dNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLnNwb3RTaGFkb3dNYXRyaXgudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvd01hdHJpeDtcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3dNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWF0cml4OyAvLyBUT0RPIChhYmVsbmF0aW9uKTogYWRkIGFyZWEgbGlnaHRzIHNoYWRvdyBpbmZvIHRvIHVuaWZvcm1zXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHByb2dVbmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblx0XHRcdGNvbnN0IHVuaWZvcm1zTGlzdCA9IFdlYkdMVW5pZm9ybXMuc2VxV2l0aFZhbHVlKHByb2dVbmlmb3Jtcy5zZXEsIHVuaWZvcm1zKTtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gdW5pZm9ybXNMaXN0O1xuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlQ29tbW9uTWF0ZXJpYWxQcm9wZXJ0aWVzKG1hdGVyaWFsLCBwYXJhbWV0ZXJzKSB7XG5cdFx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCk7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMub3V0cHV0RW5jb2RpbmcgPSBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmcgPSBwYXJhbWV0ZXJzLmluc3RhbmNpbmc7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuc2tpbm5pbmcgPSBwYXJhbWV0ZXJzLnNraW5uaW5nO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0cyA9IHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoTm9ybWFscyA9IHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzID0gcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcztcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1JbnRlcnNlY3Rpb24gPSBwYXJhbWV0ZXJzLm51bUNsaXBJbnRlcnNlY3Rpb247XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4QWxwaGFzID0gcGFyYW1ldGVycy52ZXJ0ZXhBbHBoYXM7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4VGFuZ2VudHMgPSBwYXJhbWV0ZXJzLnZlcnRleFRhbmdlbnRzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldFByb2dyYW0oY2FtZXJhLCBzY2VuZSwgbWF0ZXJpYWwsIG9iamVjdCkge1xuXHRcdFx0aWYgKHNjZW5lLmlzU2NlbmUgIT09IHRydWUpIHNjZW5lID0gX2VtcHR5U2NlbmU7IC8vIHNjZW5lIGNvdWxkIGJlIGEgTWVzaCwgTGluZSwgUG9pbnRzLCAuLi5cblxuXHRcdFx0dGV4dHVyZXMucmVzZXRUZXh0dXJlVW5pdHMoKTtcblx0XHRcdGNvbnN0IGZvZyA9IHNjZW5lLmZvZztcblx0XHRcdGNvbnN0IGVudmlyb25tZW50ID0gbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IHNjZW5lLmVudmlyb25tZW50IDogbnVsbDtcblx0XHRcdGNvbnN0IGVuY29kaW5nID0gX2N1cnJlbnRSZW5kZXJUYXJnZXQgPT09IG51bGwgPyBfdGhpcy5vdXRwdXRFbmNvZGluZyA6IF9jdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuZW5jb2Rpbmc7XG5cdFx0XHRjb25zdCBlbnZNYXAgPSAobWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcykuZ2V0KG1hdGVyaWFsLmVudk1hcCB8fCBlbnZpcm9ubWVudCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXhBbHBoYXMgPSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPT09IHRydWUgJiYgISFvYmplY3QuZ2VvbWV0cnkgJiYgISFvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAmJiBvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZSA9PT0gNDtcblx0XHRcdGNvbnN0IHZlcnRleFRhbmdlbnRzID0gISFvYmplY3QuZ2VvbWV0cnkgJiYgISFvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50O1xuXHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gISFvYmplY3QuZ2VvbWV0cnkgJiYgISFvYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgbW9ycGhOb3JtYWxzID0gISFvYmplY3QuZ2VvbWV0cnkgJiYgISFvYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbDtcblx0XHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKTtcblx0XHRcdGNvbnN0IGxpZ2h0cyA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5saWdodHM7XG5cblx0XHRcdGlmIChfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdGlmIChfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSkge1xuXHRcdFx0XHRcdGNvbnN0IHVzZUNhY2hlID0gY2FtZXJhID09PSBfY3VycmVudENhbWVyYSAmJiBtYXRlcmlhbC5pZCA9PT0gX2N1cnJlbnRNYXRlcmlhbElkOyAvLyB3ZSBtaWdodCB3YW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiB3aXRoIHNvbWUgQ2xpcHBpbmdHcm91cFxuXHRcdFx0XHRcdC8vIG9iamVjdCBpbnN0ZWFkIG9mIHRoZSBtYXRlcmlhbCwgb25jZSBpdCBiZWNvbWVzIGZlYXNpYmxlXG5cdFx0XHRcdFx0Ly8gKCM4NDY1LCAjODM3OSlcblxuXHRcdFx0XHRcdGNsaXBwaW5nLnNldFN0YXRlKG1hdGVyaWFsLCBjYW1lcmEsIHVzZUNhY2hlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGxldCBuZWVkc1Byb2dyYW1DaGFuZ2UgPSBmYWxzZTtcblxuXHRcdFx0aWYgKG1hdGVyaWFsLnZlcnNpb24gPT09IG1hdGVyaWFsUHJvcGVydGllcy5fX3ZlcnNpb24pIHtcblx0XHRcdFx0aWYgKG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyAmJiBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzU3RhdGVWZXJzaW9uICE9PSBsaWdodHMuc3RhdGUudmVyc2lvbikge1xuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm91dHB1dEVuY29kaW5nICE9PSBlbmNvZGluZykge1xuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFvYmplY3QuaXNJbnN0YW5jZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChvYmplY3QuaXNTa2lubmVkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuc2tpbm5pbmcgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICghb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLnNraW5uaW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwICE9PSBlbnZNYXApIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmZvZyAmJiBtYXRlcmlhbFByb3BlcnRpZXMuZm9nICE9PSBmb2cpIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gdW5kZWZpbmVkICYmIChtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IGNsaXBwaW5nLm51bVBsYW5lcyB8fCBtYXRlcmlhbFByb3BlcnRpZXMubnVtSW50ZXJzZWN0aW9uICE9PSBjbGlwcGluZy5udW1JbnRlcnNlY3Rpb24pKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4QWxwaGFzICE9PSB2ZXJ0ZXhBbHBoYXMpIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy52ZXJ0ZXhUYW5nZW50cyAhPT0gdmVydGV4VGFuZ2VudHMpIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaFRhcmdldHMgIT09IG1vcnBoVGFyZ2V0cykge1xuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoTm9ybWFscyAhPT0gbW9ycGhOb3JtYWxzKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IG1hdGVyaWFsLnZlcnNpb247XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0bGV0IHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMuY3VycmVudFByb2dyYW07XG5cblx0XHRcdGlmIChuZWVkc1Byb2dyYW1DaGFuZ2UgPT09IHRydWUpIHtcblx0XHRcdFx0cHJvZ3JhbSA9IGdldFByb2dyYW0obWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcmVmcmVzaFByb2dyYW0gPSBmYWxzZTtcblx0XHRcdGxldCByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcblx0XHRcdGxldCByZWZyZXNoTGlnaHRzID0gZmFsc2U7XG5cdFx0XHRjb25zdCBwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuXHRcdFx0XHRcdFx0bV91bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3JtcztcblxuXHRcdFx0aWYgKHN0YXRlLnVzZVByb2dyYW0ocHJvZ3JhbS5wcm9ncmFtKSkge1xuXHRcdFx0XHRyZWZyZXNoUHJvZ3JhbSA9IHRydWU7XG5cdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cdFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCkge1xuXHRcdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcblx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlZnJlc2hQcm9ncmFtIHx8IF9jdXJyZW50Q2FtZXJhICE9PSBjYW1lcmEpIHtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICdwcm9qZWN0aW9uTWF0cml4JywgY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO1xuXG5cdFx0XHRcdGlmIChjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcikge1xuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnbG9nRGVwdGhCdWZGQycsIDIuMCAvIChNYXRoLmxvZyhjYW1lcmEuZmFyICsgMS4wKSAvIE1hdGguTE4yKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoX2N1cnJlbnRDYW1lcmEgIT09IGNhbWVyYSkge1xuXHRcdFx0XHRcdF9jdXJyZW50Q2FtZXJhID0gY2FtZXJhOyAvLyBsaWdodGluZyB1bmlmb3JtcyBkZXBlbmQgb24gdGhlIGNhbWVyYSBzbyBlbmZvcmNlIGFuIHVwZGF0ZVxuXHRcdFx0XHRcdC8vIG5vdywgaW4gY2FzZSB0aGlzIG1hdGVyaWFsIHN1cHBvcnRzIGxpZ2h0cyAtIG9yIGxhdGVyLCB3aGVuXG5cdFx0XHRcdFx0Ly8gdGhlIG5leHQgbWF0ZXJpYWwgdGhhdCBkb2VzIGdldHMgYWN0aXZhdGVkOlxuXG5cdFx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTsgLy8gc2V0IHRvIHRydWUgb24gbWF0ZXJpYWwgY2hhbmdlXG5cblx0XHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTsgLy8gcmVtYWlucyBzZXQgdW50aWwgdXBkYXRlIGRvbmVcblx0XHRcdFx0fSAvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG5cdFx0XHRcdC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXG5cblxuXHRcdFx0XHRpZiAobWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IG1hdGVyaWFsLmVudk1hcCkge1xuXHRcdFx0XHRcdGNvbnN0IHVDYW1Qb3MgPSBwX3VuaWZvcm1zLm1hcC5jYW1lcmFQb3NpdGlvbjtcblxuXHRcdFx0XHRcdGlmICh1Q2FtUG9zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHVDYW1Qb3Muc2V0VmFsdWUoX2dsLCBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhLm1hdHJpeFdvcmxkKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCkge1xuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnaXNPcnRob2dyYXBoaWMnLCBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgPT09IHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc1NoYWRvd01hdGVyaWFsIHx8IG9iamVjdC5pc1NraW5uZWRNZXNoKSB7XG5cdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICd2aWV3TWF0cml4JywgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gc2tpbm5pbmcgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXG5cdFx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcblx0XHRcdC8vIG90aGVyd2lzZSB0ZXh0dXJlcyB1c2VkIGZvciBza2lubmluZyBjYW4gdGFrZSBvdmVyIHRleHR1cmUgdW5pdHMgcmVzZXJ2ZWQgZm9yIG90aGVyIG1hdGVyaWFsIHRleHR1cmVzXG5cblxuXHRcdFx0aWYgKG9iamVjdC5pc1NraW5uZWRNZXNoKSB7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoX2dsLCBvYmplY3QsICdiaW5kTWF0cml4Jyk7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoX2dsLCBvYmplY3QsICdiaW5kTWF0cml4SW52ZXJzZScpO1xuXHRcdFx0XHRjb25zdCBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcblxuXHRcdFx0XHRpZiAoc2tlbGV0b24pIHtcblx0XHRcdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMpIHtcblx0XHRcdFx0XHRcdGlmIChza2VsZXRvbi5ib25lVGV4dHVyZSA9PT0gbnVsbCkgc2tlbGV0b24uY29tcHV0ZUJvbmVUZXh0dXJlKCk7XG5cdFx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ2JvbmVUZXh0dXJlJywgc2tlbGV0b24uYm9uZVRleHR1cmUsIHRleHR1cmVzKTtcblx0XHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnYm9uZVRleHR1cmVTaXplJywgc2tlbGV0b24uYm9uZVRleHR1cmVTaXplKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbChfZ2wsIHNrZWxldG9uLCAnYm9uZU1hdHJpY2VzJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZWZyZXNoTWF0ZXJpYWwgfHwgbWF0ZXJpYWxQcm9wZXJ0aWVzLnJlY2VpdmVTaGFkb3cgIT09IG9iamVjdC5yZWNlaXZlU2hhZG93KSB7XG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5yZWNlaXZlU2hhZG93ID0gb2JqZWN0LnJlY2VpdmVTaGFkb3c7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAncmVjZWl2ZVNoYWRvdycsIG9iamVjdC5yZWNlaXZlU2hhZG93KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlZnJlc2hNYXRlcmlhbCkge1xuXHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ3RvbmVNYXBwaW5nRXhwb3N1cmUnLCBfdGhpcy50b25lTWFwcGluZ0V4cG9zdXJlKTtcblxuXHRcdFx0XHRpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm5lZWRzTGlnaHRzKSB7XG5cdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgbWF0ZXJpYWwgcmVxdWlyZXMgbGlnaHRpbmcgaW5mb1xuXHRcdFx0XHRcdC8vIG5vdGU6IGFsbCBsaWdodGluZyB1bmlmb3JtcyBhcmUgYWx3YXlzIHNldCBjb3JyZWN0bHlcblx0XHRcdFx0XHQvLyB0aGV5IHNpbXBseSByZWZlcmVuY2UgdGhlIHJlbmRlcmVyJ3Mgc3RhdGUgZm9yIHRoZWlyXG5cdFx0XHRcdFx0Ly8gdmFsdWVzXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyB1c2UgdGhlIGN1cnJlbnQgbWF0ZXJpYWwncyAubmVlZHNVcGRhdGUgZmxhZ3MgdG8gc2V0XG5cdFx0XHRcdFx0Ly8gdGhlIEdMIHN0YXRlIHdoZW4gcmVxdWlyZWRcblx0XHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZShtX3VuaWZvcm1zLCByZWZyZXNoTGlnaHRzKTtcblx0XHRcdFx0fSAvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xuXG5cblx0XHRcdFx0aWYgKGZvZyAmJiBtYXRlcmlhbC5mb2cpIHtcblx0XHRcdFx0XHRtYXRlcmlhbHMucmVmcmVzaEZvZ1VuaWZvcm1zKG1fdW5pZm9ybXMsIGZvZyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXRlcmlhbHMucmVmcmVzaE1hdGVyaWFsVW5pZm9ybXMobV91bmlmb3JtcywgbWF0ZXJpYWwsIF9waXhlbFJhdGlvLCBfaGVpZ2h0LCBfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0V2ViR0xVbmlmb3Jtcy51cGxvYWQoX2dsLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LCBtX3VuaWZvcm1zLCB0ZXh0dXJlcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmIG1hdGVyaWFsLnVuaWZvcm1zTmVlZFVwZGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRXZWJHTFVuaWZvcm1zLnVwbG9hZChfZ2wsIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG1fdW5pZm9ybXMsIHRleHR1cmVzKTtcblx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5pc1Nwcml0ZU1hdGVyaWFsKSB7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnY2VudGVyJywgb2JqZWN0LmNlbnRlcik7XG5cdFx0XHR9IC8vIGNvbW1vbiBtYXRyaWNlc1xuXG5cblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnbW9kZWxWaWV3TWF0cml4Jywgb2JqZWN0Lm1vZGVsVmlld01hdHJpeCk7XG5cdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ25vcm1hbE1hdHJpeCcsIG9iamVjdC5ub3JtYWxNYXRyaXgpO1xuXHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICdtb2RlbE1hdHJpeCcsIG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblx0XHR9IC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cblxuXG5cdFx0ZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUodW5pZm9ybXMsIHZhbHVlKSB7XG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMubGlnaHRQcm9iZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodFNoYWRvd3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodFNoYWRvd3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWF0ZXJpYWxOZWVkc0xpZ2h0cyhtYXRlcmlhbCkge1xuXHRcdFx0cmV0dXJuIG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiBtYXRlcmlhbC5saWdodHMgPT09IHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRBY3RpdmVDdWJlRmFjZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfY3VycmVudEFjdGl2ZUN1YmVGYWNlO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldEFjdGl2ZU1pcG1hcExldmVsID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWw7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0O1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uIChyZW5kZXJUYXJnZXQsIGFjdGl2ZUN1YmVGYWNlID0gMCwgYWN0aXZlTWlwbWFwTGV2ZWwgPSAwKSB7XG5cdFx0XHRfY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblx0XHRcdF9jdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSBhY3RpdmVDdWJlRmFjZTtcblx0XHRcdF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPSBhY3RpdmVNaXBtYXBMZXZlbDtcblxuXHRcdFx0aWYgKHJlbmRlclRhcmdldCAmJiBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRleHR1cmVzLnNldHVwUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBmcmFtZWJ1ZmZlciA9IG51bGw7XG5cdFx0XHRsZXQgaXNDdWJlID0gZmFsc2U7XG5cdFx0XHRsZXQgaXNSZW5kZXJUYXJnZXQzRCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdFx0XHRpZiAodGV4dHVyZS5pc0RhdGFUZXh0dXJlM0QgfHwgdGV4dHVyZS5pc0RhdGFUZXh0dXJlMkRBcnJheSkge1xuXHRcdFx0XHRcdGlzUmVuZGVyVGFyZ2V0M0QgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgX193ZWJnbEZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KS5fX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdFx0aWYgKHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCkge1xuXHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyW2FjdGl2ZUN1YmVGYWNlXTtcblx0XHRcdFx0XHRpc0N1YmUgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCkuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2N1cnJlbnRWaWV3cG9ydC5jb3B5KHJlbmRlclRhcmdldC52aWV3cG9ydCk7XG5cblx0XHRcdFx0X2N1cnJlbnRTY2lzc29yLmNvcHkocmVuZGVyVGFyZ2V0LnNjaXNzb3IpO1xuXG5cdFx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSByZW5kZXJUYXJnZXQuc2Npc3NvclRlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoX3ZpZXdwb3J0KS5tdWx0aXBseVNjYWxhcihfcGl4ZWxSYXRpbykuZmxvb3IoKTtcblxuXHRcdFx0XHRfY3VycmVudFNjaXNzb3IuY29weShfc2Npc3NvcikubXVsdGlwbHlTY2FsYXIoX3BpeGVsUmF0aW8pLmZsb29yKCk7XG5cblx0XHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IF9zY2lzc29yVGVzdDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZnJhbWVidWZmZXJCb3VuZCA9IHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblxuXHRcdFx0aWYgKGZyYW1lYnVmZmVyQm91bmQgJiYgY2FwYWJpbGl0aWVzLmRyYXdCdWZmZXJzKSB7XG5cdFx0XHRcdGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cblx0XHRcdFx0XHRcdGlmIChfY3VycmVudERyYXdCdWZmZXJzLmxlbmd0aCAhPT0gdGV4dHVyZXMubGVuZ3RoIHx8IF9jdXJyZW50RHJhd0J1ZmZlcnNbMF0gIT09IF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0X2N1cnJlbnREcmF3QnVmZmVyc1tpXSA9IF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRfY3VycmVudERyYXdCdWZmZXJzLmxlbmd0aCA9IHRleHR1cmVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoX2N1cnJlbnREcmF3QnVmZmVycy5sZW5ndGggIT09IDEgfHwgX2N1cnJlbnREcmF3QnVmZmVyc1swXSAhPT0gX2dsLkNPTE9SX0FUVEFDSE1FTlQwKSB7XG5cdFx0XHRcdFx0XHRcdF9jdXJyZW50RHJhd0J1ZmZlcnNbMF0gPSBfZ2wuQ09MT1JfQVRUQUNITUVOVDA7XG5cdFx0XHRcdFx0XHRcdF9jdXJyZW50RHJhd0J1ZmZlcnMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoX2N1cnJlbnREcmF3QnVmZmVycy5sZW5ndGggIT09IDEgfHwgX2N1cnJlbnREcmF3QnVmZmVyc1swXSAhPT0gX2dsLkJBQ0spIHtcblx0XHRcdFx0XHRcdF9jdXJyZW50RHJhd0J1ZmZlcnNbMF0gPSBfZ2wuQkFDSztcblx0XHRcdFx0XHRcdF9jdXJyZW50RHJhd0J1ZmZlcnMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0XHRfZ2wuZHJhd0J1ZmZlcnMoX2N1cnJlbnREcmF3QnVmZmVycyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9kcmF3X2J1ZmZlcnMnKS5kcmF3QnVmZmVyc1dFQkdMKF9jdXJyZW50RHJhd0J1ZmZlcnMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS52aWV3cG9ydChfY3VycmVudFZpZXdwb3J0KTtcblx0XHRcdHN0YXRlLnNjaXNzb3IoX2N1cnJlbnRTY2lzc29yKTtcblx0XHRcdHN0YXRlLnNldFNjaXNzb3JUZXN0KF9jdXJyZW50U2Npc3NvclRlc3QpO1xuXG5cdFx0XHRpZiAoaXNDdWJlKSB7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0LnRleHR1cmUpO1xuXG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgYWN0aXZlTWlwbWFwTGV2ZWwpO1xuXHRcdFx0fSBlbHNlIGlmIChpc1JlbmRlclRhcmdldDNEKSB7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0LnRleHR1cmUpO1xuXHRcdFx0XHRjb25zdCBsYXllciA9IGFjdGl2ZUN1YmVGYWNlIHx8IDA7XG5cblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgYWN0aXZlTWlwbWFwTGV2ZWwgfHwgMCwgbGF5ZXIpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIsIGFjdGl2ZUN1YmVGYWNlSW5kZXgpIHtcblx0XHRcdGlmICghKHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCkpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxldCBmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCkuX193ZWJnbEZyYW1lYnVmZmVyO1xuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ICYmIGFjdGl2ZUN1YmVGYWNlSW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyW2FjdGl2ZUN1YmVGYWNlSW5kZXhdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZnJhbWVidWZmZXIpIHtcblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlVHlwZSA9IHRleHR1cmUudHlwZTtcblxuXHRcdFx0XHRcdGlmICh0ZXh0dXJlRm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHV0aWxzLmNvbnZlcnQodGV4dHVyZUZvcm1hdCkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfRk9STUFUKSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuJyk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgaGFsZkZsb2F0U3VwcG9ydGVkQnlFeHQgPSB0ZXh0dXJlVHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiAoZXh0ZW5zaW9ucy5oYXMoJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcpIHx8IGNhcGFiaWxpdGllcy5pc1dlYkdMMiAmJiBleHRlbnNpb25zLmhhcygnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpKTtcblxuXHRcdFx0XHRcdGlmICh0ZXh0dXJlVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSAmJiB1dGlscy5jb252ZXJ0KHRleHR1cmVUeXBlKSAhPT0gX2dsLmdldFBhcmFtZXRlcihfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFKSAmJiAvLyBFZGdlIGFuZCBDaHJvbWUgTWFjIDwgNTIgKCM5NTEzKVxuXHRcdFx0XHRcdCEodGV4dHVyZVR5cGUgPT09IEZsb2F0VHlwZSAmJiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCdPRVNfdGV4dHVyZV9mbG9hdCcpIHx8IGV4dGVuc2lvbnMuaGFzKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSkpICYmIC8vIENocm9tZSBNYWMgPj0gNTIgYW5kIEZpcmVmb3hcblx0XHRcdFx0XHQhaGFsZkZsb2F0U3VwcG9ydGVkQnlFeHQpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS4nKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoX2dsLkZSQU1FQlVGRkVSKSA9PT0gX2dsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudCBlbnN1cmVzIHZhbGlkIHJlYWQgcmVxdWVzdHMgKG5vIG91dC1vZi1ib3VuZHMgcGl4ZWxzLCBzZWUgIzg2MDQpXG5cdFx0XHRcdFx0XHRpZiAoeCA+PSAwICYmIHggPD0gcmVuZGVyVGFyZ2V0LndpZHRoIC0gd2lkdGggJiYgeSA+PSAwICYmIHkgPD0gcmVuZGVyVGFyZ2V0LmhlaWdodCAtIGhlaWdodCkge1xuXHRcdFx0XHRcdFx0XHRfZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB1dGlscy5jb252ZXJ0KHRleHR1cmVGb3JtYXQpLCB1dGlscy5jb252ZXJ0KHRleHR1cmVUeXBlKSwgYnVmZmVyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZWFkUGl4ZWxzIGZyb20gcmVuZGVyVGFyZ2V0IGZhaWxlZC4gRnJhbWVidWZmZXIgbm90IGNvbXBsZXRlLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHQvLyByZXN0b3JlIGZyYW1lYnVmZmVyIG9mIGN1cnJlbnQgcmVuZGVyIHRhcmdldCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRjb25zdCBmcmFtZWJ1ZmZlciA9IF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsID8gcHJvcGVydGllcy5nZXQoX2N1cnJlbnRSZW5kZXJUYXJnZXQpLl9fd2ViZ2xGcmFtZWJ1ZmZlciA6IG51bGw7XG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB0ZXh0dXJlLCBsZXZlbCA9IDApIHtcblx0XHRcdGNvbnN0IGxldmVsU2NhbGUgPSBNYXRoLnBvdygyLCAtbGV2ZWwpO1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKHRleHR1cmUuaW1hZ2Uud2lkdGggKiBsZXZlbFNjYWxlKTtcblx0XHRcdGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3IodGV4dHVyZS5pbWFnZS5oZWlnaHQgKiBsZXZlbFNjYWxlKTtcblx0XHRcdGxldCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS5mb3JtYXQpO1xuXG5cdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyKSB7XG5cdFx0XHRcdC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTExMjAxMDBcblx0XHRcdFx0Ly8gTm90IG5lZWRlZCBpbiBDaHJvbWUgOTMrXG5cdFx0XHRcdGlmIChnbEZvcm1hdCA9PT0gX2dsLlJHQikgZ2xGb3JtYXQgPSBfZ2wuUkdCODtcblx0XHRcdFx0aWYgKGdsRm9ybWF0ID09PSBfZ2wuUkdCQSkgZ2xGb3JtYXQgPSBfZ2wuUkdCQTg7XG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCh0ZXh0dXJlLCAwKTtcblxuXHRcdFx0X2dsLmNvcHlUZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBsZXZlbCwgZ2xGb3JtYXQsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHdpZHRoLCBoZWlnaHQsIDApO1xuXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuY29weVRleHR1cmVUb1RleHR1cmUgPSBmdW5jdGlvbiAocG9zaXRpb24sIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIGxldmVsID0gMCkge1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBzcmNUZXh0dXJlLmltYWdlLndpZHRoO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gc3JjVGV4dHVyZS5pbWFnZS5oZWlnaHQ7XG5cdFx0XHRjb25zdCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoZHN0VGV4dHVyZS5mb3JtYXQpO1xuXHRcdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydChkc3RUZXh0dXJlLnR5cGUpO1xuXHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKGRzdFRleHR1cmUsIDApOyAvLyBBcyBhbm90aGVyIHRleHR1cmUgdXBsb2FkIG1heSBoYXZlIGNoYW5nZWQgcGl4ZWxTdG9yZWlcblx0XHRcdC8vIHBhcmFtZXRlcnMsIG1ha2Ugc3VyZSB0aGV5IGFyZSBjb3JyZWN0IGZvciB0aGUgZHN0VGV4dHVyZVxuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIGRzdFRleHR1cmUuZmxpcFkpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZHN0VGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfQUxJR05NRU5ULCBkc3RUZXh0dXJlLnVucGFja0FsaWdubWVudCk7XG5cblx0XHRcdGlmIChzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUpIHtcblx0XHRcdFx0X2dsLnRleFN1YkltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB3aWR0aCwgaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBzcmNUZXh0dXJlLmltYWdlLmRhdGEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHNyY1RleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSkge1xuXHRcdFx0XHRcdF9nbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHNyY1RleHR1cmUubWlwbWFwc1swXS53aWR0aCwgc3JjVGV4dHVyZS5taXBtYXBzWzBdLmhlaWdodCwgZ2xGb3JtYXQsIHNyY1RleHR1cmUubWlwbWFwc1swXS5kYXRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZ2wudGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIGdsRm9ybWF0LCBnbFR5cGUsIHNyY1RleHR1cmUuaW1hZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIEdlbmVyYXRlIG1pcG1hcHMgb25seSB3aGVuIGNvcHlpbmcgbGV2ZWwgMFxuXG5cblx0XHRcdGlmIChsZXZlbCA9PT0gMCAmJiBkc3RUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcykgX2dsLmdlbmVyYXRlTWlwbWFwKF9nbC5URVhUVVJFXzJEKTtcblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEID0gZnVuY3Rpb24gKHNvdXJjZUJveCwgcG9zaXRpb24sIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIGxldmVsID0gMCkge1xuXHRcdFx0aWYgKF90aGlzLmlzV2ViR0wxUmVuZGVyZXIpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgd2lkdGggPSBzb3VyY2VCb3gubWF4LnggLSBzb3VyY2VCb3gubWluLnggKyAxO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gc291cmNlQm94Lm1heC55IC0gc291cmNlQm94Lm1pbi55ICsgMTtcblx0XHRcdGNvbnN0IGRlcHRoID0gc291cmNlQm94Lm1heC56IC0gc291cmNlQm94Lm1pbi56ICsgMTtcblx0XHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydChkc3RUZXh0dXJlLmZvcm1hdCk7XG5cdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KGRzdFRleHR1cmUudHlwZSk7XG5cdFx0XHRsZXQgZ2xUYXJnZXQ7XG5cblx0XHRcdGlmIChkc3RUZXh0dXJlLmlzRGF0YVRleHR1cmUzRCkge1xuXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlM0QoZHN0VGV4dHVyZSwgMCk7XG5cdFx0XHRcdGdsVGFyZ2V0ID0gX2dsLlRFWFRVUkVfM0Q7XG5cdFx0XHR9IGVsc2UgaWYgKGRzdFRleHR1cmUuaXNEYXRhVGV4dHVyZTJEQXJyYXkpIHtcblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEQXJyYXkoZHN0VGV4dHVyZSwgMCk7XG5cdFx0XHRcdGdsVGFyZ2V0ID0gX2dsLlRFWFRVUkVfMkRfQVJSQVk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXIuY29weVRleHR1cmVUb1RleHR1cmUzRDogb25seSBzdXBwb3J0cyBUSFJFRS5EYXRhVGV4dHVyZTNEIGFuZCBUSFJFRS5EYXRhVGV4dHVyZTJEQXJyYXkuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBkc3RUZXh0dXJlLmZsaXBZKTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGRzdFRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgZHN0VGV4dHVyZS51bnBhY2tBbGlnbm1lbnQpO1xuXG5cdFx0XHRjb25zdCB1bnBhY2tSb3dMZW4gPSBfZ2wuZ2V0UGFyYW1ldGVyKF9nbC5VTlBBQ0tfUk9XX0xFTkdUSCk7XG5cblx0XHRcdGNvbnN0IHVucGFja0ltYWdlSGVpZ2h0ID0gX2dsLmdldFBhcmFtZXRlcihfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCk7XG5cblx0XHRcdGNvbnN0IHVucGFja1NraXBQaXhlbHMgPSBfZ2wuZ2V0UGFyYW1ldGVyKF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMpO1xuXG5cdFx0XHRjb25zdCB1bnBhY2tTa2lwUm93cyA9IF9nbC5nZXRQYXJhbWV0ZXIoX2dsLlVOUEFDS19TS0lQX1JPV1MpO1xuXG5cdFx0XHRjb25zdCB1bnBhY2tTa2lwSW1hZ2VzID0gX2dsLmdldFBhcmFtZXRlcihfZ2wuVU5QQUNLX1NLSVBfSU1BR0VTKTtcblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBzcmNUZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgPyBzcmNUZXh0dXJlLm1pcG1hcHNbMF0gOiBzcmNUZXh0dXJlLmltYWdlO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19ST1dfTEVOR1RILCBpbWFnZS53aWR0aCk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCwgaW1hZ2UuaGVpZ2h0KTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIHNvdXJjZUJveC5taW4ueCk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1NLSVBfUk9XUywgc291cmNlQm94Lm1pbi55KTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfU0tJUF9JTUFHRVMsIHNvdXJjZUJveC5taW4ueik7XG5cblx0XHRcdGlmIChzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUgfHwgc3JjVGV4dHVyZS5pc0RhdGFUZXh0dXJlM0QpIHtcblx0XHRcdFx0X2dsLnRleFN1YkltYWdlM0QoZ2xUYXJnZXQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoc3JjVGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IHVudGVzdGVkIHN1cHBvcnQgZm9yIGNvbXByZXNzZWQgc3JjVGV4dHVyZS4nKTtcblxuXHRcdFx0XHRcdF9nbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRChnbFRhcmdldCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgaW1hZ2UuZGF0YSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2dsLnRleFN1YkltYWdlM0QoZ2xUYXJnZXQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1JPV19MRU5HVEgsIHVucGFja1Jvd0xlbik7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCwgdW5wYWNrSW1hZ2VIZWlnaHQpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19TS0lQX1BJWEVMUywgdW5wYWNrU2tpcFBpeGVscyk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1NLSVBfUk9XUywgdW5wYWNrU2tpcFJvd3MpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19TS0lQX0lNQUdFUywgdW5wYWNrU2tpcEltYWdlcyk7IC8vIEdlbmVyYXRlIG1pcG1hcHMgb25seSB3aGVuIGNvcHlpbmcgbGV2ZWwgMFxuXG5cblx0XHRcdGlmIChsZXZlbCA9PT0gMCAmJiBkc3RUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcykgX2dsLmdlbmVyYXRlTWlwbWFwKGdsVGFyZ2V0KTtcblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5pbml0VGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG5cdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQodGV4dHVyZSwgMCk7XG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMucmVzZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdF9jdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSAwO1xuXHRcdFx0X2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IDA7XG5cdFx0XHRfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG5cdFx0XHRzdGF0ZS5yZXNldCgpO1xuXHRcdFx0YmluZGluZ1N0YXRlcy5yZXNldCgpO1xuXHRcdH07XG5cblx0XHRpZiAodHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdF9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb2JzZXJ2ZScsIHtcblx0XHRcdFx0ZGV0YWlsOiB0aGlzXG5cdFx0XHR9KSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHRcdH1cblx0fVxuXG5cdGNsYXNzIFdlYkdMMVJlbmRlcmVyIGV4dGVuZHMgV2ViR0xSZW5kZXJlciB7fVxuXG5cdFdlYkdMMVJlbmRlcmVyLnByb3RvdHlwZS5pc1dlYkdMMVJlbmRlcmVyID0gdHJ1ZTtcblxuXHRjbGFzcyBGb2dFeHAyIHtcblx0XHRjb25zdHJ1Y3Rvcihjb2xvciwgZGVuc2l0eSA9IDAuMDAwMjUpIHtcblx0XHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcihjb2xvcik7XG5cdFx0XHR0aGlzLmRlbnNpdHkgPSBkZW5zaXR5O1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBGb2dFeHAyKHRoaXMuY29sb3IsIHRoaXMuZGVuc2l0eSk7XG5cdFx0fVxuXG5cdFx0dG9KU09OKClcblx0XHQvKiBtZXRhICovXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dHlwZTogJ0ZvZ0V4cDInLFxuXHRcdFx0XHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcblx0XHRcdFx0ZGVuc2l0eTogdGhpcy5kZW5zaXR5XG5cdFx0XHR9O1xuXHRcdH1cblxuXHR9XG5cblx0Rm9nRXhwMi5wcm90b3R5cGUuaXNGb2dFeHAyID0gdHJ1ZTtcblxuXHRjbGFzcyBGb2cge1xuXHRcdGNvbnN0cnVjdG9yKGNvbG9yLCBuZWFyID0gMSwgZmFyID0gMTAwMCkge1xuXHRcdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcblx0XHRcdHRoaXMubmVhciA9IG5lYXI7XG5cdFx0XHR0aGlzLmZhciA9IGZhcjtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgRm9nKHRoaXMuY29sb3IsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpXG5cdFx0LyogbWV0YSAqL1xuXHRcdHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHR5cGU6ICdGb2cnLFxuXHRcdFx0XHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcblx0XHRcdFx0bmVhcjogdGhpcy5uZWFyLFxuXHRcdFx0XHRmYXI6IHRoaXMuZmFyXG5cdFx0XHR9O1xuXHRcdH1cblxuXHR9XG5cblx0Rm9nLnByb3RvdHlwZS5pc0ZvZyA9IHRydWU7XG5cblx0Y2xhc3MgU2NlbmUgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1NjZW5lJztcblx0XHRcdHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG5cdFx0XHR0aGlzLmVudmlyb25tZW50ID0gbnVsbDtcblx0XHRcdHRoaXMuZm9nID0gbnVsbDtcblx0XHRcdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cdFx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxuXG5cdFx0XHRpZiAodHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0X19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdvYnNlcnZlJywge1xuXHRcdFx0XHRcdGRldGFpbDogdGhpc1xuXHRcdFx0XHR9KSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlLCByZWN1cnNpdmUpO1xuXHRcdFx0aWYgKHNvdXJjZS5iYWNrZ3JvdW5kICE9PSBudWxsKSB0aGlzLmJhY2tncm91bmQgPSBzb3VyY2UuYmFja2dyb3VuZC5jbG9uZSgpO1xuXHRcdFx0aWYgKHNvdXJjZS5lbnZpcm9ubWVudCAhPT0gbnVsbCkgdGhpcy5lbnZpcm9ubWVudCA9IHNvdXJjZS5lbnZpcm9ubWVudC5jbG9uZSgpO1xuXHRcdFx0aWYgKHNvdXJjZS5mb2cgIT09IG51bGwpIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xuXHRcdFx0aWYgKHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsKSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xuXHRcdFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG5cdFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTihtZXRhKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdFx0aWYgKHRoaXMuZm9nICE9PSBudWxsKSBkYXRhLm9iamVjdC5mb2cgPSB0aGlzLmZvZy50b0pTT04oKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0U2NlbmUucHJvdG90eXBlLmlzU2NlbmUgPSB0cnVlO1xuXG5cdGNsYXNzIEludGVybGVhdmVkQnVmZmVyIHtcblx0XHRjb25zdHJ1Y3RvcihhcnJheSwgc3RyaWRlKSB7XG5cdFx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdFx0XHR0aGlzLnN0cmlkZSA9IHN0cmlkZTtcblx0XHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gc3RyaWRlIDogMDtcblx0XHRcdHRoaXMudXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5cdFx0XHR0aGlzLnVwZGF0ZVJhbmdlID0ge1xuXHRcdFx0XHRvZmZzZXQ6IDAsXG5cdFx0XHRcdGNvdW50OiAtMVxuXHRcdFx0fTtcblx0XHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cdFx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0XHR9XG5cblx0XHRvblVwbG9hZENhbGxiYWNrKCkge31cblxuXHRcdHNldCBuZWVkc1VwZGF0ZSh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLnZlcnNpb24rKztcblx0XHR9XG5cblx0XHRzZXRVc2FnZSh2YWx1ZSkge1xuXHRcdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKHNvdXJjZS5hcnJheSk7XG5cdFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdFx0dGhpcy5zdHJpZGUgPSBzb3VyY2Uuc3RyaWRlO1xuXHRcdFx0dGhpcy51c2FnZSA9IHNvdXJjZS51c2FnZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHlBdChpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyKSB7XG5cdFx0XHRpbmRleDEgKj0gdGhpcy5zdHJpZGU7XG5cdFx0XHRpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLnN0cmlkZTsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0aGlzLmFycmF5W2luZGV4MSArIGldID0gYXR0cmlidXRlLmFycmF5W2luZGV4MiArIGldO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXQodmFsdWUsIG9mZnNldCA9IDApIHtcblx0XHRcdHRoaXMuYXJyYXkuc2V0KHZhbHVlLCBvZmZzZXQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoZGF0YSkge1xuXHRcdFx0aWYgKGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZGF0YS5hcnJheUJ1ZmZlcnMgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5hcnJheS5idWZmZXIuX3V1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSA9IHRoaXMuYXJyYXkuc2xpY2UoMCkuYnVmZmVyO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhcnJheSA9IG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSk7XG5cdFx0XHRjb25zdCBpYiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGFycmF5LCB0aGlzLnN0cmlkZSk7XG5cdFx0XHRpYi5zZXRVc2FnZSh0aGlzLnVzYWdlKTtcblx0XHRcdHJldHVybiBpYjtcblx0XHR9XG5cblx0XHRvblVwbG9hZChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oZGF0YSkge1xuXHRcdFx0aWYgKGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZGF0YS5hcnJheUJ1ZmZlcnMgPSB7fTtcblx0XHRcdH0gLy8gZ2VuZXJhdGUgVVVJRCBmb3IgYXJyYXkgYnVmZmVyIGlmIG5lY2Vzc2FyeVxuXG5cblx0XHRcdGlmICh0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLmFycmF5QnVmZmVyc1t0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRkYXRhLmFycmF5QnVmZmVyc1t0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZF0gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheS5idWZmZXIpKTtcblx0XHRcdH0gLy9cblxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHRcdGJ1ZmZlcjogdGhpcy5hcnJheS5idWZmZXIuX3V1aWQsXG5cdFx0XHRcdHR5cGU6IHRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0c3RyaWRlOiB0aGlzLnN0cmlkZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0fVxuXG5cdEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5pc0ludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcblxuXHRjb25zdCBfdmVjdG9yJDYgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdFx0Y29uc3RydWN0b3IoaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIG5vcm1hbGl6ZWQgPSBmYWxzZSkge1xuXHRcdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0XHR0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcblx0XHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0XHRcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZCA9PT0gdHJ1ZTtcblx0XHR9XG5cblx0XHRnZXQgY291bnQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmNvdW50O1xuXHRcdH1cblxuXHRcdGdldCBhcnJheSgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXk7XG5cdFx0fVxuXG5cdFx0c2V0IG5lZWRzVXBkYXRlKHZhbHVlKSB7XG5cdFx0XHR0aGlzLmRhdGEubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDQobSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmRhdGEuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0X3ZlY3RvciQ2LnggPSB0aGlzLmdldFgoaSk7XG5cdFx0XHRcdF92ZWN0b3IkNi55ID0gdGhpcy5nZXRZKGkpO1xuXHRcdFx0XHRfdmVjdG9yJDYueiA9IHRoaXMuZ2V0WihpKTtcblxuXHRcdFx0XHRfdmVjdG9yJDYuYXBwbHlNYXRyaXg0KG0pO1xuXG5cdFx0XHRcdHRoaXMuc2V0WFlaKGksIF92ZWN0b3IkNi54LCBfdmVjdG9yJDYueSwgX3ZlY3RvciQ2LnopO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhcHBseU5vcm1hbE1hdHJpeChtKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0X3ZlY3RvciQ2LnggPSB0aGlzLmdldFgoaSk7XG5cdFx0XHRcdF92ZWN0b3IkNi55ID0gdGhpcy5nZXRZKGkpO1xuXHRcdFx0XHRfdmVjdG9yJDYueiA9IHRoaXMuZ2V0WihpKTtcblxuXHRcdFx0XHRfdmVjdG9yJDYuYXBwbHlOb3JtYWxNYXRyaXgobSk7XG5cblx0XHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ2LngsIF92ZWN0b3IkNi55LCBfdmVjdG9yJDYueik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRyYW5zZm9ybURpcmVjdGlvbihtKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0X3ZlY3RvciQ2LnggPSB0aGlzLmdldFgoaSk7XG5cdFx0XHRcdF92ZWN0b3IkNi55ID0gdGhpcy5nZXRZKGkpO1xuXHRcdFx0XHRfdmVjdG9yJDYueiA9IHRoaXMuZ2V0WihpKTtcblxuXHRcdFx0XHRfdmVjdG9yJDYudHJhbnNmb3JtRGlyZWN0aW9uKG0pO1xuXG5cdFx0XHRcdHRoaXMuc2V0WFlaKGksIF92ZWN0b3IkNi54LCBfdmVjdG9yJDYueSwgX3ZlY3RvciQ2LnopO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRYKGluZGV4LCB4KSB7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXRdID0geDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFkoaW5kZXgsIHkpIHtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDFdID0geTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFooaW5kZXgsIHopIHtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDJdID0gejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFcoaW5kZXgsIHcpIHtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDNdID0gdztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldFgoaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXRdO1xuXHRcdH1cblxuXHRcdGdldFkoaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxXTtcblx0XHR9XG5cblx0XHRnZXRaKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMl07XG5cdFx0fVxuXG5cdFx0Z2V0VyhpbmRleCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDNdO1xuXHRcdH1cblxuXHRcdHNldFhZKGluZGV4LCB4LCB5KSB7XG5cdFx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMF0gPSB4O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WFlaKGluZGV4LCB4LCB5LCB6KSB7XG5cdFx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMF0gPSB4O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMl0gPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WFlaVyhpbmRleCwgeCwgeSwgeiwgdykge1xuXHRcdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCArIDBdID0geDtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCArIDFdID0geTtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCArIDJdID0gejtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCArIDNdID0gdztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsb25lKGRhdGEpIHtcblx0XHRcdGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1RIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLmNsb25lKCk6IENsb25pbmcgYW4gaW50ZXJsYXZlZCBidWZmZXIgYXR0cmlidXRlIHdpbGwgZGVpbnRlcmxlYXZlIGJ1ZmZlciBkYXRhLicpO1xuXHRcdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLml0ZW1TaXplOyBqKyspIHtcblx0XHRcdFx0XHRcdGFycmF5LnB1c2godGhpcy5kYXRhLmFycmF5W2luZGV4ICsgal0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKGFycmF5KSwgdGhpcy5pdGVtU2l6ZSwgdGhpcy5ub3JtYWxpemVkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChkYXRhLmludGVybGVhdmVkQnVmZmVycyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnMgPSB7fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkYXRhLmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzW3RoaXMuZGF0YS51dWlkXSA9IHRoaXMuZGF0YS5jbG9uZShkYXRhKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdLCB0aGlzLml0ZW1TaXplLCB0aGlzLm9mZnNldCwgdGhpcy5ub3JtYWxpemVkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0b0pTT04oZGF0YSkge1xuXHRcdFx0aWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUudG9KU09OKCk6IFNlcmlhbGl6aW5nIGFuIGludGVybGF2ZWQgYnVmZmVyIGF0dHJpYnV0ZSB3aWxsIGRlaW50ZXJsZWF2ZSBidWZmZXIgZGF0YS4nKTtcblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gaSAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5pdGVtU2l6ZTsgaisrKSB7XG5cdFx0XHRcdFx0XHRhcnJheS5wdXNoKHRoaXMuZGF0YS5hcnJheVtpbmRleCArIGpdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gZGVpbnRlcmxlYXZlIGRhdGEgYW5kIHNhdmUgaXQgYXMgYW4gb3JkaW5hcnkgYnVmZmVyIGF0dHJpYnV0ZSBmb3Igbm93XG5cblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0XHRcdHR5cGU6IHRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0XHRhcnJheTogYXJyYXksXG5cdFx0XHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBzYXZlIGFzIHRydWUgaW50ZXJsYXZlZCBhdHRyaWJ0dWVcblx0XHRcdFx0aWYgKGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVycyA9IHt9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzW3RoaXMuZGF0YS51dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdID0gdGhpcy5kYXRhLnRvSlNPTihkYXRhKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZTogdHJ1ZSxcblx0XHRcdFx0XHRpdGVtU2l6ZTogdGhpcy5pdGVtU2l6ZSxcblx0XHRcdFx0XHRkYXRhOiB0aGlzLmRhdGEudXVpZCxcblx0XHRcdFx0XHRvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuXHRcdFx0XHRcdG5vcm1hbGl6ZWQ6IHRoaXMubm9ybWFsaXplZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlx0Y29sb3I6IDxoZXg+LFxuXHQgKlx0bWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0YWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRyb3RhdGlvbjogPGZsb2F0Pixcblx0ICpcdHNpemVBdHRlbnVhdGlvbjogPGJvb2w+XG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgU3ByaXRlTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTtcblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cdFx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XG5cdFx0XHR0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0XHR0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xuXHRcdFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuaXNTcHJpdGVNYXRlcmlhbCA9IHRydWU7XG5cblx0bGV0IF9nZW9tZXRyeTtcblxuXHRjb25zdCBfaW50ZXJzZWN0UG9pbnQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfd29ybGRTY2FsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9tdlBvc2l0aW9uID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2FsaWduZWRQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpO1xuXG5cdGNvbnN0IF9yb3RhdGVkUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxuXHRjb25zdCBfdmlld1dvcmxkTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX3ZBID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3ZCID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3ZDID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3V2QSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpO1xuXG5cdGNvbnN0IF91dkIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxuXHRjb25zdCBfdXZDID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cblx0Y2xhc3MgU3ByaXRlIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKG1hdGVyaWFsKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1Nwcml0ZSc7XG5cblx0XHRcdGlmIChfZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRfZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdFx0Y29uc3QgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbLTAuNSwgLTAuNSwgMCwgMCwgMCwgMC41LCAtMC41LCAwLCAxLCAwLCAwLjUsIDAuNSwgMCwgMSwgMSwgLTAuNSwgMC41LCAwLCAwLCAxXSk7XG5cdFx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKGZsb2F0MzJBcnJheSwgNSk7XG5cblx0XHRcdFx0X2dlb21ldHJ5LnNldEluZGV4KFswLCAxLCAyLCAwLCAyLCAzXSk7XG5cblx0XHRcdFx0X2dlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIDMsIDAsIGZhbHNlKSk7XG5cblx0XHRcdFx0X2dlb21ldHJ5LnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIDIsIDMsIGZhbHNlKSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ2VvbWV0cnkgPSBfZ2VvbWV0cnk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFNwcml0ZU1hdGVyaWFsKCk7XG5cdFx0XHR0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IyKDAuNSwgMC41KTtcblx0XHR9XG5cblx0XHRyYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuXHRcdFx0aWYgKHJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuU3ByaXRlOiBcIlJheWNhc3Rlci5jYW1lcmFcIiBuZWVkcyB0byBiZSBzZXQgaW4gb3JkZXIgdG8gcmF5Y2FzdCBhZ2FpbnN0IHNwcml0ZXMuJyk7XG5cdFx0XHR9XG5cblx0XHRcdF93b3JsZFNjYWxlLnNldEZyb21NYXRyaXhTY2FsZSh0aGlzLm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0X3ZpZXdXb3JsZE1hdHJpeC5jb3B5KHJheWNhc3Rlci5jYW1lcmEubWF0cml4V29ybGQpO1xuXG5cdFx0XHR0aGlzLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKHJheWNhc3Rlci5jYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCB0aGlzLm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0X212UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubW9kZWxWaWV3TWF0cml4KTtcblxuXHRcdFx0aWYgKHJheWNhc3Rlci5jYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSAmJiB0aGlzLm1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9PT0gZmFsc2UpIHtcblx0XHRcdFx0X3dvcmxkU2NhbGUubXVsdGlwbHlTY2FsYXIoLV9tdlBvc2l0aW9uLnopO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByb3RhdGlvbiA9IHRoaXMubWF0ZXJpYWwucm90YXRpb247XG5cdFx0XHRsZXQgc2luLCBjb3M7XG5cblx0XHRcdGlmIChyb3RhdGlvbiAhPT0gMCkge1xuXHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG5cdFx0XHRcdHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG5cdFx0XHR0cmFuc2Zvcm1WZXJ0ZXgoX3ZBLnNldCgtMC41LCAtMC41LCAwKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zKTtcblx0XHRcdHRyYW5zZm9ybVZlcnRleChfdkIuc2V0KDAuNSwgLTAuNSwgMCksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyk7XG5cdFx0XHR0cmFuc2Zvcm1WZXJ0ZXgoX3ZDLnNldCgwLjUsIDAuNSwgMCksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyk7XG5cblx0XHRcdF91dkEuc2V0KDAsIDApO1xuXG5cdFx0XHRfdXZCLnNldCgxLCAwKTtcblxuXHRcdFx0X3V2Qy5zZXQoMSwgMSk7IC8vIGNoZWNrIGZpcnN0IHRyaWFuZ2xlXG5cblxuXHRcdFx0bGV0IGludGVyc2VjdCA9IHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0VHJpYW5nbGUoX3ZBLCBfdkIsIF92QywgZmFsc2UsIF9pbnRlcnNlY3RQb2ludCk7XG5cblx0XHRcdGlmIChpbnRlcnNlY3QgPT09IG51bGwpIHtcblx0XHRcdFx0Ly8gY2hlY2sgc2Vjb25kIHRyaWFuZ2xlXG5cdFx0XHRcdHRyYW5zZm9ybVZlcnRleChfdkIuc2V0KC0wLjUsIDAuNSwgMCksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyk7XG5cblx0XHRcdFx0X3V2Qi5zZXQoMCwgMSk7XG5cblx0XHRcdFx0aW50ZXJzZWN0ID0gcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RUcmlhbmdsZShfdkEsIF92QywgX3ZCLCBmYWxzZSwgX2ludGVyc2VjdFBvaW50KTtcblxuXHRcdFx0XHRpZiAoaW50ZXJzZWN0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhfaW50ZXJzZWN0UG9pbnQpO1xuXHRcdFx0aWYgKGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyKSByZXR1cm47XG5cdFx0XHRpbnRlcnNlY3RzLnB1c2goe1xuXHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdHBvaW50OiBfaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcblx0XHRcdFx0dXY6IFRyaWFuZ2xlLmdldFVWKF9pbnRlcnNlY3RQb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFZlY3RvcjIoKSksXG5cdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdG9iamVjdDogdGhpc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdGlmIChzb3VyY2UuY2VudGVyICE9PSB1bmRlZmluZWQpIHRoaXMuY2VudGVyLmNvcHkoc291cmNlLmNlbnRlcik7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gc291cmNlLm1hdGVyaWFsO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRTcHJpdGUucHJvdG90eXBlLmlzU3ByaXRlID0gdHJ1ZTtcblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1WZXJ0ZXgodmVydGV4UG9zaXRpb24sIG12UG9zaXRpb24sIGNlbnRlciwgc2NhbGUsIHNpbiwgY29zKSB7XG5cdFx0Ly8gY29tcHV0ZSBwb3NpdGlvbiBpbiBjYW1lcmEgc3BhY2Vcblx0XHRfYWxpZ25lZFBvc2l0aW9uLnN1YlZlY3RvcnModmVydGV4UG9zaXRpb24sIGNlbnRlcikuYWRkU2NhbGFyKDAuNSkubXVsdGlwbHkoc2NhbGUpOyAvLyB0byBjaGVjayBpZiByb3RhdGlvbiBpcyBub3QgemVyb1xuXG5cblx0XHRpZiAoc2luICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdF9yb3RhdGVkUG9zaXRpb24ueCA9IGNvcyAqIF9hbGlnbmVkUG9zaXRpb24ueCAtIHNpbiAqIF9hbGlnbmVkUG9zaXRpb24ueTtcblx0XHRcdF9yb3RhdGVkUG9zaXRpb24ueSA9IHNpbiAqIF9hbGlnbmVkUG9zaXRpb24ueCArIGNvcyAqIF9hbGlnbmVkUG9zaXRpb24ueTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0X3JvdGF0ZWRQb3NpdGlvbi5jb3B5KF9hbGlnbmVkUG9zaXRpb24pO1xuXHRcdH1cblxuXHRcdHZlcnRleFBvc2l0aW9uLmNvcHkobXZQb3NpdGlvbik7XG5cdFx0dmVydGV4UG9zaXRpb24ueCArPSBfcm90YXRlZFBvc2l0aW9uLng7XG5cdFx0dmVydGV4UG9zaXRpb24ueSArPSBfcm90YXRlZFBvc2l0aW9uLnk7IC8vIHRyYW5zZm9ybSB0byB3b3JsZCBzcGFjZVxuXG5cdFx0dmVydGV4UG9zaXRpb24uYXBwbHlNYXRyaXg0KF92aWV3V29ybGRNYXRyaXgpO1xuXHR9XG5cblx0Y29uc3QgX3YxJDIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdjIkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIExPRCBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLl9jdXJyZW50TGV2ZWwgPSAwO1xuXHRcdFx0dGhpcy50eXBlID0gJ0xPRCc7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG5cdFx0XHRcdGxldmVsczoge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IFtdXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGlzTE9EOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSwgZmFsc2UpO1xuXHRcdFx0Y29uc3QgbGV2ZWxzID0gc291cmNlLmxldmVscztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGxldmVsID0gbGV2ZWxzW2ldO1xuXHRcdFx0XHR0aGlzLmFkZExldmVsKGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHNvdXJjZS5hdXRvVXBkYXRlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkTGV2ZWwob2JqZWN0LCBkaXN0YW5jZSA9IDApIHtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UpO1xuXHRcdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cdFx0XHRsZXQgbDtcblxuXHRcdFx0Zm9yIChsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwrKykge1xuXHRcdFx0XHRpZiAoZGlzdGFuY2UgPCBsZXZlbHNbbF0uZGlzdGFuY2UpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXZlbHMuc3BsaWNlKGwsIDAsIHtcblx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmFkZChvYmplY3QpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Q3VycmVudExldmVsKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRMZXZlbDtcblx0XHR9XG5cblx0XHRnZXRPYmplY3RGb3JEaXN0YW5jZShkaXN0YW5jZSkge1xuXHRcdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRcdGlmIChsZXZlbHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRsZXQgaSwgbDtcblxuXHRcdFx0XHRmb3IgKGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmIChkaXN0YW5jZSA8IGxldmVsc1tpXS5kaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGxldmVsc1tpIC0gMV0ub2JqZWN0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuXHRcdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRcdGlmIChsZXZlbHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRfdjEkMi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKF92MSQyKTtcblx0XHRcdFx0dGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZShkaXN0YW5jZSkucmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHVwZGF0ZShjYW1lcmEpIHtcblx0XHRcdGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG5cdFx0XHRpZiAobGV2ZWxzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0X3YxJDIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdFx0X3YyJDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuXG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gX3YxJDIuZGlzdGFuY2VUbyhfdjIkMSkgLyBjYW1lcmEuem9vbTtcblx0XHRcdFx0bGV2ZWxzWzBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblx0XHRcdFx0bGV0IGksIGw7XG5cblx0XHRcdFx0Zm9yIChpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPj0gbGV2ZWxzW2ldLmRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRsZXZlbHNbaSAtIDFdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRsZXZlbHNbaV0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9jdXJyZW50TGV2ZWwgPSBpIC0gMTtcblxuXHRcdFx0XHRmb3IgKDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGxldmVsc1tpXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04obWV0YSk7XG5cdFx0XHRpZiAodGhpcy5hdXRvVXBkYXRlID09PSBmYWxzZSkgZGF0YS5vYmplY3QuYXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0ZGF0YS5vYmplY3QubGV2ZWxzID0gW107XG5cdFx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGxldmVsID0gbGV2ZWxzW2ldO1xuXHRcdFx0XHRkYXRhLm9iamVjdC5sZXZlbHMucHVzaCh7XG5cdFx0XHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcblx0XHRcdFx0XHRkaXN0YW5jZTogbGV2ZWwuZGlzdGFuY2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX2Jhc2VQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9za2luSW5kZXggPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjQoKTtcblxuXHRjb25zdCBfc2tpbldlaWdodCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yNCgpO1xuXG5cdGNvbnN0IF92ZWN0b3IkNSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9tYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjbGFzcyBTa2lubmVkTWVzaCBleHRlbmRzIE1lc2gge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cdFx0XHR0aGlzLmJpbmRNb2RlID0gJ2F0dGFjaGVkJztcblx0XHRcdHRoaXMuYmluZE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5iaW5kTW9kZSA9IHNvdXJjZS5iaW5kTW9kZTtcblx0XHRcdHRoaXMuYmluZE1hdHJpeC5jb3B5KHNvdXJjZS5iaW5kTWF0cml4KTtcblx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weShzb3VyY2UuYmluZE1hdHJpeEludmVyc2UpO1xuXHRcdFx0dGhpcy5za2VsZXRvbiA9IHNvdXJjZS5za2VsZXRvbjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGJpbmQoc2tlbGV0b24sIGJpbmRNYXRyaXgpIHtcblx0XHRcdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuXHRcdFx0aWYgKGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuXHRcdFx0XHR0aGlzLnNrZWxldG9uLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cdFx0XHRcdGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJpbmRNYXRyaXguY29weShiaW5kTWF0cml4KTtcblx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weShiaW5kTWF0cml4KS5pbnZlcnQoKTtcblx0XHR9XG5cblx0XHRwb3NlKCkge1xuXHRcdFx0dGhpcy5za2VsZXRvbi5wb3NlKCk7XG5cdFx0fVxuXG5cdFx0bm9ybWFsaXplU2tpbldlaWdodHMoKSB7XG5cdFx0XHRjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdFx0Y29uc3Qgc2tpbldlaWdodCA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0O1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNraW5XZWlnaHQuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmVjdG9yLnggPSBza2luV2VpZ2h0LmdldFgoaSk7XG5cdFx0XHRcdHZlY3Rvci55ID0gc2tpbldlaWdodC5nZXRZKGkpO1xuXHRcdFx0XHR2ZWN0b3IueiA9IHNraW5XZWlnaHQuZ2V0WihpKTtcblx0XHRcdFx0dmVjdG9yLncgPSBza2luV2VpZ2h0LmdldFcoaSk7XG5cdFx0XHRcdGNvbnN0IHNjYWxlID0gMS4wIC8gdmVjdG9yLm1hbmhhdHRhbkxlbmd0aCgpO1xuXG5cdFx0XHRcdGlmIChzY2FsZSAhPT0gSW5maW5pdHkpIHtcblx0XHRcdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoc2NhbGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZlY3Rvci5zZXQoMSwgMCwgMCwgMCk7IC8vIGRvIHNvbWV0aGluZyByZWFzb25hYmxlXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRza2luV2VpZ2h0LnNldFhZWlcoaSwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiwgdmVjdG9yLncpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG5cdFx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG5cblx0XHRcdGlmICh0aGlzLmJpbmRNb2RlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5iaW5kTW9kZSA9PT0gJ2RldGFjaGVkJykge1xuXHRcdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5iaW5kTWF0cml4KS5pbnZlcnQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuU2tpbm5lZE1lc2g6IFVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJvbmVUcmFuc2Zvcm0oaW5kZXgsIHRhcmdldCkge1xuXHRcdFx0Y29uc3Qgc2tlbGV0b24gPSB0aGlzLnNrZWxldG9uO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0XHRfc2tpbkluZGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luSW5kZXgsIGluZGV4KTtcblxuXHRcdFx0X3NraW5XZWlnaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShnZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQsIGluZGV4KTtcblxuXHRcdFx0X2Jhc2VQb3NpdGlvbi5mcm9tQnVmZmVyQXR0cmlidXRlKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24sIGluZGV4KS5hcHBseU1hdHJpeDQodGhpcy5iaW5kTWF0cml4KTtcblxuXHRcdFx0dGFyZ2V0LnNldCgwLCAwLCAwKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgd2VpZ2h0ID0gX3NraW5XZWlnaHQuZ2V0Q29tcG9uZW50KGkpO1xuXG5cdFx0XHRcdGlmICh3ZWlnaHQgIT09IDApIHtcblx0XHRcdFx0XHRjb25zdCBib25lSW5kZXggPSBfc2tpbkluZGV4LmdldENvbXBvbmVudChpKTtcblxuXHRcdFx0XHRcdF9tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhza2VsZXRvbi5ib25lc1tib25lSW5kZXhdLm1hdHJpeFdvcmxkLCBza2VsZXRvbi5ib25lSW52ZXJzZXNbYm9uZUluZGV4XSk7XG5cblx0XHRcdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKF92ZWN0b3IkNS5jb3B5KF9iYXNlUG9zaXRpb24pLmFwcGx5TWF0cml4NChfbWF0cml4KSwgd2VpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmFwcGx5TWF0cml4NCh0aGlzLmJpbmRNYXRyaXhJbnZlcnNlKTtcblx0XHR9XG5cblx0fVxuXG5cdFNraW5uZWRNZXNoLnByb3RvdHlwZS5pc1NraW5uZWRNZXNoID0gdHJ1ZTtcblxuXHRjbGFzcyBCb25lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdCb25lJztcblx0XHR9XG5cblx0fVxuXG5cdEJvbmUucHJvdG90eXBlLmlzQm9uZSA9IHRydWU7XG5cblx0Y2xhc3MgRGF0YVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0XHRjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlciwgbWluRmlsdGVyID0gTmVhcmVzdEZpbHRlciwgYW5pc290cm9weSwgZW5jb2RpbmcpIHtcblx0XHRcdHN1cGVyKG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcpO1xuXHRcdFx0dGhpcy5pbWFnZSA9IHtcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0fTtcblx0XHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyO1xuXHRcdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdH1cblxuXHREYXRhVGV4dHVyZS5wcm90b3R5cGUuaXNEYXRhVGV4dHVyZSA9IHRydWU7XG5cblx0Y29uc3QgX29mZnNldE1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF9pZGVudGl0eU1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNsYXNzIFNrZWxldG9uIHtcblx0XHRjb25zdHJ1Y3Rvcihib25lcyA9IFtdLCBib25lSW52ZXJzZXMgPSBbXSkge1xuXHRcdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdFx0XHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoMCk7XG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcztcblx0XHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbnVsbDtcblx0XHRcdHRoaXMuYm9uZVRleHR1cmUgPSBudWxsO1xuXHRcdFx0dGhpcy5ib25lVGV4dHVyZVNpemUgPSAwO1xuXHRcdFx0dGhpcy5mcmFtZSA9IC0xO1xuXHRcdFx0dGhpcy5pbml0KCk7XG5cdFx0fVxuXG5cdFx0aW5pdCgpIHtcblx0XHRcdGNvbnN0IGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXHRcdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KGJvbmVzLmxlbmd0aCAqIDE2KTsgLy8gY2FsY3VsYXRlIGludmVyc2UgYm9uZSBtYXRyaWNlcyBpZiBuZWNlc3NhcnlcblxuXHRcdFx0aWYgKGJvbmVJbnZlcnNlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0dGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZVxuXHRcdFx0XHRpZiAoYm9uZXMubGVuZ3RoICE9PSBib25lSW52ZXJzZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Ta2VsZXRvbjogTnVtYmVyIG9mIGludmVyc2UgYm9uZSBtYXRyaWNlcyBkb2VzIG5vdCBtYXRjaCBhbW91bnQgb2YgYm9uZXMuJyk7XG5cdFx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaChuZXcgTWF0cml4NCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjYWxjdWxhdGVJbnZlcnNlcygpIHtcblx0XHRcdHRoaXMuYm9uZUludmVyc2VzLmxlbmd0aCA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0XHRpZiAodGhpcy5ib25lc1tpXSkge1xuXHRcdFx0XHRcdGludmVyc2UuY29weSh0aGlzLmJvbmVzW2ldLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goaW52ZXJzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cG9zZSgpIHtcblx0XHRcdC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGJvbmUgPSB0aGlzLmJvbmVzW2ldO1xuXG5cdFx0XHRcdGlmIChib25lKSB7XG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5jb3B5KHRoaXMuYm9uZUludmVyc2VzW2ldKS5pbnZlcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xuXG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1tpXTtcblxuXHRcdFx0XHRpZiAoYm9uZSkge1xuXHRcdFx0XHRcdGlmIChib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUpIHtcblx0XHRcdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoYm9uZS5wYXJlbnQubWF0cml4V29ybGQpLmludmVydCgpO1xuXHRcdFx0XHRcdFx0Ym9uZS5tYXRyaXgubXVsdGlwbHkoYm9uZS5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoYm9uZS5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR1cGRhdGUoKSB7XG5cdFx0XHRjb25zdCBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0XHRjb25zdCBib25lSW52ZXJzZXMgPSB0aGlzLmJvbmVJbnZlcnNlcztcblx0XHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IHRoaXMuYm9uZU1hdHJpY2VzO1xuXHRcdFx0Y29uc3QgYm9uZVRleHR1cmUgPSB0aGlzLmJvbmVUZXh0dXJlOyAvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuXHRcdFx0XHRjb25zdCBtYXRyaXggPSBib25lc1tpXSA/IGJvbmVzW2ldLm1hdHJpeFdvcmxkIDogX2lkZW50aXR5TWF0cml4O1xuXG5cdFx0XHRcdF9vZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIGJvbmVJbnZlcnNlc1tpXSk7XG5cblx0XHRcdFx0X29mZnNldE1hdHJpeC50b0FycmF5KGJvbmVNYXRyaWNlcywgaSAqIDE2KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJvbmVUZXh0dXJlICE9PSBudWxsKSB7XG5cdFx0XHRcdGJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgU2tlbGV0b24odGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMpO1xuXHRcdH1cblxuXHRcdGNvbXB1dGVCb25lVGV4dHVyZSgpIHtcblx0XHRcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcblx0XHRcdC8vXHRcdFx0UkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcblx0XHRcdC8vXHR3aXRoXHQ4eDhcdHBpeGVsIHRleHR1cmUgbWF4XHQgMTYgYm9uZXMgKiA0IHBpeGVscyA9XHQoOCAqIDgpXG5cdFx0XHQvL1x0XHRcdCAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heFx0IDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcblx0XHRcdC8vXHRcdFx0IDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4XHQyNTYgYm9uZXMgKiA0IHBpeGVscyA9ICgzMiAqIDMyKVxuXHRcdFx0Ly9cdFx0XHQgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXG5cdFx0XHRsZXQgc2l6ZSA9IE1hdGguc3FydCh0aGlzLmJvbmVzLmxlbmd0aCAqIDQpOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XG5cblx0XHRcdHNpemUgPSBjZWlsUG93ZXJPZlR3byhzaXplKTtcblx0XHRcdHNpemUgPSBNYXRoLm1heChzaXplLCA0KTtcblx0XHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIHNpemUgKiA0KTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcblxuXHRcdFx0Ym9uZU1hdHJpY2VzLnNldCh0aGlzLmJvbmVNYXRyaWNlcyk7IC8vIGNvcHkgY3VycmVudCB2YWx1ZXNcblxuXHRcdFx0Y29uc3QgYm9uZVRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoYm9uZU1hdHJpY2VzLCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUpO1xuXHRcdFx0dGhpcy5ib25lTWF0cmljZXMgPSBib25lTWF0cmljZXM7XG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlID0gYm9uZVRleHR1cmU7XG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlU2l6ZSA9IHNpemU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRCb25lQnlOYW1lKG5hbWUpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1tpXTtcblxuXHRcdFx0XHRpZiAoYm9uZS5uYW1lID09PSBuYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0aWYgKHRoaXMuYm9uZVRleHR1cmUgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5ib25lVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0XHRcdHRoaXMuYm9uZVRleHR1cmUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24sIGJvbmVzKSB7XG5cdFx0XHR0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5ib25lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgdXVpZCA9IGpzb24uYm9uZXNbaV07XG5cdFx0XHRcdGxldCBib25lID0gYm9uZXNbdXVpZF07XG5cblx0XHRcdFx0aWYgKGJvbmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuU2tlbGV0b246IE5vIGJvbmUgZm91bmQgd2l0aCBVVUlEOicsIHV1aWQpO1xuXHRcdFx0XHRcdGJvbmUgPSBuZXcgQm9uZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5ib25lcy5wdXNoKGJvbmUpO1xuXHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KGpzb24uYm9uZUludmVyc2VzW2ldKSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdFx0dHlwZTogJ1NrZWxldG9uJyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdTa2VsZXRvbi50b0pTT04nXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGJvbmVzOiBbXSxcblx0XHRcdFx0Ym9uZUludmVyc2VzOiBbXVxuXHRcdFx0fTtcblx0XHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdGNvbnN0IGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGJvbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBib25lID0gYm9uZXNbaV07XG5cdFx0XHRcdGRhdGEuYm9uZXMucHVzaChib25lLnV1aWQpO1xuXHRcdFx0XHRjb25zdCBib25lSW52ZXJzZSA9IGJvbmVJbnZlcnNlc1tpXTtcblx0XHRcdFx0ZGF0YS5ib25lSW52ZXJzZXMucHVzaChib25lSW52ZXJzZS50b0FycmF5KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF9pbnN0YW5jZUxvY2FsTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX2luc3RhbmNlV29ybGRNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfaW5zdGFuY2VJbnRlcnNlY3RzID0gW107XG5cblx0Y29uc3QgX21lc2ggPSAvKkBfX1BVUkVfXyovbmV3IE1lc2goKTtcblxuXHRjbGFzcyBJbnN0YW5jZWRNZXNoIGV4dGVuZHMgTWVzaCB7XG5cdFx0Y29uc3RydWN0b3IoZ2VvbWV0cnksIG1hdGVyaWFsLCBjb3VudCkge1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMuaW5zdGFuY2VNYXRyaXggPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiAxNiksIDE2KTtcblx0XHRcdHRoaXMuaW5zdGFuY2VDb2xvciA9IG51bGw7XG5cdFx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cdFx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5pbnN0YW5jZU1hdHJpeC5jb3B5KHNvdXJjZS5pbnN0YW5jZU1hdHJpeCk7XG5cdFx0XHRpZiAoc291cmNlLmluc3RhbmNlQ29sb3IgIT09IG51bGwpIHRoaXMuaW5zdGFuY2VDb2xvciA9IHNvdXJjZS5pbnN0YW5jZUNvbG9yLmNsb25lKCk7XG5cdFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Q29sb3JBdChpbmRleCwgY29sb3IpIHtcblx0XHRcdGNvbG9yLmZyb21BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyk7XG5cdFx0fVxuXG5cdFx0Z2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCkge1xuXHRcdFx0bWF0cml4LmZyb21BcnJheSh0aGlzLmluc3RhbmNlTWF0cml4LmFycmF5LCBpbmRleCAqIDE2KTtcblx0XHR9XG5cblx0XHRyYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuXHRcdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdFx0Y29uc3QgcmF5Y2FzdFRpbWVzID0gdGhpcy5jb3VudDtcblx0XHRcdF9tZXNoLmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdF9tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblx0XHRcdGlmIChfbWVzaC5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cblx0XHRcdGZvciAobGV0IGluc3RhbmNlSWQgPSAwOyBpbnN0YW5jZUlkIDwgcmF5Y2FzdFRpbWVzOyBpbnN0YW5jZUlkKyspIHtcblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSB3b3JsZCBtYXRyaXggZm9yIGVhY2ggaW5zdGFuY2Vcblx0XHRcdFx0dGhpcy5nZXRNYXRyaXhBdChpbnN0YW5jZUlkLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCk7XG5cblx0XHRcdFx0X2luc3RhbmNlV29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhtYXRyaXhXb3JsZCwgX2luc3RhbmNlTG9jYWxNYXRyaXgpOyAvLyB0aGUgbWVzaCByZXByZXNlbnRzIHRoaXMgc2luZ2xlIGluc3RhbmNlXG5cblxuXHRcdFx0XHRfbWVzaC5tYXRyaXhXb3JsZCA9IF9pbnN0YW5jZVdvcmxkTWF0cml4O1xuXG5cdFx0XHRcdF9tZXNoLnJheWNhc3QocmF5Y2FzdGVyLCBfaW5zdGFuY2VJbnRlcnNlY3RzKTsgLy8gcHJvY2VzcyB0aGUgcmVzdWx0IG9mIHJheWNhc3RcblxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gX2luc3RhbmNlSW50ZXJzZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3QgPSBfaW5zdGFuY2VJbnRlcnNlY3RzW2ldO1xuXHRcdFx0XHRcdGludGVyc2VjdC5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZDtcblx0XHRcdFx0XHRpbnRlcnNlY3Qub2JqZWN0ID0gdGhpcztcblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goaW50ZXJzZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9pbnN0YW5jZUludGVyc2VjdHMubGVuZ3RoID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXRDb2xvckF0KGluZGV4LCBjb2xvcikge1xuXHRcdFx0aWYgKHRoaXMuaW5zdGFuY2VDb2xvciA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmluc3RhbmNlQ29sb3IgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5pbnN0YW5jZU1hdHJpeC5jb3VudCAqIDMpLCAzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29sb3IudG9BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyk7XG5cdFx0fVxuXG5cdFx0c2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCkge1xuXHRcdFx0bWF0cml4LnRvQXJyYXkodGhpcy5pbnN0YW5jZU1hdHJpeC5hcnJheSwgaW5kZXggKiAxNik7XG5cdFx0fVxuXG5cdFx0dXBkYXRlTW9ycGhUYXJnZXRzKCkge31cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHR0eXBlOiAnZGlzcG9zZSdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9XG5cblx0SW5zdGFuY2VkTWVzaC5wcm90b3R5cGUuaXNJbnN0YW5jZWRNZXNoID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNvbG9yOiA8aGV4Pixcblx0ICpcdG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRsaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXHRsaW5lY2FwOiBcInJvdW5kXCIsXG5cdCAqXHRsaW5lam9pbjogXCJyb3VuZFwiXG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgTGluZUJhc2ljTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTtcblx0XHRcdHRoaXMubGluZXdpZHRoID0gMTtcblx0XHRcdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0XHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHRcdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcblx0XHRcdHRoaXMubGluZWNhcCA9IHNvdXJjZS5saW5lY2FwO1xuXHRcdFx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZUJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdGNvbnN0IF9zdGFydCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2VuZCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2ludmVyc2VNYXRyaXgkMSA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF9yYXkkMSA9IC8qQF9fUFVSRV9fKi9uZXcgUmF5KCk7XG5cblx0Y29uc3QgX3NwaGVyZSQxID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcblxuXHRjbGFzcyBMaW5lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCkpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTGluZSc7XG5cdFx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gc291cmNlLm1hdGVyaWFsO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IHNvdXJjZS5nZW9tZXRyeTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHQvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblx0XHRcdFx0aWYgKGdlb21ldHJ5LmluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRcdGNvbnN0IGxpbmVEaXN0YW5jZXMgPSBbMF07XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMSwgbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRfc3RhcnQkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpIC0gMSk7XG5cblx0XHRcdFx0XHRcdF9lbmQkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpKTtcblxuXHRcdFx0XHRcdFx0bGluZURpc3RhbmNlc1tpXSA9IGxpbmVEaXN0YW5jZXNbaSAtIDFdO1xuXHRcdFx0XHRcdFx0bGluZURpc3RhbmNlc1tpXSArPSBfc3RhcnQkMS5kaXN0YW5jZVRvKF9lbmQkMSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdsaW5lRGlzdGFuY2UnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShsaW5lRGlzdGFuY2VzLCAxKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaW5lLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCk6IENvbXB1dGF0aW9uIG9ubHkgcG9zc2libGUgd2l0aCBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChnZW9tZXRyeS5pc0dlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkxpbmUuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKSBubyBsb25nZXIgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnkuIFVzZSBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdFx0Y29uc3QgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5MaW5lLnRocmVzaG9sZDtcblx0XHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTsgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cblx0XHRcdGlmIChnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdF9zcGhlcmUkMS5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKTtcblxuXHRcdFx0X3NwaGVyZSQxLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG5cblx0XHRcdF9zcGhlcmUkMS5yYWRpdXMgKz0gdGhyZXNob2xkO1xuXHRcdFx0aWYgKHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZShfc3BoZXJlJDEpID09PSBmYWxzZSkgcmV0dXJuOyAvL1xuXG5cdFx0XHRfaW52ZXJzZU1hdHJpeCQxLmNvcHkobWF0cml4V29ybGQpLmludmVydCgpO1xuXG5cdFx0XHRfcmF5JDEuY29weShyYXljYXN0ZXIucmF5KS5hcHBseU1hdHJpeDQoX2ludmVyc2VNYXRyaXgkMSk7XG5cblx0XHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCh0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnopIC8gMyk7XG5cdFx0XHRjb25zdCBsb2NhbFRocmVzaG9sZFNxID0gbG9jYWxUaHJlc2hvbGQgKiBsb2NhbFRocmVzaG9sZDtcblx0XHRcdGNvbnN0IHZTdGFydCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB2RW5kID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGludGVyU2VnbWVudCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBpbnRlclJheSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBzdGVwID0gdGhpcy5pc0xpbmVTZWdtZW50cyA/IDIgOiAxO1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBzdGFydCwgbCA9IGVuZCAtIDE7IGkgPCBsOyBpICs9IHN0ZXApIHtcblx0XHRcdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKGkpO1xuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4LmdldFgoaSArIDEpO1xuXHRcdFx0XHRcdFx0dlN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGEpO1xuXHRcdFx0XHRcdFx0dkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBiKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZGlzdFNxID0gX3JheSQxLmRpc3RhbmNlU3FUb1NlZ21lbnQodlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50KTtcblxuXHRcdFx0XHRcdFx0aWYgKGRpc3RTcSA+IGxvY2FsVGhyZXNob2xkU3EpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuXHRcdFx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGludGVyUmF5KTtcblx0XHRcdFx0XHRcdGlmIChkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhcikgY29udGludWU7XG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuXHRcdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcblx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuXHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IHN0YXJ0LCBsID0gZW5kIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCkge1xuXHRcdFx0XHRcdFx0dlN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkpO1xuXHRcdFx0XHRcdFx0dkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMSk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGRpc3RTcSA9IF9yYXkkMS5kaXN0YW5jZVNxVG9TZWdtZW50KHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCk7XG5cblx0XHRcdFx0XHRcdGlmIChkaXN0U3EgPiBsb2NhbFRocmVzaG9sZFNxKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cblx0XHRcdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhpbnRlclJheSk7XG5cdFx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCksXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpLFxuXHRcdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxuXHRcdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGdlb21ldHJ5LmlzR2VvbWV0cnkpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTGluZS5yYXljYXN0KCkgbm8gbG9uZ2VyIHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5LiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR1cGRhdGVNb3JwaFRhcmdldHMoKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHRcdGlmIChnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRcdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1vcnBoQXR0cmlidXRlcyk7XG5cblx0XHRcdFx0aWYgKGtleXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzW2tleXNbMF1dO1xuXG5cdFx0XHRcdFx0aWYgKG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVttXS5uYW1lIHx8IFN0cmluZyhtKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbbmFtZV0gPSBtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXG5cdFx0XHRcdGlmIChtb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiBtb3JwaFRhcmdldHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkxpbmUudXBkYXRlTW9ycGhUYXJnZXRzKCkgZG9lcyBub3Qgc3VwcG9ydCBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdExpbmUucHJvdG90eXBlLmlzTGluZSA9IHRydWU7XG5cblx0Y29uc3QgX3N0YXJ0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2VuZCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIExpbmVTZWdtZW50cyBleHRlbmRzIExpbmUge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuXHRcdH1cblxuXHRcdGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHQvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblx0XHRcdFx0aWYgKGdlb21ldHJ5LmluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRcdGNvbnN0IGxpbmVEaXN0YW5jZXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICs9IDIpIHtcblx0XHRcdFx0XHRcdF9zdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpKTtcblxuXHRcdFx0XHRcdFx0X2VuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMSk7XG5cblx0XHRcdFx0XHRcdGxpbmVEaXN0YW5jZXNbaV0gPSBpID09PSAwID8gMCA6IGxpbmVEaXN0YW5jZXNbaSAtIDFdO1xuXHRcdFx0XHRcdFx0bGluZURpc3RhbmNlc1tpICsgMV0gPSBsaW5lRGlzdGFuY2VzW2ldICsgX3N0YXJ0LmRpc3RhbmNlVG8oX2VuZCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdsaW5lRGlzdGFuY2UnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShsaW5lRGlzdGFuY2VzLCAxKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaW5lU2VnbWVudHMuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTogQ29tcHV0YXRpb24gb25seSBwb3NzaWJsZSB3aXRoIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGdlb21ldHJ5LmlzR2VvbWV0cnkpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTGluZVNlZ21lbnRzLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5LiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRMaW5lU2VnbWVudHMucHJvdG90eXBlLmlzTGluZVNlZ21lbnRzID0gdHJ1ZTtcblxuXHRjbGFzcyBMaW5lTG9vcCBleHRlbmRzIExpbmUge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdMaW5lTG9vcCc7XG5cdFx0fVxuXG5cdH1cblxuXHRMaW5lTG9vcC5wcm90b3R5cGUuaXNMaW5lTG9vcCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXHRjb2xvcjogPGhleD4sXG5cdCAqXHRvcGFjaXR5OiA8ZmxvYXQ+LFxuXHQgKlx0bWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0YWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRzaXplOiA8ZmxvYXQ+LFxuXHQgKlx0c2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD5cblx0ICpcblx0ICogfVxuXHQgKi9cblxuXHRjbGFzcyBQb2ludHNNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BvaW50c01hdGVyaWFsJztcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpO1xuXHRcdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLnNpemUgPSAxO1xuXHRcdFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSB0cnVlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHRcdHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplO1xuXHRcdFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuaXNQb2ludHNNYXRlcmlhbCA9IHRydWU7XG5cblx0Y29uc3QgX2ludmVyc2VNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfcmF5ID0gLypAX19QVVJFX18qL25ldyBSYXkoKTtcblxuXHRjb25zdCBfc3BoZXJlID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcblxuXHRjb25zdCBfcG9zaXRpb24kMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIFBvaW50cyBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcihnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBtYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BvaW50cyc7XG5cdFx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gc291cmNlLm1hdGVyaWFsO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IHNvdXJjZS5nZW9tZXRyeTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0XHRjb25zdCB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XG5cdFx0XHRjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7IC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwpIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRfc3BoZXJlLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUpO1xuXG5cdFx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG5cblx0XHRcdF9zcGhlcmUucmFkaXVzICs9IHRocmVzaG9sZDtcblx0XHRcdGlmIChyYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSkgPT09IGZhbHNlKSByZXR1cm47IC8vXG5cblx0XHRcdF9pbnZlcnNlTWF0cml4LmNvcHkobWF0cml4V29ybGQpLmludmVydCgpO1xuXG5cdFx0XHRfcmF5LmNvcHkocmF5Y2FzdGVyLnJheSkuYXBwbHlNYXRyaXg0KF9pbnZlcnNlTWF0cml4KTtcblxuXHRcdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoKHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueikgLyAzKTtcblx0XHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WChpKTtcblxuXHRcdFx0XHRcdFx0X3Bvc2l0aW9uJDIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgYSk7XG5cblx0XHRcdFx0XHRcdHRlc3RQb2ludChfcG9zaXRpb24kMiwgYSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBzdGFydCwgbCA9IGVuZDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0X3Bvc2l0aW9uJDIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgaSk7XG5cblx0XHRcdFx0XHRcdHRlc3RQb2ludChfcG9zaXRpb24kMiwgaSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qb2ludHMucmF5Y2FzdCgpIG5vIGxvbmdlciBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dXBkYXRlTW9ycGhUYXJnZXRzKCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cdFx0XHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtb3JwaEF0dHJpYnV0ZXMpO1xuXG5cdFx0XHRcdGlmIChrZXlzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1trZXlzWzBdXTtcblxuXHRcdFx0XHRcdGlmIChtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xuXHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBuYW1lID0gbW9ycGhBdHRyaWJ1dGVbbV0ubmFtZSB8fCBTdHJpbmcobSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goMCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W25hbWVdID0gbTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblxuXHRcdFx0XHRpZiAobW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgbW9ycGhUYXJnZXRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qb2ludHMudXBkYXRlTW9ycGhUYXJnZXRzKCkgZG9lcyBub3Qgc3VwcG9ydCBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdFBvaW50cy5wcm90b3R5cGUuaXNQb2ludHMgPSB0cnVlO1xuXG5cdGZ1bmN0aW9uIHRlc3RQb2ludChwb2ludCwgaW5kZXgsIGxvY2FsVGhyZXNob2xkU3EsIG1hdHJpeFdvcmxkLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIG9iamVjdCkge1xuXHRcdGNvbnN0IHJheVBvaW50RGlzdGFuY2VTcSA9IF9yYXkuZGlzdGFuY2VTcVRvUG9pbnQocG9pbnQpO1xuXG5cdFx0aWYgKHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EpIHtcblx0XHRcdGNvbnN0IGludGVyc2VjdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0X3JheS5jbG9zZXN0UG9pbnRUb1BvaW50KHBvaW50LCBpbnRlcnNlY3RQb2ludCk7XG5cblx0XHRcdGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oaW50ZXJzZWN0UG9pbnQpO1xuXHRcdFx0aWYgKGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyKSByZXR1cm47XG5cdFx0XHRpbnRlcnNlY3RzLnB1c2goe1xuXHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydChyYXlQb2ludERpc3RhbmNlU3EpLFxuXHRcdFx0XHRwb2ludDogaW50ZXJzZWN0UG9pbnQsXG5cdFx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0b2JqZWN0OiBvYmplY3Rcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGNsYXNzIFZpZGVvVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXHRcdGNvbnN0cnVjdG9yKHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpIHtcblx0XHRcdHN1cGVyKHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpO1xuXHRcdFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFJHQkZvcm1hdDtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cdFx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlVmlkZW8oKSB7XG5cdFx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0dmlkZW8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayh1cGRhdGVWaWRlbyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgncmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaycgaW4gdmlkZW8pIHtcblx0XHRcdFx0dmlkZW8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayh1cGRhdGVWaWRlbyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5pbWFnZSkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHR1cGRhdGUoKSB7XG5cdFx0XHRjb25zdCB2aWRlbyA9IHRoaXMuaW1hZ2U7XG5cdFx0XHRjb25zdCBoYXNWaWRlb0ZyYW1lQ2FsbGJhY2sgPSAoJ3JlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2snIGluIHZpZGVvKTtcblxuXHRcdFx0aWYgKGhhc1ZpZGVvRnJhbWVDYWxsYmFjayA9PT0gZmFsc2UgJiYgdmlkZW8ucmVhZHlTdGF0ZSA+PSB2aWRlby5IQVZFX0NVUlJFTlRfREFUQSkge1xuXHRcdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdFZpZGVvVGV4dHVyZS5wcm90b3R5cGUuaXNWaWRlb1RleHR1cmUgPSB0cnVlO1xuXG5cdGNsYXNzIENvbXByZXNzZWRUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cdFx0Y29uc3RydWN0b3IobWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBlbmNvZGluZykge1xuXHRcdFx0c3VwZXIobnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyk7XG5cdFx0XHR0aGlzLmltYWdlID0ge1xuXHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5taXBtYXBzID0gbWlwbWFwczsgLy8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcblx0XHRcdC8vIChhbHNvIGZsaXBwaW5nIGRvZXNuJ3Qgd29yayBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyApXG5cblx0XHRcdHRoaXMuZmxpcFkgPSBmYWxzZTsgLy8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuXHRcdFx0Ly8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xuXG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdH1cblxuXHR9XG5cblx0Q29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmlzQ29tcHJlc3NlZFRleHR1cmUgPSB0cnVlO1xuXG5cdGNsYXNzIENhbnZhc1RleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0XHRjb25zdHJ1Y3RvcihjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSkge1xuXHRcdFx0c3VwZXIoY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdH1cblxuXHRDYW52YXNUZXh0dXJlLnByb3RvdHlwZS5pc0NhbnZhc1RleHR1cmUgPSB0cnVlO1xuXG5cdGNsYXNzIERlcHRoVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXHRcdGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGZvcm1hdCkge1xuXHRcdFx0Zm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBEZXB0aEZvcm1hdDtcblxuXHRcdFx0aWYgKGZvcm1hdCAhPT0gRGVwdGhGb3JtYXQgJiYgZm9ybWF0ICE9PSBEZXB0aFN0ZW5jaWxGb3JtYXQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEZXB0aFRleHR1cmUgZm9ybWF0IG11c3QgYmUgZWl0aGVyIFRIUkVFLkRlcHRoRm9ybWF0IG9yIFRIUkVFLkRlcHRoU3RlbmNpbEZvcm1hdCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhGb3JtYXQpIHR5cGUgPSBVbnNpZ25lZFNob3J0VHlwZTtcblx0XHRcdGlmICh0eXBlID09PSB1bmRlZmluZWQgJiYgZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQpIHR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG5cdFx0XHRzdXBlcihudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpO1xuXHRcdFx0dGhpcy5pbWFnZSA9IHtcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0fTtcblx0XHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xuXHRcdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG5cdFx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdH1cblxuXHR9XG5cblx0RGVwdGhUZXh0dXJlLnByb3RvdHlwZS5pc0RlcHRoVGV4dHVyZSA9IHRydWU7XG5cblx0Y2xhc3MgQ2lyY2xlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgc2VnbWVudHMgPSA4LCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMikge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdFx0fTtcblx0XHRcdHNlZ21lbnRzID0gTWF0aC5tYXgoMywgc2VnbWVudHMpOyAvLyBidWZmZXJzXG5cblx0XHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0XHRjb25zdCB1dnMgPSBbXTsgLy8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpOyAvLyBjZW50ZXIgcG9pbnRcblxuXHRcdFx0dmVydGljZXMucHVzaCgwLCAwLCAwKTtcblx0XHRcdG5vcm1hbHMucHVzaCgwLCAwLCAxKTtcblx0XHRcdHV2cy5wdXNoKDAuNSwgMC41KTtcblxuXHRcdFx0Zm9yIChsZXQgcyA9IDAsIGkgPSAzOyBzIDw9IHNlZ21lbnRzOyBzKyssIGkgKz0gMykge1xuXHRcdFx0XHRjb25zdCBzZWdtZW50ID0gdGhldGFTdGFydCArIHMgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoOyAvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKHNlZ21lbnQpO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKHNlZ21lbnQpO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goMCwgMCwgMSk7IC8vIHV2c1xuXG5cdFx0XHRcdHV2LnggPSAodmVydGljZXNbaV0gLyByYWRpdXMgKyAxKSAvIDI7XG5cdFx0XHRcdHV2LnkgPSAodmVydGljZXNbaSArIDFdIC8gcmFkaXVzICsgMSkgLyAyO1xuXHRcdFx0XHR1dnMucHVzaCh1di54LCB1di55KTtcblx0XHRcdH0gLy8gaW5kaWNlc1xuXG5cblx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKGksIGkgKyAxLCAwKTtcblx0XHRcdH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBDaXJjbGVHZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS5zZWdtZW50cywgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEN5bGluZGVyR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzVG9wID0gMSwgcmFkaXVzQm90dG9tID0gMSwgaGVpZ2h0ID0gMSwgcmFkaWFsU2VnbWVudHMgPSA4LCBoZWlnaHRTZWdtZW50cyA9IDEsIG9wZW5FbmRlZCA9IGZhbHNlLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMikge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0XHRcdHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuXHRcdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHRcdH07XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IocmFkaWFsU2VnbWVudHMpO1xuXHRcdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKGhlaWdodFNlZ21lbnRzKTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGNvbnN0IGluZGV4QXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuXHRcdFx0bGV0IGdyb3VwU3RhcnQgPSAwOyAvLyBnZW5lcmF0ZSBnZW9tZXRyeVxuXG5cdFx0XHRnZW5lcmF0ZVRvcnNvKCk7XG5cblx0XHRcdGlmIChvcGVuRW5kZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmIChyYWRpdXNUb3AgPiAwKSBnZW5lcmF0ZUNhcCh0cnVlKTtcblx0XHRcdFx0aWYgKHJhZGl1c0JvdHRvbSA+IDApIGdlbmVyYXRlQ2FwKGZhbHNlKTtcblx0XHRcdH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblxuXHRcdFx0ZnVuY3Rpb24gZ2VuZXJhdGVUb3JzbygpIHtcblx0XHRcdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwOyAvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxuXG5cdFx0XHRcdGNvbnN0IHNsb3BlID0gKHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCkgLyBoZWlnaHQ7IC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0XHRmb3IgKGxldCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXhSb3cgPSBbXTtcblx0XHRcdFx0XHRjb25zdCB2ID0geSAvIGhlaWdodFNlZ21lbnRzOyAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1cyBvZiB0aGUgY3VycmVudCByb3dcblxuXHRcdFx0XHRcdGNvbnN0IHJhZGl1cyA9IHYgKiAocmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wKSArIHJhZGl1c1RvcDtcblxuXHRcdFx0XHRcdGZvciAobGV0IHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4KyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG5cdFx0XHRcdFx0XHRjb25zdCB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XG5cdFx0XHRcdFx0XHRjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcblx0XHRcdFx0XHRcdGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpOyAvLyB2ZXJ0ZXhcblxuXHRcdFx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcblx0XHRcdFx0XHRcdHZlcnRleC55ID0gLXYgKiBoZWlnaHQgKyBoYWxmSGVpZ2h0O1xuXHRcdFx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcblx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7IC8vIG5vcm1hbFxuXG5cdFx0XHRcdFx0XHRub3JtYWwuc2V0KHNpblRoZXRhLCBzbG9wZSwgY29zVGhldGEpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0bm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopOyAvLyB1dlxuXG5cdFx0XHRcdFx0XHR1dnMucHVzaCh1LCAxIC0gdik7IC8vIHNhdmUgaW5kZXggb2YgdmVydGV4IGluIHJlc3BlY3RpdmUgcm93XG5cblx0XHRcdFx0XHRcdGluZGV4Um93LnB1c2goaW5kZXgrKyk7XG5cdFx0XHRcdFx0fSAvLyBub3cgc2F2ZSB2ZXJ0aWNlcyBvZiB0aGUgcm93IGluIG91ciBpbmRleCBhcnJheVxuXG5cblx0XHRcdFx0XHRpbmRleEFycmF5LnB1c2goaW5kZXhSb3cpO1xuXHRcdFx0XHR9IC8vIGdlbmVyYXRlIGluZGljZXNcblxuXG5cdFx0XHRcdGZvciAobGV0IHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHgrKykge1xuXHRcdFx0XHRcdGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkrKykge1xuXHRcdFx0XHRcdFx0Ly8gd2UgdXNlIHRoZSBpbmRleCBhcnJheSB0byBhY2Nlc3MgdGhlIGNvcnJlY3QgaW5kaWNlc1xuXHRcdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4QXJyYXlbeV1beF07XG5cdFx0XHRcdFx0XHRjb25zdCBiID0gaW5kZXhBcnJheVt5ICsgMV1beF07XG5cdFx0XHRcdFx0XHRjb25zdCBjID0gaW5kZXhBcnJheVt5ICsgMV1beCArIDFdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZCA9IGluZGV4QXJyYXlbeV1beCArIDFdOyAvLyBmYWNlc1xuXG5cdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG5cdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7IC8vIHVwZGF0ZSBncm91cCBjb3VudGVyXG5cblx0XHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gNjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXG5cdFx0XHRcdHNjb3BlLmFkZEdyb3VwKGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIDApOyAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcblxuXHRcdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdlbmVyYXRlQ2FwKHRvcCkge1xuXHRcdFx0XHQvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2VudGVyIHZlcnRleFxuXHRcdFx0XHRjb25zdCBjZW50ZXJJbmRleFN0YXJ0ID0gaW5kZXg7XG5cdFx0XHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXHRcdFx0XHRjb25zdCByYWRpdXMgPSB0b3AgPT09IHRydWUgPyByYWRpdXNUb3AgOiByYWRpdXNCb3R0b207XG5cdFx0XHRcdGNvbnN0IHNpZ24gPSB0b3AgPT09IHRydWUgPyAxIDogLTE7IC8vIGZpcnN0IHdlIGdlbmVyYXRlIHRoZSBjZW50ZXIgdmVydGV4IGRhdGEgb2YgdGhlIGNhcC5cblx0XHRcdFx0Ly8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXG5cdFx0XHRcdC8vIHdlIG11c3QgZ2VuZXJhdGUgYSBjZW50ZXIgdmVydGV4IHBlciBmYWNlL3NlZ21lbnRcblxuXHRcdFx0XHRmb3IgKGxldCB4ID0gMTsgeCA8PSByYWRpYWxTZWdtZW50czsgeCsrKSB7XG5cdFx0XHRcdFx0Ly8gdmVydGV4XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCgwLCBoYWxmSGVpZ2h0ICogc2lnbiwgMCk7IC8vIG5vcm1hbFxuXG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKDAsIHNpZ24sIDApOyAvLyB1dlxuXG5cdFx0XHRcdFx0dXZzLnB1c2goMC41LCAwLjUpOyAvLyBpbmNyZWFzZSBpbmRleFxuXG5cdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0fSAvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjZW50ZXIgdmVydGV4XG5cblxuXHRcdFx0XHRjb25zdCBjZW50ZXJJbmRleEVuZCA9IGluZGV4OyAvLyBub3cgd2UgZ2VuZXJhdGUgdGhlIHN1cnJvdW5kaW5nIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblx0XHRcdFx0XHRjb25zdCB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XG5cdFx0XHRcdFx0Y29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG5cdFx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7IC8vIHZlcnRleFxuXG5cdFx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IGhhbGZIZWlnaHQgKiBzaWduO1xuXHRcdFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTsgLy8gbm9ybWFsXG5cblx0XHRcdFx0XHRub3JtYWxzLnB1c2goMCwgc2lnbiwgMCk7IC8vIHV2XG5cblx0XHRcdFx0XHR1di54ID0gY29zVGhldGEgKiAwLjUgKyAwLjU7XG5cdFx0XHRcdFx0dXYueSA9IHNpblRoZXRhICogMC41ICogc2lnbiArIDAuNTtcblx0XHRcdFx0XHR1dnMucHVzaCh1di54LCB1di55KTsgLy8gaW5jcmVhc2UgaW5kZXhcblxuXHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdH0gLy8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cblx0XHRcdFx0Zm9yIChsZXQgeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IGNlbnRlckluZGV4U3RhcnQgKyB4O1xuXHRcdFx0XHRcdGNvbnN0IGkgPSBjZW50ZXJJbmRleEVuZCArIHg7XG5cblx0XHRcdFx0XHRpZiAodG9wID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHQvLyBmYWNlIHRvcFxuXHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGksIGkgKyAxLCBjKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gZmFjZSBib3R0b21cblx0XHRcdFx0XHRcdGluZGljZXMucHVzaChpICsgMSwgaSwgYyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z3JvdXBDb3VudCArPSAzO1xuXHRcdFx0XHR9IC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblxuXHRcdFx0XHRzY29wZS5hZGRHcm91cChncm91cFN0YXJ0LCBncm91cENvdW50LCB0b3AgPT09IHRydWUgPyAxIDogMik7IC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG5cdFx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBDeWxpbmRlckdlb21ldHJ5KGRhdGEucmFkaXVzVG9wLCBkYXRhLnJhZGl1c0JvdHRvbSwgZGF0YS5oZWlnaHQsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEub3BlbkVuZGVkLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGgpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQ29uZUdlb21ldHJ5IGV4dGVuZHMgQ3lsaW5kZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgaGVpZ2h0ID0gMSwgcmFkaWFsU2VnbWVudHMgPSA4LCBoZWlnaHRTZWdtZW50cyA9IDEsIG9wZW5FbmRlZCA9IGZhbHNlLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMikge1xuXHRcdFx0c3VwZXIoMCwgcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQ29uZUdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb25lR2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEuaGVpZ2h0LCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLm9wZW5FbmRlZCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFBvbHloZWRyb25HZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0XHRcdGluZGljZXM6IGluZGljZXMsXG5cdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdFx0fTsgLy8gZGVmYXVsdCBidWZmZXIgZGF0YVxuXG5cdFx0XHRjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBbXTtcblx0XHRcdGNvbnN0IHV2QnVmZmVyID0gW107IC8vIHRoZSBzdWJkaXZpc2lvbiBjcmVhdGVzIHRoZSB2ZXJ0ZXggYnVmZmVyIGRhdGFcblxuXHRcdFx0c3ViZGl2aWRlKGRldGFpbCk7IC8vIGFsbCB2ZXJ0aWNlcyBzaG91bGQgbGllIG9uIGEgY29uY2VwdHVhbCBzcGhlcmUgd2l0aCBhIGdpdmVuIHJhZGl1c1xuXG5cdFx0XHRhcHBseVJhZGl1cyhyYWRpdXMpOyAvLyBmaW5hbGx5LCBjcmVhdGUgdGhlIHV2IGRhdGFcblxuXHRcdFx0Z2VuZXJhdGVVVnMoKTsgLy8gYnVpbGQgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGV4QnVmZmVyLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGV4QnVmZmVyLnNsaWNlKCksIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2QnVmZmVyLCAyKSk7XG5cblx0XHRcdGlmIChkZXRhaWwgPT09IDApIHtcblx0XHRcdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOyAvLyBmbGF0IG5vcm1hbHNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpOyAvLyBzbW9vdGggbm9ybWFsc1xuXHRcdFx0fSAvLyBoZWxwZXIgZnVuY3Rpb25zXG5cblxuXHRcdFx0ZnVuY3Rpb24gc3ViZGl2aWRlKGRldGFpbCkge1xuXHRcdFx0XHRjb25zdCBhID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc3QgYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdGNvbnN0IGMgPSBuZXcgVmVjdG9yMygpOyAvLyBpdGVyYXRlIG92ZXIgYWxsIGZhY2VzIGFuZCBhcHBseSBhIHN1YmRpdmlzb24gd2l0aCB0aGUgZ2l2ZW4gZGV0YWlsIHZhbHVlXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSB2ZXJ0aWNlcyBvZiB0aGUgZmFjZVxuXHRcdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoaW5kaWNlc1tpICsgMF0sIGEpO1xuXHRcdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoaW5kaWNlc1tpICsgMV0sIGIpO1xuXHRcdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoaW5kaWNlc1tpICsgMl0sIGMpOyAvLyBwZXJmb3JtIHN1YmRpdmlzaW9uXG5cblx0XHRcdFx0XHRzdWJkaXZpZGVGYWNlKGEsIGIsIGMsIGRldGFpbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gc3ViZGl2aWRlRmFjZShhLCBiLCBjLCBkZXRhaWwpIHtcblx0XHRcdFx0Y29uc3QgY29scyA9IGRldGFpbCArIDE7IC8vIHdlIHVzZSB0aGlzIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgYXMgYSBkYXRhIHN0cnVjdHVyZSBmb3IgY3JlYXRpbmcgdGhlIHN1YmRpdmlzaW9uXG5cblx0XHRcdFx0Y29uc3QgdiA9IFtdOyAvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvblxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbHM7IGkrKykge1xuXHRcdFx0XHRcdHZbaV0gPSBbXTtcblx0XHRcdFx0XHRjb25zdCBhaiA9IGEuY2xvbmUoKS5sZXJwKGMsIGkgLyBjb2xzKTtcblx0XHRcdFx0XHRjb25zdCBiaiA9IGIuY2xvbmUoKS5sZXJwKGMsIGkgLyBjb2xzKTtcblx0XHRcdFx0XHRjb25zdCByb3dzID0gY29scyAtIGk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8PSByb3dzOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmIChqID09PSAwICYmIGkgPT09IGNvbHMpIHtcblx0XHRcdFx0XHRcdFx0dltpXVtqXSA9IGFqO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dltpXVtqXSA9IGFqLmNsb25lKCkubGVycChiaiwgaiAvIHJvd3MpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSAvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlc1xuXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspIHtcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDIgKiAoY29scyAtIGkpIC0gMTsgaisrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBrID0gTWF0aC5mbG9vcihqIC8gMik7XG5cblx0XHRcdFx0XHRcdGlmIChqICUgMiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRwdXNoVmVydGV4KHZbaV1bayArIDFdKTtcblx0XHRcdFx0XHRcdFx0cHVzaFZlcnRleCh2W2kgKyAxXVtrXSk7XG5cdFx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgodltpXVtrXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwdXNoVmVydGV4KHZbaV1bayArIDFdKTtcblx0XHRcdFx0XHRcdFx0cHVzaFZlcnRleCh2W2kgKyAxXVtrICsgMV0pO1xuXHRcdFx0XHRcdFx0XHRwdXNoVmVydGV4KHZbaSArIDFdW2tdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYXBwbHlSYWRpdXMocmFkaXVzKSB7XG5cdFx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7IC8vIGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGJ1ZmZlciBhbmQgYXBwbHkgdGhlIHJhZGl1cyB0byBlYWNoIHZlcnRleFxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbaSArIDBdO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gdmVydGV4QnVmZmVyW2kgKyAxXTtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRleEJ1ZmZlcltpICsgMl07XG5cdFx0XHRcdFx0dmVydGV4Lm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHJhZGl1cyk7XG5cdFx0XHRcdFx0dmVydGV4QnVmZmVyW2kgKyAwXSA9IHZlcnRleC54O1xuXHRcdFx0XHRcdHZlcnRleEJ1ZmZlcltpICsgMV0gPSB2ZXJ0ZXgueTtcblx0XHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbaSArIDJdID0gdmVydGV4Lno7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XG5cdFx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlcltpICsgMF07XG5cdFx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbaSArIDFdO1xuXHRcdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyW2kgKyAyXTtcblx0XHRcdFx0XHRjb25zdCB1ID0gYXppbXV0aCh2ZXJ0ZXgpIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cdFx0XHRcdFx0Y29uc3QgdiA9IGluY2xpbmF0aW9uKHZlcnRleCkgLyBNYXRoLlBJICsgMC41O1xuXHRcdFx0XHRcdHV2QnVmZmVyLnB1c2godSwgMSAtIHYpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29ycmVjdFVWcygpO1xuXHRcdFx0XHRjb3JyZWN0U2VhbSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb3JyZWN0U2VhbSgpIHtcblx0XHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdXZCdWZmZXIubGVuZ3RoOyBpICs9IDYpIHtcblx0XHRcdFx0XHQvLyB1diBkYXRhIG9mIGEgc2luZ2xlIGZhY2Vcblx0XHRcdFx0XHRjb25zdCB4MCA9IHV2QnVmZmVyW2kgKyAwXTtcblx0XHRcdFx0XHRjb25zdCB4MSA9IHV2QnVmZmVyW2kgKyAyXTtcblx0XHRcdFx0XHRjb25zdCB4MiA9IHV2QnVmZmVyW2kgKyA0XTtcblx0XHRcdFx0XHRjb25zdCBtYXggPSBNYXRoLm1heCh4MCwgeDEsIHgyKTtcblx0XHRcdFx0XHRjb25zdCBtaW4gPSBNYXRoLm1pbih4MCwgeDEsIHgyKTsgLy8gMC45IGlzIHNvbWV3aGF0IGFyYml0cmFyeVxuXG5cdFx0XHRcdFx0aWYgKG1heCA+IDAuOSAmJiBtaW4gPCAwLjEpIHtcblx0XHRcdFx0XHRcdGlmICh4MCA8IDAuMikgdXZCdWZmZXJbaSArIDBdICs9IDE7XG5cdFx0XHRcdFx0XHRpZiAoeDEgPCAwLjIpIHV2QnVmZmVyW2kgKyAyXSArPSAxO1xuXHRcdFx0XHRcdFx0aWYgKHgyIDwgMC4yKSB1dkJ1ZmZlcltpICsgNF0gKz0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcHVzaFZlcnRleCh2ZXJ0ZXgpIHtcblx0XHRcdFx0dmVydGV4QnVmZmVyLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFZlcnRleEJ5SW5kZXgoaW5kZXgsIHZlcnRleCkge1xuXHRcdFx0XHRjb25zdCBzdHJpZGUgPSBpbmRleCAqIDM7XG5cdFx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbc3RyaWRlICsgMF07XG5cdFx0XHRcdHZlcnRleC55ID0gdmVydGljZXNbc3RyaWRlICsgMV07XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbc3RyaWRlICsgMl07XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvcnJlY3RVVnMoKSB7XG5cdFx0XHRcdGNvbnN0IGEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjb25zdCBiID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc3QgYyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdGNvbnN0IGNlbnRyb2lkID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc3QgdXZBID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdFx0Y29uc3QgdXZCID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdFx0Y29uc3QgdXZDID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDksIGogKz0gNikge1xuXHRcdFx0XHRcdGEuc2V0KHZlcnRleEJ1ZmZlcltpICsgMF0sIHZlcnRleEJ1ZmZlcltpICsgMV0sIHZlcnRleEJ1ZmZlcltpICsgMl0pO1xuXHRcdFx0XHRcdGIuc2V0KHZlcnRleEJ1ZmZlcltpICsgM10sIHZlcnRleEJ1ZmZlcltpICsgNF0sIHZlcnRleEJ1ZmZlcltpICsgNV0pO1xuXHRcdFx0XHRcdGMuc2V0KHZlcnRleEJ1ZmZlcltpICsgNl0sIHZlcnRleEJ1ZmZlcltpICsgN10sIHZlcnRleEJ1ZmZlcltpICsgOF0pO1xuXHRcdFx0XHRcdHV2QS5zZXQodXZCdWZmZXJbaiArIDBdLCB1dkJ1ZmZlcltqICsgMV0pO1xuXHRcdFx0XHRcdHV2Qi5zZXQodXZCdWZmZXJbaiArIDJdLCB1dkJ1ZmZlcltqICsgM10pO1xuXHRcdFx0XHRcdHV2Qy5zZXQodXZCdWZmZXJbaiArIDRdLCB1dkJ1ZmZlcltqICsgNV0pO1xuXHRcdFx0XHRcdGNlbnRyb2lkLmNvcHkoYSkuYWRkKGIpLmFkZChjKS5kaXZpZGVTY2FsYXIoMyk7XG5cdFx0XHRcdFx0Y29uc3QgYXppID0gYXppbXV0aChjZW50cm9pZCk7XG5cdFx0XHRcdFx0Y29ycmVjdFVWKHV2QSwgaiArIDAsIGEsIGF6aSk7XG5cdFx0XHRcdFx0Y29ycmVjdFVWKHV2QiwgaiArIDIsIGIsIGF6aSk7XG5cdFx0XHRcdFx0Y29ycmVjdFVWKHV2QywgaiArIDQsIGMsIGF6aSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY29ycmVjdFVWKHV2LCBzdHJpZGUsIHZlY3RvciwgYXppbXV0aCkge1xuXHRcdFx0XHRpZiAoYXppbXV0aCA8IDAgJiYgdXYueCA9PT0gMSkge1xuXHRcdFx0XHRcdHV2QnVmZmVyW3N0cmlkZV0gPSB1di54IC0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh2ZWN0b3IueCA9PT0gMCAmJiB2ZWN0b3IueiA9PT0gMCkge1xuXHRcdFx0XHRcdHV2QnVmZmVyW3N0cmlkZV0gPSBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxuXG5cblx0XHRcdGZ1bmN0aW9uIGF6aW11dGgodmVjdG9yKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLmF0YW4yKHZlY3Rvci56LCAtdmVjdG9yLngpO1xuXHRcdFx0fSAvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXG5cblxuXHRcdFx0ZnVuY3Rpb24gaW5jbGluYXRpb24odmVjdG9yKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLmF0YW4yKC12ZWN0b3IueSwgTWF0aC5zcXJ0KHZlY3Rvci54ICogdmVjdG9yLnggKyB2ZWN0b3IueiAqIHZlY3Rvci56KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgUG9seWhlZHJvbkdlb21ldHJ5KGRhdGEudmVydGljZXMsIGRhdGEuaW5kaWNlcywgZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlscyk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBEb2RlY2FoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdFx0Y29uc3QgdCA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5cdFx0XHRjb25zdCByID0gMSAvIHQ7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFsvLyAowrExLCDCsTEsIMKxMSlcblx0XHRcdC0xLCAtMSwgLTEsIC0xLCAtMSwgMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgMSwgLTEsIC0xLCAxLCAtMSwgMSwgMSwgMSwgLTEsIDEsIDEsIDEsIC8vICgwLCDCsTEvz4YsIMKxz4YpXG5cdFx0XHQwLCAtciwgLXQsIDAsIC1yLCB0LCAwLCByLCAtdCwgMCwgciwgdCwgLy8gKMKxMS/PhiwgwrHPhiwgMClcblx0XHRcdC1yLCAtdCwgMCwgLXIsIHQsIDAsIHIsIC10LCAwLCByLCB0LCAwLCAvLyAowrHPhiwgMCwgwrExL8+GKVxuXHRcdFx0LXQsIDAsIC1yLCB0LCAwLCAtciwgLXQsIDAsIHIsIHQsIDAsIHJdO1xuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFszLCAxMSwgNywgMywgNywgMTUsIDMsIDE1LCAxMywgNywgMTksIDE3LCA3LCAxNywgNiwgNywgNiwgMTUsIDE3LCA0LCA4LCAxNywgOCwgMTAsIDE3LCAxMCwgNiwgOCwgMCwgMTYsIDgsIDE2LCAyLCA4LCAyLCAxMCwgMCwgMTIsIDEsIDAsIDEsIDE4LCAwLCAxOCwgMTYsIDYsIDEwLCAyLCA2LCAyLCAxMywgNiwgMTMsIDE1LCAyLCAxNiwgMTgsIDIsIDE4LCAzLCAyLCAzLCAxMywgMTgsIDEsIDksIDE4LCA5LCAxMSwgMTgsIDExLCAzLCA0LCAxNCwgMTIsIDQsIDEyLCAwLCA0LCAwLCA4LCAxMSwgOSwgNSwgMTEsIDUsIDE5LCAxMSwgMTksIDcsIDE5LCA1LCAxNCwgMTksIDE0LCA0LCAxOSwgNCwgMTcsIDEsIDEyLCAxNCwgMSwgMTQsIDUsIDEsIDUsIDldO1xuXHRcdFx0c3VwZXIodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25HZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBEb2RlY2FoZWRyb25HZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwpO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX3YwID0gbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdjEkMSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX25vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3RyaWFuZ2xlID0gbmV3IFRyaWFuZ2xlKCk7XG5cblx0Y2xhc3MgRWRnZXNHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3RvcihnZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnRWRnZXNHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHRocmVzaG9sZEFuZ2xlOiB0aHJlc2hvbGRBbmdsZVxuXHRcdFx0fTtcblx0XHRcdHRocmVzaG9sZEFuZ2xlID0gdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCA/IHRocmVzaG9sZEFuZ2xlIDogMTtcblxuXHRcdFx0aWYgKGdlb21ldHJ5LmlzR2VvbWV0cnkgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuRWRnZXNHZW9tZXRyeSBubyBsb25nZXIgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnkuIFVzZSBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRocmVzaG9sZERvdCA9IE1hdGguY29zKERFRzJSQUQgKiB0aHJlc2hvbGRBbmdsZSk7XG5cdFx0XHRjb25zdCBpbmRleEF0dHIgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXHRcdFx0Y29uc3QgaW5kZXhDb3VudCA9IGluZGV4QXR0ciA/IGluZGV4QXR0ci5jb3VudCA6IHBvc2l0aW9uQXR0ci5jb3VudDtcblx0XHRcdGNvbnN0IGluZGV4QXJyID0gWzAsIDAsIDBdO1xuXHRcdFx0Y29uc3QgdmVydEtleXMgPSBbJ2EnLCAnYicsICdjJ107XG5cdFx0XHRjb25zdCBoYXNoZXMgPSBuZXcgQXJyYXkoMyk7XG5cdFx0XHRjb25zdCBlZGdlRGF0YSA9IHt9O1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleENvdW50OyBpICs9IDMpIHtcblx0XHRcdFx0aWYgKGluZGV4QXR0cikge1xuXHRcdFx0XHRcdGluZGV4QXJyWzBdID0gaW5kZXhBdHRyLmdldFgoaSk7XG5cdFx0XHRcdFx0aW5kZXhBcnJbMV0gPSBpbmRleEF0dHIuZ2V0WChpICsgMSk7XG5cdFx0XHRcdFx0aW5kZXhBcnJbMl0gPSBpbmRleEF0dHIuZ2V0WChpICsgMik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aW5kZXhBcnJbMF0gPSBpO1xuXHRcdFx0XHRcdGluZGV4QXJyWzFdID0gaSArIDE7XG5cdFx0XHRcdFx0aW5kZXhBcnJbMl0gPSBpICsgMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHRhLFxuXHRcdFx0XHRcdGIsXG5cdFx0XHRcdFx0Y1xuXHRcdFx0XHR9ID0gX3RyaWFuZ2xlO1xuXHRcdFx0XHRhLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyLCBpbmRleEFyclswXSk7XG5cdFx0XHRcdGIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHIsIGluZGV4QXJyWzFdKTtcblx0XHRcdFx0Yy5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbMl0pO1xuXG5cdFx0XHRcdF90cmlhbmdsZS5nZXROb3JtYWwoX25vcm1hbCk7IC8vIGNyZWF0ZSBoYXNoZXMgZm9yIHRoZSBlZGdlIGZyb20gdGhlIHZlcnRpY2VzXG5cblxuXHRcdFx0XHRoYXNoZXNbMF0gPSBgJHthLnh9LCR7YS55fSwke2Euen1gO1xuXHRcdFx0XHRoYXNoZXNbMV0gPSBgJHtiLnh9LCR7Yi55fSwke2Iuen1gO1xuXHRcdFx0XHRoYXNoZXNbMl0gPSBgJHtjLnh9LCR7Yy55fSwke2Muen1gOyAvLyBza2lwIGRlZ2VuZXJhdGUgdHJpYW5nbGVzXG5cblx0XHRcdFx0aWYgKGhhc2hlc1swXSA9PT0gaGFzaGVzWzFdIHx8IGhhc2hlc1sxXSA9PT0gaGFzaGVzWzJdIHx8IGhhc2hlc1syXSA9PT0gaGFzaGVzWzBdKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH0gLy8gaXRlcmF0ZSBvdmVyIGV2ZXJ5IGVkZ2VcblxuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBmaXJzdCBhbmQgbmV4dCB2ZXJ0ZXggbWFraW5nIHVwIHRoZSBlZGdlXG5cdFx0XHRcdFx0Y29uc3Qgak5leHQgPSAoaiArIDEpICUgMztcblx0XHRcdFx0XHRjb25zdCB2ZWNIYXNoMCA9IGhhc2hlc1tqXTtcblx0XHRcdFx0XHRjb25zdCB2ZWNIYXNoMSA9IGhhc2hlc1tqTmV4dF07XG5cdFx0XHRcdFx0Y29uc3QgdjAgPSBfdHJpYW5nbGVbdmVydEtleXNbal1dO1xuXHRcdFx0XHRcdGNvbnN0IHYxID0gX3RyaWFuZ2xlW3ZlcnRLZXlzW2pOZXh0XV07XG5cdFx0XHRcdFx0Y29uc3QgaGFzaCA9IGAke3ZlY0hhc2gwfV8ke3ZlY0hhc2gxfWA7XG5cdFx0XHRcdFx0Y29uc3QgcmV2ZXJzZUhhc2ggPSBgJHt2ZWNIYXNoMX1fJHt2ZWNIYXNoMH1gO1xuXG5cdFx0XHRcdFx0aWYgKHJldmVyc2VIYXNoIGluIGVkZ2VEYXRhICYmIGVkZ2VEYXRhW3JldmVyc2VIYXNoXSkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgd2UgZm91bmQgYSBzaWJsaW5nIGVkZ2UgYWRkIGl0IGludG8gdGhlIHZlcnRleCBhcnJheSBpZlxuXHRcdFx0XHRcdFx0Ly8gaXQgbWVldHMgdGhlIGFuZ2xlIHRocmVzaG9sZCBhbmQgZGVsZXRlIHRoZSBlZGdlIGZyb20gdGhlIG1hcC5cblx0XHRcdFx0XHRcdGlmIChfbm9ybWFsLmRvdChlZGdlRGF0YVtyZXZlcnNlSGFzaF0ubm9ybWFsKSA8PSB0aHJlc2hvbGREb3QpIHtcblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCh2MC54LCB2MC55LCB2MC56KTtcblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCh2MS54LCB2MS55LCB2MS56KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZWRnZURhdGFbcmV2ZXJzZUhhc2hdID0gbnVsbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCEoaGFzaCBpbiBlZGdlRGF0YSkpIHtcblx0XHRcdFx0XHRcdC8vIGlmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGVkZ2UgaGVyZSB0aGVuIHNraXAgYWRkaW5nIGEgbmV3IG9uZVxuXHRcdFx0XHRcdFx0ZWRnZURhdGFbaGFzaF0gPSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4MDogaW5kZXhBcnJbal0sXG5cdFx0XHRcdFx0XHRcdGluZGV4MTogaW5kZXhBcnJbak5leHRdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWw6IF9ub3JtYWwuY2xvbmUoKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gaXRlcmF0ZSBvdmVyIGFsbCByZW1haW5pbmcsIHVubWF0Y2hlZCBlZGdlcyBhbmQgYWRkIHRoZW0gdG8gdGhlIHZlcnRleCBhcnJheVxuXG5cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIGVkZ2VEYXRhKSB7XG5cdFx0XHRcdGlmIChlZGdlRGF0YVtrZXldKSB7XG5cdFx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdFx0aW5kZXgwLFxuXHRcdFx0XHRcdFx0aW5kZXgxXG5cdFx0XHRcdFx0fSA9IGVkZ2VEYXRhW2tleV07XG5cblx0XHRcdFx0XHRfdjAuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHIsIGluZGV4MCk7XG5cblx0XHRcdFx0XHRfdjEkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0ciwgaW5kZXgxKTtcblxuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goX3YwLngsIF92MC55LCBfdjAueik7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaChfdjEkMS54LCBfdjEkMS55LCBfdjEkMS56KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0LlxuXHQgKlxuXHQgKiBTb21lIGNvbW1vbiBvZiBjdXJ2ZSBtZXRob2RzOlxuXHQgKiAuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50KCB0LCBvcHRpb25hbFRhcmdldCApXG5cdCAqIC5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApXG5cdCAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXG5cdCAqIC5nZXRMZW5ndGgoKVxuXHQgKiAudXBkYXRlQXJjTGVuZ3RocygpXG5cdCAqXG5cdCAqIFRoaXMgZm9sbG93aW5nIGN1cnZlcyBpbmhlcml0IGZyb20gVEhSRUUuQ3VydmU6XG5cdCAqXG5cdCAqIC0tIDJEIGN1cnZlcyAtLVxuXHQgKiBUSFJFRS5BcmNDdXJ2ZVxuXHQgKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXG5cdCAqIFRIUkVFLkVsbGlwc2VDdXJ2ZVxuXHQgKiBUSFJFRS5MaW5lQ3VydmVcblx0ICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcblx0ICogVEhSRUUuU3BsaW5lQ3VydmVcblx0ICpcblx0ICogLS0gM0QgY3VydmVzIC0tXG5cdCAqIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTNcblx0ICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcblx0ICogVEhSRUUuTGluZUN1cnZlM1xuXHQgKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcblx0ICpcblx0ICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aC5cblx0ICpcblx0ICoqL1xuXG5cdGNsYXNzIEN1cnZlIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMudHlwZSA9ICdDdXJ2ZSc7XG5cdFx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IDIwMDtcblx0XHR9IC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuXHRcdC8vXHQtIHQgWzAgLi4gMV1cblxuXG5cdFx0Z2V0UG9pbnQoKVxuXHRcdC8qIHQsIG9wdGlvbmFsVGFyZ2V0ICovXG5cdFx0e1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLicpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSAvLyBHZXQgcG9pbnQgYXQgcmVsYXRpdmUgcG9zaXRpb24gaW4gY3VydmUgYWNjb3JkaW5nIHRvIGFyYyBsZW5ndGhcblx0XHQvLyAtIHUgWzAgLi4gMV1cblxuXG5cdFx0Z2V0UG9pbnRBdCh1LCBvcHRpb25hbFRhcmdldCkge1xuXHRcdFx0Y29uc3QgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcodSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCk7XG5cdFx0fSAvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcblxuXG5cdFx0Z2V0UG9pbnRzKGRpdmlzaW9ucyA9IDUpIHtcblx0XHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQrKykge1xuXHRcdFx0XHRwb2ludHMucHVzaCh0aGlzLmdldFBvaW50KGQgLyBkaXZpc2lvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvaW50cztcblx0XHR9IC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXG5cblxuXHRcdGdldFNwYWNlZFBvaW50cyhkaXZpc2lvbnMgPSA1KSB7XG5cdFx0XHRjb25zdCBwb2ludHMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkKyspIHtcblx0XHRcdFx0cG9pbnRzLnB1c2godGhpcy5nZXRQb2ludEF0KGQgLyBkaXZpc2lvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvaW50cztcblx0XHR9IC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXG5cblxuXHRcdGdldExlbmd0aCgpIHtcblx0XHRcdGNvbnN0IGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblx0XHRcdHJldHVybiBsZW5ndGhzW2xlbmd0aHMubGVuZ3RoIC0gMV07XG5cdFx0fSAvLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xuXG5cblx0XHRnZXRMZW5ndGhzKGRpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zKSB7XG5cdFx0XHRpZiAodGhpcy5jYWNoZUFyY0xlbmd0aHMgJiYgdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBkaXZpc2lvbnMgKyAxICYmICF0aGlzLm5lZWRzVXBkYXRlKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3Rocztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgY2FjaGUgPSBbXTtcblx0XHRcdGxldCBjdXJyZW50LFxuXHRcdFx0XHRcdGxhc3QgPSB0aGlzLmdldFBvaW50KDApO1xuXHRcdFx0bGV0IHN1bSA9IDA7XG5cdFx0XHRjYWNoZS5wdXNoKDApO1xuXG5cdFx0XHRmb3IgKGxldCBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHArKykge1xuXHRcdFx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludChwIC8gZGl2aXNpb25zKTtcblx0XHRcdFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyhsYXN0KTtcblx0XHRcdFx0Y2FjaGUucHVzaChzdW0pO1xuXHRcdFx0XHRsYXN0ID0gY3VycmVudDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcblx0XHRcdHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOiBzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXG5cdFx0fVxuXG5cdFx0dXBkYXRlQXJjTGVuZ3RocygpIHtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5nZXRMZW5ndGhzKCk7XG5cdFx0fSAvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XG5cblxuXHRcdGdldFV0b1RtYXBwaW5nKHUsIGRpc3RhbmNlKSB7XG5cdFx0XHRjb25zdCBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cdFx0XHRsZXQgaSA9IDA7XG5cdFx0XHRjb25zdCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xuXHRcdFx0bGV0IHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XG5cblx0XHRcdGlmIChkaXN0YW5jZSkge1xuXHRcdFx0XHR0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzW2lsIC0gMV07XG5cdFx0XHR9IC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXG5cblxuXHRcdFx0bGV0IGxvdyA9IDAsXG5cdFx0XHRcdFx0aGlnaCA9IGlsIC0gMSxcblx0XHRcdFx0XHRjb21wYXJpc29uO1xuXG5cdFx0XHR3aGlsZSAobG93IDw9IGhpZ2gpIHtcblx0XHRcdFx0aSA9IE1hdGguZmxvb3IobG93ICsgKGhpZ2ggLSBsb3cpIC8gMik7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuXHRcdFx0XHRjb21wYXJpc29uID0gYXJjTGVuZ3Roc1tpXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuXHRcdFx0XHRpZiAoY29tcGFyaXNvbiA8IDApIHtcblx0XHRcdFx0XHRsb3cgPSBpICsgMTtcblx0XHRcdFx0fSBlbHNlIGlmIChjb21wYXJpc29uID4gMCkge1xuXHRcdFx0XHRcdGhpZ2ggPSBpIC0gMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoaWdoID0gaTtcblx0XHRcdFx0XHRicmVhazsgLy8gRE9ORVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBoaWdoO1xuXG5cdFx0XHRpZiAoYXJjTGVuZ3Roc1tpXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBpIC8gKGlsIC0gMSk7XG5cdFx0XHR9IC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXG5cblxuXHRcdFx0Y29uc3QgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1tpXTtcblx0XHRcdGNvbnN0IGxlbmd0aEFmdGVyID0gYXJjTGVuZ3Roc1tpICsgMV07XG5cdFx0XHRjb25zdCBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7IC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXG5cblx0XHRcdGNvbnN0IHNlZ21lbnRGcmFjdGlvbiA9ICh0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUpIC8gc2VnbWVudExlbmd0aDsgLy8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG5cdFx0XHRjb25zdCB0ID0gKGkgKyBzZWdtZW50RnJhY3Rpb24pIC8gKGlsIC0gMSk7XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9IC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcblx0XHQvLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG5cdFx0Ly8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcblx0XHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXG5cblxuXHRcdGdldFRhbmdlbnQodCwgb3B0aW9uYWxUYXJnZXQpIHtcblx0XHRcdGNvbnN0IGRlbHRhID0gMC4wMDAxO1xuXHRcdFx0bGV0IHQxID0gdCAtIGRlbHRhO1xuXHRcdFx0bGV0IHQyID0gdCArIGRlbHRhOyAvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXG5cblx0XHRcdGlmICh0MSA8IDApIHQxID0gMDtcblx0XHRcdGlmICh0MiA+IDEpIHQyID0gMTtcblx0XHRcdGNvbnN0IHB0MSA9IHRoaXMuZ2V0UG9pbnQodDEpO1xuXHRcdFx0Y29uc3QgcHQyID0gdGhpcy5nZXRQb2ludCh0Mik7XG5cdFx0XHRjb25zdCB0YW5nZW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgKHB0MS5pc1ZlY3RvcjIgPyBuZXcgVmVjdG9yMigpIDogbmV3IFZlY3RvcjMoKSk7XG5cdFx0XHR0YW5nZW50LmNvcHkocHQyKS5zdWIocHQxKS5ub3JtYWxpemUoKTtcblx0XHRcdHJldHVybiB0YW5nZW50O1xuXHRcdH1cblxuXHRcdGdldFRhbmdlbnRBdCh1LCBvcHRpb25hbFRhcmdldCkge1xuXHRcdFx0Y29uc3QgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcodSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KHQsIG9wdGlvbmFsVGFyZ2V0KTtcblx0XHR9XG5cblx0XHRjb21wdXRlRnJlbmV0RnJhbWVzKHNlZ21lbnRzLCBjbG9zZWQpIHtcblx0XHRcdC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcblx0XHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB0YW5nZW50cyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgYmlub3JtYWxzID0gW107XG5cdFx0XHRjb25zdCB2ZWMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTsgLy8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgdSA9IGkgLyBzZWdtZW50cztcblx0XHRcdFx0dGFuZ2VudHNbaV0gPSB0aGlzLmdldFRhbmdlbnRBdCh1LCBuZXcgVmVjdG9yMygpKTtcblx0XHRcdFx0dGFuZ2VudHNbaV0ubm9ybWFsaXplKCk7XG5cdFx0XHR9IC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXG5cdFx0XHQvLyBhbmQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbWluaW11bSB0YW5nZW50IHh5eiBjb21wb25lbnRcblxuXG5cdFx0XHRub3JtYWxzWzBdID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGJpbm9ybWFsc1swXSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHRcdGNvbnN0IHR4ID0gTWF0aC5hYnModGFuZ2VudHNbMF0ueCk7XG5cdFx0XHRjb25zdCB0eSA9IE1hdGguYWJzKHRhbmdlbnRzWzBdLnkpO1xuXHRcdFx0Y29uc3QgdHogPSBNYXRoLmFicyh0YW5nZW50c1swXS56KTtcblxuXHRcdFx0aWYgKHR4IDw9IG1pbikge1xuXHRcdFx0XHRtaW4gPSB0eDtcblx0XHRcdFx0bm9ybWFsLnNldCgxLCAwLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5IDw9IG1pbikge1xuXHRcdFx0XHRtaW4gPSB0eTtcblx0XHRcdFx0bm9ybWFsLnNldCgwLCAxLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR6IDw9IG1pbikge1xuXHRcdFx0XHRub3JtYWwuc2V0KDAsIDAsIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHR2ZWMuY3Jvc3NWZWN0b3JzKHRhbmdlbnRzWzBdLCBub3JtYWwpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0bm9ybWFsc1swXS5jcm9zc1ZlY3RvcnModGFuZ2VudHNbMF0sIHZlYyk7XG5cdFx0XHRiaW5vcm1hbHNbMF0uY3Jvc3NWZWN0b3JzKHRhbmdlbnRzWzBdLCBub3JtYWxzWzBdKTsgLy8gY29tcHV0ZSB0aGUgc2xvd2x5LXZhcnlpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXG5cblx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0bm9ybWFsc1tpXSA9IG5vcm1hbHNbaSAtIDFdLmNsb25lKCk7XG5cdFx0XHRcdGJpbm9ybWFsc1tpXSA9IGJpbm9ybWFsc1tpIC0gMV0uY2xvbmUoKTtcblx0XHRcdFx0dmVjLmNyb3NzVmVjdG9ycyh0YW5nZW50c1tpIC0gMV0sIHRhbmdlbnRzW2ldKTtcblxuXHRcdFx0XHRpZiAodmVjLmxlbmd0aCgpID4gTnVtYmVyLkVQU0lMT04pIHtcblx0XHRcdFx0XHR2ZWMubm9ybWFsaXplKCk7XG5cdFx0XHRcdFx0Y29uc3QgdGhldGEgPSBNYXRoLmFjb3MoY2xhbXAodGFuZ2VudHNbaSAtIDFdLmRvdCh0YW5nZW50c1tpXSksIC0xLCAxKSk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcblxuXHRcdFx0XHRcdG5vcm1hbHNbaV0uYXBwbHlNYXRyaXg0KG1hdC5tYWtlUm90YXRpb25BeGlzKHZlYywgdGhldGEpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJpbm9ybWFsc1tpXS5jcm9zc1ZlY3RvcnModGFuZ2VudHNbaV0sIG5vcm1hbHNbaV0pO1xuXHRcdFx0fSAvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXG5cblxuXHRcdFx0aWYgKGNsb3NlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRsZXQgdGhldGEgPSBNYXRoLmFjb3MoY2xhbXAobm9ybWFsc1swXS5kb3Qobm9ybWFsc1tzZWdtZW50c10pLCAtMSwgMSkpO1xuXHRcdFx0XHR0aGV0YSAvPSBzZWdtZW50cztcblxuXHRcdFx0XHRpZiAodGFuZ2VudHNbMF0uZG90KHZlYy5jcm9zc1ZlY3RvcnMobm9ybWFsc1swXSwgbm9ybWFsc1tzZWdtZW50c10pKSA+IDApIHtcblx0XHRcdFx0XHR0aGV0YSA9IC10aGV0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxuXHRcdFx0XHRcdG5vcm1hbHNbaV0uYXBwbHlNYXRyaXg0KG1hdC5tYWtlUm90YXRpb25BeGlzKHRhbmdlbnRzW2ldLCB0aGV0YSAqIGkpKTtcblx0XHRcdFx0XHRiaW5vcm1hbHNbaV0uY3Jvc3NWZWN0b3JzKHRhbmdlbnRzW2ldLCBub3JtYWxzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0YW5nZW50czogdGFuZ2VudHMsXG5cdFx0XHRcdG5vcm1hbHM6IG5vcm1hbHMsXG5cdFx0XHRcdGJpbm9ybWFsczogYmlub3JtYWxzXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSBzb3VyY2UuYXJjTGVuZ3RoRGl2aXNpb25zO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdFx0dHlwZTogJ0N1cnZlJyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdDdXJ2ZS50b0pTT04nXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkYXRhLmFyY0xlbmd0aERpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xuXHRcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSBqc29uLmFyY0xlbmd0aERpdmlzaW9ucztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgRWxsaXBzZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXHRcdGNvbnN0cnVjdG9yKGFYID0gMCwgYVkgPSAwLCB4UmFkaXVzID0gMSwgeVJhZGl1cyA9IDEsIGFTdGFydEFuZ2xlID0gMCwgYUVuZEFuZ2xlID0gTWF0aC5QSSAqIDIsIGFDbG9ja3dpc2UgPSBmYWxzZSwgYVJvdGF0aW9uID0gMCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdFbGxpcHNlQ3VydmUnO1xuXHRcdFx0dGhpcy5hWCA9IGFYO1xuXHRcdFx0dGhpcy5hWSA9IGFZO1xuXHRcdFx0dGhpcy54UmFkaXVzID0geFJhZGl1cztcblx0XHRcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cdFx0XHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG5cdFx0XHR0aGlzLmFFbmRBbmdsZSA9IGFFbmRBbmdsZTtcblx0XHRcdHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XG5cdFx0XHR0aGlzLmFSb3RhdGlvbiA9IGFSb3RhdGlvbjtcblx0XHR9XG5cblx0XHRnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCkge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgdHdvUGkgPSBNYXRoLlBJICogMjtcblx0XHRcdGxldCBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xuXHRcdFx0Y29uc3Qgc2FtZVBvaW50cyA9IE1hdGguYWJzKGRlbHRhQW5nbGUpIDwgTnVtYmVyLkVQU0lMT047IC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxuXG5cdFx0XHR3aGlsZSAoZGVsdGFBbmdsZSA8IDApIGRlbHRhQW5nbGUgKz0gdHdvUGk7XG5cblx0XHRcdHdoaWxlIChkZWx0YUFuZ2xlID4gdHdvUGkpIGRlbHRhQW5nbGUgLT0gdHdvUGk7XG5cblx0XHRcdGlmIChkZWx0YUFuZ2xlIDwgTnVtYmVyLkVQU0lMT04pIHtcblx0XHRcdFx0aWYgKHNhbWVQb2ludHMpIHtcblx0XHRcdFx0XHRkZWx0YUFuZ2xlID0gMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWx0YUFuZ2xlID0gdHdvUGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhc2FtZVBvaW50cykge1xuXHRcdFx0XHRpZiAoZGVsdGFBbmdsZSA9PT0gdHdvUGkpIHtcblx0XHRcdFx0XHRkZWx0YUFuZ2xlID0gLXR3b1BpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbHRhQW5nbGUgPSBkZWx0YUFuZ2xlIC0gdHdvUGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cdFx0XHRsZXQgeCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRsZXQgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG5cblx0XHRcdGlmICh0aGlzLmFSb3RhdGlvbiAhPT0gMCkge1xuXHRcdFx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcyh0aGlzLmFSb3RhdGlvbik7XG5cdFx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKHRoaXMuYVJvdGF0aW9uKTtcblx0XHRcdFx0Y29uc3QgdHggPSB4IC0gdGhpcy5hWDtcblx0XHRcdFx0Y29uc3QgdHkgPSB5IC0gdGhpcy5hWTsgLy8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXG5cdFx0XHRcdHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgdGhpcy5hWDtcblx0XHRcdFx0eSA9IHR4ICogc2luICsgdHkgKiBjb3MgKyB0aGlzLmFZO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9pbnQuc2V0KHgsIHkpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmFYID0gc291cmNlLmFYO1xuXHRcdFx0dGhpcy5hWSA9IHNvdXJjZS5hWTtcblx0XHRcdHRoaXMueFJhZGl1cyA9IHNvdXJjZS54UmFkaXVzO1xuXHRcdFx0dGhpcy55UmFkaXVzID0gc291cmNlLnlSYWRpdXM7XG5cdFx0XHR0aGlzLmFTdGFydEFuZ2xlID0gc291cmNlLmFTdGFydEFuZ2xlO1xuXHRcdFx0dGhpcy5hRW5kQW5nbGUgPSBzb3VyY2UuYUVuZEFuZ2xlO1xuXHRcdFx0dGhpcy5hQ2xvY2t3aXNlID0gc291cmNlLmFDbG9ja3dpc2U7XG5cdFx0XHR0aGlzLmFSb3RhdGlvbiA9IHNvdXJjZS5hUm90YXRpb247XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLmFYID0gdGhpcy5hWDtcblx0XHRcdGRhdGEuYVkgPSB0aGlzLmFZO1xuXHRcdFx0ZGF0YS54UmFkaXVzID0gdGhpcy54UmFkaXVzO1xuXHRcdFx0ZGF0YS55UmFkaXVzID0gdGhpcy55UmFkaXVzO1xuXHRcdFx0ZGF0YS5hU3RhcnRBbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGU7XG5cdFx0XHRkYXRhLmFFbmRBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlO1xuXHRcdFx0ZGF0YS5hQ2xvY2t3aXNlID0gdGhpcy5hQ2xvY2t3aXNlO1xuXHRcdFx0ZGF0YS5hUm90YXRpb24gPSB0aGlzLmFSb3RhdGlvbjtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdFx0dGhpcy5hWCA9IGpzb24uYVg7XG5cdFx0XHR0aGlzLmFZID0ganNvbi5hWTtcblx0XHRcdHRoaXMueFJhZGl1cyA9IGpzb24ueFJhZGl1cztcblx0XHRcdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcblx0XHRcdHRoaXMuYVN0YXJ0QW5nbGUgPSBqc29uLmFTdGFydEFuZ2xlO1xuXHRcdFx0dGhpcy5hRW5kQW5nbGUgPSBqc29uLmFFbmRBbmdsZTtcblx0XHRcdHRoaXMuYUNsb2Nrd2lzZSA9IGpzb24uYUNsb2Nrd2lzZTtcblx0XHRcdHRoaXMuYVJvdGF0aW9uID0ganNvbi5hUm90YXRpb247XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuaXNFbGxpcHNlQ3VydmUgPSB0cnVlO1xuXG5cdGNsYXNzIEFyY0N1cnZlIGV4dGVuZHMgRWxsaXBzZUN1cnZlIHtcblx0XHRjb25zdHJ1Y3RvcihhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UpIHtcblx0XHRcdHN1cGVyKGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQXJjQ3VydmUnO1xuXHRcdH1cblxuXHR9XG5cblx0QXJjQ3VydmUucHJvdG90eXBlLmlzQXJjQ3VydmUgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xuXHQgKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cblx0ICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcblx0ICpcblx0ICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXG5cdCAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcblx0ICovXG5cblx0Lypcblx0QmFzZWQgb24gYW4gb3B0aW1pemVkIGMrKyBzb2x1dGlvbiBpblxuXHQgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuXHQgLSBodHRwOi8vaWRlb25lLmNvbS9Ob0ViVk1cblxuXHRUaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXG5cdGJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxuXHR3aGljaCBjYW4gYmUgcGxhY2VkIGluIEN1cnZlVXRpbHMuXG5cdCovXG5cblx0ZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXHRcdGxldCBjMCA9IDAsXG5cdFx0XHRcdGMxID0gMCxcblx0XHRcdFx0YzIgPSAwLFxuXHRcdFx0XHRjMyA9IDA7XG5cdFx0Lypcblx0XHQgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXG5cdFx0ICpcdCBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG5cdFx0ICogc3VjaCB0aGF0XG5cdFx0ICpcdCBwKDApID0geDAsIHAoMSkgPSB4MVxuXHRcdCAqXHRhbmRcblx0XHQgKlx0IHAnKDApID0gdDAsIHAnKDEpID0gdDEuXG5cdFx0ICovXG5cblx0XHRmdW5jdGlvbiBpbml0KHgwLCB4MSwgdDAsIHQxKSB7XG5cdFx0XHRjMCA9IHgwO1xuXHRcdFx0YzEgPSB0MDtcblx0XHRcdGMyID0gLTMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xuXHRcdFx0YzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRpbml0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uKSB7XG5cdFx0XHRcdGluaXQoeDEsIHgyLCB0ZW5zaW9uICogKHgyIC0geDApLCB0ZW5zaW9uICogKHgzIC0geDEpKTtcblx0XHRcdH0sXG5cdFx0XHRpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uICh4MCwgeDEsIHgyLCB4MywgZHQwLCBkdDEsIGR0Mikge1xuXHRcdFx0XHQvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXG5cdFx0XHRcdGxldCB0MSA9ICh4MSAtIHgwKSAvIGR0MCAtICh4MiAtIHgwKSAvIChkdDAgKyBkdDEpICsgKHgyIC0geDEpIC8gZHQxO1xuXHRcdFx0XHRsZXQgdDIgPSAoeDIgLSB4MSkgLyBkdDEgLSAoeDMgLSB4MSkgLyAoZHQxICsgZHQyKSArICh4MyAtIHgyKSAvIGR0MjsgLy8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXG5cblx0XHRcdFx0dDEgKj0gZHQxO1xuXHRcdFx0XHR0MiAqPSBkdDE7XG5cdFx0XHRcdGluaXQoeDEsIHgyLCB0MSwgdDIpO1xuXHRcdFx0fSxcblx0XHRcdGNhbGM6IGZ1bmN0aW9uICh0KSB7XG5cdFx0XHRcdGNvbnN0IHQyID0gdCAqIHQ7XG5cdFx0XHRcdGNvbnN0IHQzID0gdDIgKiB0O1xuXHRcdFx0XHRyZXR1cm4gYzAgKyBjMSAqIHQgKyBjMiAqIHQyICsgYzMgKiB0Mztcblx0XHRcdH1cblx0XHR9O1xuXHR9IC8vXG5cblxuXHRjb25zdCB0bXAgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBweCA9IG5ldyBDdWJpY1BvbHkoKSxcblx0XHRcdFx0cHkgPSBuZXcgQ3ViaWNQb2x5KCksXG5cdFx0XHRcdHB6ID0gbmV3IEN1YmljUG9seSgpO1xuXG5cdGNsYXNzIENhdG11bGxSb21DdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cdFx0Y29uc3RydWN0b3IocG9pbnRzID0gW10sIGNsb3NlZCA9IGZhbHNlLCBjdXJ2ZVR5cGUgPSAnY2VudHJpcGV0YWwnLCB0ZW5zaW9uID0gMC41KSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0NhdG11bGxSb21DdXJ2ZTMnO1xuXHRcdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cdFx0XHR0aGlzLmNsb3NlZCA9IGNsb3NlZDtcblx0XHRcdHRoaXMuY3VydmVUeXBlID0gY3VydmVUeXBlO1xuXHRcdFx0dGhpcy50ZW5zaW9uID0gdGVuc2lvbjtcblx0XHR9XG5cblx0XHRnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cdFx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRcdGNvbnN0IGwgPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0Y29uc3QgcCA9IChsIC0gKHRoaXMuY2xvc2VkID8gMCA6IDEpKSAqIHQ7XG5cdFx0XHRsZXQgaW50UG9pbnQgPSBNYXRoLmZsb29yKHApO1xuXHRcdFx0bGV0IHdlaWdodCA9IHAgLSBpbnRQb2ludDtcblxuXHRcdFx0aWYgKHRoaXMuY2xvc2VkKSB7XG5cdFx0XHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoTWF0aC5mbG9vcihNYXRoLmFicyhpbnRQb2ludCkgLyBsKSArIDEpICogbDtcblx0XHRcdH0gZWxzZSBpZiAod2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSkge1xuXHRcdFx0XHRpbnRQb2ludCA9IGwgLSAyO1xuXHRcdFx0XHR3ZWlnaHQgPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcDAsIHAzOyAvLyA0IHBvaW50cyAocDEgJiBwMiBkZWZpbmVkIGJlbG93KVxuXG5cdFx0XHRpZiAodGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgPiAwKSB7XG5cdFx0XHRcdHAwID0gcG9pbnRzWyhpbnRQb2ludCAtIDEpICUgbF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxuXHRcdFx0XHR0bXAuc3ViVmVjdG9ycyhwb2ludHNbMF0sIHBvaW50c1sxXSkuYWRkKHBvaW50c1swXSk7XG5cdFx0XHRcdHAwID0gdG1wO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwMSA9IHBvaW50c1tpbnRQb2ludCAlIGxdO1xuXHRcdFx0Y29uc3QgcDIgPSBwb2ludHNbKGludFBvaW50ICsgMSkgJSBsXTtcblxuXHRcdFx0aWYgKHRoaXMuY2xvc2VkIHx8IGludFBvaW50ICsgMiA8IGwpIHtcblx0XHRcdFx0cDMgPSBwb2ludHNbKGludFBvaW50ICsgMikgJSBsXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGV4dHJhcG9sYXRlIGxhc3QgcG9pbnRcblx0XHRcdFx0dG1wLnN1YlZlY3RvcnMocG9pbnRzW2wgLSAxXSwgcG9pbnRzW2wgLSAyXSkuYWRkKHBvaW50c1tsIC0gMV0pO1xuXHRcdFx0XHRwMyA9IHRtcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuY3VydmVUeXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcpIHtcblx0XHRcdFx0Ly8gaW5pdCBDZW50cmlwZXRhbCAvIENob3JkYWwgQ2F0bXVsbC1Sb21cblx0XHRcdFx0Y29uc3QgcG93ID0gdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG5cdFx0XHRcdGxldCBkdDAgPSBNYXRoLnBvdyhwMC5kaXN0YW5jZVRvU3F1YXJlZChwMSksIHBvdyk7XG5cdFx0XHRcdGxldCBkdDEgPSBNYXRoLnBvdyhwMS5kaXN0YW5jZVRvU3F1YXJlZChwMiksIHBvdyk7XG5cdFx0XHRcdGxldCBkdDIgPSBNYXRoLnBvdyhwMi5kaXN0YW5jZVRvU3F1YXJlZChwMyksIHBvdyk7IC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXG5cblx0XHRcdFx0aWYgKGR0MSA8IDFlLTQpIGR0MSA9IDEuMDtcblx0XHRcdFx0aWYgKGR0MCA8IDFlLTQpIGR0MCA9IGR0MTtcblx0XHRcdFx0aWYgKGR0MiA8IDFlLTQpIGR0MiA9IGR0MTtcblx0XHRcdFx0cHguaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIpO1xuXHRcdFx0XHRweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20ocDAueSwgcDEueSwgcDIueSwgcDMueSwgZHQwLCBkdDEsIGR0Mik7XG5cdFx0XHRcdHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbShwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5jdXJ2ZVR5cGUgPT09ICdjYXRtdWxscm9tJykge1xuXHRcdFx0XHRweC5pbml0Q2F0bXVsbFJvbShwMC54LCBwMS54LCBwMi54LCBwMy54LCB0aGlzLnRlbnNpb24pO1xuXHRcdFx0XHRweS5pbml0Q2F0bXVsbFJvbShwMC55LCBwMS55LCBwMi55LCBwMy55LCB0aGlzLnRlbnNpb24pO1xuXHRcdFx0XHRwei5pbml0Q2F0bXVsbFJvbShwMC56LCBwMS56LCBwMi56LCBwMy56LCB0aGlzLnRlbnNpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludC5zZXQocHguY2FsYyh3ZWlnaHQpLCBweS5jYWxjKHdlaWdodCksIHB6LmNhbGMod2VpZ2h0KSk7XG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzW2ldO1xuXHRcdFx0XHR0aGlzLnBvaW50cy5wdXNoKHBvaW50LmNsb25lKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNsb3NlZCA9IHNvdXJjZS5jbG9zZWQ7XG5cdFx0XHR0aGlzLmN1cnZlVHlwZSA9IHNvdXJjZS5jdXJ2ZVR5cGU7XG5cdFx0XHR0aGlzLnRlbnNpb24gPSBzb3VyY2UudGVuc2lvbjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGRhdGEucG9pbnRzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gdGhpcy5wb2ludHNbaV07XG5cdFx0XHRcdGRhdGEucG9pbnRzLnB1c2gocG9pbnQudG9BcnJheSgpKTtcblx0XHRcdH1cblxuXHRcdFx0ZGF0YS5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcblx0XHRcdGRhdGEuY3VydmVUeXBlID0gdGhpcy5jdXJ2ZVR5cGU7XG5cdFx0XHRkYXRhLnRlbnNpb24gPSB0aGlzLnRlbnNpb247XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRmcm9tSlNPTihqc29uKSB7XG5cdFx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHBvaW50ID0ganNvbi5wb2ludHNbaV07XG5cdFx0XHRcdHRoaXMucG9pbnRzLnB1c2gobmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkocG9pbnQpKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jbG9zZWQgPSBqc29uLmNsb3NlZDtcblx0XHRcdHRoaXMuY3VydmVUeXBlID0ganNvbi5jdXJ2ZVR5cGU7XG5cdFx0XHR0aGlzLnRlbnNpb24gPSBqc29uLnRlbnNpb247XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmlzQ2F0bXVsbFJvbUN1cnZlMyA9IHRydWU7XG5cblx0LyoqXG5cdCAqIEJlemllciBDdXJ2ZXMgZm9ybXVsYXMgb2J0YWluZWQgZnJvbVxuXHQgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0LDqXppZXJfY3VydmVcblx0ICovXG5cdGZ1bmN0aW9uIENhdG11bGxSb20odCwgcDAsIHAxLCBwMiwgcDMpIHtcblx0XHRjb25zdCB2MCA9IChwMiAtIHAwKSAqIDAuNTtcblx0XHRjb25zdCB2MSA9IChwMyAtIHAxKSAqIDAuNTtcblx0XHRjb25zdCB0MiA9IHQgKiB0O1xuXHRcdGNvbnN0IHQzID0gdCAqIHQyO1xuXHRcdHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcblx0fSAvL1xuXG5cblx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDAodCwgcCkge1xuXHRcdGNvbnN0IGsgPSAxIC0gdDtcblx0XHRyZXR1cm4gayAqIGsgKiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDEodCwgcCkge1xuXHRcdHJldHVybiAyICogKDEgLSB0KSAqIHQgKiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDIodCwgcCkge1xuXHRcdHJldHVybiB0ICogdCAqIHA7XG5cdH1cblxuXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXIodCwgcDAsIHAxLCBwMikge1xuXHRcdHJldHVybiBRdWFkcmF0aWNCZXppZXJQMCh0LCBwMCkgKyBRdWFkcmF0aWNCZXppZXJQMSh0LCBwMSkgKyBRdWFkcmF0aWNCZXppZXJQMih0LCBwMik7XG5cdH0gLy9cblxuXG5cdGZ1bmN0aW9uIEN1YmljQmV6aWVyUDAodCwgcCkge1xuXHRcdGNvbnN0IGsgPSAxIC0gdDtcblx0XHRyZXR1cm4gayAqIGsgKiBrICogcDtcblx0fVxuXG5cdGZ1bmN0aW9uIEN1YmljQmV6aWVyUDEodCwgcCkge1xuXHRcdGNvbnN0IGsgPSAxIC0gdDtcblx0XHRyZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XG5cdH1cblxuXHRmdW5jdGlvbiBDdWJpY0JlemllclAyKHQsIHApIHtcblx0XHRyZXR1cm4gMyAqICgxIC0gdCkgKiB0ICogdCAqIHA7XG5cdH1cblxuXHRmdW5jdGlvbiBDdWJpY0JlemllclAzKHQsIHApIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcblx0fVxuXG5cdGZ1bmN0aW9uIEN1YmljQmV6aWVyKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG5cdFx0cmV0dXJuIEN1YmljQmV6aWVyUDAodCwgcDApICsgQ3ViaWNCZXppZXJQMSh0LCBwMSkgKyBDdWJpY0JlemllclAyKHQsIHAyKSArIEN1YmljQmV6aWVyUDModCwgcDMpO1xuXHR9XG5cblx0Y2xhc3MgQ3ViaWNCZXppZXJDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblx0XHRjb25zdHJ1Y3Rvcih2MCA9IG5ldyBWZWN0b3IyKCksIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpLCB2MyA9IG5ldyBWZWN0b3IyKCkpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZSc7XG5cdFx0XHR0aGlzLnYwID0gdjA7XG5cdFx0XHR0aGlzLnYxID0gdjE7XG5cdFx0XHR0aGlzLnYyID0gdjI7XG5cdFx0XHR0aGlzLnYzID0gdjM7XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXHRcdFx0Y29uc3QgdjAgPSB0aGlzLnYwLFxuXHRcdFx0XHRcdFx0djEgPSB0aGlzLnYxLFxuXHRcdFx0XHRcdFx0djIgPSB0aGlzLnYyLFxuXHRcdFx0XHRcdFx0djMgPSB0aGlzLnYzO1xuXHRcdFx0cG9pbnQuc2V0KEN1YmljQmV6aWVyKHQsIHYwLngsIHYxLngsIHYyLngsIHYzLngpLCBDdWJpY0Jlemllcih0LCB2MC55LCB2MS55LCB2Mi55LCB2My55KSk7XG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMudjAuY29weShzb3VyY2UudjApO1xuXHRcdFx0dGhpcy52MS5jb3B5KHNvdXJjZS52MSk7XG5cdFx0XHR0aGlzLnYyLmNvcHkoc291cmNlLnYyKTtcblx0XHRcdHRoaXMudjMuY29weShzb3VyY2UudjMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MyA9IHRoaXMudjMudG9BcnJheSgpO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0XHR0aGlzLnYwLmZyb21BcnJheShqc29uLnYwKTtcblx0XHRcdHRoaXMudjEuZnJvbUFycmF5KGpzb24udjEpO1xuXHRcdFx0dGhpcy52Mi5mcm9tQXJyYXkoanNvbi52Mik7XG5cdFx0XHR0aGlzLnYzLmZyb21BcnJheShqc29uLnYzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuaXNDdWJpY0JlemllckN1cnZlID0gdHJ1ZTtcblxuXHRjbGFzcyBDdWJpY0JlemllckN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblx0XHRjb25zdHJ1Y3Rvcih2MCA9IG5ldyBWZWN0b3IzKCksIHYxID0gbmV3IFZlY3RvcjMoKSwgdjIgPSBuZXcgVmVjdG9yMygpLCB2MyA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZTMnO1xuXHRcdFx0dGhpcy52MCA9IHYwO1xuXHRcdFx0dGhpcy52MSA9IHYxO1xuXHRcdFx0dGhpcy52MiA9IHYyO1xuXHRcdFx0dGhpcy52MyA9IHYzO1xuXHRcdH1cblxuXHRcdGdldFBvaW50KHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSkge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblx0XHRcdGNvbnN0IHYwID0gdGhpcy52MCxcblx0XHRcdFx0XHRcdHYxID0gdGhpcy52MSxcblx0XHRcdFx0XHRcdHYyID0gdGhpcy52Mixcblx0XHRcdFx0XHRcdHYzID0gdGhpcy52Mztcblx0XHRcdHBvaW50LnNldChDdWJpY0Jlemllcih0LCB2MC54LCB2MS54LCB2Mi54LCB2My54KSwgQ3ViaWNCZXppZXIodCwgdjAueSwgdjEueSwgdjIueSwgdjMueSksIEN1YmljQmV6aWVyKHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnopKTtcblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy52MC5jb3B5KHNvdXJjZS52MCk7XG5cdFx0XHR0aGlzLnYxLmNvcHkoc291cmNlLnYxKTtcblx0XHRcdHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuXHRcdFx0dGhpcy52My5jb3B5KHNvdXJjZS52Myk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG5cdFx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRmcm9tSlNPTihqc29uKSB7XG5cdFx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHRcdHRoaXMudjAuZnJvbUFycmF5KGpzb24udjApO1xuXHRcdFx0dGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG5cdFx0XHR0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcblx0XHRcdHRoaXMudjMuZnJvbUFycmF5KGpzb24udjMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuaXNDdWJpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0Y2xhc3MgTGluZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXHRcdGNvbnN0cnVjdG9yKHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZSc7XG5cdFx0XHR0aGlzLnYxID0gdjE7XG5cdFx0XHR0aGlzLnYyID0gdjI7XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0XHRwb2ludC5jb3B5KHRoaXMudjIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnQuY29weSh0aGlzLnYyKS5zdWIodGhpcy52MSk7XG5cdFx0XHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnYxKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH0gLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cblxuXHRcdGdldFBvaW50QXQodSwgb3B0aW9uYWxUYXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFBvaW50KHUsIG9wdGlvbmFsVGFyZ2V0KTtcblx0XHR9XG5cblx0XHRnZXRUYW5nZW50KHQsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCB0YW5nZW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHRcdHRhbmdlbnQuY29weSh0aGlzLnYyKS5zdWIodGhpcy52MSkubm9ybWFsaXplKCk7XG5cdFx0XHRyZXR1cm4gdGFuZ2VudDtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy52MS5jb3B5KHNvdXJjZS52MSk7XG5cdFx0XHR0aGlzLnYyLmNvcHkoc291cmNlLnYyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcblx0XHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdFx0dGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG5cdFx0XHR0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0TGluZUN1cnZlLnByb3RvdHlwZS5pc0xpbmVDdXJ2ZSA9IHRydWU7XG5cblx0Y2xhc3MgTGluZUN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblx0XHRjb25zdHJ1Y3Rvcih2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUzJztcblx0XHRcdHRoaXMuaXNMaW5lQ3VydmUzID0gdHJ1ZTtcblx0XHRcdHRoaXMudjEgPSB2MTtcblx0XHRcdHRoaXMudjIgPSB2Mjtcblx0XHR9XG5cblx0XHRnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRcdHBvaW50LmNvcHkodGhpcy52Mik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludC5jb3B5KHRoaXMudjIpLnN1Yih0aGlzLnYxKTtcblx0XHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIodCkuYWRkKHRoaXMudjEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fSAvLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcblxuXG5cdFx0Z2V0UG9pbnRBdCh1LCBvcHRpb25hbFRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQodSwgb3B0aW9uYWxUYXJnZXQpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnYxLmNvcHkoc291cmNlLnYxKTtcblx0XHRcdHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0XHR0aGlzLnYxLmZyb21BcnJheShqc29uLnYxKTtcblx0XHRcdHRoaXMudjIuZnJvbUFycmF5KGpzb24udjIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblx0XHRjb25zdHJ1Y3Rvcih2MCA9IG5ldyBWZWN0b3IyKCksIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlJztcblx0XHRcdHRoaXMudjAgPSB2MDtcblx0XHRcdHRoaXMudjEgPSB2MTtcblx0XHRcdHRoaXMudjIgPSB2Mjtcblx0XHR9XG5cblx0XHRnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IyKCkpIHtcblx0XHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cdFx0XHRjb25zdCB2MCA9IHRoaXMudjAsXG5cdFx0XHRcdFx0XHR2MSA9IHRoaXMudjEsXG5cdFx0XHRcdFx0XHR2MiA9IHRoaXMudjI7XG5cdFx0XHRwb2ludC5zZXQoUXVhZHJhdGljQmV6aWVyKHQsIHYwLngsIHYxLngsIHYyLngpLCBRdWFkcmF0aWNCZXppZXIodCwgdjAueSwgdjEueSwgdjIueSkpO1xuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnYwLmNvcHkoc291cmNlLnYwKTtcblx0XHRcdHRoaXMudjEuY29weShzb3VyY2UudjEpO1xuXHRcdFx0dGhpcy52Mi5jb3B5KHNvdXJjZS52Mik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRmcm9tSlNPTihqc29uKSB7XG5cdFx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHRcdHRoaXMudjAuZnJvbUFycmF5KGpzb24udjApO1xuXHRcdFx0dGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG5cdFx0XHR0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUgPSB0cnVlO1xuXG5cdGNsYXNzIFF1YWRyYXRpY0JlemllckN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblx0XHRjb25zdHJ1Y3Rvcih2MCA9IG5ldyBWZWN0b3IzKCksIHYxID0gbmV3IFZlY3RvcjMoKSwgdjIgPSBuZXcgVmVjdG9yMygpKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlMyc7XG5cdFx0XHR0aGlzLnYwID0gdjA7XG5cdFx0XHR0aGlzLnYxID0gdjE7XG5cdFx0XHR0aGlzLnYyID0gdjI7XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXHRcdFx0Y29uc3QgdjAgPSB0aGlzLnYwLFxuXHRcdFx0XHRcdFx0djEgPSB0aGlzLnYxLFxuXHRcdFx0XHRcdFx0djIgPSB0aGlzLnYyO1xuXHRcdFx0cG9pbnQuc2V0KFF1YWRyYXRpY0Jlemllcih0LCB2MC54LCB2MS54LCB2Mi54KSwgUXVhZHJhdGljQmV6aWVyKHQsIHYwLnksIHYxLnksIHYyLnkpLCBRdWFkcmF0aWNCZXppZXIodCwgdjAueiwgdjEueiwgdjIueikpO1xuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnYwLmNvcHkoc291cmNlLnYwKTtcblx0XHRcdHRoaXMudjEuY29weShzb3VyY2UudjEpO1xuXHRcdFx0dGhpcy52Mi5jb3B5KHNvdXJjZS52Mik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRmcm9tSlNPTihqc29uKSB7XG5cdFx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHRcdHRoaXMudjAuZnJvbUFycmF5KGpzb24udjApO1xuXHRcdFx0dGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG5cdFx0XHR0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5pc1F1YWRyYXRpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0Y2xhc3MgU3BsaW5lQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cdFx0Y29uc3RydWN0b3IocG9pbnRzID0gW10pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU3BsaW5lQ3VydmUnO1xuXHRcdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0XHRjb25zdCBwID0gKHBvaW50cy5sZW5ndGggLSAxKSAqIHQ7XG5cdFx0XHRjb25zdCBpbnRQb2ludCA9IE1hdGguZmxvb3IocCk7XG5cdFx0XHRjb25zdCB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XG5cdFx0XHRjb25zdCBwMCA9IHBvaW50c1tpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxXTtcblx0XHRcdGNvbnN0IHAxID0gcG9pbnRzW2ludFBvaW50XTtcblx0XHRcdGNvbnN0IHAyID0gcG9pbnRzW2ludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMV07XG5cdFx0XHRjb25zdCBwMyA9IHBvaW50c1tpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDJdO1xuXHRcdFx0cG9pbnQuc2V0KENhdG11bGxSb20od2VpZ2h0LCBwMC54LCBwMS54LCBwMi54LCBwMy54KSwgQ2F0bXVsbFJvbSh3ZWlnaHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkpKTtcblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzb3VyY2UucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBwb2ludCA9IHNvdXJjZS5wb2ludHNbaV07XG5cdFx0XHRcdHRoaXMucG9pbnRzLnB1c2gocG9pbnQuY2xvbmUoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGRhdGEucG9pbnRzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gdGhpcy5wb2ludHNbaV07XG5cdFx0XHRcdGRhdGEucG9pbnRzLnB1c2gocG9pbnQudG9BcnJheSgpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBwb2ludCA9IGpzb24ucG9pbnRzW2ldO1xuXHRcdFx0XHR0aGlzLnBvaW50cy5wdXNoKG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KHBvaW50KSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xuXG5cdHZhciBDdXJ2ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0X19wcm90b19fOiBudWxsLFxuXHRcdEFyY0N1cnZlOiBBcmNDdXJ2ZSxcblx0XHRDYXRtdWxsUm9tQ3VydmUzOiBDYXRtdWxsUm9tQ3VydmUzLFxuXHRcdEN1YmljQmV6aWVyQ3VydmU6IEN1YmljQmV6aWVyQ3VydmUsXG5cdFx0Q3ViaWNCZXppZXJDdXJ2ZTM6IEN1YmljQmV6aWVyQ3VydmUzLFxuXHRcdEVsbGlwc2VDdXJ2ZTogRWxsaXBzZUN1cnZlLFxuXHRcdExpbmVDdXJ2ZTogTGluZUN1cnZlLFxuXHRcdExpbmVDdXJ2ZTM6IExpbmVDdXJ2ZTMsXG5cdFx0UXVhZHJhdGljQmV6aWVyQ3VydmU6IFF1YWRyYXRpY0JlemllckN1cnZlLFxuXHRcdFF1YWRyYXRpY0JlemllckN1cnZlMzogUXVhZHJhdGljQmV6aWVyQ3VydmUzLFxuXHRcdFNwbGluZUN1cnZlOiBTcGxpbmVDdXJ2ZVxuXHR9KTtcblxuXHQvKipcblx0ICogUG9ydCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0ICh2Mi4yLjIpXG5cdCAqL1xuXHRjb25zdCBFYXJjdXQgPSB7XG5cdFx0dHJpYW5ndWxhdGU6IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltID0gMikge1xuXHRcdFx0Y29uc3QgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG5cdFx0XHRjb25zdCBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblx0XHRcdGxldCBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpO1xuXHRcdFx0Y29uc3QgdHJpYW5nbGVzID0gW107XG5cdFx0XHRpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG5cdFx0XHRsZXQgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcblx0XHRcdGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTsgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG5cblx0XHRcdGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG5cdFx0XHRcdG1pblggPSBtYXhYID0gZGF0YVswXTtcblx0XHRcdFx0bWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcblx0XHRcdFx0XHR4ID0gZGF0YVtpXTtcblx0XHRcdFx0XHR5ID0gZGF0YVtpICsgMV07XG5cdFx0XHRcdFx0aWYgKHggPCBtaW5YKSBtaW5YID0geDtcblx0XHRcdFx0XHRpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuXHRcdFx0XHRcdGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG5cdFx0XHRcdFx0aWYgKHkgPiBtYXhZKSBtYXhZID0geTtcblx0XHRcdFx0fSAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuXG5cblx0XHRcdFx0aW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG5cdFx0XHRcdGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMSAvIGludlNpemUgOiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cdFx0XHRyZXR1cm4gdHJpYW5nbGVzO1xuXHRcdH1cblx0fTsgLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5cblx0ZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuXHRcdGxldCBpLCBsYXN0O1xuXG5cdFx0aWYgKGNsb2Nrd2lzZSA9PT0gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkge1xuXHRcdFx0Zm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcblx0XHR9XG5cblx0XHRpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuXHRcdFx0cmVtb3ZlTm9kZShsYXN0KTtcblx0XHRcdGxhc3QgPSBsYXN0Lm5leHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxhc3Q7XG5cdH0gLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcblxuXG5cdGZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG5cdFx0aWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuXHRcdGlmICghZW5kKSBlbmQgPSBzdGFydDtcblx0XHRsZXQgcCA9IHN0YXJ0LFxuXHRcdFx0XHRhZ2FpbjtcblxuXHRcdGRvIHtcblx0XHRcdGFnYWluID0gZmFsc2U7XG5cblx0XHRcdGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcblx0XHRcdFx0cmVtb3ZlTm9kZShwKTtcblx0XHRcdFx0cCA9IGVuZCA9IHAucHJldjtcblx0XHRcdFx0aWYgKHAgPT09IHAubmV4dCkgYnJlYWs7XG5cdFx0XHRcdGFnYWluID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHAgPSBwLm5leHQ7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuXHRcdHJldHVybiBlbmQ7XG5cdH0gLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5cblxuXHRmdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcykge1xuXHRcdGlmICghZWFyKSByZXR1cm47IC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcblxuXHRcdGlmICghcGFzcyAmJiBpbnZTaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cdFx0bGV0IHN0b3AgPSBlYXIsXG5cdFx0XHRcdHByZXYsXG5cdFx0XHRcdG5leHQ7IC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuXG5cdFx0d2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuXHRcdFx0cHJldiA9IGVhci5wcmV2O1xuXHRcdFx0bmV4dCA9IGVhci5uZXh0O1xuXG5cdFx0XHRpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG5cdFx0XHRcdC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcblx0XHRcdFx0dHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcblx0XHRcdFx0cmVtb3ZlTm9kZShlYXIpOyAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG5cblx0XHRcdFx0ZWFyID0gbmV4dC5uZXh0O1xuXHRcdFx0XHRzdG9wID0gbmV4dC5uZXh0O1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0ZWFyID0gbmV4dDsgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcblxuXHRcdFx0aWYgKGVhciA9PT0gc3RvcCkge1xuXHRcdFx0XHQvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuXHRcdFx0XHRpZiAoIXBhc3MpIHtcblx0XHRcdFx0XHRlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTsgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcblx0XHRcdFx0fSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG5cdFx0XHRcdFx0ZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0pO1xuXHRcdFx0XHRcdGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyKTsgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cblx0XHRcdFx0fSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG5cdFx0XHRcdFx0c3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH0gLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5cblxuXHRmdW5jdGlvbiBpc0VhcihlYXIpIHtcblx0XHRjb25zdCBhID0gZWFyLnByZXYsXG5cdFx0XHRcdFx0YiA9IGVhcixcblx0XHRcdFx0XHRjID0gZWFyLm5leHQ7XG5cdFx0aWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXHRcdC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG5cblx0XHRsZXQgcCA9IGVhci5uZXh0Lm5leHQ7XG5cblx0XHR3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcblx0XHRcdGlmIChwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcblx0XHRcdHAgPSBwLm5leHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIHtcblx0XHRjb25zdCBhID0gZWFyLnByZXYsXG5cdFx0XHRcdFx0YiA9IGVhcixcblx0XHRcdFx0XHRjID0gZWFyLm5leHQ7XG5cdFx0aWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXHRcdC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG5cblx0XHRjb25zdCBtaW5UWCA9IGEueCA8IGIueCA/IGEueCA8IGMueCA/IGEueCA6IGMueCA6IGIueCA8IGMueCA/IGIueCA6IGMueCxcblx0XHRcdFx0XHRtaW5UWSA9IGEueSA8IGIueSA/IGEueSA8IGMueSA/IGEueSA6IGMueSA6IGIueSA8IGMueSA/IGIueSA6IGMueSxcblx0XHRcdFx0XHRtYXhUWCA9IGEueCA+IGIueCA/IGEueCA+IGMueCA/IGEueCA6IGMueCA6IGIueCA+IGMueCA/IGIueCA6IGMueCxcblx0XHRcdFx0XHRtYXhUWSA9IGEueSA+IGIueSA/IGEueSA+IGMueSA/IGEueSA6IGMueSA6IGIueSA+IGMueSA/IGIueSA6IGMueTsgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcblxuXHRcdGNvbnN0IG1pblogPSB6T3JkZXIobWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSxcblx0XHRcdFx0XHRtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cdFx0bGV0IHAgPSBlYXIucHJldlosXG5cdFx0XHRcdG4gPSBlYXIubmV4dFo7IC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuXG5cdFx0d2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xuXHRcdFx0aWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0cCA9IHAucHJldlo7XG5cdFx0XHRpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiYgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRuID0gbi5uZXh0Wjtcblx0XHR9IC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG5cblxuXHRcdHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG5cdFx0XHRpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiYgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRwID0gcC5wcmV2Wjtcblx0XHR9IC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG5cblxuXHRcdHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG5cdFx0XHRpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiYgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRuID0gbi5uZXh0Wjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSAvLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuXG5cblx0ZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcblx0XHRsZXQgcCA9IHN0YXJ0O1xuXG5cdFx0ZG8ge1xuXHRcdFx0Y29uc3QgYSA9IHAucHJldixcblx0XHRcdFx0XHRcdGIgPSBwLm5leHQubmV4dDtcblxuXHRcdFx0aWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXHRcdFx0XHR0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xuXHRcdFx0XHR0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0pO1xuXHRcdFx0XHR0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pOyAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG5cblx0XHRcdFx0cmVtb3ZlTm9kZShwKTtcblx0XHRcdFx0cmVtb3ZlTm9kZShwLm5leHQpO1xuXHRcdFx0XHRwID0gc3RhcnQgPSBiO1xuXHRcdFx0fVxuXG5cdFx0XHRwID0gcC5uZXh0O1xuXHRcdH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuXHRcdHJldHVybiBmaWx0ZXJQb2ludHMocCk7XG5cdH0gLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcblxuXG5cdGZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuXHRcdC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG5cdFx0bGV0IGEgPSBzdGFydDtcblxuXHRcdGRvIHtcblx0XHRcdGxldCBiID0gYS5uZXh0Lm5leHQ7XG5cblx0XHRcdHdoaWxlIChiICE9PSBhLnByZXYpIHtcblx0XHRcdFx0aWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuXHRcdFx0XHRcdC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcblx0XHRcdFx0XHRsZXQgYyA9IHNwbGl0UG9seWdvbihhLCBiKTsgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcblxuXHRcdFx0XHRcdGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcblx0XHRcdFx0XHRjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7IC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG5cblx0XHRcdFx0XHRlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuXHRcdFx0XHRcdGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YiA9IGIubmV4dDtcblx0XHRcdH1cblxuXHRcdFx0YSA9IGEubmV4dDtcblx0XHR9IHdoaWxlIChhICE9PSBzdGFydCk7XG5cdH0gLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuXG5cblx0ZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG5cdFx0Y29uc3QgcXVldWUgPSBbXTtcblx0XHRsZXQgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG5cdFx0XHRlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXHRcdFx0bGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG5cdFx0XHRpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuXHRcdFx0cXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG5cdFx0fVxuXG5cdFx0cXVldWUuc29ydChjb21wYXJlWCk7IC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG5cdFx0XHRvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dGVyTm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcblx0XHRyZXR1cm4gYS54IC0gYi54O1xuXHR9IC8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuXG5cblx0ZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcblx0XHRvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuXG5cdFx0aWYgKG91dGVyTm9kZSkge1xuXHRcdFx0Y29uc3QgYiA9IHNwbGl0UG9seWdvbihvdXRlck5vZGUsIGhvbGUpOyAvLyBmaWx0ZXIgY29sbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcblxuXHRcdFx0ZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuXHRcdFx0ZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG5cdFx0fVxuXHR9IC8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cblxuXG5cdGZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuXHRcdGxldCBwID0gb3V0ZXJOb2RlO1xuXHRcdGNvbnN0IGh4ID0gaG9sZS54O1xuXHRcdGNvbnN0IGh5ID0gaG9sZS55O1xuXHRcdGxldCBxeCA9IC1JbmZpbml0eSxcblx0XHRcdFx0bTsgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuXHRcdC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcblxuXHRcdGRvIHtcblx0XHRcdGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuXHRcdFx0XHRjb25zdCB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuXG5cdFx0XHRcdGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuXHRcdFx0XHRcdHF4ID0geDtcblxuXHRcdFx0XHRcdGlmICh4ID09PSBoeCkge1xuXHRcdFx0XHRcdFx0aWYgKGh5ID09PSBwLnkpIHJldHVybiBwO1xuXHRcdFx0XHRcdFx0aWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHAgPSBwLm5leHQ7XG5cdFx0fSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuXHRcdGlmICghbSkgcmV0dXJuIG51bGw7XG5cdFx0aWYgKGh4ID09PSBxeCkgcmV0dXJuIG07IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxlZnRtb3N0IGVuZHBvaW50XG5cdFx0Ly8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuXHRcdC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuXHRcdC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cblx0XHRjb25zdCBzdG9wID0gbSxcblx0XHRcdFx0XHRteCA9IG0ueCxcblx0XHRcdFx0XHRteSA9IG0ueTtcblx0XHRsZXQgdGFuTWluID0gSW5maW5pdHksXG5cdFx0XHRcdHRhbjtcblx0XHRwID0gbTtcblxuXHRcdGRvIHtcblx0XHRcdGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiYgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXHRcdFx0XHR0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cblx0XHRcdFx0aWYgKGxvY2FsbHlJbnNpZGUocCwgaG9sZSkgJiYgKHRhbiA8IHRhbk1pbiB8fCB0YW4gPT09IHRhbk1pbiAmJiAocC54ID4gbS54IHx8IHAueCA9PT0gbS54ICYmIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApKSkpIHtcblx0XHRcdFx0XHRtID0gcDtcblx0XHRcdFx0XHR0YW5NaW4gPSB0YW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cCA9IHAubmV4dDtcblx0XHR9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuXHRcdHJldHVybiBtO1xuXHR9IC8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xuXG5cblx0ZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkge1xuXHRcdHJldHVybiBhcmVhKG0ucHJldiwgbSwgcC5wcmV2KSA8IDAgJiYgYXJlYShwLm5leHQsIG0sIG0ubmV4dCkgPCAwO1xuXHR9IC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcblxuXG5cdGZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcblx0XHRsZXQgcCA9IHN0YXJ0O1xuXG5cdFx0ZG8ge1xuXHRcdFx0aWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblx0XHRcdHAucHJldlogPSBwLnByZXY7XG5cdFx0XHRwLm5leHRaID0gcC5uZXh0O1xuXHRcdFx0cCA9IHAubmV4dDtcblx0XHR9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cblx0XHRwLnByZXZaLm5leHRaID0gbnVsbDtcblx0XHRwLnByZXZaID0gbnVsbDtcblx0XHRzb3J0TGlua2VkKHApO1xuXHR9IC8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG5cdC8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5cblxuXHRmdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcblx0XHRsZXQgaSxcblx0XHRcdFx0cCxcblx0XHRcdFx0cSxcblx0XHRcdFx0ZSxcblx0XHRcdFx0dGFpbCxcblx0XHRcdFx0bnVtTWVyZ2VzLFxuXHRcdFx0XHRwU2l6ZSxcblx0XHRcdFx0cVNpemUsXG5cdFx0XHRcdGluU2l6ZSA9IDE7XG5cblx0XHRkbyB7XG5cdFx0XHRwID0gbGlzdDtcblx0XHRcdGxpc3QgPSBudWxsO1xuXHRcdFx0dGFpbCA9IG51bGw7XG5cdFx0XHRudW1NZXJnZXMgPSAwO1xuXG5cdFx0XHR3aGlsZSAocCkge1xuXHRcdFx0XHRudW1NZXJnZXMrKztcblx0XHRcdFx0cSA9IHA7XG5cdFx0XHRcdHBTaXplID0gMDtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcblx0XHRcdFx0XHRwU2l6ZSsrO1xuXHRcdFx0XHRcdHEgPSBxLm5leHRaO1xuXHRcdFx0XHRcdGlmICghcSkgYnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRxU2l6ZSA9IGluU2l6ZTtcblxuXHRcdFx0XHR3aGlsZSAocFNpemUgPiAwIHx8IHFTaXplID4gMCAmJiBxKSB7XG5cdFx0XHRcdFx0aWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuXHRcdFx0XHRcdFx0ZSA9IHA7XG5cdFx0XHRcdFx0XHRwID0gcC5uZXh0Wjtcblx0XHRcdFx0XHRcdHBTaXplLS07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGUgPSBxO1xuXHRcdFx0XHRcdFx0cSA9IHEubmV4dFo7XG5cdFx0XHRcdFx0XHRxU2l6ZS0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtlbHNlIGxpc3QgPSBlO1xuXHRcdFx0XHRcdGUucHJldlogPSB0YWlsO1xuXHRcdFx0XHRcdHRhaWwgPSBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cCA9IHE7XG5cdFx0XHR9XG5cblx0XHRcdHRhaWwubmV4dFogPSBudWxsO1xuXHRcdFx0aW5TaXplICo9IDI7XG5cdFx0fSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cblx0XHRyZXR1cm4gbGlzdDtcblx0fSAvLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcblxuXG5cdGZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG5cdFx0Ly8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuXHRcdHggPSAzMjc2NyAqICh4IC0gbWluWCkgKiBpbnZTaXplO1xuXHRcdHkgPSAzMjc2NyAqICh5IC0gbWluWSkgKiBpbnZTaXplO1xuXHRcdHggPSAoeCB8IHggPDwgOCkgJiAweDAwRkYwMEZGO1xuXHRcdHggPSAoeCB8IHggPDwgNCkgJiAweDBGMEYwRjBGO1xuXHRcdHggPSAoeCB8IHggPDwgMikgJiAweDMzMzMzMzMzO1xuXHRcdHggPSAoeCB8IHggPDwgMSkgJiAweDU1NTU1NTU1O1xuXHRcdHkgPSAoeSB8IHkgPDwgOCkgJiAweDAwRkYwMEZGO1xuXHRcdHkgPSAoeSB8IHkgPDwgNCkgJiAweDBGMEYwRjBGO1xuXHRcdHkgPSAoeSB8IHkgPDwgMikgJiAweDMzMzMzMzMzO1xuXHRcdHkgPSAoeSB8IHkgPDwgMSkgJiAweDU1NTU1NTU1O1xuXHRcdHJldHVybiB4IHwgeSA8PCAxO1xuXHR9IC8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcblxuXG5cdGZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XG5cdFx0bGV0IHAgPSBzdGFydCxcblx0XHRcdFx0bGVmdG1vc3QgPSBzdGFydDtcblxuXHRcdGRvIHtcblx0XHRcdGlmIChwLnggPCBsZWZ0bW9zdC54IHx8IHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSBsZWZ0bW9zdCA9IHA7XG5cdFx0XHRwID0gcC5uZXh0O1xuXHRcdH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuXHRcdHJldHVybiBsZWZ0bW9zdDtcblx0fSAvLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5cblxuXHRmdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG5cdFx0cmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSAtIChheCAtIHB4KSAqIChjeSAtIHB5KSA+PSAwICYmIChheCAtIHB4KSAqIChieSAtIHB5KSAtIChieCAtIHB4KSAqIChheSAtIHB5KSA+PSAwICYmIChieCAtIHB4KSAqIChjeSAtIHB5KSAtIChjeCAtIHB4KSAqIChieSAtIHB5KSA+PSAwO1xuXHR9IC8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuXG5cblx0ZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcblx0XHRyZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJiAoIC8vIGRvbmVzJ3QgaW50ZXJzZWN0IG90aGVyIGVkZ2VzXG5cdFx0bG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKSAmJiAoIC8vIGxvY2FsbHkgdmlzaWJsZVxuXHRcdGFyZWEoYS5wcmV2LCBhLCBiLnByZXYpIHx8IGFyZWEoYSwgYi5wcmV2LCBiKSkgfHwgLy8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXG5cdFx0ZXF1YWxzKGEsIGIpICYmIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpID4gMCAmJiBhcmVhKGIucHJldiwgYiwgYi5uZXh0KSA+IDApOyAvLyBzcGVjaWFsIHplcm8tbGVuZ3RoIGNhc2Vcblx0fSAvLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5cblxuXHRmdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcblx0XHRyZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG5cdH0gLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcblxuXG5cdGZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcblx0XHRyZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xuXHR9IC8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcblxuXG5cdGZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcblx0XHRjb25zdCBvMSA9IHNpZ24oYXJlYShwMSwgcTEsIHAyKSk7XG5cdFx0Y29uc3QgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuXHRcdGNvbnN0IG8zID0gc2lnbihhcmVhKHAyLCBxMiwgcDEpKTtcblx0XHRjb25zdCBvNCA9IHNpZ24oYXJlYShwMiwgcTIsIHExKSk7XG5cdFx0aWYgKG8xICE9PSBvMiAmJiBvMyAhPT0gbzQpIHJldHVybiB0cnVlOyAvLyBnZW5lcmFsIGNhc2VcblxuXHRcdGlmIChvMSA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHAyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHAyIGFyZSBjb2xsaW5lYXIgYW5kIHAyIGxpZXMgb24gcDFxMVxuXG5cdFx0aWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG5cblx0XHRpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcblxuXHRcdGlmIChvNCA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHExLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHExIGFyZSBjb2xsaW5lYXIgYW5kIHExIGxpZXMgb24gcDJxMlxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IC8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXG5cblxuXHRmdW5jdGlvbiBvblNlZ21lbnQocCwgcSwgcikge1xuXHRcdHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2lnbihudW0pIHtcblx0XHRyZXR1cm4gbnVtID4gMCA/IDEgOiBudW0gPCAwID8gLTEgOiAwO1xuXHR9IC8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG5cdFx0bGV0IHAgPSBhO1xuXG5cdFx0ZG8ge1xuXHRcdFx0aWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJiBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuXHRcdFx0cCA9IHAubmV4dDtcblx0XHR9IHdoaWxlIChwICE9PSBhKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSAvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cblxuXG5cdGZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuXHRcdHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgPyBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6IGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcblx0fSAvLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cblxuXG5cdGZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG5cdFx0bGV0IHAgPSBhLFxuXHRcdFx0XHRpbnNpZGUgPSBmYWxzZTtcblx0XHRjb25zdCBweCA9IChhLnggKyBiLngpIC8gMixcblx0XHRcdFx0XHRweSA9IChhLnkgKyBiLnkpIC8gMjtcblxuXHRcdGRvIHtcblx0XHRcdGlmIChwLnkgPiBweSAhPT0gcC5uZXh0LnkgPiBweSAmJiBwLm5leHQueSAhPT0gcC55ICYmIHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSBpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0cCA9IHAubmV4dDtcblx0XHR9IHdoaWxlIChwICE9PSBhKTtcblxuXHRcdHJldHVybiBpbnNpZGU7XG5cdH0gLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuXHQvLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcblxuXG5cdGZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG5cdFx0Y29uc3QgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcblx0XHRcdFx0XHRiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuXHRcdFx0XHRcdGFuID0gYS5uZXh0LFxuXHRcdFx0XHRcdGJwID0gYi5wcmV2O1xuXHRcdGEubmV4dCA9IGI7XG5cdFx0Yi5wcmV2ID0gYTtcblx0XHRhMi5uZXh0ID0gYW47XG5cdFx0YW4ucHJldiA9IGEyO1xuXHRcdGIyLm5leHQgPSBhMjtcblx0XHRhMi5wcmV2ID0gYjI7XG5cdFx0YnAubmV4dCA9IGIyO1xuXHRcdGIyLnByZXYgPSBicDtcblx0XHRyZXR1cm4gYjI7XG5cdH0gLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcblxuXG5cdGZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuXHRcdGNvbnN0IHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuXHRcdGlmICghbGFzdCkge1xuXHRcdFx0cC5wcmV2ID0gcDtcblx0XHRcdHAubmV4dCA9IHA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHAubmV4dCA9IGxhc3QubmV4dDtcblx0XHRcdHAucHJldiA9IGxhc3Q7XG5cdFx0XHRsYXN0Lm5leHQucHJldiA9IHA7XG5cdFx0XHRsYXN0Lm5leHQgPSBwO1xuXHRcdH1cblxuXHRcdHJldHVybiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZShwKSB7XG5cdFx0cC5uZXh0LnByZXYgPSBwLnByZXY7XG5cdFx0cC5wcmV2Lm5leHQgPSBwLm5leHQ7XG5cdFx0aWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuXHRcdGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcblx0fVxuXG5cdGZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuXHRcdC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuXHRcdHRoaXMuaSA9IGk7IC8vIHZlcnRleCBjb29yZGluYXRlc1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5OyAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcblxuXHRcdHRoaXMucHJldiA9IG51bGw7XG5cdFx0dGhpcy5uZXh0ID0gbnVsbDsgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuXG5cdFx0dGhpcy56ID0gbnVsbDsgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuXG5cdFx0dGhpcy5wcmV2WiA9IG51bGw7XG5cdFx0dGhpcy5uZXh0WiA9IG51bGw7IC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG5cblx0XHR0aGlzLnN0ZWluZXIgPSBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG5cdFx0bGV0IHN1bSA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG5cdFx0XHRzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcblx0XHRcdGogPSBpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdW07XG5cdH1cblxuXHRjbGFzcyBTaGFwZVV0aWxzIHtcblx0XHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cdFx0c3RhdGljIGFyZWEoY29udG91cikge1xuXHRcdFx0Y29uc3QgbiA9IGNvbnRvdXIubGVuZ3RoO1xuXHRcdFx0bGV0IGEgPSAwLjA7XG5cblx0XHRcdGZvciAobGV0IHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSsrKSB7XG5cdFx0XHRcdGEgKz0gY29udG91cltwXS54ICogY29udG91cltxXS55IC0gY29udG91cltxXS54ICogY29udG91cltwXS55O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYSAqIDAuNTtcblx0XHR9XG5cblx0XHRzdGF0aWMgaXNDbG9ja1dpc2UocHRzKSB7XG5cdFx0XHRyZXR1cm4gU2hhcGVVdGlscy5hcmVhKHB0cykgPCAwO1xuXHRcdH1cblxuXHRcdHN0YXRpYyB0cmlhbmd1bGF0ZVNoYXBlKGNvbnRvdXIsIGhvbGVzKSB7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdOyAvLyBmbGF0IGFycmF5IG9mIHZlcnRpY2VzIGxpa2UgWyB4MCx5MCwgeDEseTEsIHgyLHkyLCAuLi4gXVxuXG5cdFx0XHRjb25zdCBob2xlSW5kaWNlcyA9IFtdOyAvLyBhcnJheSBvZiBob2xlIGluZGljZXNcblxuXHRcdFx0Y29uc3QgZmFjZXMgPSBbXTsgLy8gZmluYWwgYXJyYXkgb2YgdmVydGV4IGluZGljZXMgbGlrZSBbIFsgYSxiLGQgXSwgWyBiLGMsZCBdIF1cblxuXHRcdFx0cmVtb3ZlRHVwRW5kUHRzKGNvbnRvdXIpO1xuXHRcdFx0YWRkQ29udG91cih2ZXJ0aWNlcywgY29udG91cik7IC8vXG5cblx0XHRcdGxldCBob2xlSW5kZXggPSBjb250b3VyLmxlbmd0aDtcblx0XHRcdGhvbGVzLmZvckVhY2gocmVtb3ZlRHVwRW5kUHRzKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRob2xlSW5kaWNlcy5wdXNoKGhvbGVJbmRleCk7XG5cdFx0XHRcdGhvbGVJbmRleCArPSBob2xlc1tpXS5sZW5ndGg7XG5cdFx0XHRcdGFkZENvbnRvdXIodmVydGljZXMsIGhvbGVzW2ldKTtcblx0XHRcdH0gLy9cblxuXG5cdFx0XHRjb25zdCB0cmlhbmdsZXMgPSBFYXJjdXQudHJpYW5ndWxhdGUodmVydGljZXMsIGhvbGVJbmRpY2VzKTsgLy9cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdFx0ZmFjZXMucHVzaCh0cmlhbmdsZXMuc2xpY2UoaSwgaSArIDMpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhY2VzO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlRHVwRW5kUHRzKHBvaW50cykge1xuXHRcdGNvbnN0IGwgPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKGwgPiAyICYmIHBvaW50c1tsIC0gMV0uZXF1YWxzKHBvaW50c1swXSkpIHtcblx0XHRcdHBvaW50cy5wb3AoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDb250b3VyKHZlcnRpY2VzLCBjb250b3VyKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb250b3VyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKGNvbnRvdXJbaV0ueCk7XG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKGNvbnRvdXJbaV0ueSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXG5cdCAqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXG5cdCAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG5cdCAqXHRzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXG5cdCAqXHRkZXB0aDogPGZsb2F0PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcblx0ICpcblx0ICpcdGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG5cdCAqXHRiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xuXHQgKlx0YmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSAoaW5jbHVkaW5nIGJldmVsT2Zmc2V0KSBpcyBiZXZlbFxuXHQgKlx0YmV2ZWxPZmZzZXQ6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGRvZXMgYmV2ZWwgc3RhcnRcblx0ICpcdGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXG5cdCAqXG5cdCAqXHRleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlPiAvLyBjdXJ2ZSB0byBleHRydWRlIHNoYXBlIGFsb25nXG5cdCAqXG5cdCAqXHRVVkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuXHQgKlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIEV4dHJ1ZGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3RvcihzaGFwZXMsIG9wdGlvbnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0XHRcdG9wdGlvbnM6IG9wdGlvbnNcblx0XHRcdH07XG5cdFx0XHRzaGFwZXMgPSBBcnJheS5pc0FycmF5KHNoYXBlcykgPyBzaGFwZXMgOiBbc2hhcGVzXTtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IHZlcnRpY2VzQXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IHV2QXJyYXkgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldO1xuXHRcdFx0XHRhZGRTaGFwZShzaGFwZSk7XG5cdFx0XHR9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXNBcnJheSwgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZBcnJheSwgMikpO1xuXHRcdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOyAvLyBmdW5jdGlvbnNcblxuXHRcdFx0ZnVuY3Rpb24gYWRkU2hhcGUoc2hhcGUpIHtcblx0XHRcdFx0Y29uc3QgcGxhY2Vob2xkZXIgPSBbXTsgLy8gb3B0aW9uc1xuXG5cdFx0XHRcdGNvbnN0IGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXHRcdFx0XHRjb25zdCBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xuXHRcdFx0XHRsZXQgZGVwdGggPSBvcHRpb25zLmRlcHRoICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoIDogMTAwO1xuXHRcdFx0XHRsZXQgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTtcblx0XHRcdFx0bGV0IGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7XG5cdFx0XHRcdGxldCBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7XG5cdFx0XHRcdGxldCBiZXZlbE9mZnNldCA9IG9wdGlvbnMuYmV2ZWxPZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxPZmZzZXQgOiAwO1xuXHRcdFx0XHRsZXQgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcblx0XHRcdFx0Y29uc3QgZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoO1xuXHRcdFx0XHRjb25zdCB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBXb3JsZFVWR2VuZXJhdG9yOyAvLyBkZXByZWNhdGVkIG9wdGlvbnNcblxuXHRcdFx0XHRpZiAob3B0aW9ucy5hbW91bnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuRXh0cnVkZUJ1ZmZlckdlb21ldHJ5OiBhbW91bnQgaGFzIGJlZW4gcmVuYW1lZCB0byBkZXB0aC4nKTtcblx0XHRcdFx0XHRkZXB0aCA9IG9wdGlvbnMuYW1vdW50O1xuXHRcdFx0XHR9IC8vXG5cblxuXHRcdFx0XHRsZXQgZXh0cnVkZVB0cyxcblx0XHRcdFx0XHRcdGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcblx0XHRcdFx0bGV0IHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcblxuXHRcdFx0XHRpZiAoZXh0cnVkZVBhdGgpIHtcblx0XHRcdFx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKHN0ZXBzKTtcblx0XHRcdFx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcblx0XHRcdFx0XHRiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXG5cdFx0XHRcdFx0Ly8gU0VUVVAgVE5CIHZhcmlhYmxlc1xuXHRcdFx0XHRcdC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XG5cblx0XHRcdFx0XHRzcGxpbmVUdWJlID0gZXh0cnVkZVBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyhzdGVwcywgZmFsc2UpOyAvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcblxuXHRcdFx0XHRcdGJpbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRcdHBvc2l0aW9uMiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdH0gLy8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblxuXHRcdFx0XHRpZiAoIWJldmVsRW5hYmxlZCkge1xuXHRcdFx0XHRcdGJldmVsU2VnbWVudHMgPSAwO1xuXHRcdFx0XHRcdGJldmVsVGhpY2tuZXNzID0gMDtcblx0XHRcdFx0XHRiZXZlbFNpemUgPSAwO1xuXHRcdFx0XHRcdGJldmVsT2Zmc2V0ID0gMDtcblx0XHRcdFx0fSAvLyBWYXJpYWJsZXMgaW5pdGlhbGl6YXRpb25cblxuXG5cdFx0XHRcdGNvbnN0IHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyhjdXJ2ZVNlZ21lbnRzKTtcblx0XHRcdFx0bGV0IHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdFx0XHRcdGNvbnN0IGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cdFx0XHRcdGNvbnN0IHJldmVyc2UgPSAhU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSh2ZXJ0aWNlcyk7XG5cblx0XHRcdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdFx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTsgLy8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cblxuXHRcdFx0XHRcdGZvciAobGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbaF07XG5cblx0XHRcdFx0XHRcdGlmIChTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKGFob2xlKSkge1xuXHRcdFx0XHRcdFx0XHRob2xlc1toXSA9IGFob2xlLnJldmVyc2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSh2ZXJ0aWNlcywgaG9sZXMpO1xuXHRcdFx0XHQvKiBWZXJ0aWNlcyAqL1xuXG5cdFx0XHRcdGNvbnN0IGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcblxuXHRcdFx0XHRmb3IgKGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1toXTtcblx0XHRcdFx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdChhaG9sZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBzY2FsZVB0MihwdCwgdmVjLCBzaXplKSB7XG5cdFx0XHRcdFx0aWYgKCF2ZWMpIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0Jyk7XG5cdFx0XHRcdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHNpemUpLmFkZChwdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRmbGVuID0gZmFjZXMubGVuZ3RoOyAvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XG5cblx0XHRcdFx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoaW5QdCwgaW5QcmV2LCBpbk5leHQpIHtcblx0XHRcdFx0XHQvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXG5cdFx0XHRcdFx0Ly9cdCBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxuXHRcdFx0XHRcdC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cblx0XHRcdFx0XHQvL1x0YWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxuXHRcdFx0XHRcdGxldCB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5OyAvLyByZXN1bHRpbmcgdHJhbnNsYXRpb24gdmVjdG9yIGZvciBpblB0XG5cdFx0XHRcdFx0Ly8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxuXHRcdFx0XHRcdC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXG5cblx0XHRcdFx0XHRjb25zdCB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LFxuXHRcdFx0XHRcdFx0XHRcdHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG5cdFx0XHRcdFx0Y29uc3Qgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCxcblx0XHRcdFx0XHRcdFx0XHR2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xuXHRcdFx0XHRcdGNvbnN0IHZfcHJldl9sZW5zcSA9IHZfcHJldl94ICogdl9wcmV2X3ggKyB2X3ByZXZfeSAqIHZfcHJldl95OyAvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXG5cblx0XHRcdFx0XHRjb25zdCBjb2xsaW5lYXIwID0gdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3g7XG5cblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoY29sbGluZWFyMCkgPiBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRcdFx0Ly8gbm90IGNvbGxpbmVhclxuXHRcdFx0XHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG5cdFx0XHRcdFx0XHRjb25zdCB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KHZfcHJldl9sZW5zcSk7XG5cdFx0XHRcdFx0XHRjb25zdCB2X25leHRfbGVuID0gTWF0aC5zcXJ0KHZfbmV4dF94ICogdl9uZXh0X3ggKyB2X25leHRfeSAqIHZfbmV4dF95KTsgLy8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxuXG5cdFx0XHRcdFx0XHRjb25zdCBwdFByZXZTaGlmdF94ID0gaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW47XG5cdFx0XHRcdFx0XHRjb25zdCBwdFByZXZTaGlmdF95ID0gaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW47XG5cdFx0XHRcdFx0XHRjb25zdCBwdE5leHRTaGlmdF94ID0gaW5OZXh0LnggLSB2X25leHRfeSAvIHZfbmV4dF9sZW47XG5cdFx0XHRcdFx0XHRjb25zdCBwdE5leHRTaGlmdF95ID0gaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW47IC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cblx0XHRcdFx0XHRcdGNvbnN0IHNmID0gKChwdE5leHRTaGlmdF94IC0gcHRQcmV2U2hpZnRfeCkgKiB2X25leHRfeSAtIChwdE5leHRTaGlmdF95IC0gcHRQcmV2U2hpZnRfeSkgKiB2X25leHRfeCkgLyAodl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3gpOyAvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG5cdFx0XHRcdFx0XHR2X3RyYW5zX3ggPSBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueDtcblx0XHRcdFx0XHRcdHZfdHJhbnNfeSA9IHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55OyAvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxuXHRcdFx0XHRcdFx0Ly9cdGJ1dCBwcmV2ZW50IGNyYXp5IHNwaWtlc1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2X3RyYW5zX2xlbnNxID0gdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195O1xuXG5cdFx0XHRcdFx0XHRpZiAodl90cmFuc19sZW5zcSA8PSAyKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMih2X3RyYW5zX3gsIHZfdHJhbnNfeSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQodl90cmFuc19sZW5zcSAvIDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIGNvbGxpbmVhciBlZGdlc1xuXHRcdFx0XHRcdFx0bGV0IGRpcmVjdGlvbl9lcSA9IGZhbHNlOyAvLyBhc3N1bWVzOiBvcHBvc2l0ZVxuXG5cdFx0XHRcdFx0XHRpZiAodl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRcdFx0XHRpZiAodl9uZXh0X3ggPiBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2X3ByZXZfeCA8IC1OdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh2X25leHRfeCA8IC1OdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKE1hdGguc2lnbih2X3ByZXZfeSkgPT09IE1hdGguc2lnbih2X25leHRfeSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChkaXJlY3Rpb25fZXEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVwiKTtcblx0XHRcdFx0XHRcdFx0dl90cmFuc194ID0gLXZfcHJldl95O1xuXHRcdFx0XHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeDtcblx0XHRcdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KHZfcHJldl9sZW5zcSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xuXHRcdFx0XHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcblx0XHRcdFx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3k7XG5cdFx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCh2X3ByZXZfbGVuc3EgLyAyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjIodl90cmFuc194IC8gc2hyaW5rX2J5LCB2X3RyYW5zX3kgLyBzaHJpbmtfYnkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgY29udG91ck1vdmVtZW50cyA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSsrLCBqKyssIGsrKykge1xuXHRcdFx0XHRcdGlmIChqID09PSBpbCkgaiA9IDA7XG5cdFx0XHRcdFx0aWYgKGsgPT09IGlsKSBrID0gMDsgLy9cdChqKS0tLShpKS0tLShrKVxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG5cdFx0XHRcdFx0Y29udG91ck1vdmVtZW50c1tpXSA9IGdldEJldmVsVmVjKGNvbnRvdXJbaV0sIGNvbnRvdXJbal0sIGNvbnRvdXJba10pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgaG9sZXNNb3ZlbWVudHMgPSBbXTtcblx0XHRcdFx0bGV0IG9uZUhvbGVNb3ZlbWVudHMsXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKykge1xuXHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbaF07XG5cdFx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSsrLCBqKyssIGsrKykge1xuXHRcdFx0XHRcdFx0aWYgKGogPT09IGlsKSBqID0gMDtcblx0XHRcdFx0XHRcdGlmIChrID09PSBpbCkgayA9IDA7IC8vXHQoaiktLS0oaSktLS0oaylcblxuXHRcdFx0XHRcdFx0b25lSG9sZU1vdmVtZW50c1tpXSA9IGdldEJldmVsVmVjKGFob2xlW2ldLCBhaG9sZVtqXSwgYWhvbGVba10pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGhvbGVzTW92ZW1lbnRzLnB1c2gob25lSG9sZU1vdmVtZW50cyk7XG5cdFx0XHRcdFx0dmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQob25lSG9sZU1vdmVtZW50cyk7XG5cdFx0XHRcdH0gLy8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cblxuXHRcdFx0XHRmb3IgKGxldCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIrKykge1xuXHRcdFx0XHRcdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xuXHRcdFx0XHRcdGNvbnN0IHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHRcdFx0XHRjb25zdCB6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpO1xuXHRcdFx0XHRcdGNvbnN0IGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4odCAqIE1hdGguUEkgLyAyKSArIGJldmVsT2Zmc2V0OyAvLyBjb250cmFjdCBzaGFwZVxuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoY29udG91cltpXSwgY29udG91ck1vdmVtZW50c1tpXSwgYnMpO1xuXHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgLXopO1xuXHRcdFx0XHRcdH0gLy8gZXhwYW5kIGhvbGVzXG5cblxuXHRcdFx0XHRcdGZvciAobGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbaF07XG5cdFx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbaF07XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKGFob2xlW2ldLCBvbmVIb2xlTW92ZW1lbnRzW2ldLCBicyk7XG5cdFx0XHRcdFx0XHRcdHYodmVydC54LCB2ZXJ0LnksIC16KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBicyA9IGJldmVsU2l6ZSArIGJldmVsT2Zmc2V0OyAvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdmxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc01vdmVtZW50c1tpXSwgYnMpIDogdmVydGljZXNbaV07XG5cblx0XHRcdFx0XHRpZiAoIWV4dHJ1ZGVCeVBhdGgpIHtcblx0XHRcdFx0XHRcdHYodmVydC54LCB2ZXJ0LnksIDApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xuXHRcdFx0XHRcdFx0bm9ybWFsLmNvcHkoc3BsaW5lVHViZS5ub3JtYWxzWzBdKS5tdWx0aXBseVNjYWxhcih2ZXJ0LngpO1xuXHRcdFx0XHRcdFx0Ymlub3JtYWwuY29weShzcGxpbmVUdWJlLmJpbm9ybWFsc1swXSkubXVsdGlwbHlTY2FsYXIodmVydC55KTtcblx0XHRcdFx0XHRcdHBvc2l0aW9uMi5jb3B5KGV4dHJ1ZGVQdHNbMF0pLmFkZChub3JtYWwpLmFkZChiaW5vcm1hbCk7XG5cdFx0XHRcdFx0XHR2KHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSAvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuXHRcdFx0XHQvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXG5cblxuXHRcdFx0XHRmb3IgKGxldCBzID0gMTsgcyA8PSBzdGVwczsgcysrKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0Mih2ZXJ0aWNlc1tpXSwgdmVydGljZXNNb3ZlbWVudHNbaV0sIGJzKSA6IHZlcnRpY2VzW2ldO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWV4dHJ1ZGVCeVBhdGgpIHtcblx0XHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgZGVwdGggLyBzdGVwcyAqIHMpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xuXHRcdFx0XHRcdFx0XHRub3JtYWwuY29weShzcGxpbmVUdWJlLm5vcm1hbHNbc10pLm11bHRpcGx5U2NhbGFyKHZlcnQueCk7XG5cdFx0XHRcdFx0XHRcdGJpbm9ybWFsLmNvcHkoc3BsaW5lVHViZS5iaW5vcm1hbHNbc10pLm11bHRpcGx5U2NhbGFyKHZlcnQueSk7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uMi5jb3B5KGV4dHJ1ZGVQdHNbc10pLmFkZChub3JtYWwpLmFkZChiaW5vcm1hbCk7XG5cdFx0XHRcdFx0XHRcdHYocG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcblx0XHRcdFx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXG5cblx0XHRcdFx0Zm9yIChsZXQgYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGItLSkge1xuXHRcdFx0XHRcdGNvbnN0IHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHRcdFx0XHRjb25zdCB6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpO1xuXHRcdFx0XHRcdGNvbnN0IGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4odCAqIE1hdGguUEkgLyAyKSArIGJldmVsT2Zmc2V0OyAvLyBjb250cmFjdCBzaGFwZVxuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoY29udG91cltpXSwgY29udG91ck1vdmVtZW50c1tpXSwgYnMpO1xuXHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgZGVwdGggKyB6KTtcblx0XHRcdFx0XHR9IC8vIGV4cGFuZCBob2xlc1xuXG5cblx0XHRcdFx0XHRmb3IgKGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzW2hdO1xuXHRcdFx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzW2hdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MihhaG9sZVtpXSwgb25lSG9sZU1vdmVtZW50c1tpXSwgYnMpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghZXh0cnVkZUJ5UGF0aCkge1xuXHRcdFx0XHRcdFx0XHRcdHYodmVydC54LCB2ZXJ0LnksIGRlcHRoICsgeik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbc3RlcHMgLSAxXS55LCBleHRydWRlUHRzW3N0ZXBzIC0gMV0ueCArIHopO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8qIEZhY2VzICovXG5cdFx0XHRcdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXG5cblxuXHRcdFx0XHRidWlsZExpZEZhY2VzKCk7IC8vIFNpZGVzIGZhY2VzXG5cblx0XHRcdFx0YnVpbGRTaWRlRmFjZXMoKTsgLy8vLy9cdEludGVybmFsIGZ1bmN0aW9uc1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cblx0XHRcdFx0XHRpZiAoYmV2ZWxFbmFibGVkKSB7XG5cdFx0XHRcdFx0XHRsZXQgbGF5ZXIgPSAwOyAvLyBzdGVwcyArIDFcblxuXHRcdFx0XHRcdFx0bGV0IG9mZnNldCA9IHZsZW4gKiBsYXllcjsgLy8gQm90dG9tIGZhY2VzXG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1tpXTtcblx0XHRcdFx0XHRcdFx0ZjMoZmFjZVsyXSArIG9mZnNldCwgZmFjZVsxXSArIG9mZnNldCwgZmFjZVswXSArIG9mZnNldCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcblx0XHRcdFx0XHRcdG9mZnNldCA9IHZsZW4gKiBsYXllcjsgLy8gVG9wIGZhY2VzXG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1tpXTtcblx0XHRcdFx0XHRcdFx0ZjMoZmFjZVswXSArIG9mZnNldCwgZmFjZVsxXSArIG9mZnNldCwgZmFjZVsyXSArIG9mZnNldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzW2ldO1xuXHRcdFx0XHRcdFx0XHRmMyhmYWNlWzJdLCBmYWNlWzFdLCBmYWNlWzBdKTtcblx0XHRcdFx0XHRcdH0gLy8gVG9wIGZhY2VzXG5cblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzW2ldO1xuXHRcdFx0XHRcdFx0XHRmMyhmYWNlWzBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWzFdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWzJdICsgdmxlbiAqIHN0ZXBzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzY29wZS5hZGRHcm91cChzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIDApO1xuXHRcdFx0XHR9IC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cblxuXHRcdFx0XHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcblx0XHRcdFx0XHRjb25zdCBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0XHRsZXQgbGF5ZXJvZmZzZXQgPSAwO1xuXHRcdFx0XHRcdHNpZGV3YWxscyhjb250b3VyLCBsYXllcm9mZnNldCk7XG5cdFx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzW2hdO1xuXHRcdFx0XHRcdFx0c2lkZXdhbGxzKGFob2xlLCBsYXllcm9mZnNldCk7IC8vLCB0cnVlXG5cblx0XHRcdFx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzY29wZS5hZGRHcm91cChzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIDEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gc2lkZXdhbGxzKGNvbnRvdXIsIGxheWVyb2Zmc2V0KSB7XG5cdFx0XHRcdFx0bGV0IGkgPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0XHRcdHdoaWxlICgtLWkgPj0gMCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgaiA9IGk7XG5cdFx0XHRcdFx0XHRsZXQgayA9IGkgLSAxO1xuXHRcdFx0XHRcdFx0aWYgKGsgPCAwKSBrID0gY29udG91ci5sZW5ndGggLSAxOyAvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgcyA9IDAsIHNsID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjsgcyA8IHNsOyBzKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2xlbjEgPSB2bGVuICogcztcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2xlbjIgPSB2bGVuICogKHMgKyAxKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xuXHRcdFx0XHRcdFx0XHRmNChhLCBiLCBjLCBkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiB2KHgsIHksIHopIHtcblx0XHRcdFx0XHRwbGFjZWhvbGRlci5wdXNoKHgpO1xuXHRcdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goeSk7XG5cdFx0XHRcdFx0cGxhY2Vob2xkZXIucHVzaCh6KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGYzKGEsIGIsIGMpIHtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoYSk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KGIpO1xuXHRcdFx0XHRcdGFkZFZlcnRleChjKTtcblx0XHRcdFx0XHRjb25zdCBuZXh0SW5kZXggPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cdFx0XHRcdFx0Y29uc3QgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVVihzY29wZSwgdmVydGljZXNBcnJheSwgbmV4dEluZGV4IC0gMywgbmV4dEluZGV4IC0gMiwgbmV4dEluZGV4IC0gMSk7XG5cdFx0XHRcdFx0YWRkVVYodXZzWzBdKTtcblx0XHRcdFx0XHRhZGRVVih1dnNbMV0pO1xuXHRcdFx0XHRcdGFkZFVWKHV2c1syXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBmNChhLCBiLCBjLCBkKSB7XG5cdFx0XHRcdFx0YWRkVmVydGV4KGEpO1xuXHRcdFx0XHRcdGFkZFZlcnRleChiKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoZCk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KGIpO1xuXHRcdFx0XHRcdGFkZFZlcnRleChjKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoZCk7XG5cdFx0XHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0XHRcdGNvbnN0IHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVVihzY29wZSwgdmVydGljZXNBcnJheSwgbmV4dEluZGV4IC0gNiwgbmV4dEluZGV4IC0gMywgbmV4dEluZGV4IC0gMiwgbmV4dEluZGV4IC0gMSk7XG5cdFx0XHRcdFx0YWRkVVYodXZzWzBdKTtcblx0XHRcdFx0XHRhZGRVVih1dnNbMV0pO1xuXHRcdFx0XHRcdGFkZFVWKHV2c1szXSk7XG5cdFx0XHRcdFx0YWRkVVYodXZzWzFdKTtcblx0XHRcdFx0XHRhZGRVVih1dnNbMl0pO1xuXHRcdFx0XHRcdGFkZFVWKHV2c1szXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoaW5kZXgpIHtcblx0XHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2gocGxhY2Vob2xkZXJbaW5kZXggKiAzICsgMF0pO1xuXHRcdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaChwbGFjZWhvbGRlcltpbmRleCAqIDMgKyAxXSk7XG5cdFx0XHRcdFx0dmVydGljZXNBcnJheS5wdXNoKHBsYWNlaG9sZGVyW2luZGV4ICogMyArIDJdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGFkZFVWKHZlY3RvcjIpIHtcblx0XHRcdFx0XHR1dkFycmF5LnB1c2godmVjdG9yMi54KTtcblx0XHRcdFx0XHR1dkFycmF5LnB1c2godmVjdG9yMi55KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XG5cdFx0XHRjb25zdCBvcHRpb25zID0gdGhpcy5wYXJhbWV0ZXJzLm9wdGlvbnM7XG5cdFx0XHRyZXR1cm4gdG9KU09OJDEoc2hhcGVzLCBvcHRpb25zLCBkYXRhKTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSwgc2hhcGVzKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeVNoYXBlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBqID0gMCwgamwgPSBkYXRhLnNoYXBlcy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzW2RhdGEuc2hhcGVzW2pdXTtcblx0XHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaChzaGFwZSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGV4dHJ1ZGVQYXRoID0gZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoO1xuXG5cdFx0XHRpZiAoZXh0cnVkZVBhdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGggPSBuZXcgQ3VydmVzW2V4dHJ1ZGVQYXRoLnR5cGVdKCkuZnJvbUpTT04oZXh0cnVkZVBhdGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEV4dHJ1ZGVHZW9tZXRyeShnZW9tZXRyeVNoYXBlcywgZGF0YS5vcHRpb25zKTtcblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IFdvcmxkVVZHZW5lcmF0b3IgPSB7XG5cdFx0Z2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gKGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4Qykge1xuXHRcdFx0Y29uc3QgYV94ID0gdmVydGljZXNbaW5kZXhBICogM107XG5cdFx0XHRjb25zdCBhX3kgPSB2ZXJ0aWNlc1tpbmRleEEgKiAzICsgMV07XG5cdFx0XHRjb25zdCBiX3ggPSB2ZXJ0aWNlc1tpbmRleEIgKiAzXTtcblx0XHRcdGNvbnN0IGJfeSA9IHZlcnRpY2VzW2luZGV4QiAqIDMgKyAxXTtcblx0XHRcdGNvbnN0IGNfeCA9IHZlcnRpY2VzW2luZGV4QyAqIDNdO1xuXHRcdFx0Y29uc3QgY195ID0gdmVydGljZXNbaW5kZXhDICogMyArIDFdO1xuXHRcdFx0cmV0dXJuIFtuZXcgVmVjdG9yMihhX3gsIGFfeSksIG5ldyBWZWN0b3IyKGJfeCwgYl95KSwgbmV3IFZlY3RvcjIoY194LCBjX3kpXTtcblx0XHR9LFxuXHRcdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4QywgaW5kZXhEKSB7XG5cdFx0XHRjb25zdCBhX3ggPSB2ZXJ0aWNlc1tpbmRleEEgKiAzXTtcblx0XHRcdGNvbnN0IGFfeSA9IHZlcnRpY2VzW2luZGV4QSAqIDMgKyAxXTtcblx0XHRcdGNvbnN0IGFfeiA9IHZlcnRpY2VzW2luZGV4QSAqIDMgKyAyXTtcblx0XHRcdGNvbnN0IGJfeCA9IHZlcnRpY2VzW2luZGV4QiAqIDNdO1xuXHRcdFx0Y29uc3QgYl95ID0gdmVydGljZXNbaW5kZXhCICogMyArIDFdO1xuXHRcdFx0Y29uc3QgYl96ID0gdmVydGljZXNbaW5kZXhCICogMyArIDJdO1xuXHRcdFx0Y29uc3QgY194ID0gdmVydGljZXNbaW5kZXhDICogM107XG5cdFx0XHRjb25zdCBjX3kgPSB2ZXJ0aWNlc1tpbmRleEMgKiAzICsgMV07XG5cdFx0XHRjb25zdCBjX3ogPSB2ZXJ0aWNlc1tpbmRleEMgKiAzICsgMl07XG5cdFx0XHRjb25zdCBkX3ggPSB2ZXJ0aWNlc1tpbmRleEQgKiAzXTtcblx0XHRcdGNvbnN0IGRfeSA9IHZlcnRpY2VzW2luZGV4RCAqIDMgKyAxXTtcblx0XHRcdGNvbnN0IGRfeiA9IHZlcnRpY2VzW2luZGV4RCAqIDMgKyAyXTtcblxuXHRcdFx0aWYgKE1hdGguYWJzKGFfeSAtIGJfeSkgPCBNYXRoLmFicyhhX3ggLSBiX3gpKSB7XG5cdFx0XHRcdHJldHVybiBbbmV3IFZlY3RvcjIoYV94LCAxIC0gYV96KSwgbmV3IFZlY3RvcjIoYl94LCAxIC0gYl96KSwgbmV3IFZlY3RvcjIoY194LCAxIC0gY196KSwgbmV3IFZlY3RvcjIoZF94LCAxIC0gZF96KV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gW25ldyBWZWN0b3IyKGFfeSwgMSAtIGFfeiksIG5ldyBWZWN0b3IyKGJfeSwgMSAtIGJfeiksIG5ldyBWZWN0b3IyKGNfeSwgMSAtIGNfeiksIG5ldyBWZWN0b3IyKGRfeSwgMSAtIGRfeildO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiB0b0pTT04kMShzaGFwZXMsIG9wdGlvbnMsIGRhdGEpIHtcblx0XHRkYXRhLnNoYXBlcyA9IFtdO1xuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoc2hhcGVzKSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldO1xuXHRcdFx0XHRkYXRhLnNoYXBlcy5wdXNoKHNoYXBlLnV1aWQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhLnNoYXBlcy5wdXNoKHNoYXBlcy51dWlkKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5leHRydWRlUGF0aCAhPT0gdW5kZWZpbmVkKSBkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoLnRvSlNPTigpO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cblx0Y2xhc3MgSWNvc2FoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdFx0Y29uc3QgdCA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFstMSwgdCwgMCwgMSwgdCwgMCwgLTEsIC10LCAwLCAxLCAtdCwgMCwgMCwgLTEsIHQsIDAsIDEsIHQsIDAsIC0xLCAtdCwgMCwgMSwgLXQsIHQsIDAsIC0xLCB0LCAwLCAxLCAtdCwgMCwgLTEsIC10LCAwLCAxXTtcblx0XHRcdGNvbnN0IGluZGljZXMgPSBbMCwgMTEsIDUsIDAsIDUsIDEsIDAsIDEsIDcsIDAsIDcsIDEwLCAwLCAxMCwgMTEsIDEsIDUsIDksIDUsIDExLCA0LCAxMSwgMTAsIDIsIDEwLCA3LCA2LCA3LCAxLCA4LCAzLCA5LCA0LCAzLCA0LCAyLCAzLCAyLCA2LCAzLCA2LCA4LCAzLCA4LCA5LCA0LCA5LCA1LCAyLCA0LCAxMSwgNiwgMiwgMTAsIDgsIDYsIDcsIDksIDgsIDFdO1xuXHRcdFx0c3VwZXIodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEljb3NhaGVkcm9uR2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIExhdGhlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocG9pbnRzLCBzZWdtZW50cyA9IDEyLCBwaGlTdGFydCA9IDAsIHBoaUxlbmd0aCA9IE1hdGguUEkgKiAyKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0xhdGhlR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdFx0XHR9O1xuXHRcdFx0c2VnbWVudHMgPSBNYXRoLmZsb29yKHNlZ21lbnRzKTsgLy8gY2xhbXAgcGhpTGVuZ3RoIHNvIGl0J3MgaW4gcmFuZ2Ugb2YgWyAwLCAyUEkgXVxuXG5cdFx0XHRwaGlMZW5ndGggPSBjbGFtcChwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyKTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0Y29uc3QgaW52ZXJzZVNlZ21lbnRzID0gMS4wIC8gc2VnbWVudHM7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpOyAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcyBhbmQgdXZzXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbihwaGkpO1xuXHRcdFx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcyhwaGkpO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHBvaW50cy5sZW5ndGggLSAxOyBqKyspIHtcblx0XHRcdFx0XHQvLyB2ZXJ0ZXhcblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHBvaW50c1tqXS54ICogc2luO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gcG9pbnRzW2pdLnk7XG5cdFx0XHRcdFx0dmVydGV4LnogPSBwb2ludHNbal0ueCAqIGNvcztcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyB1dlxuXG5cdFx0XHRcdFx0dXYueCA9IGkgLyBzZWdtZW50cztcblx0XHRcdFx0XHR1di55ID0gaiAvIChwb2ludHMubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0dXZzLnB1c2godXYueCwgdXYueSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gaW5kaWNlc1xuXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGggLSAxOyBqKyspIHtcblx0XHRcdFx0XHRjb25zdCBiYXNlID0gaiArIGkgKiBwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBiYXNlO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBiYXNlICsgcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0XHRjb25zdCBjID0gYmFzZSArIHBvaW50cy5sZW5ndGggKyAxO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSBiYXNlICsgMTsgLy8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpOyAvLyBnZW5lcmF0ZSBub3JtYWxzXG5cblx0XHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsgLy8gaWYgdGhlIGdlb21ldHJ5IGlzIGNsb3NlZCwgd2UgbmVlZCB0byBhdmVyYWdlIHRoZSBub3JtYWxzIGFsb25nIHRoZSBzZWFtLlxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgY29ycmVzcG9uZGluZyB2ZXJ0aWNlcyBhcmUgaWRlbnRpY2FsIChidXQgc3RpbGwgaGF2ZSBkaWZmZXJlbnQgVVZzKS5cblxuXHRcdFx0aWYgKHBoaUxlbmd0aCA9PT0gTWF0aC5QSSAqIDIpIHtcblx0XHRcdFx0Y29uc3Qgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cdFx0XHRcdGNvbnN0IG4xID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc3QgbjIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjb25zdCBuID0gbmV3IFZlY3RvcjMoKTsgLy8gdGhpcyBpcyB0aGUgYnVmZmVyIG9mZnNldCBmb3IgdGhlIGxhc3QgbGluZSBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRcdGNvbnN0IGJhc2UgPSBzZWdtZW50cyAqIHBvaW50cy5sZW5ndGggKiAzO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKywgaiArPSAzKSB7XG5cdFx0XHRcdFx0Ly8gc2VsZWN0IHRoZSBub3JtYWwgb2YgdGhlIHZlcnRleCBpbiB0aGUgZmlyc3QgbGluZVxuXHRcdFx0XHRcdG4xLnggPSBub3JtYWxzW2ogKyAwXTtcblx0XHRcdFx0XHRuMS55ID0gbm9ybWFsc1tqICsgMV07XG5cdFx0XHRcdFx0bjEueiA9IG5vcm1hbHNbaiArIDJdOyAvLyBzZWxlY3QgdGhlIG5vcm1hbCBvZiB0aGUgdmVydGV4IGluIHRoZSBsYXN0IGxpbmVcblxuXHRcdFx0XHRcdG4yLnggPSBub3JtYWxzW2Jhc2UgKyBqICsgMF07XG5cdFx0XHRcdFx0bjIueSA9IG5vcm1hbHNbYmFzZSArIGogKyAxXTtcblx0XHRcdFx0XHRuMi56ID0gbm9ybWFsc1tiYXNlICsgaiArIDJdOyAvLyBhdmVyYWdlIG5vcm1hbHNcblxuXHRcdFx0XHRcdG4uYWRkVmVjdG9ycyhuMSwgbjIpLm5vcm1hbGl6ZSgpOyAvLyBhc3NpZ24gdGhlIG5ldyB2YWx1ZXMgdG8gYm90aCBub3JtYWxzXG5cblx0XHRcdFx0XHRub3JtYWxzW2ogKyAwXSA9IG5vcm1hbHNbYmFzZSArIGogKyAwXSA9IG4ueDtcblx0XHRcdFx0XHRub3JtYWxzW2ogKyAxXSA9IG5vcm1hbHNbYmFzZSArIGogKyAxXSA9IG4ueTtcblx0XHRcdFx0XHRub3JtYWxzW2ogKyAyXSA9IG5vcm1hbHNbYmFzZSArIGogKyAyXSA9IG4uejtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IExhdGhlR2VvbWV0cnkoZGF0YS5wb2ludHMsIGRhdGEuc2VnbWVudHMsIGRhdGEucGhpU3RhcnQsIGRhdGEucGhpTGVuZ3RoKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIE9jdGFoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbMSwgMCwgMCwgLTEsIDAsIDAsIDAsIDEsIDAsIDAsIC0xLCAwLCAwLCAwLCAxLCAwLCAwLCAtMV07XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gWzAsIDIsIDQsIDAsIDQsIDMsIDAsIDMsIDUsIDAsIDUsIDIsIDEsIDIsIDUsIDEsIDUsIDMsIDEsIDMsIDQsIDEsIDQsIDJdO1xuXHRcdFx0c3VwZXIodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUGFyYW1ldHJpYyBTdXJmYWNlcyBHZW9tZXRyeVxuXHQgKiBiYXNlZCBvbiB0aGUgYnJpbGxpYW50IGFydGljbGUgYnkgQHByaWRlb3V0IGh0dHBzOi8vcHJpZGVvdXQubmV0L2Jsb2cvb2xkL2Jsb2cvaW5kZXguaHRtbEBwPTQ0Lmh0bWxcblx0ICovXG5cblx0Y2xhc3MgUGFyYW1ldHJpY0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKGZ1bmMsIHNsaWNlcywgc3RhY2tzKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BhcmFtZXRyaWNHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdGZ1bmM6IGZ1bmMsXG5cdFx0XHRcdHNsaWNlczogc2xpY2VzLFxuXHRcdFx0XHRzdGFja3M6IHN0YWNrc1xuXHRcdFx0fTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107XG5cdFx0XHRjb25zdCBFUFMgPSAwLjAwMDAxO1xuXHRcdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IHAwID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdHAxID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IHB1ID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdHB2ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0aWYgKGZ1bmMubGVuZ3RoIDwgMykge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnk6IEZ1bmN0aW9uIG11c3Qgbm93IG1vZGlmeSBhIFZlY3RvcjMgYXMgdGhpcmQgcGFyYW1ldGVyLicpO1xuXHRcdFx0fSAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblxuXHRcdFx0Y29uc3Qgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHN0YWNrczsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHYgPSBpIC8gc3RhY2tzO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHNsaWNlczsgaisrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdSA9IGogLyBzbGljZXM7IC8vIHZlcnRleFxuXG5cdFx0XHRcdFx0ZnVuYyh1LCB2LCBwMCk7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaChwMC54LCBwMC55LCBwMC56KTsgLy8gbm9ybWFsXG5cdFx0XHRcdFx0Ly8gYXBwcm94aW1hdGUgdGFuZ2VudCB2ZWN0b3JzIHZpYSBmaW5pdGUgZGlmZmVyZW5jZXNcblxuXHRcdFx0XHRcdGlmICh1IC0gRVBTID49IDApIHtcblx0XHRcdFx0XHRcdGZ1bmModSAtIEVQUywgdiwgcDEpO1xuXHRcdFx0XHRcdFx0cHUuc3ViVmVjdG9ycyhwMCwgcDEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmdW5jKHUgKyBFUFMsIHYsIHAxKTtcblx0XHRcdFx0XHRcdHB1LnN1YlZlY3RvcnMocDEsIHAwKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodiAtIEVQUyA+PSAwKSB7XG5cdFx0XHRcdFx0XHRmdW5jKHUsIHYgLSBFUFMsIHAxKTtcblx0XHRcdFx0XHRcdHB2LnN1YlZlY3RvcnMocDAsIHAxKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZnVuYyh1LCB2ICsgRVBTLCBwMSk7XG5cdFx0XHRcdFx0XHRwdi5zdWJWZWN0b3JzKHAxLCBwMCk7XG5cdFx0XHRcdFx0fSAvLyBjcm9zcyBwcm9kdWN0IG9mIHRhbmdlbnQgdmVjdG9ycyByZXR1cm5zIHN1cmZhY2Ugbm9ybWFsXG5cblxuXHRcdFx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMocHUsIHB2KS5ub3JtYWxpemUoKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7IC8vIHV2XG5cblx0XHRcdFx0XHR1dnMucHVzaCh1LCB2KTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3M7IGkrKykge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHNsaWNlczsgaisrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGkgKiBzbGljZUNvdW50ICsgajtcblx0XHRcdFx0XHRjb25zdCBiID0gaSAqIHNsaWNlQ291bnQgKyBqICsgMTtcblx0XHRcdFx0XHRjb25zdCBjID0gKGkgKyAxKSAqIHNsaWNlQ291bnQgKyBqICsgMTtcblx0XHRcdFx0XHRjb25zdCBkID0gKGkgKyAxKSAqIHNsaWNlQ291bnQgKyBqOyAvLyBmYWNlcyBvbmUgYW5kIHR3b1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaChiLCBjLCBkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBidWlsZCBnZW9tZXRyeVxuXG5cblx0XHRcdHRoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgUmluZ0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKGlubmVyUmFkaXVzID0gMC41LCBvdXRlclJhZGl1cyA9IDEsIHRoZXRhU2VnbWVudHMgPSA4LCBwaGlTZWdtZW50cyA9IDEsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuXHRcdFx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuXHRcdFx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXG5cdFx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdFx0fTtcblx0XHRcdHRoZXRhU2VnbWVudHMgPSBNYXRoLm1heCgzLCB0aGV0YVNlZ21lbnRzKTtcblx0XHRcdHBoaVNlZ21lbnRzID0gTWF0aC5tYXgoMSwgcGhpU2VnbWVudHMpOyAvLyBidWZmZXJzXG5cblx0XHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0XHRjb25zdCB1dnMgPSBbXTsgLy8gc29tZSBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRcdGxldCByYWRpdXMgPSBpbm5lclJhZGl1cztcblx0XHRcdGNvbnN0IHJhZGl1c1N0ZXAgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBwaGlTZWdtZW50cztcblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB1diA9IG5ldyBWZWN0b3IyKCk7IC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPD0gcGhpU2VnbWVudHM7IGorKykge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSB0aGV0YVNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHQvLyB2YWx1ZXMgYXJlIGdlbmVyYXRlIGZyb20gdGhlIGluc2lkZSBvZiB0aGUgcmluZyB0byB0aGUgb3V0c2lkZVxuXHRcdFx0XHRcdGNvbnN0IHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDsgLy8gdmVydGV4XG5cblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKHNlZ21lbnQpO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oc2VnbWVudCk7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTsgLy8gbm9ybWFsXG5cblx0XHRcdFx0XHRub3JtYWxzLnB1c2goMCwgMCwgMSk7IC8vIHV2XG5cblx0XHRcdFx0XHR1di54ID0gKHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxKSAvIDI7XG5cdFx0XHRcdFx0dXYueSA9ICh2ZXJ0ZXgueSAvIG91dGVyUmFkaXVzICsgMSkgLyAyO1xuXHRcdFx0XHRcdHV2cy5wdXNoKHV2LngsIHV2LnkpO1xuXHRcdFx0XHR9IC8vIGluY3JlYXNlIHRoZSByYWRpdXMgZm9yIG5leHQgcm93IG9mIHZlcnRpY2VzXG5cblxuXHRcdFx0XHRyYWRpdXMgKz0gcmFkaXVzU3RlcDtcblx0XHRcdH0gLy8gaW5kaWNlc1xuXG5cblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgcGhpU2VnbWVudHM7IGorKykge1xuXHRcdFx0XHRjb25zdCB0aGV0YVNlZ21lbnRMZXZlbCA9IGogKiAodGhldGFTZWdtZW50cyArIDEpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhldGFTZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IGkgKyB0aGV0YVNlZ21lbnRMZXZlbDtcblx0XHRcdFx0XHRjb25zdCBhID0gc2VnbWVudDtcblx0XHRcdFx0XHRjb25zdCBiID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG5cdFx0XHRcdFx0Y29uc3QgZCA9IHNlZ21lbnQgKyAxOyAvLyBmYWNlc1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaChiLCBjLCBkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBidWlsZCBnZW9tZXRyeVxuXG5cblx0XHRcdHRoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJpbmdHZW9tZXRyeShkYXRhLmlubmVyUmFkaXVzLCBkYXRhLm91dGVyUmFkaXVzLCBkYXRhLnRoZXRhU2VnbWVudHMsIGRhdGEucGhpU2VnbWVudHMsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBTaGFwZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKHNoYXBlcywgY3VydmVTZWdtZW50cyA9IDEyKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRzaGFwZXM6IHNoYXBlcyxcblx0XHRcdFx0Y3VydmVTZWdtZW50czogY3VydmVTZWdtZW50c1xuXHRcdFx0fTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0bGV0IGdyb3VwU3RhcnQgPSAwO1xuXHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwOyAvLyBhbGxvdyBzaW5nbGUgYW5kIGFycmF5IHZhbHVlcyBmb3IgXCJzaGFwZXNcIiBwYXJhbWV0ZXJcblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc2hhcGVzKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0YWRkU2hhcGUoc2hhcGVzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0YWRkU2hhcGUoc2hhcGVzW2ldKTtcblx0XHRcdFx0XHR0aGlzLmFkZEdyb3VwKGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIGkpOyAvLyBlbmFibGVzIE11bHRpTWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXHRcdFx0XHRcdGdyb3VwQ291bnQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuXHRcdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7IC8vIGhlbHBlciBmdW5jdGlvbnNcblxuXHRcdFx0ZnVuY3Rpb24gYWRkU2hhcGUoc2hhcGUpIHtcblx0XHRcdFx0Y29uc3QgaW5kZXhPZmZzZXQgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xuXHRcdFx0XHRjb25zdCBwb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKGN1cnZlU2VnbWVudHMpO1xuXHRcdFx0XHRsZXQgc2hhcGVWZXJ0aWNlcyA9IHBvaW50cy5zaGFwZTtcblx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlcyA9IHBvaW50cy5ob2xlczsgLy8gY2hlY2sgZGlyZWN0aW9uIG9mIHZlcnRpY2VzXG5cblx0XHRcdFx0aWYgKFNoYXBlVXRpbHMuaXNDbG9ja1dpc2Uoc2hhcGVWZXJ0aWNlcykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0c2hhcGVWZXJ0aWNlcyA9IHNoYXBlVmVydGljZXMucmV2ZXJzZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbaV07XG5cblx0XHRcdFx0XHRpZiAoU2hhcGVVdGlscy5pc0Nsb2NrV2lzZShzaGFwZUhvbGUpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRzaGFwZUhvbGVzW2ldID0gc2hhcGVIb2xlLnJldmVyc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZShzaGFwZVZlcnRpY2VzLCBzaGFwZUhvbGVzKTsgLy8gam9pbiB2ZXJ0aWNlcyBvZiBpbm5lciBhbmQgb3V0ZXIgcGF0aHMgdG8gYSBzaW5nbGUgYXJyYXlcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1tpXTtcblx0XHRcdFx0XHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5jb25jYXQoc2hhcGVIb2xlKTtcblx0XHRcdFx0fSAvLyB2ZXJ0aWNlcywgbm9ybWFscywgdXZzXG5cblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlVmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmVydGV4ID0gc2hhcGVWZXJ0aWNlc1tpXTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgMCk7XG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKDAsIDAsIDEpO1xuXHRcdFx0XHRcdHV2cy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSk7IC8vIHdvcmxkIHV2c1xuXHRcdFx0XHR9IC8vIGluY2lkZXNcblxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzW2ldO1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBmYWNlWzBdICsgaW5kZXhPZmZzZXQ7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGZhY2VbMV0gKyBpbmRleE9mZnNldDtcblx0XHRcdFx0XHRjb25zdCBjID0gZmFjZVsyXSArIGluZGV4T2Zmc2V0O1xuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBjKTtcblx0XHRcdFx0XHRncm91cENvdW50ICs9IDM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcmFtZXRlcnMuc2hhcGVzO1xuXHRcdFx0cmV0dXJuIHRvSlNPTihzaGFwZXMsIGRhdGEpO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhLCBzaGFwZXMpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJ5U2hhcGVzID0gW107XG5cblx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IGRhdGEuc2hhcGVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbZGF0YS5zaGFwZXNbal1dO1xuXHRcdFx0XHRnZW9tZXRyeVNoYXBlcy5wdXNoKHNoYXBlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZUdlb21ldHJ5KGdlb21ldHJ5U2hhcGVzLCBkYXRhLmN1cnZlU2VnbWVudHMpO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdG9KU09OKHNoYXBlcywgZGF0YSkge1xuXHRcdGRhdGEuc2hhcGVzID0gW107XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShzaGFwZXMpKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbaV07XG5cdFx0XHRcdGRhdGEuc2hhcGVzLnB1c2goc2hhcGUudXVpZCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEuc2hhcGVzLnB1c2goc2hhcGVzLnV1aWQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cblx0Y2xhc3MgU3BoZXJlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgd2lkdGhTZWdtZW50cyA9IDMyLCBoZWlnaHRTZWdtZW50cyA9IDE2LCBwaGlTdGFydCA9IDAsIHBoaUxlbmd0aCA9IE1hdGguUEkgKiAyLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcblx0XHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0XHR9O1xuXHRcdFx0d2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KDMsIE1hdGguZmxvb3Iod2lkdGhTZWdtZW50cykpO1xuXHRcdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCgyLCBNYXRoLmZsb29yKGhlaWdodFNlZ21lbnRzKSk7XG5cdFx0XHRjb25zdCB0aGV0YUVuZCA9IE1hdGgubWluKHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aCwgTWF0aC5QSSk7XG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0Y29uc3QgZ3JpZCA9IFtdO1xuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7IC8vIGJ1ZmZlcnNcblxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRcdGNvbnN0IHV2cyA9IFtdOyAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAobGV0IGl5ID0gMDsgaXkgPD0gaGVpZ2h0U2VnbWVudHM7IGl5KyspIHtcblx0XHRcdFx0Y29uc3QgdmVydGljZXNSb3cgPSBbXTtcblx0XHRcdFx0Y29uc3QgdiA9IGl5IC8gaGVpZ2h0U2VnbWVudHM7IC8vIHNwZWNpYWwgY2FzZSBmb3IgdGhlIHBvbGVzXG5cblx0XHRcdFx0bGV0IHVPZmZzZXQgPSAwO1xuXG5cdFx0XHRcdGlmIChpeSA9PSAwICYmIHRoZXRhU3RhcnQgPT0gMCkge1xuXHRcdFx0XHRcdHVPZmZzZXQgPSAwLjUgLyB3aWR0aFNlZ21lbnRzO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGl5ID09IGhlaWdodFNlZ21lbnRzICYmIHRoZXRhRW5kID09IE1hdGguUEkpIHtcblx0XHRcdFx0XHR1T2Zmc2V0ID0gLTAuNSAvIHdpZHRoU2VnbWVudHM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGxldCBpeCA9IDA7IGl4IDw9IHdpZHRoU2VnbWVudHM7IGl4KyspIHtcblx0XHRcdFx0XHRjb25zdCB1ID0gaXggLyB3aWR0aFNlZ21lbnRzOyAvLyB2ZXJ0ZXhcblxuXHRcdFx0XHRcdHZlcnRleC54ID0gLXJhZGl1cyAqIE1hdGguY29zKHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCkgKiBNYXRoLnNpbih0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoKTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguY29zKHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGgpO1xuXHRcdFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5zaW4ocGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoKSAqIE1hdGguc2luKHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGgpO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7IC8vIG5vcm1hbFxuXG5cdFx0XHRcdFx0bm9ybWFsLmNvcHkodmVydGV4KS5ub3JtYWxpemUoKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7IC8vIHV2XG5cblx0XHRcdFx0XHR1dnMucHVzaCh1ICsgdU9mZnNldCwgMSAtIHYpO1xuXHRcdFx0XHRcdHZlcnRpY2VzUm93LnB1c2goaW5kZXgrKyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRncmlkLnB1c2godmVydGljZXNSb3cpO1xuXHRcdFx0fSAvLyBpbmRpY2VzXG5cblxuXHRcdFx0Zm9yIChsZXQgaXkgPSAwOyBpeSA8IGhlaWdodFNlZ21lbnRzOyBpeSsrKSB7XG5cdFx0XHRcdGZvciAobGV0IGl4ID0gMDsgaXggPCB3aWR0aFNlZ21lbnRzOyBpeCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGdyaWRbaXldW2l4ICsgMV07XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGdyaWRbaXldW2l4XTtcblx0XHRcdFx0XHRjb25zdCBjID0gZ3JpZFtpeSArIDFdW2l4XTtcblx0XHRcdFx0XHRjb25zdCBkID0gZ3JpZFtpeSArIDFdW2l4ICsgMV07XG5cdFx0XHRcdFx0aWYgKGl5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwKSBpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG5cdFx0XHRcdFx0aWYgKGl5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgfHwgdGhldGFFbmQgPCBNYXRoLlBJKSBpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTcGhlcmVHZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLnBoaVN0YXJ0LCBkYXRhLnBoaUxlbmd0aCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFRldHJhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEsIGRldGFpbCA9IDApIHtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gWzEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTFdO1xuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFsyLCAxLCAwLCAwLCAzLCAyLCAxLCAzLCAwLCAyLCAzLCAxXTtcblx0XHRcdHN1cGVyKHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBUZXRyYWhlZHJvbkdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogVGV4dCA9IDNEIFRleHRcblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGZvbnQ6IDxUSFJFRS5Gb250PiwgLy8gZm9udFxuXHQgKlxuXHQgKlx0c2l6ZTogPGZsb2F0PiwgLy8gc2l6ZSBvZiB0aGUgdGV4dFxuXHQgKlx0aGVpZ2h0OiA8ZmxvYXQ+LCAvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XG5cdCAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG5cdCAqXG5cdCAqXHRiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxuXHQgKlx0YmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGV4dCBiZXZlbCBnb2VzXG5cdCAqXHRiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgKGluY2x1ZGluZyBiZXZlbE9mZnNldCkgaXMgYmV2ZWxcblx0ICpcdGJldmVsT2Zmc2V0OiA8ZmxvYXQ+IC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgZG9lcyBiZXZlbCBzdGFydFxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIFRleHRHZW9tZXRyeSBleHRlbmRzIEV4dHJ1ZGVHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IodGV4dCwgcGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0XHRjb25zdCBmb250ID0gcGFyYW1ldGVycy5mb250O1xuXG5cdFx0XHRpZiAoIShmb250ICYmIGZvbnQuaXNGb250KSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5UZXh0R2VvbWV0cnk6IGZvbnQgcGFyYW1ldGVyIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5Gb250LicpO1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNoYXBlcyA9IGZvbnQuZ2VuZXJhdGVTaGFwZXModGV4dCwgcGFyYW1ldGVycy5zaXplKTsgLy8gdHJhbnNsYXRlIHBhcmFtZXRlcnMgdG8gRXh0cnVkZUdlb21ldHJ5IEFQSVxuXG5cdFx0XHRwYXJhbWV0ZXJzLmRlcHRoID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7IC8vIGRlZmF1bHRzXG5cblx0XHRcdGlmIChwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID09PSB1bmRlZmluZWQpIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPSAxMDtcblx0XHRcdGlmIChwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9PT0gdW5kZWZpbmVkKSBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9IDg7XG5cdFx0XHRpZiAocGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPT09IHVuZGVmaW5lZCkgcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdHN1cGVyKHNoYXBlcywgcGFyYW1ldGVycyk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnVGV4dEdlb21ldHJ5Jztcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFRvcnVzR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgdHViZSA9IDAuNCwgcmFkaWFsU2VnbWVudHMgPSA4LCB0dWJ1bGFyU2VnbWVudHMgPSA2LCBhcmMgPSBNYXRoLlBJICogMikge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdHR1YmU6IHR1YmUsXG5cdFx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdGFyYzogYXJjXG5cdFx0XHR9O1xuXHRcdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKHJhZGlhbFNlZ21lbnRzKTtcblx0XHRcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IodHVidWxhclNlZ21lbnRzKTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0Y29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpOyAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcblx0XHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7IC8vIHZlcnRleFxuXG5cdFx0XHRcdFx0dmVydGV4LnggPSAocmFkaXVzICsgdHViZSAqIE1hdGguY29zKHYpKSAqIE1hdGguY29zKHUpO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gKHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyh2KSkgKiBNYXRoLnNpbih1KTtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHR1YmUgKiBNYXRoLnNpbih2KTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyBub3JtYWxcblxuXHRcdFx0XHRcdGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3ModSk7XG5cdFx0XHRcdFx0Y2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbih1KTtcblx0XHRcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyh2ZXJ0ZXgsIGNlbnRlcikubm9ybWFsaXplKCk7XG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopOyAvLyB1dlxuXG5cdFx0XHRcdFx0dXZzLnB1c2goaSAvIHR1YnVsYXJTZWdtZW50cyk7XG5cdFx0XHRcdFx0dXZzLnB1c2goaiAvIHJhZGlhbFNlZ21lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblxuXHRcdFx0Zm9yIChsZXQgaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKykge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdC8vIGluZGljZXNcblx0XHRcdFx0XHRjb25zdCBhID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogaiArIGkgLSAxO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiAoaiAtIDEpICsgaSAtIDE7XG5cdFx0XHRcdFx0Y29uc3QgYyA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBpO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBqICsgaTsgLy8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBUb3J1c0dlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLmFyYyk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBUb3J1c0tub3RHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3RvcihyYWRpdXMgPSAxLCB0dWJlID0gMC40LCB0dWJ1bGFyU2VnbWVudHMgPSA2NCwgcmFkaWFsU2VnbWVudHMgPSA4LCBwID0gMiwgcSA9IDMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0dHViZTogdHViZSxcblx0XHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0cDogcCxcblx0XHRcdFx0cTogcVxuXHRcdFx0fTtcblx0XHRcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IodHVidWxhclNlZ21lbnRzKTtcblx0XHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vcihyYWRpYWxTZWdtZW50cyk7IC8vIGJ1ZmZlcnNcblxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRcdGNvbnN0IHV2cyA9IFtdOyAvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgUDEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgUDIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgQiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBUID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IE4gPSBuZXcgVmVjdG9yMygpOyAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgKytpKSB7XG5cdFx0XHRcdC8vIHRoZSByYWRpYW4gXCJ1XCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZSBvZiB0aGUgY3VycmVudCB0dWJ1bGFyIHNlZ2VtZW50XG5cdFx0XHRcdGNvbnN0IHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogcCAqIE1hdGguUEkgKiAyOyAvLyBub3cgd2UgY2FsY3VsYXRlIHR3byBwb2ludHMuIFAxIGlzIG91ciBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSwgUDIgaXMgYSBsaXR0bGUgZmFydGhlciBhaGVhZC5cblx0XHRcdFx0Ly8gdGhlc2UgcG9pbnRzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHNwZWNpYWwgXCJjb29yZGluYXRlIHNwYWNlXCIsIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdmVydGV4IHBvc2l0aW9uc1xuXG5cdFx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSh1LCBwLCBxLCByYWRpdXMsIFAxKTtcblx0XHRcdFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKHUgKyAwLjAxLCBwLCBxLCByYWRpdXMsIFAyKTsgLy8gY2FsY3VsYXRlIG9ydGhvbm9ybWFsIGJhc2lzXG5cblx0XHRcdFx0VC5zdWJWZWN0b3JzKFAyLCBQMSk7XG5cdFx0XHRcdE4uYWRkVmVjdG9ycyhQMiwgUDEpO1xuXHRcdFx0XHRCLmNyb3NzVmVjdG9ycyhULCBOKTtcblx0XHRcdFx0Ti5jcm9zc1ZlY3RvcnMoQiwgVCk7IC8vIG5vcm1hbGl6ZSBCLCBOLiBUIGNhbiBiZSBpZ25vcmVkLCB3ZSBkb24ndCB1c2UgaXRcblxuXHRcdFx0XHRCLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHROLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyArK2opIHtcblx0XHRcdFx0XHQvLyBub3cgY2FsY3VsYXRlIHRoZSB2ZXJ0aWNlcy4gdGhleSBhcmUgbm90aGluZyBtb3JlIHRoYW4gYW4gZXh0cnVzaW9uIG9mIHRoZSB0b3J1cyBjdXJ2ZS5cblx0XHRcdFx0XHQvLyBiZWNhdXNlIHdlIGV4dHJ1ZGUgYSBzaGFwZSBpbiB0aGUgeHktcGxhbmUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGEgei12YWx1ZS5cblx0XHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdFx0Y29uc3QgY3ggPSAtdHViZSAqIE1hdGguY29zKHYpO1xuXHRcdFx0XHRcdGNvbnN0IGN5ID0gdHViZSAqIE1hdGguc2luKHYpOyAvLyBub3cgY2FsY3VsYXRlIHRoZSBmaW5hbCB2ZXJ0ZXggcG9zaXRpb24uXG5cdFx0XHRcdFx0Ly8gZmlyc3Qgd2Ugb3JpZW50IHRoZSBleHRydXNpb24gd2l0aCBvdXIgYmFzaXMgdmVjdG9zLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcblxuXHRcdFx0XHRcdHZlcnRleC54ID0gUDEueCArIChjeCAqIE4ueCArIGN5ICogQi54KTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IFAxLnkgKyAoY3ggKiBOLnkgKyBjeSAqIEIueSk7XG5cdFx0XHRcdFx0dmVydGV4LnogPSBQMS56ICsgKGN4ICogTi56ICsgY3kgKiBCLnopO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7IC8vIG5vcm1hbCAoUDEgaXMgYWx3YXlzIHRoZSBjZW50ZXIvb3JpZ2luIG9mIHRoZSBleHRydXNpb24sIHRodXMgd2UgY2FuIHVzZSBpdCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbClcblxuXHRcdFx0XHRcdG5vcm1hbC5zdWJWZWN0b3JzKHZlcnRleCwgUDEpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTsgLy8gdXZcblxuXHRcdFx0XHRcdHV2cy5wdXNoKGkgLyB0dWJ1bGFyU2VnbWVudHMpO1xuXHRcdFx0XHRcdHV2cy5wdXNoKGogLyByYWRpYWxTZWdtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cblx0XHRcdGZvciAobGV0IGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaisrKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHQvLyBpbmRpY2VzXG5cdFx0XHRcdFx0Y29uc3QgYSA9IChyYWRpYWxTZWdtZW50cyArIDEpICogKGogLSAxKSArIChpIC0gMSk7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IChyYWRpYWxTZWdtZW50cyArIDEpICogaiArIChpIC0gMSk7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IChyYWRpYWxTZWdtZW50cyArIDEpICogaiArIGk7XG5cdFx0XHRcdFx0Y29uc3QgZCA9IChyYWRpYWxTZWdtZW50cyArIDEpICogKGogLSAxKSArIGk7IC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuXHRcdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7IC8vIHRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmVcblxuXHRcdFx0ZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKHUsIHAsIHEsIHJhZGl1cywgcG9zaXRpb24pIHtcblx0XHRcdFx0Y29uc3QgY3UgPSBNYXRoLmNvcyh1KTtcblx0XHRcdFx0Y29uc3Qgc3UgPSBNYXRoLnNpbih1KTtcblx0XHRcdFx0Y29uc3QgcXVPdmVyUCA9IHEgLyBwICogdTtcblx0XHRcdFx0Y29uc3QgY3MgPSBNYXRoLmNvcyhxdU92ZXJQKTtcblx0XHRcdFx0cG9zaXRpb24ueCA9IHJhZGl1cyAqICgyICsgY3MpICogMC41ICogY3U7XG5cdFx0XHRcdHBvc2l0aW9uLnkgPSByYWRpdXMgKiAoMiArIGNzKSAqIHN1ICogMC41O1xuXHRcdFx0XHRwb3NpdGlvbi56ID0gcmFkaXVzICogTWF0aC5zaW4ocXVPdmVyUCkgKiAwLjU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgVG9ydXNLbm90R2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEudHViZSwgZGF0YS50dWJ1bGFyU2VnbWVudHMsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEucCwgZGF0YS5xKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFR1YmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3RvcihwYXRoLCB0dWJ1bGFyU2VnbWVudHMgPSA2NCwgcmFkaXVzID0gMSwgcmFkaWFsU2VnbWVudHMgPSA4LCBjbG9zZWQgPSBmYWxzZSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRwYXRoOiBwYXRoLFxuXHRcdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0Y2xvc2VkOiBjbG9zZWRcblx0XHRcdH07XG5cdFx0XHRjb25zdCBmcmFtZXMgPSBwYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXModHVidWxhclNlZ21lbnRzLCBjbG9zZWQpOyAvLyBleHBvc2UgaW50ZXJuYWxzXG5cblx0XHRcdHRoaXMudGFuZ2VudHMgPSBmcmFtZXMudGFuZ2VudHM7XG5cdFx0XHR0aGlzLm5vcm1hbHMgPSBmcmFtZXMubm9ybWFscztcblx0XHRcdHRoaXMuYmlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFsczsgLy8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdGxldCBQID0gbmV3IFZlY3RvcjMoKTsgLy8gYnVmZmVyXG5cblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0XHRjb25zdCB1dnMgPSBbXTtcblx0XHRcdGNvbnN0IGluZGljZXMgPSBbXTsgLy8gY3JlYXRlIGJ1ZmZlciBkYXRhXG5cblx0XHRcdGdlbmVyYXRlQnVmZmVyRGF0YSgpOyAvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTsgLy8gZnVuY3Rpb25zXG5cblx0XHRcdGZ1bmN0aW9uIGdlbmVyYXRlQnVmZmVyRGF0YSgpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0dWJ1bGFyU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdGdlbmVyYXRlU2VnbWVudChpKTtcblx0XHRcdFx0fSAvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgbm90IGNsb3NlZCwgZ2VuZXJhdGUgdGhlIGxhc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzXG5cdFx0XHRcdC8vIGF0IHRoZSByZWd1bGFyIHBvc2l0aW9uIG9uIHRoZSBnaXZlbiBwYXRoXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIGR1cGxpY2F0ZSB0aGUgZmlyc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzICh1dnMgd2lsbCBkaWZmZXIpXG5cblxuXHRcdFx0XHRnZW5lcmF0ZVNlZ21lbnQoY2xvc2VkID09PSBmYWxzZSA/IHR1YnVsYXJTZWdtZW50cyA6IDApOyAvLyB1dnMgYXJlIGdlbmVyYXRlZCBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uLlxuXHRcdFx0XHQvLyB0aGlzIG1ha2VzIGl0IGVhc3kgY29tcHV0ZSBjb3JyZWN0IHZhbHVlcyBmb3IgY2xvc2VkIGdlb21ldHJpZXNcblxuXHRcdFx0XHRnZW5lcmF0ZVVWcygpOyAvLyBmaW5hbGx5IGNyZWF0ZSBmYWNlc1xuXG5cdFx0XHRcdGdlbmVyYXRlSW5kaWNlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnQoaSkge1xuXHRcdFx0XHQvLyB3ZSB1c2UgZ2V0UG9pbnRBdCB0byBzYW1wbGUgZXZlbmx5IGRpc3RyaWJ1dGVkIHBvaW50cyBmcm9tIHRoZSBnaXZlbiBwYXRoXG5cdFx0XHRcdFAgPSBwYXRoLmdldFBvaW50QXQoaSAvIHR1YnVsYXJTZWdtZW50cywgUCk7IC8vIHJldHJpZXZlIGNvcnJlc3BvbmRpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbFxuXG5cdFx0XHRcdGNvbnN0IE4gPSBmcmFtZXMubm9ybWFsc1tpXTtcblx0XHRcdFx0Y29uc3QgQiA9IGZyYW1lcy5iaW5vcm1hbHNbaV07IC8vIGdlbmVyYXRlIG5vcm1hbHMgYW5kIHZlcnRpY2VzIGZvciB0aGUgY3VycmVudCBzZWdtZW50XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKykge1xuXHRcdFx0XHRcdGNvbnN0IHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblx0XHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbih2KTtcblx0XHRcdFx0XHRjb25zdCBjb3MgPSAtTWF0aC5jb3Modik7IC8vIG5vcm1hbFxuXG5cdFx0XHRcdFx0bm9ybWFsLnggPSBjb3MgKiBOLnggKyBzaW4gKiBCLng7XG5cdFx0XHRcdFx0bm9ybWFsLnkgPSBjb3MgKiBOLnkgKyBzaW4gKiBCLnk7XG5cdFx0XHRcdFx0bm9ybWFsLnogPSBjb3MgKiBOLnogKyBzaW4gKiBCLno7XG5cdFx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTsgLy8gdmVydGV4XG5cblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IFAueCArIHJhZGl1cyAqIG5vcm1hbC54O1xuXHRcdFx0XHRcdHZlcnRleC55ID0gUC55ICsgcmFkaXVzICogbm9ybWFsLnk7XG5cdFx0XHRcdFx0dmVydGV4LnogPSBQLnogKyByYWRpdXMgKiBub3JtYWwuejtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdlbmVyYXRlSW5kaWNlcygpIHtcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqKyspIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhID0gKHJhZGlhbFNlZ21lbnRzICsgMSkgKiAoaiAtIDEpICsgKGkgLSAxKTtcblx0XHRcdFx0XHRcdGNvbnN0IGIgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIGogKyAoaSAtIDEpO1xuXHRcdFx0XHRcdFx0Y29uc3QgYyA9IChyYWRpYWxTZWdtZW50cyArIDEpICogaiArIGk7XG5cdFx0XHRcdFx0XHRjb25zdCBkID0gKHJhZGlhbFNlZ21lbnRzICsgMSkgKiAoaiAtIDEpICsgaTsgLy8gZmFjZXNcblxuXHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuXHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrKSB7XG5cdFx0XHRcdFx0XHR1di54ID0gaSAvIHR1YnVsYXJTZWdtZW50cztcblx0XHRcdFx0XHRcdHV2LnkgPSBqIC8gcmFkaWFsU2VnbWVudHM7XG5cdFx0XHRcdFx0XHR1dnMucHVzaCh1di54LCB1di55KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLnBhdGggPSB0aGlzLnBhcmFtZXRlcnMucGF0aC50b0pTT04oKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHQvLyBUaGlzIG9ubHkgd29ya3MgZm9yIGJ1aWx0LWluIGN1cnZlcyAoZS5nLiBDYXRtdWxsUm9tQ3VydmUzKS5cblx0XHRcdC8vIFVzZXIgZGVmaW5lZCBjdXJ2ZXMgb3IgaW5zdGFuY2VzIG9mIEN1cnZlUGF0aCB3aWxsIG5vdCBiZSBkZXNlcmlhbGl6ZWQuXG5cdFx0XHRyZXR1cm4gbmV3IFR1YmVHZW9tZXRyeShuZXcgQ3VydmVzW2RhdGEucGF0aC50eXBlXSgpLmZyb21KU09OKGRhdGEucGF0aCksIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLnJhZGl1cywgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5jbG9zZWQpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgV2lyZWZyYW1lR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IoZ2VvbWV0cnkpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnV2lyZWZyYW1lR2VvbWV0cnknO1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNHZW9tZXRyeSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSBubyBsb25nZXIgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnkuIFVzZSBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IC8vIGJ1ZmZlclxuXG5cblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBlZGdlcyA9IG5ldyBTZXQoKTsgLy8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBlbmQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0Ly8gaW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdFx0bGV0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0XHRpZiAoZ3JvdXBzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGdyb3VwcyA9IFt7XG5cdFx0XHRcdFx0XHRzdGFydDogMCxcblx0XHRcdFx0XHRcdGNvdW50OiBpbmRpY2VzLmNvdW50LFxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleDogMFxuXHRcdFx0XHRcdH1dO1xuXHRcdFx0XHR9IC8vIGNyZWF0ZSBhIGRhdGEgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgYWxsIGVnZXMgd2l0aG91dCBkdXBsaWNhdGVzXG5cblxuXHRcdFx0XHRmb3IgKGxldCBvID0gMCwgb2wgPSBncm91cHMubGVuZ3RoOyBvIDwgb2w7ICsrbykge1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW29dO1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwU3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0XHRjb25zdCBncm91cENvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gZ3JvdXBTdGFydCwgbCA9IGdyb3VwU3RhcnQgKyBncm91cENvdW50OyBpIDwgbDsgaSArPSAzKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleDEgPSBpbmRpY2VzLmdldFgoaSArIGopO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSBpbmRpY2VzLmdldFgoaSArIChqICsgMSkgJSAzKTtcblx0XHRcdFx0XHRcdFx0c3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgaW5kZXgxKTtcblx0XHRcdFx0XHRcdFx0ZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGluZGV4Mik7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGlzVW5pcXVlRWRnZShzdGFydCwgZW5kLCBlZGdlcykgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0LnopO1xuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goZW5kLngsIGVuZC55LCBlbmQueik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHBvc2l0aW9uLmNvdW50IC8gMzsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdFx0XHQvLyB0aHJlZSBlZGdlcyBwZXIgdHJpYW5nbGUsIGFuIGVkZ2UgaXMgcmVwcmVzZW50ZWQgYXMgKGluZGV4MSwgaW5kZXgyKVxuXHRcdFx0XHRcdFx0Ly8gZS5nLiB0aGUgZmlyc3QgdHJpYW5nbGUgaGFzIHRoZSBmb2xsb3dpbmcgZWRnZXM6ICgwLDEpLCgxLDIpLCgyLDApXG5cdFx0XHRcdFx0XHRjb25zdCBpbmRleDEgPSAzICogaSArIGo7XG5cdFx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSAzICogaSArIChqICsgMSkgJSAzO1xuXHRcdFx0XHRcdFx0c3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgaW5kZXgxKTtcblx0XHRcdFx0XHRcdGVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBpbmRleDIpO1xuXG5cdFx0XHRcdFx0XHRpZiAoaXNVbmlxdWVFZGdlKHN0YXJ0LCBlbmQsIGVkZ2VzKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0LnopO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKGVuZC54LCBlbmQueSwgZW5kLnopO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBidWlsZCBnZW9tZXRyeVxuXG5cblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBpc1VuaXF1ZUVkZ2Uoc3RhcnQsIGVuZCwgZWRnZXMpIHtcblx0XHRjb25zdCBoYXNoMSA9IGAke3N0YXJ0Lnh9LCR7c3RhcnQueX0sJHtzdGFydC56fS0ke2VuZC54fSwke2VuZC55fSwke2VuZC56fWA7XG5cdFx0Y29uc3QgaGFzaDIgPSBgJHtlbmQueH0sJHtlbmQueX0sJHtlbmQuen0tJHtzdGFydC54fSwke3N0YXJ0Lnl9LCR7c3RhcnQuen1gOyAvLyBjb2luY2lkZW50IGVkZ2VcblxuXHRcdGlmIChlZGdlcy5oYXMoaGFzaDEpID09PSB0cnVlIHx8IGVkZ2VzLmhhcyhoYXNoMikgPT09IHRydWUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWRnZXMuYWRkKGhhc2gxLCBoYXNoMik7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHR2YXIgR2VvbWV0cmllcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRfX3Byb3RvX186IG51bGwsXG5cdFx0Qm94R2VvbWV0cnk6IEJveEdlb21ldHJ5LFxuXHRcdEJveEJ1ZmZlckdlb21ldHJ5OiBCb3hHZW9tZXRyeSxcblx0XHRDaXJjbGVHZW9tZXRyeTogQ2lyY2xlR2VvbWV0cnksXG5cdFx0Q2lyY2xlQnVmZmVyR2VvbWV0cnk6IENpcmNsZUdlb21ldHJ5LFxuXHRcdENvbmVHZW9tZXRyeTogQ29uZUdlb21ldHJ5LFxuXHRcdENvbmVCdWZmZXJHZW9tZXRyeTogQ29uZUdlb21ldHJ5LFxuXHRcdEN5bGluZGVyR2VvbWV0cnk6IEN5bGluZGVyR2VvbWV0cnksXG5cdFx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeTogQ3lsaW5kZXJHZW9tZXRyeSxcblx0XHREb2RlY2FoZWRyb25HZW9tZXRyeTogRG9kZWNhaGVkcm9uR2VvbWV0cnksXG5cdFx0RG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IERvZGVjYWhlZHJvbkdlb21ldHJ5LFxuXHRcdEVkZ2VzR2VvbWV0cnk6IEVkZ2VzR2VvbWV0cnksXG5cdFx0RXh0cnVkZUdlb21ldHJ5OiBFeHRydWRlR2VvbWV0cnksXG5cdFx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5OiBFeHRydWRlR2VvbWV0cnksXG5cdFx0SWNvc2FoZWRyb25HZW9tZXRyeTogSWNvc2FoZWRyb25HZW9tZXRyeSxcblx0XHRJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBJY29zYWhlZHJvbkdlb21ldHJ5LFxuXHRcdExhdGhlR2VvbWV0cnk6IExhdGhlR2VvbWV0cnksXG5cdFx0TGF0aGVCdWZmZXJHZW9tZXRyeTogTGF0aGVHZW9tZXRyeSxcblx0XHRPY3RhaGVkcm9uR2VvbWV0cnk6IE9jdGFoZWRyb25HZW9tZXRyeSxcblx0XHRPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IE9jdGFoZWRyb25HZW9tZXRyeSxcblx0XHRQYXJhbWV0cmljR2VvbWV0cnk6IFBhcmFtZXRyaWNHZW9tZXRyeSxcblx0XHRQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk6IFBhcmFtZXRyaWNHZW9tZXRyeSxcblx0XHRQbGFuZUdlb21ldHJ5OiBQbGFuZUdlb21ldHJ5LFxuXHRcdFBsYW5lQnVmZmVyR2VvbWV0cnk6IFBsYW5lR2VvbWV0cnksXG5cdFx0UG9seWhlZHJvbkdlb21ldHJ5OiBQb2x5aGVkcm9uR2VvbWV0cnksXG5cdFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBQb2x5aGVkcm9uR2VvbWV0cnksXG5cdFx0UmluZ0dlb21ldHJ5OiBSaW5nR2VvbWV0cnksXG5cdFx0UmluZ0J1ZmZlckdlb21ldHJ5OiBSaW5nR2VvbWV0cnksXG5cdFx0U2hhcGVHZW9tZXRyeTogU2hhcGVHZW9tZXRyeSxcblx0XHRTaGFwZUJ1ZmZlckdlb21ldHJ5OiBTaGFwZUdlb21ldHJ5LFxuXHRcdFNwaGVyZUdlb21ldHJ5OiBTcGhlcmVHZW9tZXRyeSxcblx0XHRTcGhlcmVCdWZmZXJHZW9tZXRyeTogU3BoZXJlR2VvbWV0cnksXG5cdFx0VGV0cmFoZWRyb25HZW9tZXRyeTogVGV0cmFoZWRyb25HZW9tZXRyeSxcblx0XHRUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBUZXRyYWhlZHJvbkdlb21ldHJ5LFxuXHRcdFRleHRHZW9tZXRyeTogVGV4dEdlb21ldHJ5LFxuXHRcdFRleHRCdWZmZXJHZW9tZXRyeTogVGV4dEdlb21ldHJ5LFxuXHRcdFRvcnVzR2VvbWV0cnk6IFRvcnVzR2VvbWV0cnksXG5cdFx0VG9ydXNCdWZmZXJHZW9tZXRyeTogVG9ydXNHZW9tZXRyeSxcblx0XHRUb3J1c0tub3RHZW9tZXRyeTogVG9ydXNLbm90R2VvbWV0cnksXG5cdFx0VG9ydXNLbm90QnVmZmVyR2VvbWV0cnk6IFRvcnVzS25vdEdlb21ldHJ5LFxuXHRcdFR1YmVHZW9tZXRyeTogVHViZUdlb21ldHJ5LFxuXHRcdFR1YmVCdWZmZXJHZW9tZXRyeTogVHViZUdlb21ldHJ5LFxuXHRcdFdpcmVmcmFtZUdlb21ldHJ5OiBXaXJlZnJhbWVHZW9tZXRyeVxuXHR9KTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNvbG9yOiA8VEhSRUUuQ29sb3I+XG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgU2hhZG93TWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdTaGFkb3dNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHRcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRTaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUuaXNTaGFkb3dNYXRlcmlhbCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXHRjb2xvcjogPGhleD4sXG5cdCAqXHRyb3VnaG5lc3M6IDxmbG9hdD4sXG5cdCAqXHRtZXRhbG5lc3M6IDxmbG9hdD4sXG5cdCAqXHRvcGFjaXR5OiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0bWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0bGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxuXHQgKlxuXHQgKlx0YW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRhb01hcEludGVuc2l0eTogPGZsb2F0PlxuXHQgKlxuXHQgKlx0ZW1pc3NpdmU6IDxoZXg+LFxuXHQgKlx0ZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcdGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0YnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGJ1bXBTY2FsZTogPGZsb2F0Pixcblx0ICpcblx0ICpcdG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdG5vcm1hbE1hcFR5cGU6IFRIUkVFLlRhbmdlbnRTcGFjZU5vcm1hbE1hcCxcblx0ICpcdG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG5cdCAqXG5cdCAqXHRkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0Pixcblx0ICpcdGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRyb3VnaG5lc3NNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRtZXRhbG5lc3NNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGVudk1hcDogbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcblx0ICpcdGVudk1hcEludGVuc2l0eTogPGZsb2F0PlxuXHQgKlxuXHQgKlx0cmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0d2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqXHR3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRmbGF0U2hhZGluZzogPGJvb2w+XG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgTWVzaFN0YW5kYXJkTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuZGVmaW5lcyA9IHtcblx0XHRcdFx0J1NUQU5EQVJEJzogJydcblx0XHRcdH07XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcigweGZmZmZmZik7IC8vIGRpZmZ1c2VcblxuXHRcdFx0dGhpcy5yb3VnaG5lc3MgPSAxLjA7XG5cdFx0XHR0aGlzLm1ldGFsbmVzcyA9IDAuMDtcblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoMHgwMDAwMDApO1xuXHRcdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblx0XHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0XHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblx0XHRcdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcblx0XHRcdHRoaXMubWV0YWxuZXNzTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXHRcdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuZGVmaW5lcyA9IHtcblx0XHRcdFx0J1NUQU5EQVJEJzogJydcblx0XHRcdH07XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHRcdHRoaXMucm91Z2huZXNzID0gc291cmNlLnJvdWdobmVzcztcblx0XHRcdHRoaXMubWV0YWxuZXNzID0gc291cmNlLm1ldGFsbmVzcztcblx0XHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cdFx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoc291cmNlLmVtaXNzaXZlKTtcblx0XHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHRcdHRoaXMubm9ybWFsU2NhbGUuY29weShzb3VyY2Uubm9ybWFsU2NhbGUpO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBzb3VyY2Uucm91Z2huZXNzTWFwO1xuXHRcdFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0XHRcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gc291cmNlLmVudk1hcEludGVuc2l0eTtcblx0XHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNsZWFyY29hdDogPGZsb2F0Pixcblx0ICpcdGNsZWFyY29hdE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGNsZWFyY29hdFJvdWdobmVzczogPGZsb2F0Pixcblx0ICpcdGNsZWFyY29hdFJvdWdobmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGNsZWFyY29hdE5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG5cdCAqXHRjbGVhcmNvYXROb3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRyZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG5cdCAqXHRpb3I6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRzaGVlbjogPENvbG9yPixcblx0ICpcblx0ICpcdHRyYW5zbWlzc2lvbjogPGZsb2F0Pixcblx0ICpcdHRyYW5zbWlzc2lvbk1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdHRoaWNrbmVzczogPGZsb2F0Pixcblx0ICpcdHRoaWNrbmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGF0dGVudWF0aW9uRGlzdGFuY2U6IDxmbG9hdD4sXG5cdCAqXHRhdHRlbnVhdGlvblRpbnQ6IDxDb2xvcj4sXG5cdCAqXG5cdCAqXHRzcGVjdWxhckludGVuc2l0eTogPGZsb2F0Pixcblx0ICpcdHNwZWN1bGFySW50ZW5zaXR5aE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdHNwZWN1bGFyVGludDogPENvbG9yPixcblx0ICpcdHNwZWN1bGFyVGludE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKVxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hQaHlzaWNhbE1hdGVyaWFsIGV4dGVuZHMgTWVzaFN0YW5kYXJkTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLmRlZmluZXMgPSB7XG5cdFx0XHRcdCdTVEFOREFSRCc6ICcnLFxuXHRcdFx0XHQnUEhZU0lDQUwnOiAnJ1xuXHRcdFx0fTtcblx0XHRcdHRoaXMudHlwZSA9ICdNZXNoUGh5c2ljYWxNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNsZWFyY29hdCA9IDAuMDtcblx0XHRcdHRoaXMuY2xlYXJjb2F0TWFwID0gbnVsbDtcblx0XHRcdHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzID0gMC4wO1xuXHRcdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuXHRcdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAwLjU7IC8vIG1hcHMgdG8gRjAgPSAwLjA0XG5cblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaW9yJywge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gKDEgKyAwLjQgKiB0aGlzLnJlZmxlY3Rpdml0eSkgLyAoMSAtIDAuNCAqIHRoaXMucmVmbGVjdGl2aXR5KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoaW9yKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBjbGFtcCgyLjUgKiAoaW9yIC0gMSkgLyAoaW9yICsgMSksIDAsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuc2hlZW4gPSBudWxsOyAvLyBudWxsIHdpbGwgZGlzYWJsZSBzaGVlbiBic2RmXG5cblx0XHRcdHRoaXMudHJhbnNtaXNzaW9uID0gMC4wO1xuXHRcdFx0dGhpcy50cmFuc21pc3Npb25NYXAgPSBudWxsO1xuXHRcdFx0dGhpcy50aGlja25lc3MgPSAwLjAxO1xuXHRcdFx0dGhpcy50aGlja25lc3NNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlID0gMC4wO1xuXHRcdFx0dGhpcy5hdHRlbnVhdGlvblRpbnQgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG5cdFx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5ID0gMS4wO1xuXHRcdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLnNwZWN1bGFyVGludCA9IG5ldyBDb2xvcigxLCAxLCAxKTtcblx0XHRcdHRoaXMuc3BlY3VsYXJUaW50TWFwID0gbnVsbDtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmRlZmluZXMgPSB7XG5cdFx0XHRcdCdTVEFOREFSRCc6ICcnLFxuXHRcdFx0XHQnUEhZU0lDQUwnOiAnJ1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuY2xlYXJjb2F0ID0gc291cmNlLmNsZWFyY29hdDtcblx0XHRcdHRoaXMuY2xlYXJjb2F0TWFwID0gc291cmNlLmNsZWFyY29hdE1hcDtcblx0XHRcdHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzID0gc291cmNlLmNsZWFyY29hdFJvdWdobmVzcztcblx0XHRcdHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gc291cmNlLmNsZWFyY29hdFJvdWdobmVzc01hcDtcblx0XHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwID0gc291cmNlLmNsZWFyY29hdE5vcm1hbE1hcDtcblx0XHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUuY29weShzb3VyY2UuY2xlYXJjb2F0Tm9ybWFsU2NhbGUpO1xuXHRcdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuXG5cdFx0XHRpZiAoc291cmNlLnNoZWVuKSB7XG5cdFx0XHRcdHRoaXMuc2hlZW4gPSAodGhpcy5zaGVlbiB8fCBuZXcgQ29sb3IoKSkuY29weShzb3VyY2Uuc2hlZW4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zaGVlbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudHJhbnNtaXNzaW9uID0gc291cmNlLnRyYW5zbWlzc2lvbjtcblx0XHRcdHRoaXMudHJhbnNtaXNzaW9uTWFwID0gc291cmNlLnRyYW5zbWlzc2lvbk1hcDtcblx0XHRcdHRoaXMudGhpY2tuZXNzID0gc291cmNlLnRoaWNrbmVzcztcblx0XHRcdHRoaXMudGhpY2tuZXNzTWFwID0gc291cmNlLnRoaWNrbmVzc01hcDtcblx0XHRcdHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IHNvdXJjZS5hdHRlbnVhdGlvbkRpc3RhbmNlO1xuXHRcdFx0dGhpcy5hdHRlbnVhdGlvblRpbnQuY29weShzb3VyY2UuYXR0ZW51YXRpb25UaW50KTtcblx0XHRcdHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgPSBzb3VyY2Uuc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwID0gc291cmNlLnNwZWN1bGFySW50ZW5zaXR5TWFwO1xuXHRcdFx0dGhpcy5zcGVjdWxhclRpbnQuY29weShzb3VyY2Uuc3BlY3VsYXJUaW50KTtcblx0XHRcdHRoaXMuc3BlY3VsYXJUaW50TWFwID0gc291cmNlLnNwZWN1bGFyVGludE1hcDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0TWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlx0Y29sb3I6IDxoZXg+LFxuXHQgKlx0c3BlY3VsYXI6IDxoZXg+LFxuXHQgKlx0c2hpbmluZXNzOiA8ZmxvYXQ+LFxuXHQgKlx0b3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICpcdG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0bGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICpcdGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0YW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICpcdGVtaXNzaXZlOiA8aGV4Pixcblx0ICpcdGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXHRlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRidW1wU2NhbGU6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRub3JtYWxNYXBUeXBlOiBUSFJFRS5UYW5nZW50U3BhY2VOb3JtYWxNYXAsXG5cdCAqXHRub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuXHQgKlxuXHQgKlx0ZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0ZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqXHRkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0c3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGVudk1hcDogbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcblx0ICpcdGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uLFxuXHQgKlx0cmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuXHQgKlx0cmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0d2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqXHR3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRmbGF0U2hhZGluZzogPGJvb2w+XG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgTWVzaFBob25nTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZGlmZnVzZVxuXG5cdFx0XHR0aGlzLnNwZWN1bGFyID0gbmV3IENvbG9yKDB4MTExMTExKTtcblx0XHRcdHRoaXMuc2hpbmluZXNzID0gMzA7XG5cdFx0XHR0aGlzLm1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cdFx0XHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XG5cdFx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdFx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXHRcdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdFx0dGhpcy5zcGVjdWxhci5jb3B5KHNvdXJjZS5zcGVjdWxhcik7XG5cdFx0XHR0aGlzLnNoaW5pbmVzcyA9IHNvdXJjZS5zaGluaW5lc3M7XG5cdFx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblx0XHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KHNvdXJjZS5lbWlzc2l2ZSk7XG5cdFx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblx0XHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG5cdFx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoc291cmNlLm5vcm1hbFNjYWxlKTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cdFx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXHRcdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdFx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdFx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoUGhvbmdNYXRlcmlhbCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXHRjb2xvcjogPGhleD4sXG5cdCAqXG5cdCAqXHRtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRncmFkaWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0bGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICpcdGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0YW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICpcdGVtaXNzaXZlOiA8aGV4Pixcblx0ICpcdGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXHRlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRidW1wU2NhbGU6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRub3JtYWxNYXBUeXBlOiBUSFJFRS5UYW5nZW50U3BhY2VOb3JtYWxNYXAsXG5cdCAqXHRub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuXHQgKlxuXHQgKlx0ZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0ZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqXHRkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0YWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHR3aXJlZnJhbWU6IDxib29sZWFuPixcblx0ICpcdHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0Pixcblx0ICpcblx0ICogfVxuXHQgKi9cblxuXHRjbGFzcyBNZXNoVG9vbk1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLmRlZmluZXMgPSB7XG5cdFx0XHRcdCdUT09OJzogJydcblx0XHRcdH07XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaFRvb25NYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTtcblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZ3JhZGllbnRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXHRcdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXHRcdFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigweDAwMDAwMCk7XG5cdFx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuXHRcdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXHRcdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdFx0dGhpcy5ncmFkaWVudE1hcCA9IHNvdXJjZS5ncmFkaWVudE1hcDtcblx0XHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cdFx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoc291cmNlLmVtaXNzaXZlKTtcblx0XHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHRcdHRoaXMubm9ybWFsU2NhbGUuY29weShzb3VyY2Uubm9ybWFsU2NhbGUpO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0TWVzaFRvb25NYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoVG9vbk1hdGVyaWFsID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0YnVtcFNjYWxlOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0bm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0bm9ybWFsTWFwVHlwZTogVEhSRUUuVGFuZ2VudFNwYWNlTm9ybWFsTWFwLFxuXHQgKlx0bm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcblx0ICpcblx0ICpcdGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuXHQgKlx0ZGlzcGxhY2VtZW50QmlhczogPGZsb2F0Pixcblx0ICpcblx0ICpcdHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKlx0d2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG5cdCAqXG5cdCAqXHRmbGF0U2hhZGluZzogPGJvb2w+XG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgTWVzaE5vcm1hbE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaE5vcm1hbE1hdGVyaWFsJztcblx0XHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdFx0dGhpcy5mb2cgPSBmYWxzZTtcblx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblx0XHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KHNvdXJjZS5ub3JtYWxTY2FsZSk7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaE5vcm1hbE1hdGVyaWFsID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNvbG9yOiA8aGV4Pixcblx0ICpcdG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqXHRhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqXHRlbWlzc2l2ZTogPGhleD4sXG5cdCAqXHRlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxuXHQgKlx0ZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0ZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuXHQgKlx0Y29tYmluZTogVEhSRUUuTXVsdGlwbHksXG5cdCAqXHRyZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG5cdCAqXHRyZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHR3aXJlZnJhbWU6IDxib29sZWFuPixcblx0ICpcdHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0Pixcblx0ICpcblx0ICogfVxuXHQgKi9cblxuXHRjbGFzcyBNZXNoTGFtYmVydE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZGlmZnVzZVxuXG5cdFx0XHR0aGlzLm1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcblx0XHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0XHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cdFx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblx0XHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KHNvdXJjZS5lbWlzc2l2ZSk7XG5cdFx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblx0XHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cdFx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXHRcdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdFx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdFx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdE1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaExhbWJlcnRNYXRlcmlhbCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXHRjb2xvcjogPGhleD4sXG5cdCAqXHRvcGFjaXR5OiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0bWF0Y2FwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0bWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0YnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGJ1bXBTY2FsZTogPGZsb2F0Pixcblx0ICpcblx0ICpcdG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdG5vcm1hbE1hcFR5cGU6IFRIUkVFLlRhbmdlbnRTcGFjZU5vcm1hbE1hcCxcblx0ICpcdG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG5cdCAqXG5cdCAqXHRkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0Pixcblx0ICpcdGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGZsYXRTaGFkaW5nOiA8Ym9vbD5cblx0ICogfVxuXHQgKi9cblxuXHRjbGFzcyBNZXNoTWF0Y2FwTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuZGVmaW5lcyA9IHtcblx0XHRcdFx0J01BVENBUCc6ICcnXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy50eXBlID0gJ01lc2hNYXRjYXBNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZGlmZnVzZVxuXG5cdFx0XHR0aGlzLm1hdGNhcCA9IG51bGw7XG5cdFx0XHR0aGlzLm1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXHRcdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5kZWZpbmVzID0ge1xuXHRcdFx0XHQnTUFUQ0FQJzogJydcblx0XHRcdH07XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHRcdHRoaXMubWF0Y2FwID0gc291cmNlLm1hdGNhcDtcblx0XHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG5cdFx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoc291cmNlLm5vcm1hbFNjYWxlKTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRNZXNoTWF0Y2FwTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaE1hdGNhcE1hdGVyaWFsID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNvbG9yOiA8aGV4Pixcblx0ICpcdG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRsaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRzY2FsZTogPGZsb2F0Pixcblx0ICpcdGRhc2hTaXplOiA8ZmxvYXQ+LFxuXHQgKlx0Z2FwU2l6ZTogPGZsb2F0PlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIExpbmVEYXNoZWRNYXRlcmlhbCBleHRlbmRzIExpbmVCYXNpY01hdGVyaWFsIHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0xpbmVEYXNoZWRNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLnNjYWxlID0gMTtcblx0XHRcdHRoaXMuZGFzaFNpemUgPSAzO1xuXHRcdFx0dGhpcy5nYXBTaXplID0gMTtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnNjYWxlID0gc291cmNlLnNjYWxlO1xuXHRcdFx0dGhpcy5kYXNoU2l6ZSA9IHNvdXJjZS5kYXNoU2l6ZTtcblx0XHRcdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZURhc2hlZE1hdGVyaWFsID0gdHJ1ZTtcblxuXHR2YXIgTWF0ZXJpYWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdF9fcHJvdG9fXzogbnVsbCxcblx0XHRTaGFkb3dNYXRlcmlhbDogU2hhZG93TWF0ZXJpYWwsXG5cdFx0U3ByaXRlTWF0ZXJpYWw6IFNwcml0ZU1hdGVyaWFsLFxuXHRcdFJhd1NoYWRlck1hdGVyaWFsOiBSYXdTaGFkZXJNYXRlcmlhbCxcblx0XHRTaGFkZXJNYXRlcmlhbDogU2hhZGVyTWF0ZXJpYWwsXG5cdFx0UG9pbnRzTWF0ZXJpYWw6IFBvaW50c01hdGVyaWFsLFxuXHRcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiBNZXNoUGh5c2ljYWxNYXRlcmlhbCxcblx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbDogTWVzaFN0YW5kYXJkTWF0ZXJpYWwsXG5cdFx0TWVzaFBob25nTWF0ZXJpYWw6IE1lc2hQaG9uZ01hdGVyaWFsLFxuXHRcdE1lc2hUb29uTWF0ZXJpYWw6IE1lc2hUb29uTWF0ZXJpYWwsXG5cdFx0TWVzaE5vcm1hbE1hdGVyaWFsOiBNZXNoTm9ybWFsTWF0ZXJpYWwsXG5cdFx0TWVzaExhbWJlcnRNYXRlcmlhbDogTWVzaExhbWJlcnRNYXRlcmlhbCxcblx0XHRNZXNoRGVwdGhNYXRlcmlhbDogTWVzaERlcHRoTWF0ZXJpYWwsXG5cdFx0TWVzaERpc3RhbmNlTWF0ZXJpYWw6IE1lc2hEaXN0YW5jZU1hdGVyaWFsLFxuXHRcdE1lc2hCYXNpY01hdGVyaWFsOiBNZXNoQmFzaWNNYXRlcmlhbCxcblx0XHRNZXNoTWF0Y2FwTWF0ZXJpYWw6IE1lc2hNYXRjYXBNYXRlcmlhbCxcblx0XHRMaW5lRGFzaGVkTWF0ZXJpYWw6IExpbmVEYXNoZWRNYXRlcmlhbCxcblx0XHRMaW5lQmFzaWNNYXRlcmlhbDogTGluZUJhc2ljTWF0ZXJpYWwsXG5cdFx0TWF0ZXJpYWw6IE1hdGVyaWFsXG5cdH0pO1xuXG5cdGNvbnN0IEFuaW1hdGlvblV0aWxzID0ge1xuXHRcdC8vIHNhbWUgYXMgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgYWxzbyB3b3JrcyBvbiB0eXBlZCBhcnJheXNcblx0XHRhcnJheVNsaWNlOiBmdW5jdGlvbiAoYXJyYXksIGZyb20sIHRvKSB7XG5cdFx0XHRpZiAoQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KGFycmF5KSkge1xuXHRcdFx0XHQvLyBpbiBpb3M5IGFycmF5LnN1YmFycmF5KGZyb20sIHVuZGVmaW5lZCkgd2lsbCByZXR1cm4gZW1wdHkgYXJyYXlcblx0XHRcdFx0Ly8gYnV0IGFycmF5LnN1YmFycmF5KGZyb20pIG9yIGFycmF5LnN1YmFycmF5KGZyb20sIGxlbikgaXMgY29ycmVjdFxuXHRcdFx0XHRyZXR1cm4gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGFycmF5LnN1YmFycmF5KGZyb20sIHRvICE9PSB1bmRlZmluZWQgPyB0byA6IGFycmF5Lmxlbmd0aCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXkuc2xpY2UoZnJvbSwgdG8pO1xuXHRcdH0sXG5cdFx0Ly8gY29udmVydHMgYW4gYXJyYXkgdG8gYSBzcGVjaWZpYyB0eXBlXG5cdFx0Y29udmVydEFycmF5OiBmdW5jdGlvbiAoYXJyYXksIHR5cGUsIGZvcmNlQ2xvbmUpIHtcblx0XHRcdGlmICghYXJyYXkgfHwgLy8gbGV0ICd1bmRlZmluZWQnIGFuZCAnbnVsbCcgcGFzc1xuXHRcdFx0IWZvcmNlQ2xvbmUgJiYgYXJyYXkuY29uc3RydWN0b3IgPT09IHR5cGUpIHJldHVybiBhcnJheTtcblxuXHRcdFx0aWYgKHR5cGVvZiB0eXBlLkJZVEVTX1BFUl9FTEVNRU5UID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRyZXR1cm4gbmV3IHR5cGUoYXJyYXkpOyAvLyBjcmVhdGUgdHlwZWQgYXJyYXlcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5KTsgLy8gY3JlYXRlIEFycmF5XG5cdFx0fSxcblx0XHRpc1R5cGVkQXJyYXk6IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0XHRcdHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSAmJiAhKG9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3KTtcblx0XHR9LFxuXHRcdC8vIHJldHVybnMgYW4gYXJyYXkgYnkgd2hpY2ggdGltZXMgYW5kIHZhbHVlcyBjYW4gYmUgc29ydGVkXG5cdFx0Z2V0S2V5ZnJhbWVPcmRlcjogZnVuY3Rpb24gKHRpbWVzKSB7XG5cdFx0XHRmdW5jdGlvbiBjb21wYXJlVGltZShpLCBqKSB7XG5cdFx0XHRcdHJldHVybiB0aW1lc1tpXSAtIHRpbWVzW2pdO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBuID0gdGltZXMubGVuZ3RoO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG4pO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbjsgKytpKSByZXN1bHRbaV0gPSBpO1xuXG5cdFx0XHRyZXN1bHQuc29ydChjb21wYXJlVGltZSk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0Ly8gdXNlcyB0aGUgYXJyYXkgcHJldmlvdXNseSByZXR1cm5lZCBieSAnZ2V0S2V5ZnJhbWVPcmRlcicgdG8gc29ydCBkYXRhXG5cdFx0c29ydGVkQXJyYXk6IGZ1bmN0aW9uICh2YWx1ZXMsIHN0cmlkZSwgb3JkZXIpIHtcblx0XHRcdGNvbnN0IG5WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gbmV3IHZhbHVlcy5jb25zdHJ1Y3RvcihuVmFsdWVzKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGRzdE9mZnNldCA9IDA7IGRzdE9mZnNldCAhPT0gblZhbHVlczsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IHNyY09mZnNldCA9IG9yZGVyW2ldICogc3RyaWRlO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqICE9PSBzdHJpZGU7ICsraikge1xuXHRcdFx0XHRcdHJlc3VsdFtkc3RPZmZzZXQrK10gPSB2YWx1ZXNbc3JjT2Zmc2V0ICsgal07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdC8vIGZ1bmN0aW9uIGZvciBwYXJzaW5nIEFPUyBrZXlmcmFtZSBmb3JtYXRzXG5cdFx0ZmxhdHRlbkpTT046IGZ1bmN0aW9uIChqc29uS2V5cywgdGltZXMsIHZhbHVlcywgdmFsdWVQcm9wZXJ0eU5hbWUpIHtcblx0XHRcdGxldCBpID0gMSxcblx0XHRcdFx0XHRrZXkgPSBqc29uS2V5c1swXTtcblxuXHRcdFx0d2hpbGUgKGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVt2YWx1ZVByb3BlcnR5TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRrZXkgPSBqc29uS2V5c1tpKytdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoa2V5ID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gbm8gZGF0YVxuXG5cdFx0XHRsZXQgdmFsdWUgPSBrZXlbdmFsdWVQcm9wZXJ0eU5hbWVdO1xuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gbm8gZGF0YVxuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdHZhbHVlID0ga2V5W3ZhbHVlUHJvcGVydHlOYW1lXTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aW1lcy5wdXNoKGtleS50aW1lKTtcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgdmFsdWUpOyAvLyBwdXNoIGFsbCBlbGVtZW50c1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGtleSA9IGpzb25LZXlzW2krK107XG5cdFx0XHRcdH0gd2hpbGUgKGtleSAhPT0gdW5kZWZpbmVkKTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUudG9BcnJheSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIC4uLmFzc3VtZSBUSFJFRS5NYXRoLWlzaFxuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0dmFsdWUgPSBrZXlbdmFsdWVQcm9wZXJ0eU5hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRpbWVzLnB1c2goa2V5LnRpbWUpO1xuXHRcdFx0XHRcdFx0dmFsdWUudG9BcnJheSh2YWx1ZXMsIHZhbHVlcy5sZW5ndGgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGtleSA9IGpzb25LZXlzW2krK107XG5cdFx0XHRcdH0gd2hpbGUgKGtleSAhPT0gdW5kZWZpbmVkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIG90aGVyd2lzZSBwdXNoIGFzLWlzXG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGtleVt2YWx1ZVByb3BlcnR5TmFtZV07XG5cblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGltZXMucHVzaChrZXkudGltZSk7XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0a2V5ID0ganNvbktleXNbaSsrXTtcblx0XHRcdFx0fSB3aGlsZSAoa2V5ICE9PSB1bmRlZmluZWQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3ViY2xpcDogZnVuY3Rpb24gKHNvdXJjZUNsaXAsIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgPSAzMCkge1xuXHRcdFx0Y29uc3QgY2xpcCA9IHNvdXJjZUNsaXAuY2xvbmUoKTtcblx0XHRcdGNsaXAubmFtZSA9IG5hbWU7XG5cdFx0XHRjb25zdCB0cmFja3MgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjb25zdCB0cmFjayA9IGNsaXAudHJhY2tzW2ldO1xuXHRcdFx0XHRjb25zdCB2YWx1ZVNpemUgPSB0cmFjay5nZXRWYWx1ZVNpemUoKTtcblx0XHRcdFx0Y29uc3QgdGltZXMgPSBbXTtcblx0XHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCB0cmFjay50aW1lcy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdGNvbnN0IGZyYW1lID0gdHJhY2sudGltZXNbal0gKiBmcHM7XG5cdFx0XHRcdFx0aWYgKGZyYW1lIDwgc3RhcnRGcmFtZSB8fCBmcmFtZSA+PSBlbmRGcmFtZSkgY29udGludWU7XG5cdFx0XHRcdFx0dGltZXMucHVzaCh0cmFjay50aW1lc1tqXSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBrID0gMDsgayA8IHZhbHVlU2l6ZTsgKytrKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCh0cmFjay52YWx1ZXNbaiAqIHZhbHVlU2l6ZSArIGtdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGltZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblx0XHRcdFx0dHJhY2sudGltZXMgPSBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkodGltZXMsIHRyYWNrLnRpbWVzLmNvbnN0cnVjdG9yKTtcblx0XHRcdFx0dHJhY2sudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KHZhbHVlcywgdHJhY2sudmFsdWVzLmNvbnN0cnVjdG9yKTtcblx0XHRcdFx0dHJhY2tzLnB1c2godHJhY2spO1xuXHRcdFx0fVxuXG5cdFx0XHRjbGlwLnRyYWNrcyA9IHRyYWNrczsgLy8gZmluZCBtaW5pbXVtIC50aW1lcyB2YWx1ZSBhY3Jvc3MgYWxsIHRyYWNrcyBpbiB0aGUgdHJpbW1lZCBjbGlwXG5cblx0XHRcdGxldCBtaW5TdGFydFRpbWUgPSBJbmZpbml0eTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRpZiAobWluU3RhcnRUaW1lID4gY2xpcC50cmFja3NbaV0udGltZXNbMF0pIHtcblx0XHRcdFx0XHRtaW5TdGFydFRpbWUgPSBjbGlwLnRyYWNrc1tpXS50aW1lc1swXTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBzaGlmdCBhbGwgdHJhY2tzIHN1Y2ggdGhhdCBjbGlwIGJlZ2lucyBhdCB0PTBcblxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNsaXAudHJhY2tzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGNsaXAudHJhY2tzW2ldLnNoaWZ0KC0xICogbWluU3RhcnRUaW1lKTtcblx0XHRcdH1cblxuXHRcdFx0Y2xpcC5yZXNldER1cmF0aW9uKCk7XG5cdFx0XHRyZXR1cm4gY2xpcDtcblx0XHR9LFxuXHRcdG1ha2VDbGlwQWRkaXRpdmU6IGZ1bmN0aW9uICh0YXJnZXRDbGlwLCByZWZlcmVuY2VGcmFtZSA9IDAsIHJlZmVyZW5jZUNsaXAgPSB0YXJnZXRDbGlwLCBmcHMgPSAzMCkge1xuXHRcdFx0aWYgKGZwcyA8PSAwKSBmcHMgPSAzMDtcblx0XHRcdGNvbnN0IG51bVRyYWNrcyA9IHJlZmVyZW5jZUNsaXAudHJhY2tzLmxlbmd0aDtcblx0XHRcdGNvbnN0IHJlZmVyZW5jZVRpbWUgPSByZWZlcmVuY2VGcmFtZSAvIGZwczsgLy8gTWFrZSBlYWNoIHRyYWNrJ3MgdmFsdWVzIHJlbGF0aXZlIHRvIHRoZSB2YWx1ZXMgYXQgdGhlIHJlZmVyZW5jZSBmcmFtZVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG51bVRyYWNrczsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IHJlZmVyZW5jZVRyYWNrID0gcmVmZXJlbmNlQ2xpcC50cmFja3NbaV07XG5cdFx0XHRcdGNvbnN0IHJlZmVyZW5jZVRyYWNrVHlwZSA9IHJlZmVyZW5jZVRyYWNrLlZhbHVlVHlwZU5hbWU7IC8vIFNraXAgdGhpcyB0cmFjayBpZiBpdCdzIG5vbi1udW1lcmljXG5cblx0XHRcdFx0aWYgKHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ2Jvb2wnIHx8IHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ3N0cmluZycpIGNvbnRpbnVlOyAvLyBGaW5kIHRoZSB0cmFjayBpbiB0aGUgdGFyZ2V0IGNsaXAgd2hvc2UgbmFtZSBhbmQgdHlwZSBtYXRjaGVzIHRoZSByZWZlcmVuY2UgdHJhY2tcblxuXHRcdFx0XHRjb25zdCB0YXJnZXRUcmFjayA9IHRhcmdldENsaXAudHJhY2tzLmZpbmQoZnVuY3Rpb24gKHRyYWNrKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYWNrLm5hbWUgPT09IHJlZmVyZW5jZVRyYWNrLm5hbWUgJiYgdHJhY2suVmFsdWVUeXBlTmFtZSA9PT0gcmVmZXJlbmNlVHJhY2tUeXBlO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHRhcmdldFRyYWNrID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXHRcdFx0XHRsZXQgcmVmZXJlbmNlT2Zmc2V0ID0gMDtcblx0XHRcdFx0Y29uc3QgcmVmZXJlbmNlVmFsdWVTaXplID0gcmVmZXJlbmNlVHJhY2suZ2V0VmFsdWVTaXplKCk7XG5cblx0XHRcdFx0aWYgKHJlZmVyZW5jZVRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lKSB7XG5cdFx0XHRcdFx0cmVmZXJlbmNlT2Zmc2V0ID0gcmVmZXJlbmNlVmFsdWVTaXplIC8gMztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCB0YXJnZXRPZmZzZXQgPSAwO1xuXHRcdFx0XHRjb25zdCB0YXJnZXRWYWx1ZVNpemUgPSB0YXJnZXRUcmFjay5nZXRWYWx1ZVNpemUoKTtcblxuXHRcdFx0XHRpZiAodGFyZ2V0VHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUpIHtcblx0XHRcdFx0XHR0YXJnZXRPZmZzZXQgPSB0YXJnZXRWYWx1ZVNpemUgLyAzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgbGFzdEluZGV4ID0gcmVmZXJlbmNlVHJhY2sudGltZXMubGVuZ3RoIC0gMTtcblx0XHRcdFx0bGV0IHJlZmVyZW5jZVZhbHVlOyAvLyBGaW5kIHRoZSB2YWx1ZSB0byBzdWJ0cmFjdCBvdXQgb2YgdGhlIHRyYWNrXG5cblx0XHRcdFx0aWYgKHJlZmVyZW5jZVRpbWUgPD0gcmVmZXJlbmNlVHJhY2sudGltZXNbMF0pIHtcblx0XHRcdFx0XHQvLyBSZWZlcmVuY2UgZnJhbWUgaXMgZWFybGllciB0aGFuIHRoZSBmaXJzdCBrZXlmcmFtZSwgc28ganVzdCB1c2UgdGhlIGZpcnN0IGtleWZyYW1lXG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdFx0XHRjb25zdCBlbmRJbmRleCA9IHJlZmVyZW5jZVZhbHVlU2l6ZSAtIHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UocmVmZXJlbmNlVHJhY2sudmFsdWVzLCBzdGFydEluZGV4LCBlbmRJbmRleCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVmZXJlbmNlVGltZSA+PSByZWZlcmVuY2VUcmFjay50aW1lc1tsYXN0SW5kZXhdKSB7XG5cdFx0XHRcdFx0Ly8gUmVmZXJlbmNlIGZyYW1lIGlzIGFmdGVyIHRoZSBsYXN0IGtleWZyYW1lLCBzbyBqdXN0IHVzZSB0aGUgbGFzdCBrZXlmcmFtZVxuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSBsYXN0SW5kZXggKiByZWZlcmVuY2VWYWx1ZVNpemUgKyByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRcdFx0Y29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0XHRcdHJlZmVyZW5jZVZhbHVlID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZShyZWZlcmVuY2VUcmFjay52YWx1ZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBJbnRlcnBvbGF0ZSB0byB0aGUgcmVmZXJlbmNlIHZhbHVlXG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnQgPSByZWZlcmVuY2VUcmFjay5jcmVhdGVJbnRlcnBvbGFudCgpO1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRcdFx0Y29uc3QgZW5kSW5kZXggPSByZWZlcmVuY2VWYWx1ZVNpemUgLSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRcdFx0aW50ZXJwb2xhbnQuZXZhbHVhdGUocmVmZXJlbmNlVGltZSk7XG5cdFx0XHRcdFx0cmVmZXJlbmNlVmFsdWUgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKGludGVycG9sYW50LnJlc3VsdEJ1ZmZlciwgc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuXHRcdFx0XHR9IC8vIENvbmp1Z2F0ZSB0aGUgcXVhdGVybmlvblxuXG5cblx0XHRcdFx0aWYgKHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ3F1YXRlcm5pb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVmZXJlbmNlUXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCkuZnJvbUFycmF5KHJlZmVyZW5jZVZhbHVlKS5ub3JtYWxpemUoKS5jb25qdWdhdGUoKTtcblx0XHRcdFx0XHRyZWZlcmVuY2VRdWF0LnRvQXJyYXkocmVmZXJlbmNlVmFsdWUpO1xuXHRcdFx0XHR9IC8vIFN1YnRyYWN0IHRoZSByZWZlcmVuY2UgdmFsdWUgZnJvbSBhbGwgb2YgdGhlIHRyYWNrIHZhbHVlc1xuXG5cblx0XHRcdFx0Y29uc3QgbnVtVGltZXMgPSB0YXJnZXRUcmFjay50aW1lcy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBudW1UaW1lczsgKytqKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWVTdGFydCA9IGogKiB0YXJnZXRWYWx1ZVNpemUgKyB0YXJnZXRPZmZzZXQ7XG5cblx0XHRcdFx0XHRpZiAocmVmZXJlbmNlVHJhY2tUeXBlID09PSAncXVhdGVybmlvbicpIHtcblx0XHRcdFx0XHRcdC8vIE11bHRpcGx5IHRoZSBjb25qdWdhdGUgZm9yIHF1YXRlcm5pb24gdHJhY2sgdHlwZXNcblx0XHRcdFx0XHRcdFF1YXRlcm5pb24ubXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQodGFyZ2V0VHJhY2sudmFsdWVzLCB2YWx1ZVN0YXJ0LCByZWZlcmVuY2VWYWx1ZSwgMCwgdGFyZ2V0VHJhY2sudmFsdWVzLCB2YWx1ZVN0YXJ0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWVFbmQgPSB0YXJnZXRWYWx1ZVNpemUgLSB0YXJnZXRPZmZzZXQgKiAyOyAvLyBTdWJ0cmFjdCBlYWNoIHZhbHVlIGZvciBhbGwgb3RoZXIgbnVtZXJpYyB0cmFjayB0eXBlc1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBrID0gMDsgayA8IHZhbHVlRW5kOyArK2spIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0VHJhY2sudmFsdWVzW3ZhbHVlU3RhcnQgKyBrXSAtPSByZWZlcmVuY2VWYWx1ZVtrXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGFyZ2V0Q2xpcC5ibGVuZE1vZGUgPSBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZTtcblx0XHRcdHJldHVybiB0YXJnZXRDbGlwO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQWJzdHJhY3QgYmFzZSBjbGFzcyBvZiBpbnRlcnBvbGFudHMgb3ZlciBwYXJhbWV0cmljIHNhbXBsZXMuXG5cdCAqXG5cdCAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxuXHQgKiBhbG9uZyBhIGN1cnZlIGRlZmluZWQgYnkgdGhlIGRhdGEuXG5cdCAqXG5cdCAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxuXHQgKiBhcHBseSBzcGVjaWFsIGludGVycHJldGF0aW9ucyB0byB0aGUgZGF0YS5cblx0ICpcblx0ICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXG5cdCAqIHRoZSBhY3R1YWwgaW50ZXJwb2xhdGlvbiB0byBkZXJpdmVkIGNsYXNzZXMuXG5cdCAqXG5cdCAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xuXHQgKiBhbmQgTyhsb2cgTikgZm9yIHJhbmRvbSBhY2Nlc3MsIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbnMuXG5cdCAqXG5cdCAqIFJlZmVyZW5jZXM6XG5cdCAqXG5cdCAqIFx0XHRodHRwOi8vd3d3Lm9vZGVzaWduLmNvbS90ZW1wbGF0ZS1tZXRob2QtcGF0dGVybi5odG1sXG5cdCAqXG5cdCAqL1xuXHRjbGFzcyBJbnRlcnBvbGFudCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMgPSBwYXJhbWV0ZXJQb3NpdGlvbnM7XG5cdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cdFx0XHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gcmVzdWx0QnVmZmVyIDogbmV3IHNhbXBsZVZhbHVlcy5jb25zdHJ1Y3RvcihzYW1wbGVTaXplKTtcblx0XHRcdHRoaXMuc2FtcGxlVmFsdWVzID0gc2FtcGxlVmFsdWVzO1xuXHRcdFx0dGhpcy52YWx1ZVNpemUgPSBzYW1wbGVTaXplO1xuXHRcdFx0dGhpcy5zZXR0aW5ncyA9IG51bGw7XG5cdFx0XHR0aGlzLkRlZmF1bHRTZXR0aW5nc18gPSB7fTtcblx0XHR9XG5cblx0XHRldmFsdWF0ZSh0KSB7XG5cdFx0XHRjb25zdCBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zO1xuXHRcdFx0bGV0IGkxID0gdGhpcy5fY2FjaGVkSW5kZXgsXG5cdFx0XHRcdFx0dDEgPSBwcFtpMV0sXG5cdFx0XHRcdFx0dDAgPSBwcFtpMSAtIDFdO1xuXG5cdFx0XHR2YWxpZGF0ZV9pbnRlcnZhbDoge1xuXHRcdFx0XHRzZWVrOiB7XG5cdFx0XHRcdFx0bGV0IHJpZ2h0O1xuXG5cdFx0XHRcdFx0bGluZWFyX3NjYW46IHtcblx0XHRcdFx0XHRcdC8vLSBTZWUgaHR0cDovL2pzcGVyZi5jb20vY29tcGFyaXNvbi10by11bmRlZmluZWQvM1xuXHRcdFx0XHRcdFx0Ly8tIHNsb3dlciBjb2RlOlxuXHRcdFx0XHRcdFx0Ly8tXG5cdFx0XHRcdFx0XHQvLy0gXHRcdFx0XHRpZiAoIHQgPj0gdDEgfHwgdDEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGZvcndhcmRfc2NhbjogaWYgKCEodCA8IHQxKSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBnaXZlVXBBdCA9IGkxICsgMjs7KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHQxID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0IDwgdDApIGJyZWFrIGZvcndhcmRfc2NhbjsgLy8gYWZ0ZXIgZW5kXG5cblx0XHRcdFx0XHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFmdGVyRW5kXyhpMSAtIDEsIHQsIHQwKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoaTEgPT09IGdpdmVVcEF0KSBicmVhazsgLy8gdGhpcyBsb29wXG5cblx0XHRcdFx0XHRcdFx0XHR0MCA9IHQxO1xuXHRcdFx0XHRcdFx0XHRcdHQxID0gcHBbKytpMV07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAodCA8IHQxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2Vlaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gLy8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBpbmRleFxuXG5cblx0XHRcdFx0XHRcdFx0cmlnaHQgPSBwcC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGJyZWFrIGxpbmVhcl9zY2FuO1xuXHRcdFx0XHRcdFx0fSAvLy0gc2xvd2VyIGNvZGU6XG5cdFx0XHRcdFx0XHQvLy1cdFx0XHRcdFx0aWYgKCB0IDwgdDAgfHwgdDAgPT09IHVuZGVmaW5lZCApIHtcblxuXG5cdFx0XHRcdFx0XHRpZiAoISh0ID49IHQwKSkge1xuXHRcdFx0XHRcdFx0XHQvLyBsb29waW5nP1xuXHRcdFx0XHRcdFx0XHRjb25zdCB0MWdsb2JhbCA9IHBwWzFdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICh0IDwgdDFnbG9iYWwpIHtcblx0XHRcdFx0XHRcdFx0XHRpMSA9IDI7IC8vICsgMSwgdXNpbmcgdGhlIHNjYW4gZm9yIHRoZSBkZXRhaWxzXG5cblx0XHRcdFx0XHRcdFx0XHR0MCA9IHQxZ2xvYmFsO1xuXHRcdFx0XHRcdFx0XHR9IC8vIGxpbmVhciByZXZlcnNlIHNjYW5cblxuXG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGdpdmVVcEF0ID0gaTEgLSAyOzspIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodDAgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gYmVmb3JlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5iZWZvcmVTdGFydF8oMCwgdCwgdDEpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlmIChpMSA9PT0gZ2l2ZVVwQXQpIGJyZWFrOyAvLyB0aGlzIGxvb3BcblxuXHRcdFx0XHRcdFx0XHRcdHQxID0gdDA7XG5cdFx0XHRcdFx0XHRcdFx0dDAgPSBwcFstLWkxIC0gMV07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAodCA+PSB0MCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBpbmRleFxuXG5cblx0XHRcdFx0XHRcdFx0cmlnaHQgPSBpMTtcblx0XHRcdFx0XHRcdFx0aTEgPSAwO1xuXHRcdFx0XHRcdFx0XHRicmVhayBsaW5lYXJfc2Nhbjtcblx0XHRcdFx0XHRcdH0gLy8gdGhlIGludGVydmFsIGlzIHZhbGlkXG5cblxuXHRcdFx0XHRcdFx0YnJlYWsgdmFsaWRhdGVfaW50ZXJ2YWw7XG5cdFx0XHRcdFx0fSAvLyBsaW5lYXIgc2NhblxuXHRcdFx0XHRcdC8vIGJpbmFyeSBzZWFyY2hcblxuXG5cdFx0XHRcdFx0d2hpbGUgKGkxIDwgcmlnaHQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1pZCA9IGkxICsgcmlnaHQgPj4+IDE7XG5cblx0XHRcdFx0XHRcdGlmICh0IDwgcHBbbWlkXSkge1xuXHRcdFx0XHRcdFx0XHRyaWdodCA9IG1pZDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGkxID0gbWlkICsgMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0MSA9IHBwW2kxXTtcblx0XHRcdFx0XHR0MCA9IHBwW2kxIC0gMV07IC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxuXG5cdFx0XHRcdFx0aWYgKHQwID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmJlZm9yZVN0YXJ0XygwLCB0LCB0MSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHQxID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFmdGVyRW5kXyhpMSAtIDEsIHQwLCB0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gc2Vla1xuXG5cblx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcblx0XHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKGkxLCB0MCwgdDEpO1xuXHRcdFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxuXG5cblx0XHRcdHJldHVybiB0aGlzLmludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKTtcblx0XHR9XG5cblx0XHRnZXRTZXR0aW5nc18oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncyB8fCB0aGlzLkRlZmF1bHRTZXR0aW5nc187XG5cdFx0fVxuXG5cdFx0Y29weVNhbXBsZVZhbHVlXyhpbmRleCkge1xuXHRcdFx0Ly8gY29waWVzIGEgc2FtcGxlIHZhbHVlIHRvIHRoZSByZXN1bHQgYnVmZmVyXG5cdFx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSBpbmRleCAqIHN0cmlkZTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKytpKSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHZhbHVlc1tvZmZzZXQgKyBpXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9IC8vIFRlbXBsYXRlIG1ldGhvZHMgZm9yIGRlcml2ZWQgY2xhc3NlczpcblxuXG5cdFx0aW50ZXJwb2xhdGVfKClcblx0XHQvKiBpMSwgdDAsIHQsIHQxICovXG5cdFx0e1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjYWxsIHRvIGFic3RyYWN0IG1ldGhvZCcpOyAvLyBpbXBsZW1lbnRhdGlvbnMgc2hhbGwgcmV0dXJuIHRoaXMucmVzdWx0QnVmZmVyXG5cdFx0fVxuXG5cdFx0aW50ZXJ2YWxDaGFuZ2VkXygpXG5cdFx0LyogaTEsIHQwLCB0MSAqL1xuXHRcdHsvLyBlbXB0eVxuXHRcdH1cblxuXHR9IC8vIEFMSUFTIERFRklOSVRJT05TXG5cblxuXHRJbnRlcnBvbGFudC5wcm90b3R5cGUuYmVmb3JlU3RhcnRfID0gSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV87XG5cdEludGVycG9sYW50LnByb3RvdHlwZS5hZnRlckVuZF8gPSBJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXztcblxuXHQvKipcblx0ICogRmFzdCBhbmQgc2ltcGxlIGN1YmljIHNwbGluZSBpbnRlcnBvbGFudC5cblx0ICpcblx0ICogSXQgd2FzIGRlcml2ZWQgZnJvbSBhIEhlcm1pdGlhbiBjb25zdHJ1Y3Rpb24gc2V0dGluZyB0aGUgZmlyc3QgZGVyaXZhdGl2ZVxuXHQgKiBhdCBlYWNoIHNhbXBsZSBwb3NpdGlvbiB0byB0aGUgbGluZWFyIHNsb3BlIGJldHdlZW4gbmVpZ2hib3JpbmcgcG9zaXRpb25zXG5cdCAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxuXHQgKi9cblxuXHRjbGFzcyBDdWJpY0ludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcblx0XHRcdHN1cGVyKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpO1xuXHRcdFx0dGhpcy5fd2VpZ2h0UHJldiA9IC0wO1xuXHRcdFx0dGhpcy5fb2Zmc2V0UHJldiA9IC0wO1xuXHRcdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IC0wO1xuXHRcdFx0dGhpcy5fb2Zmc2V0TmV4dCA9IC0wO1xuXHRcdFx0dGhpcy5EZWZhdWx0U2V0dGluZ3NfID0ge1xuXHRcdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdFx0ZW5kaW5nRW5kOiBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGludGVydmFsQ2hhbmdlZF8oaTEsIHQwLCB0MSkge1xuXHRcdFx0Y29uc3QgcHAgPSB0aGlzLnBhcmFtZXRlclBvc2l0aW9ucztcblx0XHRcdGxldCBpUHJldiA9IGkxIC0gMixcblx0XHRcdFx0XHRpTmV4dCA9IGkxICsgMSxcblx0XHRcdFx0XHR0UHJldiA9IHBwW2lQcmV2XSxcblx0XHRcdFx0XHR0TmV4dCA9IHBwW2lOZXh0XTtcblxuXHRcdFx0aWYgKHRQcmV2ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c3dpdGNoICh0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ1N0YXJ0KSB7XG5cdFx0XHRcdFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XG5cdFx0XHRcdFx0XHQvLyBmJyh0MCkgPSAwXG5cdFx0XHRcdFx0XHRpUHJldiA9IGkxO1xuXHRcdFx0XHRcdFx0dFByZXYgPSAyICogdDAgLSB0MTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxuXHRcdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXG5cdFx0XHRcdFx0XHRpUHJldiA9IHBwLmxlbmd0aCAtIDI7XG5cdFx0XHRcdFx0XHR0UHJldiA9IHQwICsgcHBbaVByZXZdIC0gcHBbaVByZXYgKyAxXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcblx0XHRcdFx0XHRcdC8vIGYnJyh0MCkgPSAwIGEuay5hLiBOYXR1cmFsIFNwbGluZVxuXHRcdFx0XHRcdFx0aVByZXYgPSBpMTtcblx0XHRcdFx0XHRcdHRQcmV2ID0gdDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHROZXh0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c3dpdGNoICh0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ0VuZCkge1xuXHRcdFx0XHRcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxuXHRcdFx0XHRcdFx0Ly8gZicodE4pID0gMFxuXHRcdFx0XHRcdFx0aU5leHQgPSBpMTtcblx0XHRcdFx0XHRcdHROZXh0ID0gMiAqIHQxIC0gdDA7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcblx0XHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxuXHRcdFx0XHRcdFx0aU5leHQgPSAxO1xuXHRcdFx0XHRcdFx0dE5leHQgPSB0MSArIHBwWzFdIC0gcHBbMF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHQvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cdFx0XHRcdFx0XHQvLyBmJycodE4pID0gMCwgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0XHRpTmV4dCA9IGkxIC0gMTtcblx0XHRcdFx0XHRcdHROZXh0ID0gdDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaGFsZkR0ID0gKHQxIC0gdDApICogMC41LFxuXHRcdFx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG5cdFx0XHR0aGlzLl93ZWlnaHRQcmV2ID0gaGFsZkR0IC8gKHQwIC0gdFByZXYpO1xuXHRcdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IGhhbGZEdCAvICh0TmV4dCAtIHQxKTtcblx0XHRcdHRoaXMuX29mZnNldFByZXYgPSBpUHJldiAqIHN0cmlkZTtcblx0XHRcdHRoaXMuX29mZnNldE5leHQgPSBpTmV4dCAqIHN0cmlkZTtcblx0XHR9XG5cblx0XHRpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0XHRcdFx0bzEgPSBpMSAqIHN0cmlkZSxcblx0XHRcdFx0XHRcdG8wID0gbzEgLSBzdHJpZGUsXG5cdFx0XHRcdFx0XHRvUCA9IHRoaXMuX29mZnNldFByZXYsXG5cdFx0XHRcdFx0XHRvTiA9IHRoaXMuX29mZnNldE5leHQsXG5cdFx0XHRcdFx0XHR3UCA9IHRoaXMuX3dlaWdodFByZXYsXG5cdFx0XHRcdFx0XHR3TiA9IHRoaXMuX3dlaWdodE5leHQsXG5cdFx0XHRcdFx0XHRwID0gKHQgLSB0MCkgLyAodDEgLSB0MCksXG5cdFx0XHRcdFx0XHRwcCA9IHAgKiBwLFxuXHRcdFx0XHRcdFx0cHBwID0gcHAgKiBwOyAvLyBldmFsdWF0ZSBwb2x5bm9taWFsc1xuXG5cdFx0XHRjb25zdCBzUCA9IC13UCAqIHBwcCArIDIgKiB3UCAqIHBwIC0gd1AgKiBwO1xuXHRcdFx0Y29uc3QgczAgPSAoMSArIHdQKSAqIHBwcCArICgtMS41IC0gMiAqIHdQKSAqIHBwICsgKC0wLjUgKyB3UCkgKiBwICsgMTtcblx0XHRcdGNvbnN0IHMxID0gKC0xIC0gd04pICogcHBwICsgKDEuNSArIHdOKSAqIHBwICsgMC41ICogcDtcblx0XHRcdGNvbnN0IHNOID0gd04gKiBwcHAgLSB3TiAqIHBwOyAvLyBjb21iaW5lIGRhdGEgbGluZWFybHlcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKytpKSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHNQICogdmFsdWVzW29QICsgaV0gKyBzMCAqIHZhbHVlc1tvMCArIGldICsgczEgKiB2YWx1ZXNbbzEgKyBpXSArIHNOICogdmFsdWVzW29OICsgaV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBMaW5lYXJJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKSB7XG5cdFx0XHRzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcblx0XHR9XG5cblx0XHRpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0XHRcdFx0b2Zmc2V0MSA9IGkxICogc3RyaWRlLFxuXHRcdFx0XHRcdFx0b2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUsXG5cdFx0XHRcdFx0XHR3ZWlnaHQxID0gKHQgLSB0MCkgLyAodDEgLSB0MCksXG5cdFx0XHRcdFx0XHR3ZWlnaHQwID0gMSAtIHdlaWdodDE7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsraSkge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB2YWx1ZXNbb2Zmc2V0MCArIGldICogd2VpZ2h0MCArIHZhbHVlc1tvZmZzZXQxICsgaV0gKiB3ZWlnaHQxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEludGVycG9sYW50IHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBzYW1wbGUgdmFsdWUgYXQgdGhlIHBvc2l0aW9uIHByZWNlZWRpbmdcblx0ICogdGhlIHBhcmFtZXRlci5cblx0ICovXG5cblx0Y2xhc3MgRGlzY3JldGVJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKSB7XG5cdFx0XHRzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcblx0XHR9XG5cblx0XHRpbnRlcnBvbGF0ZV8oaTFcblx0XHQvKiwgdDAsIHQsIHQxICovXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKGkxIC0gMSk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBLZXlmcmFtZVRyYWNrIHtcblx0XHRjb25zdHJ1Y3RvcihuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uKSB7XG5cdFx0XHRpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIG5hbWUgaXMgdW5kZWZpbmVkJyk7XG5cdFx0XHRpZiAodGltZXMgPT09IHVuZGVmaW5lZCB8fCB0aW1lcy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogbm8ga2V5ZnJhbWVzIGluIHRyYWNrIG5hbWVkICcgKyBuYW1lKTtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLnRpbWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KHRpbWVzLCB0aGlzLlRpbWVCdWZmZXJUeXBlKTtcblx0XHRcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KHZhbHVlcywgdGhpcy5WYWx1ZUJ1ZmZlclR5cGUpO1xuXHRcdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKGludGVycG9sYXRpb24gfHwgdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbik7XG5cdFx0fSAvLyBTZXJpYWxpemF0aW9uIChpbiBzdGF0aWMgY29udGV4dCwgYmVjYXVzZSBvZiBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uXG5cdFx0Ly8gYW5kIGF1dG9tYXRpYyBpbnZvY2F0aW9uIG9mIC50b0pTT04pOlxuXG5cblx0XHRzdGF0aWMgdG9KU09OKHRyYWNrKSB7XG5cdFx0XHRjb25zdCB0cmFja1R5cGUgPSB0cmFjay5jb25zdHJ1Y3Rvcjtcblx0XHRcdGxldCBqc29uOyAvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyB0b0pTT04gbWV0aG9kXG5cblx0XHRcdGlmICh0cmFja1R5cGUudG9KU09OICE9PSB0aGlzLnRvSlNPTikge1xuXHRcdFx0XHRqc29uID0gdHJhY2tUeXBlLnRvSlNPTih0cmFjayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgdGhlIGRhdGEgY2FuIGJlIHNlcmlhbGl6ZWQgYXMtaXNcblx0XHRcdFx0anNvbiA9IHtcblx0XHRcdFx0XHQnbmFtZSc6IHRyYWNrLm5hbWUsXG5cdFx0XHRcdFx0J3RpbWVzJzogQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KHRyYWNrLnRpbWVzLCBBcnJheSksXG5cdFx0XHRcdFx0J3ZhbHVlcyc6IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSh0cmFjay52YWx1ZXMsIEFycmF5KVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gdHJhY2suZ2V0SW50ZXJwb2xhdGlvbigpO1xuXG5cdFx0XHRcdGlmIChpbnRlcnBvbGF0aW9uICE9PSB0cmFjay5EZWZhdWx0SW50ZXJwb2xhdGlvbikge1xuXHRcdFx0XHRcdGpzb24uaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0anNvbi50eXBlID0gdHJhY2suVmFsdWVUeXBlTmFtZTsgLy8gbWFuZGF0b3J5XG5cblx0XHRcdHJldHVybiBqc29uO1xuXHRcdH1cblxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlKHJlc3VsdCkge1xuXHRcdFx0cmV0dXJuIG5ldyBEaXNjcmV0ZUludGVycG9sYW50KHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQpO1xuXHRcdH1cblxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcihyZXN1bHQpIHtcblx0XHRcdHJldHVybiBuZXcgTGluZWFySW50ZXJwb2xhbnQodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoKHJlc3VsdCkge1xuXHRcdFx0cmV0dXJuIG5ldyBDdWJpY0ludGVycG9sYW50KHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQpO1xuXHRcdH1cblxuXHRcdHNldEludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbikge1xuXHRcdFx0bGV0IGZhY3RvcnlNZXRob2Q7XG5cblx0XHRcdHN3aXRjaCAoaW50ZXJwb2xhdGlvbikge1xuXHRcdFx0XHRjYXNlIEludGVycG9sYXRlRGlzY3JldGU6XG5cdFx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZUxpbmVhcjpcblx0XHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZVNtb290aDpcblx0XHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmYWN0b3J5TWV0aG9kID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9ICd1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciAnICsgdGhpcy5WYWx1ZVR5cGVOYW1lICsgJyBrZXlmcmFtZSB0cmFjayBuYW1lZCAnICsgdGhpcy5uYW1lO1xuXG5cdFx0XHRcdGlmICh0aGlzLmNyZWF0ZUludGVycG9sYW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCwgdW5sZXNzIHRoZSBkZWZhdWx0IGl0c2VsZiBpcyBtZXNzZWQgdXBcblx0XHRcdFx0XHRpZiAoaW50ZXJwb2xhdGlvbiAhPT0gdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2Vcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLktleWZyYW1lVHJhY2s6JywgbWVzc2FnZSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNyZWF0ZUludGVycG9sYW50ID0gZmFjdG9yeU1ldGhvZDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldEludGVycG9sYXRpb24oKSB7XG5cdFx0XHRzd2l0Y2ggKHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQpIHtcblx0XHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOlxuXHRcdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuXG5cdFx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6XG5cdFx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlTGluZWFyO1xuXG5cdFx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6XG5cdFx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlU21vb3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdldFZhbHVlU2l6ZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggLyB0aGlzLnRpbWVzLmxlbmd0aDtcblx0XHR9IC8vIG1vdmUgYWxsIGtleWZyYW1lcyBlaXRoZXIgZm9yd2FyZHMgb3IgYmFja3dhcmRzIGluIHRpbWVcblxuXG5cdFx0c2hpZnQodGltZU9mZnNldCkge1xuXHRcdFx0aWYgKHRpbWVPZmZzZXQgIT09IDAuMCkge1xuXHRcdFx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXM7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRcdHRpbWVzW2ldICs9IHRpbWVPZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSAvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXG5cblxuXHRcdHNjYWxlKHRpbWVTY2FsZSkge1xuXHRcdFx0aWYgKHRpbWVTY2FsZSAhPT0gMS4wKSB7XG5cdFx0XHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcztcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdFx0dGltZXNbaV0gKj0gdGltZVNjYWxlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gLy8gcmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW3N0YXJ0VGltZSwgZW5kVGltZV0uXG5cdFx0Ly8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xuXG5cblx0XHR0cmltKHN0YXJ0VGltZSwgZW5kVGltZSkge1xuXHRcdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzLFxuXHRcdFx0XHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XG5cdFx0XHRsZXQgZnJvbSA9IDAsXG5cdFx0XHRcdFx0dG8gPSBuS2V5cyAtIDE7XG5cblx0XHRcdHdoaWxlIChmcm9tICE9PSBuS2V5cyAmJiB0aW1lc1tmcm9tXSA8IHN0YXJ0VGltZSkge1xuXHRcdFx0XHQrK2Zyb207XG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlICh0byAhPT0gLTEgJiYgdGltZXNbdG9dID4gZW5kVGltZSkge1xuXHRcdFx0XHQtLXRvO1xuXHRcdFx0fVxuXG5cdFx0XHQrK3RvOyAvLyBpbmNsdXNpdmUgLT4gZXhjbHVzaXZlIGJvdW5kXG5cblx0XHRcdGlmIChmcm9tICE9PSAwIHx8IHRvICE9PSBuS2V5cykge1xuXHRcdFx0XHQvLyBlbXB0eSB0cmFja3MgYXJlIGZvcmJpZGRlbiwgc28ga2VlcCBhdCBsZWFzdCBvbmUga2V5ZnJhbWVcblx0XHRcdFx0aWYgKGZyb20gPj0gdG8pIHtcblx0XHRcdFx0XHR0byA9IE1hdGgubWF4KHRvLCAxKTtcblx0XHRcdFx0XHRmcm9tID0gdG8gLSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcblx0XHRcdFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UodGltZXMsIGZyb20sIHRvKTtcblx0XHRcdFx0dGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHRoaXMudmFsdWVzLCBmcm9tICogc3RyaWRlLCB0byAqIHN0cmlkZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gLy8gZW5zdXJlIHdlIGRvIG5vdCBnZXQgYSBHYXJiYWdlSW5HYXJiYWdlT3V0IHNpdHVhdGlvbiwgbWFrZSBzdXJlIHRyYWNrcyBhcmUgYXQgbGVhc3QgbWluaW1hbGx5IHZpYWJsZVxuXG5cblx0XHR2YWxpZGF0ZSgpIHtcblx0XHRcdGxldCB2YWxpZCA9IHRydWU7XG5cdFx0XHRjb25zdCB2YWx1ZVNpemUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xuXG5cdFx0XHRpZiAodmFsdWVTaXplIC0gTWF0aC5mbG9vcih2YWx1ZVNpemUpICE9PSAwKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IEludmFsaWQgdmFsdWUgc2l6ZSBpbiB0cmFjay4nLCB0aGlzKTtcblx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzLFxuXHRcdFx0XHRcdFx0dmFsdWVzID0gdGhpcy52YWx1ZXMsXG5cdFx0XHRcdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aDtcblxuXHRcdFx0aWYgKG5LZXlzID09PSAwKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IFRyYWNrIGlzIGVtcHR5LicsIHRoaXMpO1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcHJldlRpbWUgPSBudWxsO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbktleXM7IGkrKykge1xuXHRcdFx0XHRjb25zdCBjdXJyVGltZSA9IHRpbWVzW2ldO1xuXG5cdFx0XHRcdGlmICh0eXBlb2YgY3VyclRpbWUgPT09ICdudW1iZXInICYmIGlzTmFOKGN1cnJUaW1lKSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IFRpbWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyLicsIHRoaXMsIGksIGN1cnJUaW1lKTtcblx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSBudWxsICYmIHByZXZUaW1lID4gY3VyclRpbWUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5LZXlmcmFtZVRyYWNrOiBPdXQgb2Ygb3JkZXIga2V5cy4nLCB0aGlzLCBpLCBjdXJyVGltZSwgcHJldlRpbWUpO1xuXHRcdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwcmV2VGltZSA9IGN1cnJUaW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKEFuaW1hdGlvblV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZXMpKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IFZhbHVlIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsaWQ7XG5cdFx0fSAvLyByZW1vdmVzIGVxdWl2YWxlbnQgc2VxdWVudGlhbCBrZXlzIGFzIGNvbW1vbiBpbiBtb3JwaCB0YXJnZXQgc2VxdWVuY2VzXG5cdFx0Ly8gKDAsMCwwLDAsMSwxLDEsMCwwLDAsMCwwLDAsMCkgLS0+ICgwLDAsMSwxLDAsMClcblxuXG5cdFx0b3B0aW1pemUoKSB7XG5cdFx0XHQvLyB0aW1lcyBvciB2YWx1ZXMgbWF5IGJlIHNoYXJlZCB3aXRoIG90aGVyIHRyYWNrcywgc28gb3ZlcndyaXRpbmcgaXMgdW5zYWZlXG5cdFx0XHRjb25zdCB0aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UodGhpcy50aW1lcyksXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHRoaXMudmFsdWVzKSxcblx0XHRcdFx0XHRcdHN0cmlkZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCksXG5cdFx0XHRcdFx0XHRzbW9vdGhJbnRlcnBvbGF0aW9uID0gdGhpcy5nZXRJbnRlcnBvbGF0aW9uKCkgPT09IEludGVycG9sYXRlU21vb3RoLFxuXHRcdFx0XHRcdFx0bGFzdEluZGV4ID0gdGltZXMubGVuZ3RoIC0gMTtcblx0XHRcdGxldCB3cml0ZUluZGV4ID0gMTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBsYXN0SW5kZXg7ICsraSkge1xuXHRcdFx0XHRsZXQga2VlcCA9IGZhbHNlO1xuXHRcdFx0XHRjb25zdCB0aW1lID0gdGltZXNbaV07XG5cdFx0XHRcdGNvbnN0IHRpbWVOZXh0ID0gdGltZXNbaSArIDFdOyAvLyByZW1vdmUgYWRqYWNlbnQga2V5ZnJhbWVzIHNjaGVkdWxlZCBhdCB0aGUgc2FtZSB0aW1lXG5cblx0XHRcdFx0aWYgKHRpbWUgIT09IHRpbWVOZXh0ICYmIChpICE9PSAxIHx8IHRpbWUgIT09IHRpbWVzWzBdKSkge1xuXHRcdFx0XHRcdGlmICghc21vb3RoSW50ZXJwb2xhdGlvbikge1xuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGtleWZyYW1lcyBzYW1lIGFzIHRoZWlyIG5laWdoYm9yc1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gaSAqIHN0cmlkZSxcblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldFAgPSBvZmZzZXQgLSBzdHJpZGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXROID0gb2Zmc2V0ICsgc3RyaWRlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiAhPT0gc3RyaWRlOyArK2opIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2YWx1ZXNbb2Zmc2V0ICsgal07XG5cblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9PSB2YWx1ZXNbb2Zmc2V0UCArIGpdIHx8IHZhbHVlICE9PSB2YWx1ZXNbb2Zmc2V0TiArIGpdKSB7XG5cdFx0XHRcdFx0XHRcdFx0a2VlcCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0a2VlcCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGluLXBsYWNlIGNvbXBhY3Rpb25cblxuXG5cdFx0XHRcdGlmIChrZWVwKSB7XG5cdFx0XHRcdFx0aWYgKGkgIT09IHdyaXRlSW5kZXgpIHtcblx0XHRcdFx0XHRcdHRpbWVzW3dyaXRlSW5kZXhdID0gdGltZXNbaV07XG5cdFx0XHRcdFx0XHRjb25zdCByZWFkT2Zmc2V0ID0gaSAqIHN0cmlkZSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogIT09IHN0cmlkZTsgKytqKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1t3cml0ZU9mZnNldCArIGpdID0gdmFsdWVzW3JlYWRPZmZzZXQgKyBqXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQrK3dyaXRlSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gZmx1c2ggbGFzdCBrZXlmcmFtZSAoY29tcGFjdGlvbiBsb29rcyBhaGVhZClcblxuXG5cdFx0XHRpZiAobGFzdEluZGV4ID4gMCkge1xuXHRcdFx0XHR0aW1lc1t3cml0ZUluZGV4XSA9IHRpbWVzW2xhc3RJbmRleF07XG5cblx0XHRcdFx0Zm9yIChsZXQgcmVhZE9mZnNldCA9IGxhc3RJbmRleCAqIHN0cmlkZSwgd3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlLCBqID0gMDsgaiAhPT0gc3RyaWRlOyArK2opIHtcblx0XHRcdFx0XHR2YWx1ZXNbd3JpdGVPZmZzZXQgKyBqXSA9IHZhbHVlc1tyZWFkT2Zmc2V0ICsgal07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQrK3dyaXRlSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh3cml0ZUluZGV4ICE9PSB0aW1lcy5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UodGltZXMsIDAsIHdyaXRlSW5kZXgpO1xuXHRcdFx0XHR0aGlzLnZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UodmFsdWVzLCAwLCB3cml0ZUluZGV4ICogc3RyaWRlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudGltZXMgPSB0aW1lcztcblx0XHRcdFx0dGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0Y29uc3QgdGltZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHRoaXMudGltZXMsIDApO1xuXHRcdFx0Y29uc3QgdmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSh0aGlzLnZhbHVlcywgMCk7XG5cdFx0XHRjb25zdCBUeXBlZEtleWZyYW1lVHJhY2sgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHRcdFx0Y29uc3QgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKHRoaXMubmFtZSwgdGltZXMsIHZhbHVlcyk7IC8vIEludGVycG9sYW50IGFyZ3VtZW50IHRvIGNvbnN0cnVjdG9yIGlzIG5vdCBzYXZlZCwgc28gY29weSB0aGUgZmFjdG9yeSBtZXRob2QgZGlyZWN0bHkuXG5cblx0XHRcdHRyYWNrLmNyZWF0ZUludGVycG9sYW50ID0gdGhpcy5jcmVhdGVJbnRlcnBvbGFudDtcblx0XHRcdHJldHVybiB0cmFjaztcblx0XHR9XG5cblx0fVxuXG5cdEtleWZyYW1lVHJhY2sucHJvdG90eXBlLlRpbWVCdWZmZXJUeXBlID0gRmxvYXQzMkFycmF5O1xuXHRLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZUJ1ZmZlclR5cGUgPSBGbG9hdDMyQXJyYXk7XG5cdEtleWZyYW1lVHJhY2sucHJvdG90eXBlLkRlZmF1bHRJbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGVMaW5lYXI7XG5cblx0LyoqXG5cdCAqIEEgVHJhY2sgb2YgQm9vbGVhbiBrZXlmcmFtZSB2YWx1ZXMuXG5cdCAqL1xuXG5cdGNsYXNzIEJvb2xlYW5LZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxuXG5cdEJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ2Jvb2wnO1xuXHRCb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlID0gQXJyYXk7XG5cdEJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRlRGlzY3JldGU7XG5cdEJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIgPSB1bmRlZmluZWQ7XG5cdEJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGggPSB1bmRlZmluZWQ7IC8vIE5vdGU6IEFjdHVhbGx5IHRoaXMgdHJhY2sgY291bGQgaGF2ZSBhIG9wdGltaXplZCAvIGNvbXByZXNzZWRcblxuXHQvKipcblx0ICogQSBUcmFjayBvZiBrZXlmcmFtZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgY29sb3IuXG5cdCAqL1xuXG5cdGNsYXNzIENvbG9yS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge31cblxuXHRDb2xvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnY29sb3InOyAvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblx0LyoqXG5cdCAqIEEgVHJhY2sgb2YgbnVtZXJpYyBrZXlmcmFtZSB2YWx1ZXMuXG5cdCAqL1xuXG5cdGNsYXNzIE51bWJlcktleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHt9XG5cblx0TnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdudW1iZXInOyAvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblx0LyoqXG5cdCAqIFNwaGVyaWNhbCBsaW5lYXIgdW5pdCBxdWF0ZXJuaW9uIGludGVycG9sYW50LlxuXHQgKi9cblxuXHRjbGFzcyBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuXHRcdFx0c3VwZXIocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcik7XG5cdFx0fVxuXG5cdFx0aW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpIHtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0XHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRcdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdFx0XHRcdGFscGhhID0gKHQgLSB0MCkgLyAodDEgLSB0MCk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0gaTEgKiBzdHJpZGU7XG5cblx0XHRcdGZvciAobGV0IGVuZCA9IG9mZnNldCArIHN0cmlkZTsgb2Zmc2V0ICE9PSBlbmQ7IG9mZnNldCArPSA0KSB7XG5cdFx0XHRcdFF1YXRlcm5pb24uc2xlcnBGbGF0KHJlc3VsdCwgMCwgdmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQSBUcmFjayBvZiBxdWF0ZXJuaW9uIGtleWZyYW1lIHZhbHVlcy5cblx0ICovXG5cblx0Y2xhc3MgUXVhdGVybmlvbktleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHtcblx0XHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIocmVzdWx0KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCh0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0KTtcblx0XHR9XG5cblx0fVxuXG5cdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ3F1YXRlcm5pb24nOyAvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblx0UXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkRlZmF1bHRJbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGVMaW5lYXI7XG5cdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGggPSB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEEgVHJhY2sgdGhhdCBpbnRlcnBvbGF0ZXMgU3RyaW5nc1xuXHQgKi9cblxuXHRjbGFzcyBTdHJpbmdLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxuXG5cdFN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnc3RyaW5nJztcblx0U3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlID0gQXJyYXk7XG5cdFN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLkRlZmF1bHRJbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcblx0U3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyID0gdW5kZWZpbmVkO1xuXHRTdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGggPSB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEEgVHJhY2sgb2YgdmVjdG9yZWQga2V5ZnJhbWUgdmFsdWVzLlxuXHQgKi9cblxuXHRjbGFzcyBWZWN0b3JLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxuXG5cdFZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAndmVjdG9yJzsgLy8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxuXG5cdGNsYXNzIEFuaW1hdGlvbkNsaXAge1xuXHRcdGNvbnN0cnVjdG9yKG5hbWUsIGR1cmF0aW9uID0gLTEsIHRyYWNrcywgYmxlbmRNb2RlID0gTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdFx0dGhpcy50cmFja3MgPSB0cmFja3M7XG5cdFx0XHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG5cdFx0XHR0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcblx0XHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpOyAvLyB0aGlzIG1lYW5zIGl0IHNob3VsZCBmaWd1cmUgb3V0IGl0cyBkdXJhdGlvbiBieSBzY2FubmluZyB0aGUgdHJhY2tzXG5cblx0XHRcdGlmICh0aGlzLmR1cmF0aW9uIDwgMCkge1xuXHRcdFx0XHR0aGlzLnJlc2V0RHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGF0aWMgcGFyc2UoanNvbikge1xuXHRcdFx0Y29uc3QgdHJhY2tzID0gW10sXG5cdFx0XHRcdFx0XHRqc29uVHJhY2tzID0ganNvbi50cmFja3MsXG5cdFx0XHRcdFx0XHRmcmFtZVRpbWUgPSAxLjAgLyAoanNvbi5mcHMgfHwgMS4wKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBqc29uVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdHRyYWNrcy5wdXNoKHBhcnNlS2V5ZnJhbWVUcmFjayhqc29uVHJhY2tzW2ldKS5zY2FsZShmcmFtZVRpbWUpKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2xpcCA9IG5ldyB0aGlzKGpzb24ubmFtZSwganNvbi5kdXJhdGlvbiwgdHJhY2tzLCBqc29uLmJsZW5kTW9kZSk7XG5cdFx0XHRjbGlwLnV1aWQgPSBqc29uLnV1aWQ7XG5cdFx0XHRyZXR1cm4gY2xpcDtcblx0XHR9XG5cblx0XHRzdGF0aWMgdG9KU09OKGNsaXApIHtcblx0XHRcdGNvbnN0IHRyYWNrcyA9IFtdLFxuXHRcdFx0XHRcdFx0Y2xpcFRyYWNrcyA9IGNsaXAudHJhY2tzO1xuXHRcdFx0Y29uc3QganNvbiA9IHtcblx0XHRcdFx0J25hbWUnOiBjbGlwLm5hbWUsXG5cdFx0XHRcdCdkdXJhdGlvbic6IGNsaXAuZHVyYXRpb24sXG5cdFx0XHRcdCd0cmFja3MnOiB0cmFja3MsXG5cdFx0XHRcdCd1dWlkJzogY2xpcC51dWlkLFxuXHRcdFx0XHQnYmxlbmRNb2RlJzogY2xpcC5ibGVuZE1vZGVcblx0XHRcdH07XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gY2xpcFRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHR0cmFja3MucHVzaChLZXlmcmFtZVRyYWNrLnRvSlNPTihjbGlwVHJhY2tzW2ldKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBqc29uO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBDcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZShuYW1lLCBtb3JwaFRhcmdldFNlcXVlbmNlLCBmcHMsIG5vTG9vcCkge1xuXHRcdFx0Y29uc3QgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhUYXJnZXRTZXF1ZW5jZS5sZW5ndGg7XG5cdFx0XHRjb25zdCB0cmFja3MgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7IGkrKykge1xuXHRcdFx0XHRsZXQgdGltZXMgPSBbXTtcblx0XHRcdFx0bGV0IHZhbHVlcyA9IFtdO1xuXHRcdFx0XHR0aW1lcy5wdXNoKChpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSkgJSBudW1Nb3JwaFRhcmdldHMsIGksIChpICsgMSkgJSBudW1Nb3JwaFRhcmdldHMpO1xuXHRcdFx0XHR2YWx1ZXMucHVzaCgwLCAxLCAwKTtcblx0XHRcdFx0Y29uc3Qgb3JkZXIgPSBBbmltYXRpb25VdGlscy5nZXRLZXlmcmFtZU9yZGVyKHRpbWVzKTtcblx0XHRcdFx0dGltZXMgPSBBbmltYXRpb25VdGlscy5zb3J0ZWRBcnJheSh0aW1lcywgMSwgb3JkZXIpO1xuXHRcdFx0XHR2YWx1ZXMgPSBBbmltYXRpb25VdGlscy5zb3J0ZWRBcnJheSh2YWx1ZXMsIDEsIG9yZGVyKTsgLy8gaWYgdGhlcmUgaXMgYSBrZXkgYXQgdGhlIGZpcnN0IGZyYW1lLCBkdXBsaWNhdGUgaXQgYXMgdGhlXG5cdFx0XHRcdC8vIGxhc3QgZnJhbWUgYXMgd2VsbCBmb3IgcGVyZmVjdCBsb29wLlxuXG5cdFx0XHRcdGlmICghbm9Mb29wICYmIHRpbWVzWzBdID09PSAwKSB7XG5cdFx0XHRcdFx0dGltZXMucHVzaChudW1Nb3JwaFRhcmdldHMpO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlc1swXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cmFja3MucHVzaChuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjaygnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1snICsgbW9ycGhUYXJnZXRTZXF1ZW5jZVtpXS5uYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzKS5zY2FsZSgxLjAgLyBmcHMpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzKG5hbWUsIC0xLCB0cmFja3MpO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmaW5kQnlOYW1lKG9iamVjdE9yQ2xpcEFycmF5LCBuYW1lKSB7XG5cdFx0XHRsZXQgY2xpcEFycmF5ID0gb2JqZWN0T3JDbGlwQXJyYXk7XG5cblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShvYmplY3RPckNsaXBBcnJheSkpIHtcblx0XHRcdFx0Y29uc3QgbyA9IG9iamVjdE9yQ2xpcEFycmF5O1xuXHRcdFx0XHRjbGlwQXJyYXkgPSBvLmdlb21ldHJ5ICYmIG8uZ2VvbWV0cnkuYW5pbWF0aW9ucyB8fCBvLmFuaW1hdGlvbnM7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2xpcEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChjbGlwQXJyYXlbaV0ubmFtZSA9PT0gbmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiBjbGlwQXJyYXlbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0c3RhdGljIENyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzKG1vcnBoVGFyZ2V0cywgZnBzLCBub0xvb3ApIHtcblx0XHRcdGNvbnN0IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307IC8vIHRlc3RlZCB3aXRoIGh0dHBzOi8vcmVnZXgxMDEuY29tLyBvbiB0cmljayBzZXF1ZW5jZXNcblx0XHRcdC8vIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxuXG5cdFx0XHRjb25zdCBwYXR0ZXJuID0gL14oW1xcdy1dKj8pKFtcXGRdKykkLzsgLy8gc29ydCBtb3JwaCB0YXJnZXQgbmFtZXMgaW50byBhbmltYXRpb24gZ3JvdXBzIGJhc2VkXG5cdFx0XHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1tpXTtcblx0XHRcdFx0Y29uc3QgcGFydHMgPSBtb3JwaFRhcmdldC5uYW1lLm1hdGNoKHBhdHRlcm4pO1xuXG5cdFx0XHRcdGlmIChwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHBhcnRzWzFdO1xuXHRcdFx0XHRcdGxldCBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1tuYW1lXTtcblxuXHRcdFx0XHRcdGlmICghYW5pbWF0aW9uTW9ycGhUYXJnZXRzKSB7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1tuYW1lXSA9IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKG1vcnBoVGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjbGlwcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMpIHtcblx0XHRcdFx0Y2xpcHMucHVzaCh0aGlzLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKG5hbWUsIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzW25hbWVdLCBmcHMsIG5vTG9vcCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2xpcHM7XG5cdFx0fSAvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcblxuXG5cdFx0c3RhdGljIHBhcnNlQW5pbWF0aW9uKGFuaW1hdGlvbiwgYm9uZXMpIHtcblx0XHRcdGlmICghYW5pbWF0aW9uKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkFuaW1hdGlvbkNsaXA6IE5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGEuJyk7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhZGROb25lbXB0eVRyYWNrID0gZnVuY3Rpb24gKHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MpIHtcblx0XHRcdFx0Ly8gb25seSByZXR1cm4gdHJhY2sgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGtleXMuXG5cdFx0XHRcdGlmIChhbmltYXRpb25LZXlzLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0XHRcdGNvbnN0IHRpbWVzID0gW107XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0XHRcdFx0QW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oYW5pbWF0aW9uS2V5cywgdGltZXMsIHZhbHVlcywgcHJvcGVydHlOYW1lKTsgLy8gZW1wdHkga2V5cyBhcmUgZmlsdGVyZWQgb3V0LCBzbyBjaGVjayBhZ2FpblxuXG5cdFx0XHRcdFx0aWYgKHRpbWVzLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0ZGVzdFRyYWNrcy5wdXNoKG5ldyB0cmFja1R5cGUodHJhY2tOYW1lLCB0aW1lcywgdmFsdWVzKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCB0cmFja3MgPSBbXTtcblx0XHRcdGNvbnN0IGNsaXBOYW1lID0gYW5pbWF0aW9uLm5hbWUgfHwgJ2RlZmF1bHQnO1xuXHRcdFx0Y29uc3QgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcblx0XHRcdGNvbnN0IGJsZW5kTW9kZSA9IGFuaW1hdGlvbi5ibGVuZE1vZGU7IC8vIGF1dG9tYXRpYyBsZW5ndGggZGV0ZXJtaW5hdGlvbiBpbiBBbmltYXRpb25DbGlwLlxuXG5cdFx0XHRsZXQgZHVyYXRpb24gPSBhbmltYXRpb24ubGVuZ3RoIHx8IC0xO1xuXHRcdFx0Y29uc3QgaGllcmFyY2h5VHJhY2tzID0gYW5pbWF0aW9uLmhpZXJhcmNoeSB8fCBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoKyspIHtcblx0XHRcdFx0Y29uc3QgYW5pbWF0aW9uS2V5cyA9IGhpZXJhcmNoeVRyYWNrc1toXS5rZXlzOyAvLyBza2lwIGVtcHR5IHRyYWNrc1xuXG5cdFx0XHRcdGlmICghYW5pbWF0aW9uS2V5cyB8fCBhbmltYXRpb25LZXlzLmxlbmd0aCA9PT0gMCkgY29udGludWU7IC8vIHByb2Nlc3MgbW9ycGggdGFyZ2V0c1xuXG5cdFx0XHRcdGlmIChhbmltYXRpb25LZXlzWzBdLm1vcnBoVGFyZ2V0cykge1xuXHRcdFx0XHRcdC8vIGZpZ3VyZSBvdXQgYWxsIG1vcnBoIHRhcmdldHMgdXNlZCBpbiB0aGlzIHRyYWNrXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xuXHRcdFx0XHRcdGxldCBrO1xuXG5cdFx0XHRcdFx0Zm9yIChrID0gMDsgayA8IGFuaW1hdGlvbktleXMubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmIChhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cykge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0bW9ycGhUYXJnZXROYW1lc1thbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0c1ttXV0gPSAtMTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gLy8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cblx0XHRcdFx0XHQvLyBtb3JwaFRhcmdldEluZmx1ZW5jZXMgZXhjZXB0IGZvciB0aGUga2V5cyBpbiB3aGljaFxuXHRcdFx0XHRcdC8vIHRoZSBtb3JwaFRhcmdldCBpcyBuYW1lZC5cblxuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdGltZXMgPSBbXTtcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBtID0gMDsgbSAhPT0gYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMubGVuZ3RoOyArK20pIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYW5pbWF0aW9uS2V5ID0gYW5pbWF0aW9uS2V5c1trXTtcblx0XHRcdFx0XHRcdFx0dGltZXMucHVzaChhbmltYXRpb25LZXkudGltZSk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKGFuaW1hdGlvbktleS5tb3JwaFRhcmdldCA9PT0gbW9ycGhUYXJnZXROYW1lID8gMSA6IDApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0cmFja3MucHVzaChuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjaygnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlWycgKyBtb3JwaFRhcmdldE5hbWUgKyAnXScsIHRpbWVzLCB2YWx1ZXMpKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkdXJhdGlvbiA9IG1vcnBoVGFyZ2V0TmFtZXMubGVuZ3RoICogKGZwcyB8fCAxLjApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIC4uLmFzc3VtZSBza2VsZXRhbCBhbmltYXRpb25cblx0XHRcdFx0XHRjb25zdCBib25lTmFtZSA9ICcuYm9uZXNbJyArIGJvbmVzW2hdLm5hbWUgKyAnXSc7XG5cdFx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucG9zaXRpb24nLCBhbmltYXRpb25LZXlzLCAncG9zJywgdHJhY2tzKTtcblx0XHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucXVhdGVybmlvbicsIGFuaW1hdGlvbktleXMsICdyb3QnLCB0cmFja3MpO1xuXHRcdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soVmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnNjYWxlJywgYW5pbWF0aW9uS2V5cywgJ3NjbCcsIHRyYWNrcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNsaXAgPSBuZXcgdGhpcyhjbGlwTmFtZSwgZHVyYXRpb24sIHRyYWNrcywgYmxlbmRNb2RlKTtcblx0XHRcdHJldHVybiBjbGlwO1xuXHRcdH1cblxuXHRcdHJlc2V0RHVyYXRpb24oKSB7XG5cdFx0XHRjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrcztcblx0XHRcdGxldCBkdXJhdGlvbiA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gdHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbaV07XG5cdFx0XHRcdGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRyYWNrLnRpbWVzW3RyYWNrLnRpbWVzLmxlbmd0aCAtIDFdKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dHJpbSgpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy50cmFja3NbaV0udHJpbSgwLCB0aGlzLmR1cmF0aW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dmFsaWRhdGUoKSB7XG5cdFx0XHRsZXQgdmFsaWQgPSB0cnVlO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhbGlkID0gdmFsaWQgJiYgdGhpcy50cmFja3NbaV0udmFsaWRhdGUoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbGlkO1xuXHRcdH1cblxuXHRcdG9wdGltaXplKCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLnRyYWNrc1tpXS5vcHRpbWl6ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRyYWNrcy5wdXNoKHRoaXMudHJhY2tzW2ldLmNsb25lKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5uYW1lLCB0aGlzLmR1cmF0aW9uLCB0cmFja3MsIHRoaXMuYmxlbmRNb2RlKTtcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b0pTT04odGhpcyk7XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lKHR5cGVOYW1lKSB7XG5cdFx0c3dpdGNoICh0eXBlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRjYXNlICdzY2FsYXInOlxuXHRcdFx0Y2FzZSAnZG91YmxlJzpcblx0XHRcdGNhc2UgJ2Zsb2F0Jzpcblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRjYXNlICdpbnRlZ2VyJzpcblx0XHRcdFx0cmV0dXJuIE51bWJlcktleWZyYW1lVHJhY2s7XG5cblx0XHRcdGNhc2UgJ3ZlY3Rvcic6XG5cdFx0XHRjYXNlICd2ZWN0b3IyJzpcblx0XHRcdGNhc2UgJ3ZlY3RvcjMnOlxuXHRcdFx0Y2FzZSAndmVjdG9yNCc6XG5cdFx0XHRcdHJldHVybiBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuXG5cdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdHJldHVybiBDb2xvcktleWZyYW1lVHJhY2s7XG5cblx0XHRcdGNhc2UgJ3F1YXRlcm5pb24nOlxuXHRcdFx0XHRyZXR1cm4gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cblx0XHRcdGNhc2UgJ2Jvb2wnOlxuXHRcdFx0Y2FzZSAnYm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiBCb29sZWFuS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0cmV0dXJuIFN0cmluZ0tleWZyYW1lVHJhY2s7XG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUSFJFRS5LZXlmcmFtZVRyYWNrOiBVbnN1cHBvcnRlZCB0eXBlTmFtZTogJyArIHR5cGVOYW1lKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlS2V5ZnJhbWVUcmFjayhqc29uKSB7XG5cdFx0aWYgKGpzb24udHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIHR5cGUgdW5kZWZpbmVkLCBjYW4gbm90IHBhcnNlJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdHJhY2tUeXBlID0gZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZShqc29uLnR5cGUpO1xuXG5cdFx0aWYgKGpzb24udGltZXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc3QgdGltZXMgPSBbXSxcblx0XHRcdFx0XHRcdHZhbHVlcyA9IFtdO1xuXHRcdFx0QW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oanNvbi5rZXlzLCB0aW1lcywgdmFsdWVzLCAndmFsdWUnKTtcblx0XHRcdGpzb24udGltZXMgPSB0aW1lcztcblx0XHRcdGpzb24udmFsdWVzID0gdmFsdWVzO1xuXHRcdH0gLy8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgcGFyc2UgbWV0aG9kXG5cblxuXHRcdGlmICh0cmFja1R5cGUucGFyc2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRyYWNrVHlwZS5wYXJzZShqc29uKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIGEgY29uc3RydWN0b3IgY29tcGF0aWJsZSB3aXRoIHRoZSBiYXNlXG5cdFx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZShqc29uLm5hbWUsIGpzb24udGltZXMsIGpzb24udmFsdWVzLCBqc29uLmludGVycG9sYXRpb24pO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IENhY2hlID0ge1xuXHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdGZpbGVzOiB7fSxcblx0XHRhZGQ6IGZ1bmN0aW9uIChrZXksIGZpbGUpIHtcblx0XHRcdGlmICh0aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47IC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQWRkaW5nIGtleTonLCBrZXkgKTtcblxuXHRcdFx0dGhpcy5maWxlc1trZXldID0gZmlsZTtcblx0XHR9LFxuXHRcdGdldDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjsgLy8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmZpbGVzW2tleV07XG5cdFx0fSxcblx0XHRyZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLmZpbGVzW2tleV07XG5cdFx0fSxcblx0XHRjbGVhcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5maWxlcyA9IHt9O1xuXHRcdH1cblx0fTtcblxuXHRjbGFzcyBMb2FkaW5nTWFuYWdlciB7XG5cdFx0Y29uc3RydWN0b3Iob25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRsZXQgaXNMb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRsZXQgaXRlbXNMb2FkZWQgPSAwO1xuXHRcdFx0bGV0IGl0ZW1zVG90YWwgPSAwO1xuXHRcdFx0bGV0IHVybE1vZGlmaWVyID0gdW5kZWZpbmVkO1xuXHRcdFx0Y29uc3QgaGFuZGxlcnMgPSBbXTsgLy8gUmVmZXIgdG8gIzU2ODkgZm9yIHRoZSByZWFzb24gd2h5IHdlIGRvbid0IHNldCAub25TdGFydFxuXHRcdFx0Ly8gaW4gdGhlIGNvbnN0cnVjdG9yXG5cblx0XHRcdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMub25Mb2FkID0gb25Mb2FkO1xuXHRcdFx0dGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcblx0XHRcdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG5cblx0XHRcdHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKHVybCkge1xuXHRcdFx0XHRpdGVtc1RvdGFsKys7XG5cblx0XHRcdFx0aWYgKGlzTG9hZGluZyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRpZiAoc2NvcGUub25TdGFydCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzY29wZS5vblN0YXJ0KHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlzTG9hZGluZyA9IHRydWU7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAodXJsKSB7XG5cdFx0XHRcdGl0ZW1zTG9hZGVkKys7XG5cblx0XHRcdFx0aWYgKHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHNjb3BlLm9uUHJvZ3Jlc3ModXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXRlbXNMb2FkZWQgPT09IGl0ZW1zVG90YWwpIHtcblx0XHRcdFx0XHRpc0xvYWRpbmcgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmIChzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0c2NvcGUub25Mb2FkKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICh1cmwpIHtcblx0XHRcdFx0aWYgKHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHNjb3BlLm9uRXJyb3IodXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5yZXNvbHZlVVJMID0gZnVuY3Rpb24gKHVybCkge1xuXHRcdFx0XHRpZiAodXJsTW9kaWZpZXIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXJsTW9kaWZpZXIodXJsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB1cmw7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnNldFVSTE1vZGlmaWVyID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuXHRcdFx0XHR1cmxNb2RpZmllciA9IHRyYW5zZm9ybTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmFkZEhhbmRsZXIgPSBmdW5jdGlvbiAocmVnZXgsIGxvYWRlcikge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKHJlZ2V4LCBsb2FkZXIpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdHRoaXMucmVtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChyZWdleCkge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YocmVnZXgpO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmdldEhhbmRsZXIgPSBmdW5jdGlvbiAoZmlsZSkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xuXHRcdFx0XHRcdGNvbnN0IHJlZ2V4ID0gaGFuZGxlcnNbaV07XG5cdFx0XHRcdFx0Y29uc3QgbG9hZGVyID0gaGFuZGxlcnNbaSArIDFdO1xuXHRcdFx0XHRcdGlmIChyZWdleC5nbG9iYWwpIHJlZ2V4Lmxhc3RJbmRleCA9IDA7IC8vIHNlZSAjMTc5MjBcblxuXHRcdFx0XHRcdGlmIChyZWdleC50ZXN0KGZpbGUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbG9hZGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IERlZmF1bHRMb2FkaW5nTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcigpO1xuXG5cdGNsYXNzIExvYWRlciB7XG5cdFx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdFx0dGhpcy5tYW5hZ2VyID0gbWFuYWdlciAhPT0gdW5kZWZpbmVkID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblx0XHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblx0XHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cdFx0XHR0aGlzLnBhdGggPSAnJztcblx0XHRcdHRoaXMucmVzb3VyY2VQYXRoID0gJyc7XG5cdFx0XHR0aGlzLnJlcXVlc3RIZWFkZXIgPSB7fTtcblx0XHR9XG5cblx0XHRsb2FkKClcblx0XHQvKiB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciAqL1xuXHRcdHt9XG5cblx0XHRsb2FkQXN5bmModXJsLCBvblByb2dyZXNzKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHRzY29wZS5sb2FkKHVybCwgcmVzb2x2ZSwgb25Qcm9ncmVzcywgcmVqZWN0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHBhcnNlKClcblx0XHQvKiBkYXRhICovXG5cdFx0e31cblxuXHRcdHNldENyb3NzT3JpZ2luKGNyb3NzT3JpZ2luKSB7XG5cdFx0XHR0aGlzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRXaXRoQ3JlZGVudGlhbHModmFsdWUpIHtcblx0XHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRQYXRoKHBhdGgpIHtcblx0XHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRSZXNvdXJjZVBhdGgocmVzb3VyY2VQYXRoKSB7XG5cdFx0XHR0aGlzLnJlc291cmNlUGF0aCA9IHJlc291cmNlUGF0aDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFJlcXVlc3RIZWFkZXIocmVxdWVzdEhlYWRlcikge1xuXHRcdFx0dGhpcy5yZXF1ZXN0SGVhZGVyID0gcmVxdWVzdEhlYWRlcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgbG9hZGluZyA9IHt9O1xuXG5cdGNsYXNzIEZpbGVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRcdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRcdHN1cGVyKG1hbmFnZXIpO1xuXHRcdH1cblxuXHRcdGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRcdGlmICh1cmwgPT09IHVuZGVmaW5lZCkgdXJsID0gJyc7XG5cdFx0XHRpZiAodGhpcy5wYXRoICE9PSB1bmRlZmluZWQpIHVybCA9IHRoaXMucGF0aCArIHVybDtcblx0XHRcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKHVybCk7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBjYWNoZWQgPSBDYWNoZS5nZXQodXJsKTtcblxuXHRcdFx0aWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChvbkxvYWQpIG9uTG9hZChjYWNoZWQpO1xuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0XHR9LCAwKTtcblx0XHRcdFx0cmV0dXJuIGNhY2hlZDtcblx0XHRcdH0gLy8gQ2hlY2sgaWYgcmVxdWVzdCBpcyBkdXBsaWNhdGVcblxuXG5cdFx0XHRpZiAobG9hZGluZ1t1cmxdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bG9hZGluZ1t1cmxdLnB1c2goe1xuXHRcdFx0XHRcdG9uTG9hZDogb25Mb2FkLFxuXHRcdFx0XHRcdG9uUHJvZ3Jlc3M6IG9uUHJvZ3Jlc3MsXG5cdFx0XHRcdFx0b25FcnJvcjogb25FcnJvclxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSAvLyBDaGVjayBmb3IgZGF0YTogVVJJXG5cblxuXHRcdFx0Y29uc3QgZGF0YVVyaVJlZ2V4ID0gL15kYXRhOiguKj8pKDtiYXNlNjQpPywoLiopJC87XG5cdFx0XHRjb25zdCBkYXRhVXJpUmVnZXhSZXN1bHQgPSB1cmwubWF0Y2goZGF0YVVyaVJlZ2V4KTtcblx0XHRcdGxldCByZXF1ZXN0OyAvLyBTYWZhcmkgY2FuIG5vdCBoYW5kbGUgRGF0YSBVUklzIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Qgc28gcHJvY2VzcyBtYW51YWxseVxuXG5cdFx0XHRpZiAoZGF0YVVyaVJlZ2V4UmVzdWx0KSB7XG5cdFx0XHRcdGNvbnN0IG1pbWVUeXBlID0gZGF0YVVyaVJlZ2V4UmVzdWx0WzFdO1xuXHRcdFx0XHRjb25zdCBpc0Jhc2U2NCA9ICEhZGF0YVVyaVJlZ2V4UmVzdWx0WzJdO1xuXHRcdFx0XHRsZXQgZGF0YSA9IGRhdGFVcmlSZWdleFJlc3VsdFszXTtcblx0XHRcdFx0ZGF0YSA9IGRlY29kZVVSSUNvbXBvbmVudChkYXRhKTtcblx0XHRcdFx0aWYgKGlzQmFzZTY0KSBkYXRhID0gYXRvYihkYXRhKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGxldCByZXNwb25zZTtcblx0XHRcdFx0XHRjb25zdCByZXNwb25zZVR5cGUgPSAodGhpcy5yZXNwb25zZVR5cGUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxuXHRcdFx0XHRcdFx0Y2FzZSAnYmxvYic6XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG5cblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmlld1tpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChyZXNwb25zZVR5cGUgPT09ICdibG9iJykge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gbmV3IEJsb2IoW3ZpZXcuYnVmZmVyXSwge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogbWltZVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IHZpZXcuYnVmZmVyO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2RvY3VtZW50Jzpcblx0XHRcdFx0XHRcdFx0Y29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoZGF0YSwgbWltZVR5cGUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnanNvbic6XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gSlNPTi5wYXJzZShkYXRhKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdC8vICd0ZXh0JyBvciBvdGhlclxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGRhdGE7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gLy8gV2FpdCBmb3IgbmV4dCBicm93c2VyIHRpY2sgbGlrZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBldmVudCBkaXNwYXRjaGluZyBkb2VzXG5cblxuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKHJlc3BvbnNlKTtcblx0XHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0XHRcdH0sIDApO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdC8vIFdhaXQgZm9yIG5leHQgYnJvd3NlciB0aWNrIGxpa2Ugc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3QgZXZlbnQgZGlzcGF0Y2hpbmcgZG9lc1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKG9uRXJyb3IpIG9uRXJyb3IoZXJyb3IpO1xuXHRcdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0XHRcdH0sIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJbml0aWFsaXNlIGFycmF5IGZvciBkdXBsaWNhdGUgcmVxdWVzdHNcblx0XHRcdFx0bG9hZGluZ1t1cmxdID0gW107XG5cdFx0XHRcdGxvYWRpbmdbdXJsXS5wdXNoKHtcblx0XHRcdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdFx0XHRvblByb2dyZXNzOiBvblByb2dyZXNzLFxuXHRcdFx0XHRcdG9uRXJyb3I6IG9uRXJyb3Jcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdFx0cmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuXHRcdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRjb25zdCByZXNwb25zZSA9IHRoaXMucmVzcG9uc2U7XG5cdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gbG9hZGluZ1t1cmxdO1xuXHRcdFx0XHRcdGRlbGV0ZSBsb2FkaW5nW3VybF07XG5cblx0XHRcdFx0XHRpZiAodGhpcy5zdGF0dXMgPT09IDIwMCB8fCB0aGlzLnN0YXR1cyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gU29tZSBicm93c2VycyByZXR1cm4gSFRUUCBTdGF0dXMgMCB3aGVuIHVzaW5nIG5vbi1odHRwIHByb3RvY29sXG5cdFx0XHRcdFx0XHQvLyBlLmcuICdmaWxlOi8vJyBvciAnZGF0YTovLycuIEhhbmRsZSBhcyBzdWNjZXNzLlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuc3RhdHVzID09PSAwKSBjb25zb2xlLndhcm4oJ1RIUkVFLkZpbGVMb2FkZXI6IEhUVFAgU3RhdHVzIDAgcmVjZWl2ZWQuJyk7IC8vIEFkZCB0byBjYWNoZSBvbmx5IG9uIEhUVFAgc3VjY2Vzcywgc28gdGhhdCB3ZSBkbyBub3QgY2FjaGVcblx0XHRcdFx0XHRcdC8vIGVycm9yIHJlc3BvbnNlIGJvZGllcyBhcyBwcm9wZXIgcmVzcG9uc2VzIHRvIHJlcXVlc3RzLlxuXG5cdFx0XHRcdFx0XHRDYWNoZS5hZGQodXJsLCByZXNwb25zZSk7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuXHRcdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2sub25Mb2FkKSBjYWxsYmFjay5vbkxvYWQocmVzcG9uc2UpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG5cdFx0XHRcdFx0XHRcdGlmIChjYWxsYmFjay5vbkVycm9yKSBjYWxsYmFjay5vbkVycm9yKGV2ZW50KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gbG9hZGluZ1t1cmxdO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKGNhbGxiYWNrLm9uUHJvZ3Jlc3MpIGNhbGxiYWNrLm9uUHJvZ3Jlc3MoZXZlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gbG9hZGluZ1t1cmxdO1xuXHRcdFx0XHRcdGRlbGV0ZSBsb2FkaW5nW3VybF07XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG5cdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2sub25FcnJvcikgY2FsbGJhY2sub25FcnJvcihldmVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gbG9hZGluZ1t1cmxdO1xuXHRcdFx0XHRcdGRlbGV0ZSBsb2FkaW5nW3VybF07XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG5cdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2sub25FcnJvcikgY2FsbGJhY2sub25FcnJvcihldmVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0XHRpZiAodGhpcy5yZXNwb25zZVR5cGUgIT09IHVuZGVmaW5lZCkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcblx0XHRcdFx0aWYgKHRoaXMud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG5cdFx0XHRcdGlmIChyZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSh0aGlzLm1pbWVUeXBlICE9PSB1bmRlZmluZWQgPyB0aGlzLm1pbWVUeXBlIDogJ3RleHQvcGxhaW4nKTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IGhlYWRlciBpbiB0aGlzLnJlcXVlc3RIZWFkZXIpIHtcblx0XHRcdFx0XHRyZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB0aGlzLnJlcXVlc3RIZWFkZXJbaGVhZGVyXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXF1ZXN0LnNlbmQobnVsbCk7XG5cdFx0XHR9XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG5cdFx0XHRyZXR1cm4gcmVxdWVzdDtcblx0XHR9XG5cblx0XHRzZXRSZXNwb25zZVR5cGUodmFsdWUpIHtcblx0XHRcdHRoaXMucmVzcG9uc2VUeXBlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRNaW1lVHlwZSh2YWx1ZSkge1xuXHRcdFx0dGhpcy5taW1lVHlwZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBBbmltYXRpb25Mb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRcdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRcdHN1cGVyKG1hbmFnZXIpO1xuXHRcdH1cblxuXHRcdGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuXHRcdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdFx0bG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAodGV4dCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG9uTG9hZChzY29wZS5wYXJzZShKU09OLnBhcnNlKHRleHQpKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRpZiAob25FcnJvcikge1xuXHRcdFx0XHRcdFx0b25FcnJvcihlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yKTtcblx0XHR9XG5cblx0XHRwYXJzZShqc29uKSB7XG5cdFx0XHRjb25zdCBhbmltYXRpb25zID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBjbGlwID0gQW5pbWF0aW9uQ2xpcC5wYXJzZShqc29uW2ldKTtcblx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKGNsaXApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcblx0ICpcblx0ICogU3ViIGNsYXNzZXMgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHBhcnNlKCkgbWV0aG9kIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiBsb2FkKCkuXG5cdCAqL1xuXG5cdGNsYXNzIENvbXByZXNzZWRUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHRzdXBlcihtYW5hZ2VyKTtcblx0XHR9XG5cblx0XHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBpbWFnZXMgPSBbXTtcblx0XHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgQ29tcHJlc3NlZFRleHR1cmUoKTtcblx0XHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuXHRcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHNjb3BlLndpdGhDcmVkZW50aWFscyk7XG5cdFx0XHRsZXQgbG9hZGVkID0gMDtcblxuXHRcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoaSkge1xuXHRcdFx0XHRsb2FkZXIubG9hZCh1cmxbaV0sIGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdFx0XHRjb25zdCB0ZXhEYXRhcyA9IHNjb3BlLnBhcnNlKGJ1ZmZlciwgdHJ1ZSk7XG5cdFx0XHRcdFx0aW1hZ2VzW2ldID0ge1xuXHRcdFx0XHRcdFx0d2lkdGg6IHRleERhdGFzLndpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXG5cdFx0XHRcdFx0XHRmb3JtYXQ6IHRleERhdGFzLmZvcm1hdCxcblx0XHRcdFx0XHRcdG1pcG1hcHM6IHRleERhdGFzLm1pcG1hcHNcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGxvYWRlZCArPSAxO1xuXG5cdFx0XHRcdFx0aWYgKGxvYWRlZCA9PT0gNikge1xuXHRcdFx0XHRcdFx0aWYgKHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxKSB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblx0XHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKHRleHR1cmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHVybCkpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcblx0XHRcdFx0XHRsb2FkVGV4dHVyZShpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cdFx0XHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0XHRcdGNvbnN0IHRleERhdGFzID0gc2NvcGUucGFyc2UoYnVmZmVyLCB0cnVlKTtcblxuXHRcdFx0XHRcdGlmICh0ZXhEYXRhcy5pc0N1YmVtYXApIHtcblx0XHRcdFx0XHRcdGNvbnN0IGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgZiA9IDA7IGYgPCBmYWNlczsgZisrKSB7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1tmXSA9IHtcblx0XHRcdFx0XHRcdFx0XHRtaXBtYXBzOiBbXVxuXHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGltYWdlc1tmXS5taXBtYXBzLnB1c2godGV4RGF0YXMubWlwbWFwc1tmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBpXSk7XG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VzW2ZdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbZl0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbZl0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEpIHtcblx0XHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChvbkxvYWQpIG9uTG9hZCh0ZXh0dXJlKTtcblx0XHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW1hZ2VMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRcdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRcdHN1cGVyKG1hbmFnZXIpO1xuXHRcdH1cblxuXHRcdGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRcdGlmICh0aGlzLnBhdGggIT09IHVuZGVmaW5lZCkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xuXHRcdFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwodXJsKTtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IGNhY2hlZCA9IENhY2hlLmdldCh1cmwpO1xuXG5cdFx0XHRpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKGNhY2hlZCk7XG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0XHRcdH0sIDApO1xuXHRcdFx0XHRyZXR1cm4gY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdpbWcnKTtcblxuXHRcdFx0ZnVuY3Rpb24gb25JbWFnZUxvYWQoKSB7XG5cdFx0XHRcdGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkltYWdlTG9hZCwgZmFsc2UpO1xuXHRcdFx0XHRpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uSW1hZ2VFcnJvciwgZmFsc2UpO1xuXHRcdFx0XHRDYWNoZS5hZGQodXJsLCB0aGlzKTtcblx0XHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKHRoaXMpO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25JbWFnZUVycm9yKGV2ZW50KSB7XG5cdFx0XHRcdGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkltYWdlTG9hZCwgZmFsc2UpO1xuXHRcdFx0XHRpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uSW1hZ2VFcnJvciwgZmFsc2UpO1xuXHRcdFx0XHRpZiAob25FcnJvcikgb25FcnJvcihldmVudCk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25JbWFnZUxvYWQsIGZhbHNlKTtcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25JbWFnZUVycm9yLCBmYWxzZSk7XG5cblx0XHRcdGlmICh1cmwuc3Vic3RyKDAsIDUpICE9PSAnZGF0YTonKSB7XG5cdFx0XHRcdGlmICh0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQpIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblx0XHRcdH1cblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcblx0XHRcdGltYWdlLnNyYyA9IHVybDtcblx0XHRcdHJldHVybiBpbWFnZTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEN1YmVUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHRzdXBlcihtYW5hZ2VyKTtcblx0XHR9XG5cblx0XHRsb2FkKHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZSgpO1xuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuXHRcdFx0bGV0IGxvYWRlZCA9IDA7XG5cblx0XHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKGkpIHtcblx0XHRcdFx0bG9hZGVyLmxvYWQodXJsc1tpXSwgZnVuY3Rpb24gKGltYWdlKSB7XG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZXNbaV0gPSBpbWFnZTtcblx0XHRcdFx0XHRsb2FkZWQrKztcblxuXHRcdFx0XHRcdGlmIChsb2FkZWQgPT09IDYpIHtcblx0XHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKHRleHR1cmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdW5kZWZpbmVkLCBvbkVycm9yKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGxvYWRUZXh0dXJlKGkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGxvYWQgZ2VuZXJpYyBiaW5hcnkgdGV4dHVyZXMgZm9ybWF0cyAocmdiZSwgaGRyLCAuLi4pXG5cdCAqXG5cdCAqIFN1YiBjbGFzc2VzIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBwYXJzZSgpIG1ldGhvZCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gbG9hZCgpLlxuXHQgKi9cblxuXHRjbGFzcyBEYXRhVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdFx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdFx0c3VwZXIobWFuYWdlcik7XG5cdFx0fVxuXG5cdFx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSgpO1xuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcblx0XHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG5cdFx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoc2NvcGUud2l0aENyZWRlbnRpYWxzKTtcblx0XHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0XHRjb25zdCB0ZXhEYXRhID0gc2NvcGUucGFyc2UoYnVmZmVyKTtcblx0XHRcdFx0aWYgKCF0ZXhEYXRhKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKHRleERhdGEuaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRleERhdGEuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmRhdGEgPSB0ZXhEYXRhLmRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gdGV4RGF0YS53cmFwUyAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS53cmFwUyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdHRleHR1cmUud3JhcFQgPSB0ZXhEYXRhLndyYXBUICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLndyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSB0ZXhEYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS5tYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gdGV4RGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IHRleERhdGEubWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHRcdFx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSB0ZXhEYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IHRleERhdGEuYW5pc290cm9weSA6IDE7XG5cblx0XHRcdFx0aWYgKHRleERhdGEuZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRleHR1cmUuZW5jb2RpbmcgPSB0ZXhEYXRhLmVuY29kaW5nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRleERhdGEuZmxpcFkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRleHR1cmUuZmxpcFkgPSB0ZXhEYXRhLmZsaXBZO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRleERhdGEuZm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGEuZm9ybWF0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRleERhdGEudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRleERhdGEubWlwbWFwcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xuXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyOyAvLyBwcmVzdW1hYmx5Li4uXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGV4RGF0YS5taXBtYXBDb3VudCA9PT0gMSkge1xuXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRleERhdGEuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRleERhdGEuZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdGlmIChvbkxvYWQpIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHRzdXBlcihtYW5hZ2VyKTtcblx0XHR9XG5cblx0XHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcblx0XHRcdGNvbnN0IGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMuY3Jvc3NPcmlnaW4pO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGltYWdlKSB7XG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZTsgLy8gSlBFR3MgY2FuJ3QgaGF2ZSBhbiBhbHBoYSBjaGFubmVsLCBzbyBtZW1vcnkgY2FuIGJlIHNhdmVkIGJ5IHN0b3JpbmcgdGhlbSBhcyBSR0IuXG5cblx0XHRcdFx0Y29uc3QgaXNKUEVHID0gdXJsLnNlYXJjaCgvXFwuanBlP2coJHxcXD8pL2kpID4gMCB8fCB1cmwuc2VhcmNoKC9eZGF0YVxcOmltYWdlXFwvanBlZy8pID09PSAwO1xuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IGlzSlBFRyA/IFJHQkZvcm1hdCA6IFJHQkFGb3JtYXQ7XG5cdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdGlmIChvbkxvYWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG9uTG9hZCh0ZXh0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKlx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXG5cdCAqXHRjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Y2xhc3MgQ3VydmVQYXRoIGV4dGVuZHMgQ3VydmUge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdDdXJ2ZVBhdGgnO1xuXHRcdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblx0XHRcdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG5cdFx0fVxuXG5cdFx0YWRkKGN1cnZlKSB7XG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHR9XG5cblx0XHRjbG9zZVBhdGgoKSB7XG5cdFx0XHQvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcblx0XHRcdGNvbnN0IHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1swXS5nZXRQb2ludCgwKTtcblx0XHRcdGNvbnN0IGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbdGhpcy5jdXJ2ZXMubGVuZ3RoIC0gMV0uZ2V0UG9pbnQoMSk7XG5cblx0XHRcdGlmICghc3RhcnRQb2ludC5lcXVhbHMoZW5kUG9pbnQpKSB7XG5cdFx0XHRcdHRoaXMuY3VydmVzLnB1c2gobmV3IExpbmVDdXJ2ZShlbmRQb2ludCwgc3RhcnRQb2ludCkpO1xuXHRcdFx0fVxuXHRcdH0gLy8gVG8gZ2V0IGFjY3VyYXRlIHBvaW50IHdpdGggcmVmZXJlbmNlIHRvXG5cdFx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxuXHRcdC8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcblx0XHQvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG5cdFx0Ly8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXG5cdFx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuXHRcdC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG5cblx0XHRnZXRQb2ludCh0KSB7XG5cdFx0XHRjb25zdCBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRjb25zdCBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdFx0bGV0IGkgPSAwOyAvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuXHRcdFx0d2hpbGUgKGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmIChjdXJ2ZUxlbmd0aHNbaV0gPj0gZCkge1xuXHRcdFx0XHRcdGNvbnN0IGRpZmYgPSBjdXJ2ZUxlbmd0aHNbaV0gLSBkO1xuXHRcdFx0XHRcdGNvbnN0IGN1cnZlID0gdGhpcy5jdXJ2ZXNbaV07XG5cdFx0XHRcdFx0Y29uc3Qgc2VnbWVudExlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xuXHRcdFx0XHRcdGNvbnN0IHUgPSBzZWdtZW50TGVuZ3RoID09PSAwID8gMCA6IDEgLSBkaWZmIC8gc2VnbWVudExlbmd0aDtcblx0XHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh1KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7IC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXHRcdH0gLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuXHRcdC8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxuXHRcdC8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcblxuXG5cdFx0Z2V0TGVuZ3RoKCkge1xuXHRcdFx0Y29uc3QgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cdFx0XHRyZXR1cm4gbGVuc1tsZW5zLmxlbmd0aCAtIDFdO1xuXHRcdH0gLy8gY2FjaGVMZW5ndGhzIG11c3QgYmUgcmVjYWxjdWxhdGVkLlxuXG5cblx0XHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmNhY2hlTGVuZ3RocyA9IG51bGw7XG5cdFx0XHR0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdH0gLy8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXG5cdFx0Ly8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuXG5cdFx0Z2V0Q3VydmVMZW5ndGhzKCkge1xuXHRcdFx0Ly8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxuXHRcdFx0aWYgKHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3Rocztcblx0XHRcdH0gLy8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcblx0XHRcdC8vIFB1c2ggc3VtcyBpbnRvIGNhY2hlZCBhcnJheVxuXG5cblx0XHRcdGNvbnN0IGxlbmd0aHMgPSBbXTtcblx0XHRcdGxldCBzdW1zID0gMDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0c3VtcyArPSB0aGlzLmN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHRcdFx0bGVuZ3Rocy5wdXNoKHN1bXMpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XG5cdFx0XHRyZXR1cm4gbGVuZ3Rocztcblx0XHR9XG5cblx0XHRnZXRTcGFjZWRQb2ludHMoZGl2aXNpb25zID0gNDApIHtcblx0XHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkrKykge1xuXHRcdFx0XHRwb2ludHMucHVzaCh0aGlzLmdldFBvaW50KGkgLyBkaXZpc2lvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuYXV0b0Nsb3NlKSB7XG5cdFx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb2ludHM7XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnRzKGRpdmlzaW9ucyA9IDEyKSB7XG5cdFx0XHRjb25zdCBwb2ludHMgPSBbXTtcblx0XHRcdGxldCBsYXN0O1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgY3VydmVzID0gdGhpcy5jdXJ2ZXM7IGkgPCBjdXJ2ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRcdGNvbnN0IHJlc29sdXRpb24gPSBjdXJ2ZSAmJiBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSA/IGRpdmlzaW9ucyAqIDIgOiBjdXJ2ZSAmJiAoY3VydmUuaXNMaW5lQ3VydmUgfHwgY3VydmUuaXNMaW5lQ3VydmUzKSA/IDEgOiBjdXJ2ZSAmJiBjdXJ2ZS5pc1NwbGluZUN1cnZlID8gZGl2aXNpb25zICogY3VydmUucG9pbnRzLmxlbmd0aCA6IGRpdmlzaW9ucztcblx0XHRcdFx0Y29uc3QgcHRzID0gY3VydmUuZ2V0UG9pbnRzKHJlc29sdXRpb24pO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSBwdHNbal07XG5cdFx0XHRcdFx0aWYgKGxhc3QgJiYgbGFzdC5lcXVhbHMocG9pbnQpKSBjb250aW51ZTsgLy8gZW5zdXJlcyBubyBjb25zZWN1dGl2ZSBwb2ludHMgYXJlIGR1cGxpY2F0ZXNcblxuXHRcdFx0XHRcdHBvaW50cy5wdXNoKHBvaW50KTtcblx0XHRcdFx0XHRsYXN0ID0gcG9pbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuYXV0b0Nsb3NlICYmIHBvaW50cy5sZW5ndGggPiAxICYmICFwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLmVxdWFscyhwb2ludHNbMF0pKSB7XG5cdFx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb2ludHM7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuY3VydmVzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY3VydmUgPSBzb3VyY2UuY3VydmVzW2ldO1xuXHRcdFx0XHR0aGlzLmN1cnZlcy5wdXNoKGN1cnZlLmNsb25lKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmF1dG9DbG9zZSA9IHNvdXJjZS5hdXRvQ2xvc2U7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xuXHRcdFx0ZGF0YS5jdXJ2ZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY3VydmUgPSB0aGlzLmN1cnZlc1tpXTtcblx0XHRcdFx0ZGF0YS5jdXJ2ZXMucHVzaChjdXJ2ZS50b0pTT04oKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdFx0dGhpcy5hdXRvQ2xvc2UgPSBqc29uLmF1dG9DbG9zZTtcblx0XHRcdHRoaXMuY3VydmVzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnZlID0ganNvbi5jdXJ2ZXNbaV07XG5cdFx0XHRcdHRoaXMuY3VydmVzLnB1c2gobmV3IEN1cnZlc1tjdXJ2ZS50eXBlXSgpLmZyb21KU09OKGN1cnZlKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgUGF0aCBleHRlbmRzIEN1cnZlUGF0aCB7XG5cdFx0Y29uc3RydWN0b3IocG9pbnRzKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BhdGgnO1xuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0XHRpZiAocG9pbnRzKSB7XG5cdFx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyhwb2ludHMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHMocG9pbnRzKSB7XG5cdFx0XHR0aGlzLm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dGhpcy5saW5lVG8ocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bW92ZVRvKHgsIHkpIHtcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LnNldCh4LCB5KTsgLy8gVE9ETyBjb25zaWRlciByZWZlcmVuY2luZyB2ZWN0b3JzIGluc3RlYWQgb2YgY29weWluZz9cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bGluZVRvKHgsIHkpIHtcblx0XHRcdGNvbnN0IGN1cnZlID0gbmV3IExpbmVDdXJ2ZSh0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgVmVjdG9yMih4LCB5KSk7XG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LnNldCh4LCB5KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHF1YWRyYXRpY0N1cnZlVG8oYUNQeCwgYUNQeSwgYVgsIGFZKSB7XG5cdFx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSh0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgVmVjdG9yMihhQ1B4LCBhQ1B5KSwgbmV3IFZlY3RvcjIoYVgsIGFZKSk7XG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LnNldChhWCwgYVkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YmV6aWVyQ3VydmVUbyhhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZKSB7XG5cdFx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBDdWJpY0JlemllckN1cnZlKHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksIG5ldyBWZWN0b3IyKGFDUDF4LCBhQ1AxeSksIG5ldyBWZWN0b3IyKGFDUDJ4LCBhQ1AyeSksIG5ldyBWZWN0b3IyKGFYLCBhWSkpO1xuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoYVgsIGFZKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNwbGluZVRocnUocHRzXG5cdFx0LypBcnJheSBvZiBWZWN0b3IqL1xuXHRcdCkge1xuXHRcdFx0Y29uc3QgbnB0cyA9IFt0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpXS5jb25jYXQocHRzKTtcblx0XHRcdGNvbnN0IGN1cnZlID0gbmV3IFNwbGluZUN1cnZlKG5wdHMpO1xuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KHB0c1twdHMubGVuZ3RoIC0gMV0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YXJjKGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSkge1xuXHRcdFx0Y29uc3QgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xuXHRcdFx0Y29uc3QgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xuXHRcdFx0dGhpcy5hYnNhcmMoYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhYnNhcmMoYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlKSB7XG5cdFx0XHR0aGlzLmFic2VsbGlwc2UoYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVsbGlwc2UoYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24pIHtcblx0XHRcdGNvbnN0IHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcblx0XHRcdGNvbnN0IHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcblx0XHRcdHRoaXMuYWJzZWxsaXBzZShhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWJzZWxsaXBzZShhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbikge1xuXHRcdFx0Y29uc3QgY3VydmUgPSBuZXcgRWxsaXBzZUN1cnZlKGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uKTtcblxuXHRcdFx0aWYgKHRoaXMuY3VydmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gaWYgYSBwcmV2aW91cyBjdXJ2ZSBpcyBwcmVzZW50LCBhdHRlbXB0IHRvIGpvaW5cblx0XHRcdFx0Y29uc3QgZmlyc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KDApO1xuXG5cdFx0XHRcdGlmICghZmlyc3RQb2ludC5lcXVhbHModGhpcy5jdXJyZW50UG9pbnQpKSB7XG5cdFx0XHRcdFx0dGhpcy5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0Y29uc3QgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoMSk7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KGxhc3RQb2ludCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weShzb3VyY2UuY3VycmVudFBvaW50KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGRhdGEuY3VycmVudFBvaW50ID0gdGhpcy5jdXJyZW50UG9pbnQudG9BcnJheSgpO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5mcm9tQXJyYXkoanNvbi5jdXJyZW50UG9pbnQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBTaGFwZSBleHRlbmRzIFBhdGgge1xuXHRcdGNvbnN0cnVjdG9yKHBvaW50cykge1xuXHRcdFx0c3VwZXIocG9pbnRzKTtcblx0XHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1NoYXBlJztcblx0XHRcdHRoaXMuaG9sZXMgPSBbXTtcblx0XHR9XG5cblx0XHRnZXRQb2ludHNIb2xlcyhkaXZpc2lvbnMpIHtcblx0XHRcdGNvbnN0IGhvbGVzUHRzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aG9sZXNQdHNbaV0gPSB0aGlzLmhvbGVzW2ldLmdldFBvaW50cyhkaXZpc2lvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaG9sZXNQdHM7XG5cdFx0fSAvLyBnZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcblxuXG5cdFx0ZXh0cmFjdFBvaW50cyhkaXZpc2lvbnMpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHNoYXBlOiB0aGlzLmdldFBvaW50cyhkaXZpc2lvbnMpLFxuXHRcdFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyhkaXZpc2lvbnMpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmhvbGVzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBob2xlID0gc291cmNlLmhvbGVzW2ldO1xuXHRcdFx0XHR0aGlzLmhvbGVzLnB1c2goaG9sZS5jbG9uZSgpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdFx0ZGF0YS5ob2xlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGhvbGUgPSB0aGlzLmhvbGVzW2ldO1xuXHRcdFx0XHRkYXRhLmhvbGVzLnB1c2goaG9sZS50b0pTT04oKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdFx0dGhpcy51dWlkID0ganNvbi51dWlkO1xuXHRcdFx0dGhpcy5ob2xlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24uaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGhvbGUgPSBqc29uLmhvbGVzW2ldO1xuXHRcdFx0XHR0aGlzLmhvbGVzLnB1c2gobmV3IFBhdGgoKS5mcm9tSlNPTihob2xlKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgTGlnaHQgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdFx0Y29uc3RydWN0b3IoY29sb3IsIGludGVuc2l0eSA9IDEpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTGlnaHQnO1xuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcihjb2xvcik7XG5cdFx0XHR0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eTtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkgey8vIEVtcHR5IGhlcmUgaW4gYmFzZSBjbGFzczsgc29tZSBzdWJjbGFzc2VzIG92ZXJyaWRlLlxuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHRcdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTihtZXRhKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdFx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXHRcdFx0ZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cdFx0XHRpZiAodGhpcy5ncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XG5cdFx0XHRpZiAodGhpcy5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG5cdFx0XHRpZiAodGhpcy5hbmdsZSAhPT0gdW5kZWZpbmVkKSBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XG5cdFx0XHRpZiAodGhpcy5kZWNheSAhPT0gdW5kZWZpbmVkKSBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XG5cdFx0XHRpZiAodGhpcy5wZW51bWJyYSAhPT0gdW5kZWZpbmVkKSBkYXRhLm9iamVjdC5wZW51bWJyYSA9IHRoaXMucGVudW1icmE7XG5cdFx0XHRpZiAodGhpcy5zaGFkb3cgIT09IHVuZGVmaW5lZCkgZGF0YS5vYmplY3Quc2hhZG93ID0gdGhpcy5zaGFkb3cudG9KU09OKCk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0fVxuXG5cdExpZ2h0LnByb3RvdHlwZS5pc0xpZ2h0ID0gdHJ1ZTtcblxuXHRjbGFzcyBIZW1pc3BoZXJlTGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cdFx0Y29uc3RydWN0b3Ioc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkpIHtcblx0XHRcdHN1cGVyKHNreUNvbG9yLCBpbnRlbnNpdHkpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XG5cdFx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoT2JqZWN0M0QuRGVmYXVsdFVwKTtcblx0XHRcdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cdFx0XHR0aGlzLmdyb3VuZENvbG9yID0gbmV3IENvbG9yKGdyb3VuZENvbG9yKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXHRcdFx0dGhpcy5ncm91bmRDb2xvci5jb3B5KHNvdXJjZS5ncm91bmRDb2xvcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdEhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuaXNIZW1pc3BoZXJlTGlnaHQgPSB0cnVlO1xuXG5cdGNvbnN0IF9wcm9qU2NyZWVuTWF0cml4JDEgPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfbGlnaHRQb3NpdGlvbldvcmxkJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfbG9va1RhcmdldCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgTGlnaHRTaGFkb3cge1xuXHRcdGNvbnN0cnVjdG9yKGNhbWVyYSkge1xuXHRcdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0XHR0aGlzLmJpYXMgPSAwO1xuXHRcdFx0dGhpcy5ub3JtYWxCaWFzID0gMDtcblx0XHRcdHRoaXMucmFkaXVzID0gMTtcblx0XHRcdHRoaXMubWFwU2l6ZSA9IG5ldyBWZWN0b3IyKDUxMiwgNTEyKTtcblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMubWFwUGFzcyA9IG51bGw7XG5cdFx0XHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCk7XG5cdFx0XHR0aGlzLl9mcmFtZUV4dGVudHMgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHRcdHRoaXMuX3ZpZXdwb3J0Q291bnQgPSAxO1xuXHRcdFx0dGhpcy5fdmlld3BvcnRzID0gW25ldyBWZWN0b3I0KDAsIDAsIDEsIDEpXTtcblx0XHR9XG5cblx0XHRnZXRWaWV3cG9ydENvdW50KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZpZXdwb3J0Q291bnQ7XG5cdFx0fVxuXG5cdFx0Z2V0RnJ1c3R1bSgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9mcnVzdHVtO1xuXHRcdH1cblxuXHRcdHVwZGF0ZU1hdHJpY2VzKGxpZ2h0KSB7XG5cdFx0XHRjb25zdCBzaGFkb3dDYW1lcmEgPSB0aGlzLmNhbWVyYTtcblx0XHRcdGNvbnN0IHNoYWRvd01hdHJpeCA9IHRoaXMubWF0cml4O1xuXG5cdFx0XHRfbGlnaHRQb3NpdGlvbldvcmxkJDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoX2xpZ2h0UG9zaXRpb25Xb3JsZCQxKTtcblxuXHRcdFx0X2xvb2tUYXJnZXQkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0c2hhZG93Q2FtZXJhLmxvb2tBdChfbG9va1RhcmdldCQxKTtcblx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeCQxLm11bHRpcGx5TWF0cmljZXMoc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuXG5cdFx0XHR0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KF9wcm9qU2NyZWVuTWF0cml4JDEpO1xuXG5cdFx0XHRzaGFkb3dNYXRyaXguc2V0KDAuNSwgMC4wLCAwLjAsIDAuNSwgMC4wLCAwLjUsIDAuMCwgMC41LCAwLjAsIDAuMCwgMC41LCAwLjUsIDAuMCwgMC4wLCAwLjAsIDEuMCk7XG5cdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO1xuXHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuXHRcdH1cblxuXHRcdGdldFZpZXdwb3J0KHZpZXdwb3J0SW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLl92aWV3cG9ydHNbdmlld3BvcnRJbmRleF07XG5cdFx0fVxuXG5cdFx0Z2V0RnJhbWVFeHRlbnRzKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2ZyYW1lRXh0ZW50cztcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0aWYgKHRoaXMubWFwKSB7XG5cdFx0XHRcdHRoaXMubWFwLmRpc3Bvc2UoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMubWFwUGFzcykge1xuXHRcdFx0XHR0aGlzLm1hcFBhc3MuZGlzcG9zZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHR0aGlzLmNhbWVyYSA9IHNvdXJjZS5jYW1lcmEuY2xvbmUoKTtcblx0XHRcdHRoaXMuYmlhcyA9IHNvdXJjZS5iaWFzO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBzb3VyY2UucmFkaXVzO1xuXHRcdFx0dGhpcy5tYXBTaXplLmNvcHkoc291cmNlLm1hcFNpemUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IG9iamVjdCA9IHt9O1xuXHRcdFx0aWYgKHRoaXMuYmlhcyAhPT0gMCkgb2JqZWN0LmJpYXMgPSB0aGlzLmJpYXM7XG5cdFx0XHRpZiAodGhpcy5ub3JtYWxCaWFzICE9PSAwKSBvYmplY3Qubm9ybWFsQmlhcyA9IHRoaXMubm9ybWFsQmlhcztcblx0XHRcdGlmICh0aGlzLnJhZGl1cyAhPT0gMSkgb2JqZWN0LnJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXHRcdFx0aWYgKHRoaXMubWFwU2l6ZS54ICE9PSA1MTIgfHwgdGhpcy5tYXBTaXplLnkgIT09IDUxMikgb2JqZWN0Lm1hcFNpemUgPSB0aGlzLm1hcFNpemUudG9BcnJheSgpO1xuXHRcdFx0b2JqZWN0LmNhbWVyYSA9IHRoaXMuY2FtZXJhLnRvSlNPTihmYWxzZSkub2JqZWN0O1xuXHRcdFx0ZGVsZXRlIG9iamVjdC5jYW1lcmEubWF0cml4O1xuXHRcdFx0cmV0dXJuIG9iamVjdDtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFNwb3RMaWdodFNoYWRvdyBleHRlbmRzIExpZ2h0U2hhZG93IHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSg1MCwgMSwgMC41LCA1MDApKTtcblx0XHRcdHRoaXMuZm9jdXMgPSAxO1xuXHRcdH1cblxuXHRcdHVwZGF0ZU1hdHJpY2VzKGxpZ2h0KSB7XG5cdFx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcblx0XHRcdGNvbnN0IGZvdiA9IFJBRDJERUcgKiAyICogbGlnaHQuYW5nbGUgKiB0aGlzLmZvY3VzO1xuXHRcdFx0Y29uc3QgYXNwZWN0ID0gdGhpcy5tYXBTaXplLndpZHRoIC8gdGhpcy5tYXBTaXplLmhlaWdodDtcblx0XHRcdGNvbnN0IGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IGNhbWVyYS5mYXI7XG5cblx0XHRcdGlmIChmb3YgIT09IGNhbWVyYS5mb3YgfHwgYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0IHx8IGZhciAhPT0gY2FtZXJhLmZhcikge1xuXHRcdFx0XHRjYW1lcmEuZm92ID0gZm92O1xuXHRcdFx0XHRjYW1lcmEuYXNwZWN0ID0gYXNwZWN0O1xuXHRcdFx0XHRjYW1lcmEuZmFyID0gZmFyO1xuXHRcdFx0XHRjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdXBlci51cGRhdGVNYXRyaWNlcyhsaWdodCk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFNwb3RMaWdodFNoYWRvdy5wcm90b3R5cGUuaXNTcG90TGlnaHRTaGFkb3cgPSB0cnVlO1xuXG5cdGNsYXNzIFNwb3RMaWdodCBleHRlbmRzIExpZ2h0IHtcblx0XHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSA9IDAsIGFuZ2xlID0gTWF0aC5QSSAvIDMsIHBlbnVtYnJhID0gMCwgZGVjYXkgPSAxKSB7XG5cdFx0XHRzdXBlcihjb2xvciwgaW50ZW5zaXR5KTtcblx0XHRcdHRoaXMudHlwZSA9ICdTcG90TGlnaHQnO1xuXHRcdFx0dGhpcy5wb3NpdGlvbi5jb3B5KE9iamVjdDNELkRlZmF1bHRVcCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblx0XHRcdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHRcdHRoaXMuYW5nbGUgPSBhbmdsZTtcblx0XHRcdHRoaXMucGVudW1icmEgPSBwZW51bWJyYTtcblx0XHRcdHRoaXMuZGVjYXkgPSBkZWNheTsgLy8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG5cdFx0XHR0aGlzLnNoYWRvdyA9IG5ldyBTcG90TGlnaHRTaGFkb3coKTtcblx0XHR9XG5cblx0XHRnZXQgcG93ZXIoKSB7XG5cdFx0XHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXG5cdFx0XHQvLyByZWY6IGVxdWF0aW9uICgxNykgZnJvbSBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiBNYXRoLlBJO1xuXHRcdH1cblxuXHRcdHNldCBwb3dlcihwb3dlcikge1xuXHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxuXHRcdFx0Ly8gcmVmOiBlcXVhdGlvbiAoMTcpIGZyb20gaHR0cHM6Ly9zZWJsYWdhcmRlLmZpbGVzLndvcmRwcmVzcy5jb20vMjAxNS8wNy9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnJfdjMyLnBkZlxuXHRcdFx0dGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvIE1hdGguUEk7XG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblx0XHRcdHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcblx0XHRcdHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XG5cdFx0XHR0aGlzLnBlbnVtYnJhID0gc291cmNlLnBlbnVtYnJhO1xuXHRcdFx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblx0XHRcdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xuXHRcdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFNwb3RMaWdodC5wcm90b3R5cGUuaXNTcG90TGlnaHQgPSB0cnVlO1xuXG5cdGNvbnN0IF9wcm9qU2NyZWVuTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX2xpZ2h0UG9zaXRpb25Xb3JsZCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9sb29rVGFyZ2V0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgUG9pbnRMaWdodFNoYWRvdyBleHRlbmRzIExpZ2h0U2hhZG93IHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSg5MCwgMSwgMC41LCA1MDApKTtcblx0XHRcdHRoaXMuX2ZyYW1lRXh0ZW50cyA9IG5ldyBWZWN0b3IyKDQsIDIpO1xuXHRcdFx0dGhpcy5fdmlld3BvcnRDb3VudCA9IDY7XG5cdFx0XHR0aGlzLl92aWV3cG9ydHMgPSBbLy8gVGhlc2Ugdmlld3BvcnRzIG1hcCBhIGN1YmUtbWFwIG9udG8gYSAyRCB0ZXh0dXJlIHdpdGggdGhlXG5cdFx0XHQvLyBmb2xsb3dpbmcgb3JpZW50YXRpb246XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdHh6WFpcblx0XHRcdC8vXHQgeSBZXG5cdFx0XHQvL1xuXHRcdFx0Ly8gWCAtIFBvc2l0aXZlIHggZGlyZWN0aW9uXG5cdFx0XHQvLyB4IC0gTmVnYXRpdmUgeCBkaXJlY3Rpb25cblx0XHRcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxuXHRcdFx0Ly8geSAtIE5lZ2F0aXZlIHkgZGlyZWN0aW9uXG5cdFx0XHQvLyBaIC0gUG9zaXRpdmUgeiBkaXJlY3Rpb25cblx0XHRcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxuXHRcdFx0Ly8gcG9zaXRpdmUgWFxuXHRcdFx0bmV3IFZlY3RvcjQoMiwgMSwgMSwgMSksIC8vIG5lZ2F0aXZlIFhcblx0XHRcdG5ldyBWZWN0b3I0KDAsIDEsIDEsIDEpLCAvLyBwb3NpdGl2ZSBaXG5cdFx0XHRuZXcgVmVjdG9yNCgzLCAxLCAxLCAxKSwgLy8gbmVnYXRpdmUgWlxuXHRcdFx0bmV3IFZlY3RvcjQoMSwgMSwgMSwgMSksIC8vIHBvc2l0aXZlIFlcblx0XHRcdG5ldyBWZWN0b3I0KDMsIDAsIDEsIDEpLCAvLyBuZWdhdGl2ZSBZXG5cdFx0XHRuZXcgVmVjdG9yNCgxLCAwLCAxLCAxKV07XG5cdFx0XHR0aGlzLl9jdWJlRGlyZWN0aW9ucyA9IFtuZXcgVmVjdG9yMygxLCAwLCAwKSwgbmV3IFZlY3RvcjMoLTEsIDAsIDApLCBuZXcgVmVjdG9yMygwLCAwLCAxKSwgbmV3IFZlY3RvcjMoMCwgMCwgLTEpLCBuZXcgVmVjdG9yMygwLCAxLCAwKSwgbmV3IFZlY3RvcjMoMCwgLTEsIDApXTtcblx0XHRcdHRoaXMuX2N1YmVVcHMgPSBbbmV3IFZlY3RvcjMoMCwgMSwgMCksIG5ldyBWZWN0b3IzKDAsIDEsIDApLCBuZXcgVmVjdG9yMygwLCAxLCAwKSwgbmV3IFZlY3RvcjMoMCwgMSwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBuZXcgVmVjdG9yMygwLCAwLCAtMSldO1xuXHRcdH1cblxuXHRcdHVwZGF0ZU1hdHJpY2VzKGxpZ2h0LCB2aWV3cG9ydEluZGV4ID0gMCkge1xuXHRcdFx0Y29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXRyaXggPSB0aGlzLm1hdHJpeDtcblx0XHRcdGNvbnN0IGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IGNhbWVyYS5mYXI7XG5cblx0XHRcdGlmIChmYXIgIT09IGNhbWVyYS5mYXIpIHtcblx0XHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcblx0XHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdH1cblxuXHRcdFx0X2xpZ2h0UG9zaXRpb25Xb3JsZC5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXG5cdFx0XHRjYW1lcmEucG9zaXRpb24uY29weShfbGlnaHRQb3NpdGlvbldvcmxkKTtcblxuXHRcdFx0X2xvb2tUYXJnZXQuY29weShjYW1lcmEucG9zaXRpb24pO1xuXG5cdFx0XHRfbG9va1RhcmdldC5hZGQodGhpcy5fY3ViZURpcmVjdGlvbnNbdmlld3BvcnRJbmRleF0pO1xuXG5cdFx0XHRjYW1lcmEudXAuY29weSh0aGlzLl9jdWJlVXBzW3ZpZXdwb3J0SW5kZXhdKTtcblx0XHRcdGNhbWVyYS5sb29rQXQoX2xvb2tUYXJnZXQpO1xuXHRcdFx0Y2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0XHRzaGFkb3dNYXRyaXgubWFrZVRyYW5zbGF0aW9uKC1fbGlnaHRQb3NpdGlvbldvcmxkLngsIC1fbGlnaHRQb3NpdGlvbldvcmxkLnksIC1fbGlnaHRQb3NpdGlvbldvcmxkLnopO1xuXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlKTtcblxuXHRcdFx0dGhpcy5fZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChfcHJvalNjcmVlbk1hdHJpeCk7XG5cdFx0fVxuXG5cdH1cblxuXHRQb2ludExpZ2h0U2hhZG93LnByb3RvdHlwZS5pc1BvaW50TGlnaHRTaGFkb3cgPSB0cnVlO1xuXG5cdGNsYXNzIFBvaW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cdFx0Y29uc3RydWN0b3IoY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UgPSAwLCBkZWNheSA9IDEpIHtcblx0XHRcdHN1cGVyKGNvbG9yLCBpbnRlbnNpdHkpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BvaW50TGlnaHQnO1xuXHRcdFx0dGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdFx0dGhpcy5kZWNheSA9IGRlY2F5OyAvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXG5cblx0XHRcdHRoaXMuc2hhZG93ID0gbmV3IFBvaW50TGlnaHRTaGFkb3coKTtcblx0XHR9XG5cblx0XHRnZXQgcG93ZXIoKSB7XG5cdFx0XHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXG5cdFx0XHQvLyByZWY6IGVxdWF0aW9uICgxNSkgZnJvbSBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiA0ICogTWF0aC5QSTtcblx0XHR9XG5cblx0XHRzZXQgcG93ZXIocG93ZXIpIHtcblx0XHRcdC8vIGludGVuc2l0eSA9IHBvd2VyIHBlciBzb2xpZCBhbmdsZS5cblx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE1KSBmcm9tIGh0dHBzOi8vc2VibGFnYXJkZS5maWxlcy53b3JkcHJlc3MuY29tLzIwMTUvMDcvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyX3YzMi5wZGZcblx0XHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoNCAqIE1hdGguUEkpO1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLnNoYWRvdy5kaXNwb3NlKCk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdFx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXHRcdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFBvaW50TGlnaHQucHJvdG90eXBlLmlzUG9pbnRMaWdodCA9IHRydWU7XG5cblx0Y2xhc3MgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBleHRlbmRzIExpZ2h0U2hhZG93IHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLTUsIDUsIDUsIC01LCAwLjUsIDUwMCkpO1xuXHRcdH1cblxuXHR9XG5cblx0RGlyZWN0aW9uYWxMaWdodFNoYWRvdy5wcm90b3R5cGUuaXNEaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gdHJ1ZTtcblxuXHRjbGFzcyBEaXJlY3Rpb25hbExpZ2h0IGV4dGVuZHMgTGlnaHQge1xuXHRcdGNvbnN0cnVjdG9yKGNvbG9yLCBpbnRlbnNpdHkpIHtcblx0XHRcdHN1cGVyKGNvbG9yLCBpbnRlbnNpdHkpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXHRcdFx0dGhpcy5wb3NpdGlvbi5jb3B5KE9iamVjdDNELkRlZmF1bHRVcCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblx0XHRcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5zaGFkb3cuZGlzcG9zZSgpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblx0XHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHREaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5pc0RpcmVjdGlvbmFsTGlnaHQgPSB0cnVlO1xuXG5cdGNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblx0XHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5KSB7XG5cdFx0XHRzdXBlcihjb2xvciwgaW50ZW5zaXR5KTtcblx0XHRcdHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xuXHRcdH1cblxuXHR9XG5cblx0QW1iaWVudExpZ2h0LnByb3RvdHlwZS5pc0FtYmllbnRMaWdodCA9IHRydWU7XG5cblx0Y2xhc3MgUmVjdEFyZWFMaWdodCBleHRlbmRzIExpZ2h0IHtcblx0XHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5LCB3aWR0aCA9IDEwLCBoZWlnaHQgPSAxMCkge1xuXHRcdFx0c3VwZXIoY29sb3IsIGludGVuc2l0eSk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnUmVjdEFyZWFMaWdodCc7XG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTihtZXRhKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdFx0ZGF0YS5vYmplY3Qud2lkdGggPSB0aGlzLndpZHRoO1xuXHRcdFx0ZGF0YS5vYmplY3QuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0fVxuXG5cdFJlY3RBcmVhTGlnaHQucHJvdG90eXBlLmlzUmVjdEFyZWFMaWdodCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIFByaW1hcnkgcmVmZXJlbmNlOlxuXHQgKlx0IGh0dHBzOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L3BhcGVycy9lbnZtYXAvZW52bWFwLnBkZlxuXHQgKlxuXHQgKiBTZWNvbmRhcnkgcmVmZXJlbmNlOlxuXHQgKlx0IGh0dHBzOi8vd3d3LnBwc2xvYW4ub3JnL3B1YmxpY2F0aW9ucy9TdHVwaWRTSDM2LnBkZlxuXHQgKi9cblx0Ly8gMy1iYW5kIFNIIGRlZmluZWQgYnkgOSBjb2VmZmljaWVudHNcblxuXHRjbGFzcyBTcGhlcmljYWxIYXJtb25pY3MzIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMuY29lZmZpY2llbnRzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuY29lZmZpY2llbnRzLnB1c2gobmV3IFZlY3RvcjMoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2V0KGNvZWZmaWNpZW50cykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0dGhpcy5jb2VmZmljaWVudHNbaV0uY29weShjb2VmZmljaWVudHNbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR6ZXJvKCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0dGhpcy5jb2VmZmljaWVudHNbaV0uc2V0KDAsIDAsIDApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IC8vIGdldCB0aGUgcmFkaWFuY2UgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbm9ybWFsXG5cdFx0Ly8gdGFyZ2V0IGlzIGEgVmVjdG9yM1xuXG5cblx0XHRnZXRBdChub3JtYWwsIHRhcmdldCkge1xuXHRcdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGhcblx0XHRcdGNvbnN0IHggPSBub3JtYWwueCxcblx0XHRcdFx0XHRcdHkgPSBub3JtYWwueSxcblx0XHRcdFx0XHRcdHogPSBub3JtYWwuejtcblx0XHRcdGNvbnN0IGNvZWZmID0gdGhpcy5jb2VmZmljaWVudHM7IC8vIGJhbmQgMFxuXG5cdFx0XHR0YXJnZXQuY29weShjb2VmZlswXSkubXVsdGlwbHlTY2FsYXIoMC4yODIwOTUpOyAvLyBiYW5kIDFcblxuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlsxXSwgMC40ODg2MDMgKiB5KTtcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbMl0sIDAuNDg4NjAzICogeik7XG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzNdLCAwLjQ4ODYwMyAqIHgpOyAvLyBiYW5kIDJcblxuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls0XSwgMS4wOTI1NDggKiAoeCAqIHkpKTtcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbNV0sIDEuMDkyNTQ4ICogKHkgKiB6KSk7XG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzZdLCAwLjMxNTM5MiAqICgzLjAgKiB6ICogeiAtIDEuMCkpO1xuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls3XSwgMS4wOTI1NDggKiAoeCAqIHopKTtcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbOF0sIDAuNTQ2Mjc0ICogKHggKiB4IC0geSAqIHkpKTtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fSAvLyBnZXQgdGhlIGlycmFkaWFuY2UgKHJhZGlhbmNlIGNvbnZvbHZlZCB3aXRoIGNvc2luZSBsb2JlKSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBub3JtYWxcblx0XHQvLyB0YXJnZXQgaXMgYSBWZWN0b3IzXG5cdFx0Ly8gaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvcGFwZXJzL2Vudm1hcC9lbnZtYXAucGRmXG5cblxuXHRcdGdldElycmFkaWFuY2VBdChub3JtYWwsIHRhcmdldCkge1xuXHRcdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGhcblx0XHRcdGNvbnN0IHggPSBub3JtYWwueCxcblx0XHRcdFx0XHRcdHkgPSBub3JtYWwueSxcblx0XHRcdFx0XHRcdHogPSBub3JtYWwuejtcblx0XHRcdGNvbnN0IGNvZWZmID0gdGhpcy5jb2VmZmljaWVudHM7IC8vIGJhbmQgMFxuXG5cdFx0XHR0YXJnZXQuY29weShjb2VmZlswXSkubXVsdGlwbHlTY2FsYXIoMC44ODYyMjcpOyAvLyDPgCAqIDAuMjgyMDk1XG5cdFx0XHQvLyBiYW5kIDFcblxuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlsxXSwgMi4wICogMC41MTE2NjQgKiB5KTsgLy8gKCAyICogz4AgLyAzICkgKiAwLjQ4ODYwM1xuXG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzJdLCAyLjAgKiAwLjUxMTY2NCAqIHopO1xuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlszXSwgMi4wICogMC41MTE2NjQgKiB4KTsgLy8gYmFuZCAyXG5cblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbNF0sIDIuMCAqIDAuNDI5MDQzICogeCAqIHkpOyAvLyAoIM+AIC8gNCApICogMS4wOTI1NDhcblxuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls1XSwgMi4wICogMC40MjkwNDMgKiB5ICogeik7XG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzZdLCAwLjc0MzEyNSAqIHogKiB6IC0gMC4yNDc3MDgpOyAvLyAoIM+AIC8gNCApICogMC4zMTUzOTIgKiAzXG5cblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbN10sIDIuMCAqIDAuNDI5MDQzICogeCAqIHopO1xuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls4XSwgMC40MjkwNDMgKiAoeCAqIHggLSB5ICogeSkpOyAvLyAoIM+AIC8gNCApICogMC41NDYyNzRcblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRhZGQoc2gpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuY29lZmZpY2llbnRzW2ldLmFkZChzaC5jb2VmZmljaWVudHNbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRTY2FsZWRTSChzaCwgcykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0dGhpcy5jb2VmZmljaWVudHNbaV0uYWRkU2NhbGVkVmVjdG9yKHNoLmNvZWZmaWNpZW50c1tpXSwgcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNjYWxlKHMpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuY29lZmZpY2llbnRzW2ldLm11bHRpcGx5U2NhbGFyKHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRsZXJwKHNoLCBhbHBoYSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0dGhpcy5jb2VmZmljaWVudHNbaV0ubGVycChzaC5jb2VmZmljaWVudHNbaV0sIGFscGhhKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXF1YWxzKHNoKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHRpZiAoIXRoaXMuY29lZmZpY2llbnRzW2ldLmVxdWFscyhzaC5jb2VmZmljaWVudHNbaV0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGNvcHkoc2gpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldChzaC5jb2VmZmljaWVudHMpO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHRmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcblx0XHRcdGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHRjb2VmZmljaWVudHNbaV0uZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgKyBpICogMyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0Y29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdGNvZWZmaWNpZW50c1tpXS50b0FycmF5KGFycmF5LCBvZmZzZXQgKyBpICogMyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheTtcblx0XHR9IC8vIGV2YWx1YXRlIHRoZSBiYXNpcyBmdW5jdGlvbnNcblx0XHQvLyBzaEJhc2lzIGlzIGFuIEFycmF5WyA5IF1cblxuXG5cdFx0c3RhdGljIGdldEJhc2lzQXQobm9ybWFsLCBzaEJhc2lzKSB7XG5cdFx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxuXHRcdFx0Y29uc3QgeCA9IG5vcm1hbC54LFxuXHRcdFx0XHRcdFx0eSA9IG5vcm1hbC55LFxuXHRcdFx0XHRcdFx0eiA9IG5vcm1hbC56OyAvLyBiYW5kIDBcblxuXHRcdFx0c2hCYXNpc1swXSA9IDAuMjgyMDk1OyAvLyBiYW5kIDFcblxuXHRcdFx0c2hCYXNpc1sxXSA9IDAuNDg4NjAzICogeTtcblx0XHRcdHNoQmFzaXNbMl0gPSAwLjQ4ODYwMyAqIHo7XG5cdFx0XHRzaEJhc2lzWzNdID0gMC40ODg2MDMgKiB4OyAvLyBiYW5kIDJcblxuXHRcdFx0c2hCYXNpc1s0XSA9IDEuMDkyNTQ4ICogeCAqIHk7XG5cdFx0XHRzaEJhc2lzWzVdID0gMS4wOTI1NDggKiB5ICogejtcblx0XHRcdHNoQmFzaXNbNl0gPSAwLjMxNTM5MiAqICgzICogeiAqIHogLSAxKTtcblx0XHRcdHNoQmFzaXNbN10gPSAxLjA5MjU0OCAqIHggKiB6O1xuXHRcdFx0c2hCYXNpc1s4XSA9IDAuNTQ2Mjc0ICogKHggKiB4IC0geSAqIHkpO1xuXHRcdH1cblxuXHR9XG5cblx0U3BoZXJpY2FsSGFybW9uaWNzMy5wcm90b3R5cGUuaXNTcGhlcmljYWxIYXJtb25pY3MzID0gdHJ1ZTtcblxuXHRjbGFzcyBMaWdodFByb2JlIGV4dGVuZHMgTGlnaHQge1xuXHRcdGNvbnN0cnVjdG9yKHNoID0gbmV3IFNwaGVyaWNhbEhhcm1vbmljczMoKSwgaW50ZW5zaXR5ID0gMSkge1xuXHRcdFx0c3VwZXIodW5kZWZpbmVkLCBpbnRlbnNpdHkpO1xuXHRcdFx0dGhpcy5zaCA9IHNoO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnNoLmNvcHkoc291cmNlLnNoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHRoaXMuaW50ZW5zaXR5ID0ganNvbi5pbnRlbnNpdHk7IC8vIFRPRE86IE1vdmUgdGhpcyBiaXQgdG8gTGlnaHQuZnJvbUpTT04oKTtcblxuXHRcdFx0dGhpcy5zaC5mcm9tQXJyYXkoanNvbi5zaCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04obWV0YSkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTihtZXRhKTtcblx0XHRcdGRhdGEub2JqZWN0LnNoID0gdGhpcy5zaC50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0fVxuXG5cdExpZ2h0UHJvYmUucHJvdG90eXBlLmlzTGlnaHRQcm9iZSA9IHRydWU7XG5cblx0Y2xhc3MgTWF0ZXJpYWxMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRcdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRcdHN1cGVyKG1hbmFnZXIpO1xuXHRcdFx0dGhpcy50ZXh0dXJlcyA9IHt9O1xuXHRcdH1cblxuXHRcdGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHNjb3BlLm1hbmFnZXIpO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgoc2NvcGUucGF0aCk7XG5cdFx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcihzY29wZS5yZXF1ZXN0SGVhZGVyKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoc2NvcGUud2l0aENyZWRlbnRpYWxzKTtcblx0XHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKHRleHQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRvbkxvYWQoc2NvcGUucGFyc2UoSlNPTi5wYXJzZSh0ZXh0KSkpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0aWYgKG9uRXJyb3IpIHtcblx0XHRcdFx0XHRcdG9uRXJyb3IoZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdFx0fVxuXG5cdFx0cGFyc2UoanNvbikge1xuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xuXG5cdFx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlKG5hbWUpIHtcblx0XHRcdFx0aWYgKHRleHR1cmVzW25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRleHR1cmVzW25hbWVdO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBNYXRlcmlhbHNbanNvbi50eXBlXSgpO1xuXHRcdFx0aWYgKGpzb24udXVpZCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xuXHRcdFx0aWYgKGpzb24ubmFtZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5uYW1lID0ganNvbi5uYW1lO1xuXHRcdFx0aWYgKGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5jb2xvciAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoanNvbi5jb2xvcik7XG5cdFx0XHRpZiAoanNvbi5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwucm91Z2huZXNzID0ganNvbi5yb3VnaG5lc3M7XG5cdFx0XHRpZiAoanNvbi5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubWV0YWxuZXNzID0ganNvbi5tZXRhbG5lc3M7XG5cdFx0XHRpZiAoanNvbi5zaGVlbiAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaGVlbiA9IG5ldyBDb2xvcigpLnNldEhleChqc29uLnNoZWVuKTtcblx0XHRcdGlmIChqc29uLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuZW1pc3NpdmUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KGpzb24uZW1pc3NpdmUpO1xuXHRcdFx0aWYgKGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5zcGVjdWxhciAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoanNvbi5zcGVjdWxhcik7XG5cdFx0XHRpZiAoanNvbi5zcGVjdWxhckludGVuc2l0eSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eSA9IGpzb24uc3BlY3VsYXJJbnRlbnNpdHk7XG5cdFx0XHRpZiAoanNvbi5zcGVjdWxhclRpbnQgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5zcGVjdWxhclRpbnQgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXJUaW50LnNldEhleChqc29uLnNwZWN1bGFyVGludCk7XG5cdFx0XHRpZiAoanNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XG5cdFx0XHRpZiAoanNvbi5jbGVhcmNvYXQgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY2xlYXJjb2F0ID0ganNvbi5jbGVhcmNvYXQ7XG5cdFx0XHRpZiAoanNvbi5jbGVhcmNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0ganNvbi5jbGVhcmNvYXRSb3VnaG5lc3M7XG5cdFx0XHRpZiAoanNvbi50cmFuc21pc3Npb24gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudHJhbnNtaXNzaW9uID0ganNvbi50cmFuc21pc3Npb247XG5cdFx0XHRpZiAoanNvbi50aGlja25lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudGhpY2tuZXNzID0ganNvbi50aGlja25lc3M7XG5cdFx0XHRpZiAoanNvbi5hdHRlbnVhdGlvbkRpc3RhbmNlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBqc29uLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0XHRpZiAoanNvbi5hdHRlbnVhdGlvblRpbnQgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5hdHRlbnVhdGlvblRpbnQgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYXR0ZW51YXRpb25UaW50LnNldEhleChqc29uLmF0dGVudWF0aW9uVGludCk7XG5cdFx0XHRpZiAoanNvbi5mb2cgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZm9nID0ganNvbi5mb2c7XG5cdFx0XHRpZiAoanNvbi5mbGF0U2hhZGluZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uZmxhdFNoYWRpbmc7XG5cdFx0XHRpZiAoanNvbi5ibGVuZGluZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG5cdFx0XHRpZiAoanNvbi5jb21iaW5lICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNvbWJpbmUgPSBqc29uLmNvbWJpbmU7XG5cdFx0XHRpZiAoanNvbi5zaWRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XG5cdFx0XHRpZiAoanNvbi5zaGFkb3dTaWRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNoYWRvd1NpZGUgPSBqc29uLnNoYWRvd1NpZGU7XG5cdFx0XHRpZiAoanNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG5cdFx0XHRpZiAoanNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG5cdFx0XHRpZiAoanNvbi5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYWxwaGFUZXN0ID0ganNvbi5hbHBoYVRlc3Q7XG5cdFx0XHRpZiAoanNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0ganNvbi5kZXB0aFRlc3Q7XG5cdFx0XHRpZiAoanNvbi5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XG5cdFx0XHRpZiAoanNvbi5jb2xvcldyaXRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNvbG9yV3JpdGUgPSBqc29uLmNvbG9yV3JpdGU7XG5cdFx0XHRpZiAoanNvbi5zdGVuY2lsV3JpdGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbFdyaXRlID0ganNvbi5zdGVuY2lsV3JpdGU7XG5cdFx0XHRpZiAoanNvbi5zdGVuY2lsV3JpdGVNYXNrICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2sgPSBqc29uLnN0ZW5jaWxXcml0ZU1hc2s7XG5cdFx0XHRpZiAoanNvbi5zdGVuY2lsRnVuYyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zdGVuY2lsRnVuYyA9IGpzb24uc3RlbmNpbEZ1bmM7XG5cdFx0XHRpZiAoanNvbi5zdGVuY2lsUmVmICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnN0ZW5jaWxSZWYgPSBqc29uLnN0ZW5jaWxSZWY7XG5cdFx0XHRpZiAoanNvbi5zdGVuY2lsRnVuY01hc2sgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrID0ganNvbi5zdGVuY2lsRnVuY01hc2s7XG5cdFx0XHRpZiAoanNvbi5zdGVuY2lsRmFpbCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zdGVuY2lsRmFpbCA9IGpzb24uc3RlbmNpbEZhaWw7XG5cdFx0XHRpZiAoanNvbi5zdGVuY2lsWkZhaWwgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbFpGYWlsID0ganNvbi5zdGVuY2lsWkZhaWw7XG5cdFx0XHRpZiAoanNvbi5zdGVuY2lsWlBhc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbFpQYXNzID0ganNvbi5zdGVuY2lsWlBhc3M7XG5cdFx0XHRpZiAoanNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG5cdFx0XHRpZiAoanNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHRpZiAoanNvbi53aXJlZnJhbWVMaW5lY2FwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSBqc29uLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0XHRpZiAoanNvbi53aXJlZnJhbWVMaW5lam9pbiAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IGpzb24ud2lyZWZyYW1lTGluZWpvaW47XG5cdFx0XHRpZiAoanNvbi5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5yb3RhdGlvbiA9IGpzb24ucm90YXRpb247XG5cdFx0XHRpZiAoanNvbi5saW5ld2lkdGggIT09IDEpIG1hdGVyaWFsLmxpbmV3aWR0aCA9IGpzb24ubGluZXdpZHRoO1xuXHRcdFx0aWYgKGpzb24uZGFzaFNpemUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZGFzaFNpemUgPSBqc29uLmRhc2hTaXplO1xuXHRcdFx0aWYgKGpzb24uZ2FwU2l6ZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5nYXBTaXplID0ganNvbi5nYXBTaXplO1xuXHRcdFx0aWYgKGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2NhbGUgPSBqc29uLnNjYWxlO1xuXHRcdFx0aWYgKGpzb24ucG9seWdvbk9mZnNldCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0ganNvbi5wb2x5Z29uT2Zmc2V0O1xuXHRcdFx0aWYgKGpzb24ucG9seWdvbk9mZnNldEZhY3RvciAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yID0ganNvbi5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuXHRcdFx0aWYgKGpzb24ucG9seWdvbk9mZnNldFVuaXRzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyA9IGpzb24ucG9seWdvbk9mZnNldFVuaXRzO1xuXHRcdFx0aWYgKGpzb24uZGl0aGVyaW5nICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRpdGhlcmluZyA9IGpzb24uZGl0aGVyaW5nO1xuXHRcdFx0aWYgKGpzb24uYWxwaGFUb0NvdmVyYWdlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmFscGhhVG9Db3ZlcmFnZSA9IGpzb24uYWxwaGFUb0NvdmVyYWdlO1xuXHRcdFx0aWYgKGpzb24ucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSA9IGpzb24ucHJlbXVsdGlwbGllZEFscGhhO1xuXHRcdFx0aWYgKGpzb24udmlzaWJsZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC52aXNpYmxlID0ganNvbi52aXNpYmxlO1xuXHRcdFx0aWYgKGpzb24udG9uZU1hcHBlZCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50b25lTWFwcGVkID0ganNvbi50b25lTWFwcGVkO1xuXHRcdFx0aWYgKGpzb24udXNlckRhdGEgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xuXG5cdFx0XHRpZiAoanNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGpzb24udmVydGV4Q29sb3JzID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzID4gMCA/IHRydWUgOiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBTaGFkZXIgTWF0ZXJpYWxcblxuXG5cdFx0XHRpZiAoanNvbi51bmlmb3JtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBqc29uLnVuaWZvcm1zKSB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybSA9IGpzb24udW5pZm9ybXNbbmFtZV07XG5cdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0gPSB7fTtcblxuXHRcdFx0XHRcdHN3aXRjaCAodW5pZm9ybS50eXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSBnZXRUZXh0dXJlKHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gbmV3IENvbG9yKCkuc2V0SGV4KHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndjInOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndjMnOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndjQnOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IG5ldyBWZWN0b3I0KCkuZnJvbUFycmF5KHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbTMnOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IG5ldyBNYXRyaXgzKCkuZnJvbUFycmF5KHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbTQnOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KHVuaWZvcm0udmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoanNvbi5kZWZpbmVzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRlZmluZXMgPSBqc29uLmRlZmluZXM7XG5cdFx0XHRpZiAoanNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0ganNvbi52ZXJ0ZXhTaGFkZXI7XG5cdFx0XHRpZiAoanNvbi5mcmFnbWVudFNoYWRlciAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XG5cblx0XHRcdGlmIChqc29uLmV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBqc29uLmV4dGVuc2lvbnMpIHtcblx0XHRcdFx0XHRtYXRlcmlhbC5leHRlbnNpb25zW2tleV0gPSBqc29uLmV4dGVuc2lvbnNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBEZXByZWNhdGVkXG5cblxuXHRcdFx0aWYgKGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uc2hhZGluZyA9PT0gMTsgLy8gVEhSRUUuRmxhdFNoYWRpbmdcblx0XHRcdC8vIGZvciBQb2ludHNNYXRlcmlhbFxuXG5cdFx0XHRpZiAoanNvbi5zaXplICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XG5cdFx0XHRpZiAoanNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0ganNvbi5zaXplQXR0ZW51YXRpb247IC8vIG1hcHNcblxuXHRcdFx0aWYgKGpzb24ubWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoanNvbi5tYXApO1xuXHRcdFx0aWYgKGpzb24ubWF0Y2FwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm1hdGNhcCA9IGdldFRleHR1cmUoanNvbi5tYXRjYXApO1xuXHRcdFx0aWYgKGpzb24uYWxwaGFNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYWxwaGFNYXAgPSBnZXRUZXh0dXJlKGpzb24uYWxwaGFNYXApO1xuXHRcdFx0aWYgKGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5idW1wTWFwID0gZ2V0VGV4dHVyZShqc29uLmJ1bXBNYXApO1xuXHRcdFx0aWYgKGpzb24uYnVtcFNjYWxlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGpzb24uYnVtcFNjYWxlO1xuXHRcdFx0aWYgKGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm5vcm1hbE1hcCA9IGdldFRleHR1cmUoanNvbi5ub3JtYWxNYXApO1xuXHRcdFx0aWYgKGpzb24ubm9ybWFsTWFwVHlwZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID0ganNvbi5ub3JtYWxNYXBUeXBlO1xuXG5cdFx0XHRpZiAoanNvbi5ub3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGxldCBub3JtYWxTY2FsZSA9IGpzb24ubm9ybWFsU2NhbGU7XG5cblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobm9ybWFsU2NhbGUpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdC8vIEJsZW5kZXIgZXhwb3J0ZXIgdXNlZCB0byBleHBvcnQgYSBzY2FsYXIuIFNlZSAjNzQ1OVxuXHRcdFx0XHRcdG5vcm1hbFNjYWxlID0gW25vcm1hbFNjYWxlLCBub3JtYWxTY2FsZV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KG5vcm1hbFNjYWxlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IGdldFRleHR1cmUoanNvbi5kaXNwbGFjZW1lbnRNYXApO1xuXHRcdFx0aWYgKGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0aWYgKGpzb24uZGlzcGxhY2VtZW50QmlhcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0ganNvbi5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0aWYgKGpzb24ucm91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoanNvbi5yb3VnaG5lc3NNYXApO1xuXHRcdFx0aWYgKGpzb24ubWV0YWxuZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm1ldGFsbmVzc01hcCA9IGdldFRleHR1cmUoanNvbi5tZXRhbG5lc3NNYXApO1xuXHRcdFx0aWYgKGpzb24uZW1pc3NpdmVNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBnZXRUZXh0dXJlKGpzb24uZW1pc3NpdmVNYXApO1xuXHRcdFx0aWYgKGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgPSBqc29uLmVtaXNzaXZlSW50ZW5zaXR5O1xuXHRcdFx0aWYgKGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBnZXRUZXh0dXJlKGpzb24uc3BlY3VsYXJNYXApO1xuXHRcdFx0aWYgKGpzb24uc3BlY3VsYXJJbnRlbnNpdHlNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSBnZXRUZXh0dXJlKGpzb24uc3BlY3VsYXJJbnRlbnNpdHlNYXApO1xuXHRcdFx0aWYgKGpzb24uc3BlY3VsYXJUaW50TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNwZWN1bGFyVGludE1hcCA9IGdldFRleHR1cmUoanNvbi5zcGVjdWxhclRpbnRNYXApO1xuXHRcdFx0aWYgKGpzb24uZW52TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmVudk1hcCA9IGdldFRleHR1cmUoanNvbi5lbnZNYXApO1xuXHRcdFx0aWYgKGpzb24uZW52TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmVudk1hcEludGVuc2l0eSA9IGpzb24uZW52TWFwSW50ZW5zaXR5O1xuXHRcdFx0aWYgKGpzb24ucmVmbGVjdGl2aXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xuXHRcdFx0aWYgKGpzb24ucmVmcmFjdGlvblJhdGlvICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IGpzb24ucmVmcmFjdGlvblJhdGlvO1xuXHRcdFx0aWYgKGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubGlnaHRNYXAgPSBnZXRUZXh0dXJlKGpzb24ubGlnaHRNYXApO1xuXHRcdFx0aWYgKGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdFx0aWYgKGpzb24uYW9NYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYW9NYXAgPSBnZXRUZXh0dXJlKGpzb24uYW9NYXApO1xuXHRcdFx0aWYgKGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBqc29uLmFvTWFwSW50ZW5zaXR5O1xuXHRcdFx0aWYgKGpzb24uZ3JhZGllbnRNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZ3JhZGllbnRNYXAgPSBnZXRUZXh0dXJlKGpzb24uZ3JhZGllbnRNYXApO1xuXHRcdFx0aWYgKGpzb24uY2xlYXJjb2F0TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdE1hcCA9IGdldFRleHR1cmUoanNvbi5jbGVhcmNvYXRNYXApO1xuXHRcdFx0aWYgKGpzb24uY2xlYXJjb2F0Um91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoanNvbi5jbGVhcmNvYXRSb3VnaG5lc3NNYXApO1xuXHRcdFx0aWYgKGpzb24uY2xlYXJjb2F0Tm9ybWFsTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCA9IGdldFRleHR1cmUoanNvbi5jbGVhcmNvYXROb3JtYWxNYXApO1xuXHRcdFx0aWYgKGpzb24uY2xlYXJjb2F0Tm9ybWFsU2NhbGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheShqc29uLmNsZWFyY29hdE5vcm1hbFNjYWxlKTtcblx0XHRcdGlmIChqc29uLnRyYW5zbWlzc2lvbk1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50cmFuc21pc3Npb25NYXAgPSBnZXRUZXh0dXJlKGpzb24udHJhbnNtaXNzaW9uTWFwKTtcblx0XHRcdGlmIChqc29uLnRoaWNrbmVzc01hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50aGlja25lc3NNYXAgPSBnZXRUZXh0dXJlKGpzb24udGhpY2tuZXNzTWFwKTtcblx0XHRcdHJldHVybiBtYXRlcmlhbDtcblx0XHR9XG5cblx0XHRzZXRUZXh0dXJlcyh2YWx1ZSkge1xuXHRcdFx0dGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBMb2FkZXJVdGlscyB7XG5cdFx0c3RhdGljIGRlY29kZVRleHQoYXJyYXkpIHtcblx0XHRcdGlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJyYXkpO1xuXHRcdFx0fSAvLyBBdm9pZCB0aGUgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSkgc2hvcnRjdXQsIHdoaWNoXG5cdFx0XHQvLyB0aHJvd3MgYSBcIm1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgZXJyb3IgZm9yIGxhcmdlIGFycmF5cy5cblxuXG5cdFx0XHRsZXQgcyA9ICcnO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdC8vIEltcGxpY2l0bHkgYXNzdW1lcyBsaXR0bGUtZW5kaWFuLlxuXHRcdFx0XHRzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBtZXJnZXMgbXVsdGktYnl0ZSB1dGYtOCBjaGFyYWN0ZXJzLlxuXHRcdFx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzKSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIHNlZSAjMTYzNThcblx0XHRcdFx0cmV0dXJuIHM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3RhdGljIGV4dHJhY3RVcmxCYXNlKHVybCkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSB1cmwubGFzdEluZGV4T2YoJy8nKTtcblx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHJldHVybiAnLi8nO1xuXHRcdFx0cmV0dXJuIHVybC5zdWJzdHIoMCwgaW5kZXggKyAxKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLmluc3RhbmNlQ291bnQgPSBJbmZpbml0eTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5pbnN0YW5jZUNvdW50ID0gc291cmNlLmluc3RhbmNlQ291bnQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTih0aGlzKTtcblx0XHRcdGRhdGEuaW5zdGFuY2VDb3VudCA9IHRoaXMuaW5zdGFuY2VDb3VudDtcblx0XHRcdGRhdGEuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0fVxuXG5cdEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcblxuXHRjbGFzcyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCwgbWVzaFBlckF0dHJpYnV0ZSA9IDEpIHtcblx0XHRcdGlmICh0eXBlb2Ygbm9ybWFsaXplZCA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0bWVzaFBlckF0dHJpYnV0ZSA9IG5vcm1hbGl6ZWQ7XG5cdFx0XHRcdG5vcm1hbGl6ZWQgPSBmYWxzZTtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlOiBUaGUgY29uc3RydWN0b3Igbm93IGV4cGVjdHMgbm9ybWFsaXplZCBhcyB0aGUgdGhpcmQgYXJndW1lbnQuJyk7XG5cdFx0XHR9XG5cblx0XHRcdHN1cGVyKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGRhdGEubWVzaFBlckF0dHJpYnV0ZSA9IHRoaXMubWVzaFBlckF0dHJpYnV0ZTtcblx0XHRcdGRhdGEuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdH1cblxuXHRJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRjbGFzcyBCdWZmZXJHZW9tZXRyeUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdFx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdFx0c3VwZXIobWFuYWdlcik7XG5cdFx0fVxuXG5cdFx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoc2NvcGUubWFuYWdlcik7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aChzY29wZS5wYXRoKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHNjb3BlLnJlcXVlc3RIZWFkZXIpO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyhzY29wZS53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdFx0bG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAodGV4dCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG9uTG9hZChzY29wZS5wYXJzZShKU09OLnBhcnNlKHRleHQpKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRpZiAob25FcnJvcikge1xuXHRcdFx0XHRcdFx0b25FcnJvcihlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yKTtcblx0XHR9XG5cblx0XHRwYXJzZShqc29uKSB7XG5cdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlck1hcCA9IHt9O1xuXHRcdFx0Y29uc3QgYXJyYXlCdWZmZXJNYXAgPSB7fTtcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0SW50ZXJsZWF2ZWRCdWZmZXIoanNvbiwgdXVpZCkge1xuXHRcdFx0XHRpZiAoaW50ZXJsZWF2ZWRCdWZmZXJNYXBbdXVpZF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGludGVybGVhdmVkQnVmZmVyTWFwW3V1aWRdO1xuXHRcdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlcnMgPSBqc29uLmludGVybGVhdmVkQnVmZmVycztcblx0XHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBpbnRlcmxlYXZlZEJ1ZmZlcnNbdXVpZF07XG5cdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IGdldEFycmF5QnVmZmVyKGpzb24sIGludGVybGVhdmVkQnVmZmVyLmJ1ZmZlcik7XG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gZ2V0VHlwZWRBcnJheShpbnRlcmxlYXZlZEJ1ZmZlci50eXBlLCBidWZmZXIpO1xuXHRcdFx0XHRjb25zdCBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihhcnJheSwgaW50ZXJsZWF2ZWRCdWZmZXIuc3RyaWRlKTtcblx0XHRcdFx0aWIudXVpZCA9IGludGVybGVhdmVkQnVmZmVyLnV1aWQ7XG5cdFx0XHRcdGludGVybGVhdmVkQnVmZmVyTWFwW3V1aWRdID0gaWI7XG5cdFx0XHRcdHJldHVybiBpYjtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIoanNvbiwgdXVpZCkge1xuXHRcdFx0XHRpZiAoYXJyYXlCdWZmZXJNYXBbdXVpZF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGFycmF5QnVmZmVyTWFwW3V1aWRdO1xuXHRcdFx0XHRjb25zdCBhcnJheUJ1ZmZlcnMgPSBqc29uLmFycmF5QnVmZmVycztcblx0XHRcdFx0Y29uc3QgYXJyYXlCdWZmZXIgPSBhcnJheUJ1ZmZlcnNbdXVpZF07XG5cdFx0XHRcdGNvbnN0IGFiID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKS5idWZmZXI7XG5cdFx0XHRcdGFycmF5QnVmZmVyTWFwW3V1aWRdID0gYWI7XG5cdFx0XHRcdHJldHVybiBhYjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBqc29uLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPyBuZXcgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkoKSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Y29uc3QgaW5kZXggPSBqc29uLmRhdGEuaW5kZXg7XG5cblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnN0IHR5cGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5KGluZGV4LnR5cGUsIGluZGV4LmFycmF5KTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgobmV3IEJ1ZmZlckF0dHJpYnV0ZSh0eXBlZEFycmF5LCAxKSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBqc29uLmRhdGEuYXR0cmlidXRlcztcblxuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0XHRcdGxldCBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHRcdFx0aWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBnZXRJbnRlcmxlYXZlZEJ1ZmZlcihqc29uLmRhdGEsIGF0dHJpYnV0ZS5kYXRhKTtcblx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm9mZnNldCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHR5cGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5KGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuYXJyYXkpO1xuXHRcdFx0XHRcdGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZUNvbnN0ciA9IGF0dHJpYnV0ZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA/IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA6IEJ1ZmZlckF0dHJpYnV0ZTtcblx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgYnVmZmVyQXR0cmlidXRlQ29uc3RyKHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGF0dHJpYnV0ZS5uYW1lICE9PSB1bmRlZmluZWQpIGJ1ZmZlckF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRcdGlmIChhdHRyaWJ1dGUudXNhZ2UgIT09IHVuZGVmaW5lZCkgYnVmZmVyQXR0cmlidXRlLnNldFVzYWdlKGF0dHJpYnV0ZS51c2FnZSk7XG5cblx0XHRcdFx0aWYgKGF0dHJpYnV0ZS51cGRhdGVSYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlLnVwZGF0ZVJhbmdlLm9mZnNldCA9IGF0dHJpYnV0ZS51cGRhdGVSYW5nZS5vZmZzZXQ7XG5cdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlLnVwZGF0ZVJhbmdlLmNvdW50ID0gYXR0cmlidXRlLnVwZGF0ZVJhbmdlLmNvdW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKGtleSwgYnVmZmVyQXR0cmlidXRlKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0ganNvbi5kYXRhLm1vcnBoQXR0cmlidXRlcztcblxuXHRcdFx0aWYgKG1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBtb3JwaEF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVBcnJheSA9IG1vcnBoQXR0cmlidXRlc1trZXldO1xuXHRcdFx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBhdHRyaWJ1dGVBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVBcnJheVtpXTtcblx0XHRcdFx0XHRcdGxldCBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHRcdFx0XHRcdGlmIChhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IGdldEludGVybGVhdmVkQnVmZmVyKGpzb24uZGF0YSwgYXR0cmlidXRlLmRhdGEpO1xuXHRcdFx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm9mZnNldCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgdHlwZWRBcnJheSA9IGdldFR5cGVkQXJyYXkoYXR0cmlidXRlLnR5cGUsIGF0dHJpYnV0ZS5hcnJheSk7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUodHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChhdHRyaWJ1dGUubmFtZSAhPT0gdW5kZWZpbmVkKSBidWZmZXJBdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuXHRcdFx0XHRcdFx0YXJyYXkucHVzaChidWZmZXJBdHRyaWJ1dGUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1trZXldID0gYXJyYXk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBqc29uLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHRcdGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGdyb3VwcyA9IGpzb24uZGF0YS5ncm91cHMgfHwganNvbi5kYXRhLmRyYXdjYWxscyB8fCBqc29uLmRhdGEub2Zmc2V0cztcblxuXHRcdFx0aWYgKGdyb3VwcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gZ3JvdXBzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG5cdFx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdFx0aWYgKGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0XHRpZiAoYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjZW50ZXIuZnJvbUFycmF5KGJvdW5kaW5nU3BoZXJlLmNlbnRlcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoanNvbi5uYW1lKSBnZW9tZXRyeS5uYW1lID0ganNvbi5uYW1lO1xuXHRcdFx0aWYgKGpzb24udXNlckRhdGEpIGdlb21ldHJ5LnVzZXJEYXRhID0ganNvbi51c2VyRGF0YTtcblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIE9iamVjdExvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdFx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdFx0c3VwZXIobWFuYWdlcik7XG5cdFx0fVxuXG5cdFx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29uc3QgcGF0aCA9IHRoaXMucGF0aCA9PT0gJycgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpIDogdGhpcy5wYXRoO1xuXHRcdFx0dGhpcy5yZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoO1xuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcblx0XHRcdGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG5cdFx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG5cdFx0XHRsb2FkZXIubG9hZCh1cmwsIGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRcdGxldCBqc29uID0gbnVsbDtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKHRleHQpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGlmIChvbkVycm9yICE9PSB1bmRlZmluZWQpIG9uRXJyb3IoZXJyb3IpO1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFOk9iamVjdExvYWRlcjogQ2FuXFwndCBwYXJzZSAnICsgdXJsICsgJy4nLCBlcnJvci5tZXNzYWdlKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRcdFx0aWYgKG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5Jykge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFwndCBsb2FkICcgKyB1cmwpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLnBhcnNlKGpzb24sIG9uTG9hZCk7XG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yKTtcblx0XHR9XG5cblx0XHRhc3luYyBsb2FkQXN5bmModXJsLCBvblByb2dyZXNzKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBwYXRoID0gdGhpcy5wYXRoID09PSAnJyA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKHVybCkgOiB0aGlzLnBhdGg7XG5cdFx0XHR0aGlzLnJlc291cmNlUGF0aCA9IHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGg7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcblx0XHRcdGNvbnN0IHRleHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKHVybCwgb25Qcm9ncmVzcyk7XG5cdFx0XHRjb25zdCBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcblxuXHRcdFx0aWYgKG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5Jykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFwndCBsb2FkICcgKyB1cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXdhaXQgc2NvcGUucGFyc2VBc3luYyhqc29uKTtcblx0XHR9XG5cblx0XHRwYXJzZShqc29uLCBvbkxvYWQpIHtcblx0XHRcdGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucyhqc29uLmFuaW1hdGlvbnMpO1xuXHRcdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJzZVNoYXBlcyhqc29uLnNoYXBlcyk7XG5cdFx0XHRjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoanNvbi5nZW9tZXRyaWVzLCBzaGFwZXMpO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcyhqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAob25Mb2FkICE9PSB1bmRlZmluZWQpIG9uTG9hZChvYmplY3QpO1xuXHRcdFx0fSk7XG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHRoaXMucGFyc2VUZXh0dXJlcyhqc29uLnRleHR1cmVzLCBpbWFnZXMpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscyhqc29uLm1hdGVyaWFscywgdGV4dHVyZXMpO1xuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdChqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucyk7XG5cdFx0XHRjb25zdCBza2VsZXRvbnMgPSB0aGlzLnBhcnNlU2tlbGV0b25zKGpzb24uc2tlbGV0b25zLCBvYmplY3QpO1xuXHRcdFx0dGhpcy5iaW5kU2tlbGV0b25zKG9iamVjdCwgc2tlbGV0b25zKTsgLy9cblxuXHRcdFx0aWYgKG9uTG9hZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGxldCBoYXNJbWFnZXMgPSBmYWxzZTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IHV1aWQgaW4gaW1hZ2VzKSB7XG5cdFx0XHRcdFx0aWYgKGltYWdlc1t1dWlkXSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGhhc0ltYWdlcyA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaGFzSW1hZ2VzID09PSBmYWxzZSkgb25Mb2FkKG9iamVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0fVxuXG5cdFx0YXN5bmMgcGFyc2VBc3luYyhqc29uKSB7XG5cdFx0XHRjb25zdCBhbmltYXRpb25zID0gdGhpcy5wYXJzZUFuaW1hdGlvbnMoanNvbi5hbmltYXRpb25zKTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyc2VTaGFwZXMoanNvbi5zaGFwZXMpO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKGpzb24uZ2VvbWV0cmllcywgc2hhcGVzKTtcblx0XHRcdGNvbnN0IGltYWdlcyA9IGF3YWl0IHRoaXMucGFyc2VJbWFnZXNBc3luYyhqc29uLmltYWdlcyk7XG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHRoaXMucGFyc2VUZXh0dXJlcyhqc29uLnRleHR1cmVzLCBpbWFnZXMpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscyhqc29uLm1hdGVyaWFscywgdGV4dHVyZXMpO1xuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdChqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucyk7XG5cdFx0XHRjb25zdCBza2VsZXRvbnMgPSB0aGlzLnBhcnNlU2tlbGV0b25zKGpzb24uc2tlbGV0b25zLCBvYmplY3QpO1xuXHRcdFx0dGhpcy5iaW5kU2tlbGV0b25zKG9iamVjdCwgc2tlbGV0b25zKTtcblx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0fVxuXG5cdFx0cGFyc2VTaGFwZXMoanNvbikge1xuXHRcdFx0Y29uc3Qgc2hhcGVzID0ge307XG5cblx0XHRcdGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IHNoYXBlID0gbmV3IFNoYXBlKCkuZnJvbUpTT04oanNvbltpXSk7XG5cdFx0XHRcdFx0c2hhcGVzW3NoYXBlLnV1aWRdID0gc2hhcGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNoYXBlcztcblx0XHR9XG5cblx0XHRwYXJzZVNrZWxldG9ucyhqc29uLCBvYmplY3QpIHtcblx0XHRcdGNvbnN0IHNrZWxldG9ucyA9IHt9O1xuXHRcdFx0Y29uc3QgYm9uZXMgPSB7fTsgLy8gZ2VuZXJhdGUgYm9uZSBsb29rdXAgdGFibGVcblxuXHRcdFx0b2JqZWN0LnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0XHRpZiAoY2hpbGQuaXNCb25lKSBib25lc1tjaGlsZC51dWlkXSA9IGNoaWxkO1xuXHRcdFx0fSk7IC8vIGNyZWF0ZSBza2VsZXRvbnNcblxuXHRcdFx0aWYgKGpzb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBuZXcgU2tlbGV0b24oKS5mcm9tSlNPTihqc29uW2ldLCBib25lcyk7XG5cdFx0XHRcdFx0c2tlbGV0b25zW3NrZWxldG9uLnV1aWRdID0gc2tlbGV0b247XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNrZWxldG9ucztcblx0XHR9XG5cblx0XHRwYXJzZUdlb21ldHJpZXMoanNvbiwgc2hhcGVzKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyaWVzID0ge307XG5cblx0XHRcdGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3QgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IGdlb21ldHJ5O1xuXHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uW2ldO1xuXG5cdFx0XHRcdFx0c3dpdGNoIChkYXRhLnR5cGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ0J1ZmZlckdlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZShkYXRhKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0dlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuT2JqZWN0TG9hZGVyOiBUaGUgbGVnYWN5IEdlb21ldHJ5IHR5cGUgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4nKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhLnR5cGUgaW4gR2VvbWV0cmllcykge1xuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gR2VvbWV0cmllc1tkYXRhLnR5cGVdLmZyb21KU09OKGRhdGEsIHNoYXBlcyk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKGBUSFJFRS5PYmplY3RMb2FkZXI6IFVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgXCIke2RhdGEudHlwZX1cImApO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xuXHRcdFx0XHRcdGlmIChkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkgZ2VvbWV0cnkubmFtZSA9IGRhdGEubmFtZTtcblx0XHRcdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSA9PT0gdHJ1ZSAmJiBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQpIGdlb21ldHJ5LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblx0XHRcdFx0XHRnZW9tZXRyaWVzW2RhdGEudXVpZF0gPSBnZW9tZXRyeTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cmllcztcblx0XHR9XG5cblx0XHRwYXJzZU1hdGVyaWFscyhqc29uLCB0ZXh0dXJlcykge1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB7fTsgLy8gTXVsdGlNYXRlcmlhbFxuXG5cdFx0XHRjb25zdCBtYXRlcmlhbHMgPSB7fTtcblxuXHRcdFx0aWYgKGpzb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcblx0XHRcdFx0bG9hZGVyLnNldFRleHR1cmVzKHRleHR1cmVzKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGpzb25baV07XG5cblx0XHRcdFx0XHRpZiAoZGF0YS50eXBlID09PSAnTXVsdGlNYXRlcmlhbCcpIHtcblx0XHRcdFx0XHRcdC8vIERlcHJlY2F0ZWRcblx0XHRcdFx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgZGF0YS5tYXRlcmlhbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBkYXRhLm1hdGVyaWFsc1tqXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoY2FjaGVbbWF0ZXJpYWwudXVpZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdGNhY2hlW21hdGVyaWFsLnV1aWRdID0gbG9hZGVyLnBhcnNlKG1hdGVyaWFsKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGFycmF5LnB1c2goY2FjaGVbbWF0ZXJpYWwudXVpZF0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbHNbZGF0YS51dWlkXSA9IGFycmF5O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoY2FjaGVbZGF0YS51dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGNhY2hlW2RhdGEudXVpZF0gPSBsb2FkZXIucGFyc2UoZGF0YSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFsc1tkYXRhLnV1aWRdID0gY2FjaGVbZGF0YS51dWlkXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFscztcblx0XHR9XG5cblx0XHRwYXJzZUFuaW1hdGlvbnMoanNvbikge1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IHt9O1xuXG5cdFx0XHRpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uW2ldO1xuXHRcdFx0XHRcdGNvbnN0IGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlKGRhdGEpO1xuXHRcdFx0XHRcdGFuaW1hdGlvbnNbY2xpcC51dWlkXSA9IGNsaXA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbnM7XG5cdFx0fVxuXG5cdFx0cGFyc2VJbWFnZXMoanNvbiwgb25Mb2FkKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBpbWFnZXMgPSB7fTtcblx0XHRcdGxldCBsb2FkZXI7XG5cblx0XHRcdGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwpIHtcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcblx0XHRcdFx0cmV0dXJuIGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0XHR9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZGVzZXJpYWxpemVJbWFnZShpbWFnZSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlO1xuXHRcdFx0XHRcdGNvbnN0IHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QodXJsKSA/IHVybCA6IHNjb3BlLnJlc291cmNlUGF0aCArIHVybDtcblx0XHRcdFx0XHRyZXR1cm4gbG9hZEltYWdlKHBhdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChpbWFnZS5kYXRhKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRkYXRhOiBnZXRUeXBlZEFycmF5KGltYWdlLnR5cGUsIGltYWdlLmRhdGEpLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgbWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcihvbkxvYWQpO1xuXHRcdFx0XHRsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIobWFuYWdlcik7XG5cdFx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBqc29uLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBpbWFnZSA9IGpzb25baV07XG5cdFx0XHRcdFx0Y29uc3QgdXJsID0gaW1hZ2UudXJsO1xuXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodXJsKSkge1xuXHRcdFx0XHRcdFx0Ly8gbG9hZCBhcnJheSBvZiBpbWFnZXMgZS5nIEN1YmVUZXh0dXJlXG5cdFx0XHRcdFx0XHRpbWFnZXNbaW1hZ2UudXVpZF0gPSBbXTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIGpsID0gdXJsLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgY3VycmVudFVybCA9IHVybFtqXTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBkZXNlcmlhbGl6ZUltYWdlKGN1cnJlbnRVcmwpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChkZXNlcmlhbGl6ZWRJbWFnZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChkZXNlcmlhbGl6ZWRJbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGltYWdlc1tpbWFnZS51dWlkXS5wdXNoKGRlc2VyaWFsaXplZEltYWdlKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgYXJyYXkgb2YgZGF0YSB0ZXh0dXJlcyBmb3IgY3ViZSB0ZXh0dXJlc1xuXHRcdFx0XHRcdFx0XHRcdFx0aW1hZ2VzW2ltYWdlLnV1aWRdLnB1c2gobmV3IERhdGFUZXh0dXJlKGRlc2VyaWFsaXplZEltYWdlLmRhdGEsIGRlc2VyaWFsaXplZEltYWdlLndpZHRoLCBkZXNlcmlhbGl6ZWRJbWFnZS5oZWlnaHQpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gbG9hZCBzaW5nbGUgaW1hZ2Vcblx0XHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gZGVzZXJpYWxpemVJbWFnZShpbWFnZS51cmwpO1xuXG5cdFx0XHRcdFx0XHRpZiAoZGVzZXJpYWxpemVkSW1hZ2UgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzW2ltYWdlLnV1aWRdID0gZGVzZXJpYWxpemVkSW1hZ2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZXM7XG5cdFx0fVxuXG5cdFx0YXN5bmMgcGFyc2VJbWFnZXNBc3luYyhqc29uKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBpbWFnZXMgPSB7fTtcblx0XHRcdGxldCBsb2FkZXI7XG5cblx0XHRcdGFzeW5jIGZ1bmN0aW9uIGRlc2VyaWFsaXplSW1hZ2UoaW1hZ2UpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRjb25zdCB1cmwgPSBpbWFnZTtcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gL14oXFwvXFwvKXwoW2Etel0rOihcXC9cXC8pPykvaS50ZXN0KHVybCkgPyB1cmwgOiBzY29wZS5yZXNvdXJjZVBhdGggKyB1cmw7XG5cdFx0XHRcdFx0cmV0dXJuIGF3YWl0IGxvYWRlci5sb2FkQXN5bmMocGF0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGltYWdlLmRhdGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdGRhdGE6IGdldFR5cGVkQXJyYXkoaW1hZ2UudHlwZSwgaW1hZ2UuZGF0YSksXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoanNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIodGhpcy5tYW5hZ2VyKTtcblx0XHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMuY3Jvc3NPcmlnaW4pO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGpzb24ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGltYWdlID0ganNvbltpXTtcblx0XHRcdFx0XHRjb25zdCB1cmwgPSBpbWFnZS51cmw7XG5cblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh1cmwpKSB7XG5cdFx0XHRcdFx0XHQvLyBsb2FkIGFycmF5IG9mIGltYWdlcyBlLmcgQ3ViZVRleHR1cmVcblx0XHRcdFx0XHRcdGltYWdlc1tpbWFnZS51dWlkXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgamwgPSB1cmwubGVuZ3RoOyBqIDwgamw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VXJsID0gdXJsW2pdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBkZXNlcmlhbGl6ZWRJbWFnZSA9IGF3YWl0IGRlc2VyaWFsaXplSW1hZ2UoY3VycmVudFVybCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGRlc2VyaWFsaXplZEltYWdlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGRlc2VyaWFsaXplZEltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW1hZ2VzW2ltYWdlLnV1aWRdLnB1c2goZGVzZXJpYWxpemVkSW1hZ2UpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBhcnJheSBvZiBkYXRhIHRleHR1cmVzIGZvciBjdWJlIHRleHR1cmVzXG5cdFx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbaW1hZ2UudXVpZF0ucHVzaChuZXcgRGF0YVRleHR1cmUoZGVzZXJpYWxpemVkSW1hZ2UuZGF0YSwgZGVzZXJpYWxpemVkSW1hZ2Uud2lkdGgsIGRlc2VyaWFsaXplZEltYWdlLmhlaWdodCkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBsb2FkIHNpbmdsZSBpbWFnZVxuXHRcdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBhd2FpdCBkZXNlcmlhbGl6ZUltYWdlKGltYWdlLnVybCk7XG5cblx0XHRcdFx0XHRcdGlmIChkZXNlcmlhbGl6ZWRJbWFnZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRpbWFnZXNbaW1hZ2UudXVpZF0gPSBkZXNlcmlhbGl6ZWRJbWFnZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlcztcblx0XHR9XG5cblx0XHRwYXJzZVRleHR1cmVzKGpzb24sIGltYWdlcykge1xuXHRcdFx0ZnVuY3Rpb24gcGFyc2VDb25zdGFudCh2YWx1ZSwgdHlwZSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gdHlwZVt2YWx1ZV07XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRleHR1cmVzID0ge307XG5cblx0XHRcdGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uW2ldO1xuXG5cdFx0XHRcdFx0aWYgKGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaW1hZ2VzW2RhdGEuaW1hZ2VdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgdGV4dHVyZTtcblx0XHRcdFx0XHRjb25zdCBpbWFnZSA9IGltYWdlc1tkYXRhLmltYWdlXTtcblxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGltYWdlKSkge1xuXHRcdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZShpbWFnZSk7XG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2UubGVuZ3RoID09PSA2KSB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGltYWdlICYmIGltYWdlLmRhdGEpIHtcblx0XHRcdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZShpbWFnZS5kYXRhLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgVGV4dHVyZShpbWFnZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChpbWFnZSkgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7IC8vIHRleHR1cmVzIGNhbiBoYXZlIHVuZGVmaW5lZCBpbWFnZSBkYXRhXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGV4dHVyZS51dWlkID0gZGF0YS51dWlkO1xuXHRcdFx0XHRcdGlmIChkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5uYW1lID0gZGF0YS5uYW1lO1xuXHRcdFx0XHRcdGlmIChkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudChkYXRhLm1hcHBpbmcsIFRFWFRVUkVfTUFQUElORyk7XG5cdFx0XHRcdFx0aWYgKGRhdGEub2Zmc2V0ICE9PSB1bmRlZmluZWQpIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheShkYXRhLm9mZnNldCk7XG5cdFx0XHRcdFx0aWYgKGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQpIHRleHR1cmUucmVwZWF0LmZyb21BcnJheShkYXRhLnJlcGVhdCk7XG5cdFx0XHRcdFx0aWYgKGRhdGEuY2VudGVyICE9PSB1bmRlZmluZWQpIHRleHR1cmUuY2VudGVyLmZyb21BcnJheShkYXRhLmNlbnRlcik7XG5cdFx0XHRcdFx0aWYgKGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XG5cblx0XHRcdFx0XHRpZiAoZGF0YS53cmFwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSBwYXJzZUNvbnN0YW50KGRhdGEud3JhcFswXSwgVEVYVFVSRV9XUkFQUElORyk7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gcGFyc2VDb25zdGFudChkYXRhLndyYXBbMV0sIFRFWFRVUkVfV1JBUFBJTkcpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkYXRhLmZvcm1hdCAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLmZvcm1hdCA9IGRhdGEuZm9ybWF0O1xuXHRcdFx0XHRcdGlmIChkYXRhLnR5cGUgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS50eXBlID0gZGF0YS50eXBlO1xuXHRcdFx0XHRcdGlmIChkYXRhLmVuY29kaW5nICE9PSB1bmRlZmluZWQpIHRleHR1cmUuZW5jb2RpbmcgPSBkYXRhLmVuY29kaW5nO1xuXHRcdFx0XHRcdGlmIChkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoZGF0YS5taW5GaWx0ZXIsIFRFWFRVUkVfRklMVEVSKTtcblx0XHRcdFx0XHRpZiAoZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5tYWdGaWx0ZXIgPSBwYXJzZUNvbnN0YW50KGRhdGEubWFnRmlsdGVyLCBURVhUVVJFX0ZJTFRFUik7XG5cdFx0XHRcdFx0aWYgKGRhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XG5cdFx0XHRcdFx0aWYgKGRhdGEuZmxpcFkgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5mbGlwWSA9IGRhdGEuZmxpcFk7XG5cdFx0XHRcdFx0aWYgKGRhdGEucHJlbXVsdGlwbHlBbHBoYSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSBkYXRhLnByZW11bHRpcGx5QWxwaGE7XG5cdFx0XHRcdFx0aWYgKGRhdGEudW5wYWNrQWxpZ25tZW50ICE9PSB1bmRlZmluZWQpIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ID0gZGF0YS51bnBhY2tBbGlnbm1lbnQ7XG5cdFx0XHRcdFx0dGV4dHVyZXNbZGF0YS51dWlkXSA9IHRleHR1cmU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmVzO1xuXHRcdH1cblxuXHRcdHBhcnNlT2JqZWN0KGRhdGEsIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMpIHtcblx0XHRcdGxldCBvYmplY3Q7XG5cblx0XHRcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KG5hbWUpIHtcblx0XHRcdFx0aWYgKGdlb21ldHJpZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyaWVzW25hbWVdO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRNYXRlcmlhbChuYW1lKSB7XG5cdFx0XHRcdGlmIChuYW1lID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcblx0XHRcdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdXVpZCA9IG5hbWVbaV07XG5cblx0XHRcdFx0XHRcdGlmIChtYXRlcmlhbHNbdXVpZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgdXVpZCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGFycmF5LnB1c2gobWF0ZXJpYWxzW3V1aWRdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobWF0ZXJpYWxzW25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgbmFtZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxzW25hbWVdO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlKHV1aWQpIHtcblx0XHRcdFx0aWYgKHRleHR1cmVzW3V1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCB1dWlkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0ZXh0dXJlc1t1dWlkXTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGdlb21ldHJ5LCBtYXRlcmlhbDtcblxuXHRcdFx0c3dpdGNoIChkYXRhLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnU2NlbmUnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTY2VuZSgpO1xuXG5cdFx0XHRcdFx0aWYgKGRhdGEuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRpZiAoTnVtYmVyLmlzSW50ZWdlcihkYXRhLmJhY2tncm91bmQpKSB7XG5cdFx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gbmV3IENvbG9yKGRhdGEuYmFja2dyb3VuZCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IGdldFRleHR1cmUoZGF0YS5iYWNrZ3JvdW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZGF0YS5lbnZpcm9ubWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRvYmplY3QuZW52aXJvbm1lbnQgPSBnZXRUZXh0dXJlKGRhdGEuZW52aXJvbm1lbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkYXRhLmZvZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZycpIHtcblx0XHRcdFx0XHRcdFx0b2JqZWN0LmZvZyA9IG5ldyBGb2coZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLm5lYXIsIGRhdGEuZm9nLmZhcik7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGRhdGEuZm9nLnR5cGUgPT09ICdGb2dFeHAyJykge1xuXHRcdFx0XHRcdFx0XHRvYmplY3QuZm9nID0gbmV3IEZvZ0V4cDIoZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLmRlbnNpdHkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyKTtcblx0XHRcdFx0XHRpZiAoZGF0YS5mb2N1cyAhPT0gdW5kZWZpbmVkKSBvYmplY3QuZm9jdXMgPSBkYXRhLmZvY3VzO1xuXHRcdFx0XHRcdGlmIChkYXRhLnpvb20gIT09IHVuZGVmaW5lZCkgb2JqZWN0Lnpvb20gPSBkYXRhLnpvb207XG5cdFx0XHRcdFx0aWYgKGRhdGEuZmlsbUdhdWdlICE9PSB1bmRlZmluZWQpIG9iamVjdC5maWxtR2F1Z2UgPSBkYXRhLmZpbG1HYXVnZTtcblx0XHRcdFx0XHRpZiAoZGF0YS5maWxtT2Zmc2V0ICE9PSB1bmRlZmluZWQpIG9iamVjdC5maWxtT2Zmc2V0ID0gZGF0YS5maWxtT2Zmc2V0O1xuXHRcdFx0XHRcdGlmIChkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhLnZpZXcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYShkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhcik7XG5cdFx0XHRcdFx0aWYgKGRhdGEuem9vbSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcblx0XHRcdFx0XHRpZiAoZGF0YS52aWV3ICE9PSB1bmRlZmluZWQpIG9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YS52aWV3KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdBbWJpZW50TGlnaHQnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBBbWJpZW50TGlnaHQoZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0Jzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRMaWdodChkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnUmVjdEFyZWFMaWdodCc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFJlY3RBcmVhTGlnaHQoZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTcG90TGlnaHQoZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEucGVudW1icmEsIGRhdGEuZGVjYXkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodChkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTGlnaHRQcm9iZSc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IExpZ2h0UHJvYmUoKS5mcm9tSlNPTihkYXRhKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTa2lubmVkTWVzaCc6XG5cdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZXRHZW9tZXRyeShkYXRhLmdlb21ldHJ5KTtcblx0XHRcdFx0XHRtYXRlcmlhbCA9IGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpO1xuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTa2lubmVkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0XHRcdGlmIChkYXRhLmJpbmRNb2RlICE9PSB1bmRlZmluZWQpIG9iamVjdC5iaW5kTW9kZSA9IGRhdGEuYmluZE1vZGU7XG5cdFx0XHRcdFx0aWYgKGRhdGEuYmluZE1hdHJpeCAhPT0gdW5kZWZpbmVkKSBvYmplY3QuYmluZE1hdHJpeC5mcm9tQXJyYXkoZGF0YS5iaW5kTWF0cml4KTtcblx0XHRcdFx0XHRpZiAoZGF0YS5za2VsZXRvbiAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2tlbGV0b24gPSBkYXRhLnNrZWxldG9uO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01lc2gnOlxuXHRcdFx0XHRcdGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSk7XG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBnZXRNYXRlcmlhbChkYXRhLm1hdGVyaWFsKTtcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0luc3RhbmNlZE1lc2gnOlxuXHRcdFx0XHRcdGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSk7XG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBnZXRNYXRlcmlhbChkYXRhLm1hdGVyaWFsKTtcblx0XHRcdFx0XHRjb25zdCBjb3VudCA9IGRhdGEuY291bnQ7XG5cdFx0XHRcdFx0Y29uc3QgaW5zdGFuY2VNYXRyaXggPSBkYXRhLmluc3RhbmNlTWF0cml4O1xuXHRcdFx0XHRcdGNvbnN0IGluc3RhbmNlQ29sb3IgPSBkYXRhLmluc3RhbmNlQ29sb3I7XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEluc3RhbmNlZE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsLCBjb3VudCk7XG5cdFx0XHRcdFx0b2JqZWN0Lmluc3RhbmNlTWF0cml4ID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGluc3RhbmNlTWF0cml4LmFycmF5KSwgMTYpO1xuXHRcdFx0XHRcdGlmIChpbnN0YW5jZUNvbG9yICE9PSB1bmRlZmluZWQpIG9iamVjdC5pbnN0YW5jZUNvbG9yID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGluc3RhbmNlQ29sb3IuYXJyYXkpLCBpbnN0YW5jZUNvbG9yLml0ZW1TaXplKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdMT0QnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMT0QoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdMaW5lJzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZShnZXRHZW9tZXRyeShkYXRhLmdlb21ldHJ5KSwgZ2V0TWF0ZXJpYWwoZGF0YS5tYXRlcmlhbCkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0xpbmVMb29wJzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZUxvb3AoZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSksIGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdMaW5lU2VnbWVudHMnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSksIGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQb2ludENsb3VkJzpcblx0XHRcdFx0Y2FzZSAnUG9pbnRzJzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRzKGdldEdlb21ldHJ5KGRhdGEuZ2VvbWV0cnkpLCBnZXRNYXRlcmlhbChkYXRhLm1hdGVyaWFsKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU3ByaXRlJzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgU3ByaXRlKGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdHcm91cCc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEdyb3VwKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnQm9uZSc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEJvbmUoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBPYmplY3QzRCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QudXVpZCA9IGRhdGEudXVpZDtcblx0XHRcdGlmIChkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XG5cblx0XHRcdGlmIChkYXRhLm1hdHJpeCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9iamVjdC5tYXRyaXguZnJvbUFycmF5KGRhdGEubWF0cml4KTtcblx0XHRcdFx0aWYgKGRhdGEubWF0cml4QXV0b1VwZGF0ZSAhPT0gdW5kZWZpbmVkKSBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGRhdGEubWF0cml4QXV0b1VwZGF0ZTtcblx0XHRcdFx0aWYgKG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlKSBvYmplY3QubWF0cml4LmRlY29tcG9zZShvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCkgb2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheShkYXRhLnBvc2l0aW9uKTtcblx0XHRcdFx0aWYgKGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheShkYXRhLnJvdGF0aW9uKTtcblx0XHRcdFx0aWYgKGRhdGEucXVhdGVybmlvbiAhPT0gdW5kZWZpbmVkKSBvYmplY3QucXVhdGVybmlvbi5mcm9tQXJyYXkoZGF0YS5xdWF0ZXJuaW9uKTtcblx0XHRcdFx0aWYgKGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnNjYWxlLmZyb21BcnJheShkYXRhLnNjYWxlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEuY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcblx0XHRcdGlmIChkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XG5cblx0XHRcdGlmIChkYXRhLnNoYWRvdykge1xuXHRcdFx0XHRpZiAoZGF0YS5zaGFkb3cuYmlhcyAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2hhZG93LmJpYXMgPSBkYXRhLnNoYWRvdy5iaWFzO1xuXHRcdFx0XHRpZiAoZGF0YS5zaGFkb3cubm9ybWFsQmlhcyAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2hhZG93Lm5vcm1hbEJpYXMgPSBkYXRhLnNoYWRvdy5ub3JtYWxCaWFzO1xuXHRcdFx0XHRpZiAoZGF0YS5zaGFkb3cucmFkaXVzICE9PSB1bmRlZmluZWQpIG9iamVjdC5zaGFkb3cucmFkaXVzID0gZGF0YS5zaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRpZiAoZGF0YS5zaGFkb3cubWFwU2l6ZSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2hhZG93Lm1hcFNpemUuZnJvbUFycmF5KGRhdGEuc2hhZG93Lm1hcFNpemUpO1xuXHRcdFx0XHRpZiAoZGF0YS5zaGFkb3cuY2FtZXJhICE9PSB1bmRlZmluZWQpIG9iamVjdC5zaGFkb3cuY2FtZXJhID0gdGhpcy5wYXJzZU9iamVjdChkYXRhLnNoYWRvdy5jYW1lcmEpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQpIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xuXHRcdFx0aWYgKGRhdGEuZnJ1c3R1bUN1bGxlZCAhPT0gdW5kZWZpbmVkKSBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IGRhdGEuZnJ1c3R1bUN1bGxlZDtcblx0XHRcdGlmIChkYXRhLnJlbmRlck9yZGVyICE9PSB1bmRlZmluZWQpIG9iamVjdC5yZW5kZXJPcmRlciA9IGRhdGEucmVuZGVyT3JkZXI7XG5cdFx0XHRpZiAoZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXHRcdFx0aWYgKGRhdGEubGF5ZXJzICE9PSB1bmRlZmluZWQpIG9iamVjdC5sYXllcnMubWFzayA9IGRhdGEubGF5ZXJzO1xuXG5cdFx0XHRpZiAoZGF0YS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gZGF0YS5jaGlsZHJlbjtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b2JqZWN0LmFkZCh0aGlzLnBhcnNlT2JqZWN0KGNoaWxkcmVuW2ldLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEuYW5pbWF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnN0IG9iamVjdEFuaW1hdGlvbnMgPSBkYXRhLmFuaW1hdGlvbnM7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RBbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdXVpZCA9IG9iamVjdEFuaW1hdGlvbnNbaV07XG5cdFx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMucHVzaChhbmltYXRpb25zW3V1aWRdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YS50eXBlID09PSAnTE9EJykge1xuXHRcdFx0XHRpZiAoZGF0YS5hdXRvVXBkYXRlICE9PSB1bmRlZmluZWQpIG9iamVjdC5hdXRvVXBkYXRlID0gZGF0YS5hdXRvVXBkYXRlO1xuXHRcdFx0XHRjb25zdCBsZXZlbHMgPSBkYXRhLmxldmVscztcblxuXHRcdFx0XHRmb3IgKGxldCBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwrKykge1xuXHRcdFx0XHRcdGNvbnN0IGxldmVsID0gbGV2ZWxzW2xdO1xuXHRcdFx0XHRcdGNvbnN0IGNoaWxkID0gb2JqZWN0LmdldE9iamVjdEJ5UHJvcGVydHkoJ3V1aWQnLCBsZXZlbC5vYmplY3QpO1xuXG5cdFx0XHRcdFx0aWYgKGNoaWxkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdG9iamVjdC5hZGRMZXZlbChjaGlsZCwgbGV2ZWwuZGlzdGFuY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXHRcdH1cblxuXHRcdGJpbmRTa2VsZXRvbnMob2JqZWN0LCBza2VsZXRvbnMpIHtcblx0XHRcdGlmIChPYmplY3Qua2V5cyhza2VsZXRvbnMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXHRcdFx0b2JqZWN0LnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0XHRpZiAoY2hpbGQuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSAmJiBjaGlsZC5za2VsZXRvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBza2VsZXRvbnNbY2hpbGQuc2tlbGV0b25dO1xuXG5cdFx0XHRcdFx0aWYgKHNrZWxldG9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBza2VsZXRvbiBmb3VuZCB3aXRoIFVVSUQ6JywgY2hpbGQuc2tlbGV0b24pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjaGlsZC5iaW5kKHNrZWxldG9uLCBjaGlsZC5iaW5kTWF0cml4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvKiBERVBSRUNBVEVEICovXG5cblxuXHRcdHNldFRleHR1cmVQYXRoKHZhbHVlKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogLnNldFRleHR1cmVQYXRoKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0UmVzb3VyY2VQYXRoKCkuJyk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRSZXNvdXJjZVBhdGgodmFsdWUpO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgVEVYVFVSRV9NQVBQSU5HID0ge1xuXHRcdFVWTWFwcGluZzogVVZNYXBwaW5nLFxuXHRcdEN1YmVSZWZsZWN0aW9uTWFwcGluZzogQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLFxuXHRcdEN1YmVSZWZyYWN0aW9uTWFwcGluZzogQ3ViZVJlZnJhY3Rpb25NYXBwaW5nLFxuXHRcdEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcblx0XHRFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcsXG5cdFx0Q3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLFxuXHRcdEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZ1xuXHR9O1xuXHRjb25zdCBURVhUVVJFX1dSQVBQSU5HID0ge1xuXHRcdFJlcGVhdFdyYXBwaW5nOiBSZXBlYXRXcmFwcGluZyxcblx0XHRDbGFtcFRvRWRnZVdyYXBwaW5nOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuXHRcdE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcblx0fTtcblx0Y29uc3QgVEVYVFVSRV9GSUxURVIgPSB7XG5cdFx0TmVhcmVzdEZpbHRlcjogTmVhcmVzdEZpbHRlcixcblx0XHROZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcjogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdFx0TmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcjogTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcblx0XHRMaW5lYXJGaWx0ZXI6IExpbmVhckZpbHRlcixcblx0XHRMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyOiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHRcdExpbmVhck1pcG1hcExpbmVhckZpbHRlcjogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXG5cdH07XG5cblx0Y2xhc3MgSW1hZ2VCaXRtYXBMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRcdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRcdHN1cGVyKG1hbmFnZXIpO1xuXG5cdFx0XHRpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBjcmVhdGVJbWFnZUJpdG1hcCgpIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuSW1hZ2VCaXRtYXBMb2FkZXI6IGZldGNoKCkgbm90IHN1cHBvcnRlZC4nKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5vcHRpb25zID0ge1xuXHRcdFx0XHRwcmVtdWx0aXBseUFscGhhOiAnbm9uZSdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0c2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdFx0aWYgKHVybCA9PT0gdW5kZWZpbmVkKSB1cmwgPSAnJztcblx0XHRcdGlmICh0aGlzLnBhdGggIT09IHVuZGVmaW5lZCkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xuXHRcdFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwodXJsKTtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IGNhY2hlZCA9IENhY2hlLmdldCh1cmwpO1xuXG5cdFx0XHRpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKGNhY2hlZCk7XG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0XHRcdH0sIDApO1xuXHRcdFx0XHRyZXR1cm4gY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmZXRjaE9wdGlvbnMgPSB7fTtcblx0XHRcdGZldGNoT3B0aW9ucy5jcmVkZW50aWFscyA9IHRoaXMuY3Jvc3NPcmlnaW4gPT09ICdhbm9ueW1vdXMnID8gJ3NhbWUtb3JpZ2luJyA6ICdpbmNsdWRlJztcblx0XHRcdGZldGNoT3B0aW9ucy5oZWFkZXJzID0gdGhpcy5yZXF1ZXN0SGVhZGVyO1xuXHRcdFx0ZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHRcdFx0XHRyZXR1cm4gcmVzLmJsb2IoKTtcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24gKGJsb2IpIHtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIE9iamVjdC5hc3NpZ24oc2NvcGUub3B0aW9ucywge1xuXHRcdFx0XHRcdGNvbG9yU3BhY2VDb252ZXJzaW9uOiAnbm9uZSdcblx0XHRcdFx0fSkpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoaW1hZ2VCaXRtYXApIHtcblx0XHRcdFx0Q2FjaGUuYWRkKHVybCwgaW1hZ2VCaXRtYXApO1xuXHRcdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQoaW1hZ2VCaXRtYXApO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHRcdH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmIChvbkVycm9yKSBvbkVycm9yKGUpO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHRcdH0pO1xuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcblx0XHR9XG5cblx0fVxuXG5cdEltYWdlQml0bWFwTG9hZGVyLnByb3RvdHlwZS5pc0ltYWdlQml0bWFwTG9hZGVyID0gdHJ1ZTtcblxuXHRjbGFzcyBTaGFwZVBhdGgge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0dGhpcy50eXBlID0gJ1NoYXBlUGF0aCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCk7XG5cdFx0XHR0aGlzLnN1YlBhdGhzID0gW107XG5cdFx0XHR0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcblx0XHR9XG5cblx0XHRtb3ZlVG8oeCwgeSkge1xuXHRcdFx0dGhpcy5jdXJyZW50UGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0XHR0aGlzLnN1YlBhdGhzLnB1c2godGhpcy5jdXJyZW50UGF0aCk7XG5cdFx0XHR0aGlzLmN1cnJlbnRQYXRoLm1vdmVUbyh4LCB5KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGxpbmVUbyh4LCB5KSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRQYXRoLmxpbmVUbyh4LCB5KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHF1YWRyYXRpY0N1cnZlVG8oYUNQeCwgYUNQeSwgYVgsIGFZKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRQYXRoLnF1YWRyYXRpY0N1cnZlVG8oYUNQeCwgYUNQeSwgYVgsIGFZKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGJlemllckN1cnZlVG8oYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSkge1xuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5iZXppZXJDdXJ2ZVRvKGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c3BsaW5lVGhydShwdHMpIHtcblx0XHRcdHRoaXMuY3VycmVudFBhdGguc3BsaW5lVGhydShwdHMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9TaGFwZXMoaXNDQ1csIG5vSG9sZXMpIHtcblx0XHRcdGZ1bmN0aW9uIHRvU2hhcGVzTm9Ib2xlcyhpblN1YnBhdGhzKSB7XG5cdFx0XHRcdGNvbnN0IHNoYXBlcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gaW5TdWJwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCB0bXBQYXRoID0gaW5TdWJwYXRoc1tpXTtcblx0XHRcdFx0XHRjb25zdCB0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xuXHRcdFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXHRcdFx0XHRcdHNoYXBlcy5wdXNoKHRtcFNoYXBlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzaGFwZXM7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKGluUHQsIGluUG9seWdvbikge1xuXHRcdFx0XHRjb25zdCBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDsgLy8gaW5QdCBvbiBwb2x5Z29uIGNvbnRvdXIgPT4gaW1tZWRpYXRlIHN1Y2Nlc3NcdFx0b3Jcblx0XHRcdFx0Ly8gdG9nZ2xpbmcgb2YgaW5zaWRlL291dHNpZGUgYXQgZXZlcnkgc2luZ2xlISBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgYW4gZWRnZVxuXHRcdFx0XHQvL1x0d2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XG5cdFx0XHRcdC8vXHRub3QgY291bnRpbmcgbG93ZXJZIGVuZHBvaW50cyBvZiBlZGdlcyBhbmQgd2hvbGUgZWRnZXMgb24gdGhhdCBsaW5lXG5cblx0XHRcdFx0bGV0IGluc2lkZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGZvciAobGV0IHAgPSBwb2x5TGVuIC0gMSwgcSA9IDA7IHEgPCBwb2x5TGVuOyBwID0gcSsrKSB7XG5cdFx0XHRcdFx0bGV0IGVkZ2VMb3dQdCA9IGluUG9seWdvbltwXTtcblx0XHRcdFx0XHRsZXQgZWRnZUhpZ2hQdCA9IGluUG9seWdvbltxXTtcblx0XHRcdFx0XHRsZXQgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XG5cdFx0XHRcdFx0bGV0IGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xuXG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKGVkZ2VEeSkgPiBOdW1iZXIuRVBTSUxPTikge1xuXHRcdFx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXG5cdFx0XHRcdFx0XHRpZiAoZWRnZUR5IDwgMCkge1xuXHRcdFx0XHRcdFx0XHRlZGdlTG93UHQgPSBpblBvbHlnb25bcV07XG5cdFx0XHRcdFx0XHRcdGVkZ2VEeCA9IC1lZGdlRHg7XG5cdFx0XHRcdFx0XHRcdGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bcF07XG5cdFx0XHRcdFx0XHRcdGVkZ2VEeSA9IC1lZGdlRHk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChpblB0LnkgPCBlZGdlTG93UHQueSB8fCBpblB0LnkgPiBlZGdlSGlnaFB0LnkpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpZiAoaW5QdC55ID09PSBlZGdlTG93UHQueSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5QdC54ID09PSBlZGdlTG93UHQueCkgcmV0dXJuIHRydWU7IC8vIGluUHQgaXMgb24gY29udG91ciA/XG5cdFx0XHRcdFx0XHRcdC8vIGNvbnRpbnVlO1x0XHRcdFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcGVycEVkZ2UgPSBlZGdlRHkgKiAoaW5QdC54IC0gZWRnZUxvd1B0LngpIC0gZWRnZUR4ICogKGluUHQueSAtIGVkZ2VMb3dQdC55KTtcblx0XHRcdFx0XHRcdFx0aWYgKHBlcnBFZGdlID09PSAwKSByZXR1cm4gdHJ1ZTsgLy8gaW5QdCBpcyBvbiBjb250b3VyID9cblxuXHRcdFx0XHRcdFx0XHRpZiAocGVycEVkZ2UgPCAwKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTsgLy8gdHJ1ZSBpbnRlcnNlY3Rpb24gbGVmdCBvZiBpblB0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuXHRcdFx0XHRcdFx0aWYgKGluUHQueSAhPT0gZWRnZUxvd1B0LnkpIGNvbnRpbnVlOyAvLyBwYXJhbGxlbFxuXHRcdFx0XHRcdFx0Ly8gZWRnZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XG5cblx0XHRcdFx0XHRcdGlmIChlZGdlSGlnaFB0LnggPD0gaW5QdC54ICYmIGluUHQueCA8PSBlZGdlTG93UHQueCB8fCBlZGdlTG93UHQueCA8PSBpblB0LnggJiYgaW5QdC54IDw9IGVkZ2VIaWdoUHQueCkgcmV0dXJuIHRydWU7IC8vIGluUHQ6IFBvaW50IG9uIGNvbnRvdXIgIVxuXHRcdFx0XHRcdFx0Ly8gY29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGluc2lkZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaXNDbG9ja1dpc2UgPSBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlO1xuXHRcdFx0Y29uc3Qgc3ViUGF0aHMgPSB0aGlzLnN1YlBhdGhzO1xuXHRcdFx0aWYgKHN1YlBhdGhzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuXHRcdFx0aWYgKG5vSG9sZXMgPT09IHRydWUpIHJldHVybiB0b1NoYXBlc05vSG9sZXMoc3ViUGF0aHMpO1xuXHRcdFx0bGV0IHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IFtdO1xuXG5cdFx0XHRpZiAoc3ViUGF0aHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHRtcFBhdGggPSBzdWJQYXRoc1swXTtcblx0XHRcdFx0dG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcblx0XHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cdFx0XHRcdHNoYXBlcy5wdXNoKHRtcFNoYXBlKTtcblx0XHRcdFx0cmV0dXJuIHNoYXBlcztcblx0XHRcdH1cblxuXHRcdFx0bGV0IGhvbGVzRmlyc3QgPSAhaXNDbG9ja1dpc2Uoc3ViUGF0aHNbMF0uZ2V0UG9pbnRzKCkpO1xuXHRcdFx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gIWhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0OyAvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xuXG5cdFx0XHRjb25zdCBiZXR0ZXJTaGFwZUhvbGVzID0gW107XG5cdFx0XHRjb25zdCBuZXdTaGFwZXMgPSBbXTtcblx0XHRcdGxldCBuZXdTaGFwZUhvbGVzID0gW107XG5cdFx0XHRsZXQgbWFpbklkeCA9IDA7XG5cdFx0XHRsZXQgdG1wUG9pbnRzO1xuXHRcdFx0bmV3U2hhcGVzW21haW5JZHhdID0gdW5kZWZpbmVkO1xuXHRcdFx0bmV3U2hhcGVIb2xlc1ttYWluSWR4XSA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbaV07XG5cdFx0XHRcdHRtcFBvaW50cyA9IHRtcFBhdGguZ2V0UG9pbnRzKCk7XG5cdFx0XHRcdHNvbGlkID0gaXNDbG9ja1dpc2UodG1wUG9pbnRzKTtcblx0XHRcdFx0c29saWQgPSBpc0NDVyA/ICFzb2xpZCA6IHNvbGlkO1xuXG5cdFx0XHRcdGlmIChzb2xpZCkge1xuXHRcdFx0XHRcdGlmICghaG9sZXNGaXJzdCAmJiBuZXdTaGFwZXNbbWFpbklkeF0pIG1haW5JZHgrKztcblx0XHRcdFx0XHRuZXdTaGFwZXNbbWFpbklkeF0gPSB7XG5cdFx0XHRcdFx0XHRzOiBuZXcgU2hhcGUoKSxcblx0XHRcdFx0XHRcdHA6IHRtcFBvaW50c1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0bmV3U2hhcGVzW21haW5JZHhdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cdFx0XHRcdFx0aWYgKGhvbGVzRmlyc3QpIG1haW5JZHgrKztcblx0XHRcdFx0XHRuZXdTaGFwZUhvbGVzW21haW5JZHhdID0gW107IC8vY29uc29sZS5sb2coJ2N3JywgaSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3U2hhcGVIb2xlc1ttYWluSWR4XS5wdXNoKHtcblx0XHRcdFx0XHRcdGg6IHRtcFBhdGgsXG5cdFx0XHRcdFx0XHRwOiB0bXBQb2ludHNbMF1cblx0XHRcdFx0XHR9KTsgLy9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXG5cblxuXHRcdFx0aWYgKCFuZXdTaGFwZXNbMF0pIHJldHVybiB0b1NoYXBlc05vSG9sZXMoc3ViUGF0aHMpO1xuXG5cdFx0XHRpZiAobmV3U2hhcGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0bGV0IGFtYmlndW91cyA9IGZhbHNlO1xuXHRcdFx0XHRjb25zdCB0b0NoYW5nZSA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHgrKykge1xuXHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbc0lkeF0gPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAobGV0IHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHgrKykge1xuXHRcdFx0XHRcdGNvbnN0IHNobyA9IG5ld1NoYXBlSG9sZXNbc0lkeF07XG5cblx0XHRcdFx0XHRmb3IgKGxldCBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHgrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgaG8gPSBzaG9baElkeF07XG5cdFx0XHRcdFx0XHRsZXQgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4KyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKGlzUG9pbnRJbnNpZGVQb2x5Z29uKGhvLnAsIG5ld1NoYXBlc1tzMklkeF0ucCkpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc0lkeCAhPT0gczJJZHgpIHRvQ2hhbmdlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdFx0ZnJvbXM6IHNJZHgsXG5cdFx0XHRcdFx0XHRcdFx0XHR0b3M6IHMySWR4LFxuXHRcdFx0XHRcdFx0XHRcdFx0aG9sZTogaElkeFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGhvbGVfdW5hc3NpZ25lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aG9sZV91bmFzc2lnbmVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzW3MySWR4XS5wdXNoKGhvKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0YW1iaWd1b3VzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGhvbGVfdW5hc3NpZ25lZCkge1xuXHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzW3NJZHhdLnB1c2goaG8pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSAvLyBjb25zb2xlLmxvZyhcImFtYmlndW91czogXCIsIGFtYmlndW91cyk7XG5cblxuXHRcdFx0XHRpZiAodG9DaGFuZ2UubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidG8gY2hhbmdlOiBcIiwgdG9DaGFuZ2UpO1xuXHRcdFx0XHRcdGlmICghYW1iaWd1b3VzKSBuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgdG1wSG9sZXM7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG5ld1NoYXBlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdHRtcFNoYXBlID0gbmV3U2hhcGVzW2ldLnM7XG5cdFx0XHRcdHNoYXBlcy5wdXNoKHRtcFNoYXBlKTtcblx0XHRcdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzW2ldO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcblx0XHRcdFx0XHR0bXBTaGFwZS5ob2xlcy5wdXNoKHRtcEhvbGVzW2pdLmgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xuXG5cblx0XHRcdHJldHVybiBzaGFwZXM7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBGb250IHtcblx0XHRjb25zdHJ1Y3RvcihkYXRhKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAnRm9udCc7XG5cdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdH1cblxuXHRcdGdlbmVyYXRlU2hhcGVzKHRleHQsIHNpemUgPSAxMDApIHtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IFtdO1xuXHRcdFx0Y29uc3QgcGF0aHMgPSBjcmVhdGVQYXRocyh0ZXh0LCBzaXplLCB0aGlzLmRhdGEpO1xuXG5cdFx0XHRmb3IgKGxldCBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCsrKSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHNoYXBlcywgcGF0aHNbcF0udG9TaGFwZXMoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzaGFwZXM7XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRocyh0ZXh0LCBzaXplLCBkYXRhKSB7XG5cdFx0Y29uc3QgY2hhcnMgPSBBcnJheS5mcm9tKHRleHQpO1xuXHRcdGNvbnN0IHNjYWxlID0gc2l6ZSAvIGRhdGEucmVzb2x1dGlvbjtcblx0XHRjb25zdCBsaW5lX2hlaWdodCA9IChkYXRhLmJvdW5kaW5nQm94LnlNYXggLSBkYXRhLmJvdW5kaW5nQm94LnlNaW4gKyBkYXRhLnVuZGVybGluZVRoaWNrbmVzcykgKiBzY2FsZTtcblx0XHRjb25zdCBwYXRocyA9IFtdO1xuXHRcdGxldCBvZmZzZXRYID0gMCxcblx0XHRcdFx0b2Zmc2V0WSA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjaGFyID0gY2hhcnNbaV07XG5cblx0XHRcdGlmIChjaGFyID09PSAnXFxuJykge1xuXHRcdFx0XHRvZmZzZXRYID0gMDtcblx0XHRcdFx0b2Zmc2V0WSAtPSBsaW5lX2hlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHJldCA9IGNyZWF0ZVBhdGgoY2hhciwgc2NhbGUsIG9mZnNldFgsIG9mZnNldFksIGRhdGEpO1xuXHRcdFx0XHRvZmZzZXRYICs9IHJldC5vZmZzZXRYO1xuXHRcdFx0XHRwYXRocy5wdXNoKHJldC5wYXRoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRoKGNoYXIsIHNjYWxlLCBvZmZzZXRYLCBvZmZzZXRZLCBkYXRhKSB7XG5cdFx0Y29uc3QgZ2x5cGggPSBkYXRhLmdseXBoc1tjaGFyXSB8fCBkYXRhLmdseXBoc1snPyddO1xuXG5cdFx0aWYgKCFnbHlwaCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuRm9udDogY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgZG9lcyBub3QgZXhpc3RzIGluIGZvbnQgZmFtaWx5ICcgKyBkYXRhLmZhbWlseU5hbWUgKyAnLicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG5cdFx0bGV0IHgsIHksIGNweCwgY3B5LCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyO1xuXG5cdFx0aWYgKGdseXBoLm8pIHtcblx0XHRcdGNvbnN0IG91dGxpbmUgPSBnbHlwaC5fY2FjaGVkT3V0bGluZSB8fCAoZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCcgJykpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IG91dGxpbmUubGVuZ3RoOyBpIDwgbDspIHtcblx0XHRcdFx0Y29uc3QgYWN0aW9uID0gb3V0bGluZVtpKytdO1xuXG5cdFx0XHRcdHN3aXRjaCAoYWN0aW9uKSB7XG5cdFx0XHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRcdFx0XHQvLyBtb3ZlVG9cblx0XHRcdFx0XHRcdHggPSBvdXRsaW5lW2krK10gKiBzY2FsZSArIG9mZnNldFg7XG5cdFx0XHRcdFx0XHR5ID0gb3V0bGluZVtpKytdICogc2NhbGUgKyBvZmZzZXRZO1xuXHRcdFx0XHRcdFx0cGF0aC5tb3ZlVG8oeCwgeSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHRcdFx0Ly8gbGluZVRvXG5cdFx0XHRcdFx0XHR4ID0gb3V0bGluZVtpKytdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0eSA9IG91dGxpbmVbaSsrXSAqIHNjYWxlICsgb2Zmc2V0WTtcblx0XHRcdFx0XHRcdHBhdGgubGluZVRvKHgsIHkpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdxJzpcblx0XHRcdFx0XHRcdC8vIHF1YWRyYXRpY0N1cnZlVG9cblx0XHRcdFx0XHRcdGNweCA9IG91dGxpbmVbaSsrXSAqIHNjYWxlICsgb2Zmc2V0WDtcblx0XHRcdFx0XHRcdGNweSA9IG91dGxpbmVbaSsrXSAqIHNjYWxlICsgb2Zmc2V0WTtcblx0XHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lW2krK10gKiBzY2FsZSArIG9mZnNldFg7XG5cdFx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVtpKytdICogc2NhbGUgKyBvZmZzZXRZO1xuXHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKGNweDEsIGNweTEsIGNweCwgY3B5KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdFx0XHQvLyBiZXppZXJDdXJ2ZVRvXG5cdFx0XHRcdFx0XHRjcHggPSBvdXRsaW5lW2krK10gKiBzY2FsZSArIG9mZnNldFg7XG5cdFx0XHRcdFx0XHRjcHkgPSBvdXRsaW5lW2krK10gKiBzY2FsZSArIG9mZnNldFk7XG5cdFx0XHRcdFx0XHRjcHgxID0gb3V0bGluZVtpKytdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0Y3B5MSA9IG91dGxpbmVbaSsrXSAqIHNjYWxlICsgb2Zmc2V0WTtcblx0XHRcdFx0XHRcdGNweDIgPSBvdXRsaW5lW2krK10gKiBzY2FsZSArIG9mZnNldFg7XG5cdFx0XHRcdFx0XHRjcHkyID0gb3V0bGluZVtpKytdICogc2NhbGUgKyBvZmZzZXRZO1xuXHRcdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKGNweDEsIGNweTEsIGNweDIsIGNweTIsIGNweCwgY3B5KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG9mZnNldFg6IGdseXBoLmhhICogc2NhbGUsXG5cdFx0XHRwYXRoOiBwYXRoXG5cdFx0fTtcblx0fVxuXG5cdEZvbnQucHJvdG90eXBlLmlzRm9udCA9IHRydWU7XG5cblx0Y2xhc3MgRm9udExvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdFx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdFx0c3VwZXIobWFuYWdlcik7XG5cdFx0fVxuXG5cdFx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcblx0XHRcdGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG5cdFx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyhzY29wZS53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdFx0bG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAodGV4dCkge1xuXHRcdFx0XHRsZXQganNvbjtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKHRleHQpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Gb250TG9hZGVyOiB0eXBlZmFjZS5qcyBzdXBwb3J0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSB0eXBlZmFjZS5qc29uIGluc3RlYWQuJyk7XG5cdFx0XHRcdFx0anNvbiA9IEpTT04ucGFyc2UodGV4dC5zdWJzdHJpbmcoNjUsIHRleHQubGVuZ3RoIC0gMikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZm9udCA9IHNjb3BlLnBhcnNlKGpzb24pO1xuXHRcdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQoZm9udCk7XG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yKTtcblx0XHR9XG5cblx0XHRwYXJzZShqc29uKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEZvbnQoanNvbik7XG5cdFx0fVxuXG5cdH1cblxuXHRsZXQgX2NvbnRleHQ7XG5cblx0Y29uc3QgQXVkaW9Db250ZXh0ID0ge1xuXHRcdGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChfY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdF9jb250ZXh0ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBfY29udGV4dDtcblx0XHR9LFxuXHRcdHNldENvbnRleHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0X2NvbnRleHQgPSB2YWx1ZTtcblx0XHR9XG5cdH07XG5cblx0Y2xhc3MgQXVkaW9Mb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRcdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRcdHN1cGVyKG1hbmFnZXIpO1xuXHRcdH1cblxuXHRcdGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcblx0XHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGJ1ZmZlci4gVGhlIGBkZWNvZGVBdWRpb0RhdGFgIG1ldGhvZFxuXHRcdFx0XHRcdC8vIGRldGFjaGVzIHRoZSBidWZmZXIgd2hlbiBjb21wbGV0ZSwgcHJldmVudGluZyByZXVzZS5cblx0XHRcdFx0XHRjb25zdCBidWZmZXJDb3B5ID0gYnVmZmVyLnNsaWNlKDApO1xuXHRcdFx0XHRcdGNvbnN0IGNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xuXHRcdFx0XHRcdGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGJ1ZmZlckNvcHksIGZ1bmN0aW9uIChhdWRpb0J1ZmZlcikge1xuXHRcdFx0XHRcdFx0b25Mb2FkKGF1ZGlvQnVmZmVyKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGlmIChvbkVycm9yKSB7XG5cdFx0XHRcdFx0XHRvbkVycm9yKGUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSGVtaXNwaGVyZUxpZ2h0UHJvYmUgZXh0ZW5kcyBMaWdodFByb2JlIHtcblx0XHRjb25zdHJ1Y3Rvcihza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSA9IDEpIHtcblx0XHRcdHN1cGVyKHVuZGVmaW5lZCwgaW50ZW5zaXR5KTtcblx0XHRcdGNvbnN0IGNvbG9yMSA9IG5ldyBDb2xvcigpLnNldChza3lDb2xvcik7XG5cdFx0XHRjb25zdCBjb2xvcjIgPSBuZXcgQ29sb3IoKS5zZXQoZ3JvdW5kQ29sb3IpO1xuXHRcdFx0Y29uc3Qgc2t5ID0gbmV3IFZlY3RvcjMoY29sb3IxLnIsIGNvbG9yMS5nLCBjb2xvcjEuYik7XG5cdFx0XHRjb25zdCBncm91bmQgPSBuZXcgVmVjdG9yMyhjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iKTsgLy8gd2l0aG91dCBleHRyYSBmYWN0b3Igb2YgUEkgaW4gdGhlIHNoYWRlciwgc2hvdWxkID0gMSAvIE1hdGguc3FydCggTWF0aC5QSSApO1xuXG5cdFx0XHRjb25zdCBjMCA9IE1hdGguc3FydChNYXRoLlBJKTtcblx0XHRcdGNvbnN0IGMxID0gYzAgKiBNYXRoLnNxcnQoMC43NSk7XG5cdFx0XHR0aGlzLnNoLmNvZWZmaWNpZW50c1swXS5jb3B5KHNreSkuYWRkKGdyb3VuZCkubXVsdGlwbHlTY2FsYXIoYzApO1xuXHRcdFx0dGhpcy5zaC5jb2VmZmljaWVudHNbMV0uY29weShza3kpLnN1Yihncm91bmQpLm11bHRpcGx5U2NhbGFyKGMxKTtcblx0XHR9XG5cblx0fVxuXG5cdEhlbWlzcGhlcmVMaWdodFByb2JlLnByb3RvdHlwZS5pc0hlbWlzcGhlcmVMaWdodFByb2JlID0gdHJ1ZTtcblxuXHRjbGFzcyBBbWJpZW50TGlnaHRQcm9iZSBleHRlbmRzIExpZ2h0UHJvYmUge1xuXHRcdGNvbnN0cnVjdG9yKGNvbG9yLCBpbnRlbnNpdHkgPSAxKSB7XG5cdFx0XHRzdXBlcih1bmRlZmluZWQsIGludGVuc2l0eSk7XG5cdFx0XHRjb25zdCBjb2xvcjEgPSBuZXcgQ29sb3IoKS5zZXQoY29sb3IpOyAvLyB3aXRob3V0IGV4dHJhIGZhY3RvciBvZiBQSSBpbiB0aGUgc2hhZGVyLCB3b3VsZCBiZSAyIC8gTWF0aC5zcXJ0KCBNYXRoLlBJICk7XG5cblx0XHRcdHRoaXMuc2guY29lZmZpY2llbnRzWzBdLnNldChjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iKS5tdWx0aXBseVNjYWxhcigyICogTWF0aC5zcXJ0KE1hdGguUEkpKTtcblx0XHR9XG5cblx0fVxuXG5cdEFtYmllbnRMaWdodFByb2JlLnByb3RvdHlwZS5pc0FtYmllbnRMaWdodFByb2JlID0gdHJ1ZTtcblxuXHRjb25zdCBfZXllUmlnaHQgPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfZXllTGVmdCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNsYXNzIFN0ZXJlb0NhbWVyYSB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcblx0XHRcdHRoaXMuYXNwZWN0ID0gMTtcblx0XHRcdHRoaXMuZXllU2VwID0gMC4wNjQ7XG5cdFx0XHR0aGlzLmNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHRcdHRoaXMuY2FtZXJhTC5sYXllcnMuZW5hYmxlKDEpO1xuXHRcdFx0dGhpcy5jYW1lcmFMLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuY2FtZXJhUiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHRcdFx0dGhpcy5jYW1lcmFSLmxheWVycy5lbmFibGUoMik7XG5cdFx0XHR0aGlzLmNhbWVyYVIubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fY2FjaGUgPSB7XG5cdFx0XHRcdGZvY3VzOiBudWxsLFxuXHRcdFx0XHRmb3Y6IG51bGwsXG5cdFx0XHRcdGFzcGVjdDogbnVsbCxcblx0XHRcdFx0bmVhcjogbnVsbCxcblx0XHRcdFx0ZmFyOiBudWxsLFxuXHRcdFx0XHR6b29tOiBudWxsLFxuXHRcdFx0XHRleWVTZXA6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dXBkYXRlKGNhbWVyYSkge1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZTtcblx0XHRcdGNvbnN0IG5lZWRzVXBkYXRlID0gY2FjaGUuZm9jdXMgIT09IGNhbWVyYS5mb2N1cyB8fCBjYWNoZS5mb3YgIT09IGNhbWVyYS5mb3YgfHwgY2FjaGUuYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3QgfHwgY2FjaGUubmVhciAhPT0gY2FtZXJhLm5lYXIgfHwgY2FjaGUuZmFyICE9PSBjYW1lcmEuZmFyIHx8IGNhY2hlLnpvb20gIT09IGNhbWVyYS56b29tIHx8IGNhY2hlLmV5ZVNlcCAhPT0gdGhpcy5leWVTZXA7XG5cblx0XHRcdGlmIChuZWVkc1VwZGF0ZSkge1xuXHRcdFx0XHRjYWNoZS5mb2N1cyA9IGNhbWVyYS5mb2N1cztcblx0XHRcdFx0Y2FjaGUuZm92ID0gY2FtZXJhLmZvdjtcblx0XHRcdFx0Y2FjaGUuYXNwZWN0ID0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0O1xuXHRcdFx0XHRjYWNoZS5uZWFyID0gY2FtZXJhLm5lYXI7XG5cdFx0XHRcdGNhY2hlLmZhciA9IGNhbWVyYS5mYXI7XG5cdFx0XHRcdGNhY2hlLnpvb20gPSBjYW1lcmEuem9vbTtcblx0XHRcdFx0Y2FjaGUuZXllU2VwID0gdGhpcy5leWVTZXA7IC8vIE9mZi1heGlzIHN0ZXJlb3Njb3BpYyBlZmZlY3QgYmFzZWQgb25cblx0XHRcdFx0Ly8gaHR0cDovL3BhdWxib3Vya2UubmV0L3N0ZXJlb2dyYXBoaWNzL3N0ZXJlb3JlbmRlci9cblxuXHRcdFx0XHRjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY2xvbmUoKTtcblx0XHRcdFx0Y29uc3QgZXllU2VwSGFsZiA9IGNhY2hlLmV5ZVNlcCAvIDI7XG5cdFx0XHRcdGNvbnN0IGV5ZVNlcE9uUHJvamVjdGlvbiA9IGV5ZVNlcEhhbGYgKiBjYWNoZS5uZWFyIC8gY2FjaGUuZm9jdXM7XG5cdFx0XHRcdGNvbnN0IHltYXggPSBjYWNoZS5uZWFyICogTWF0aC50YW4oREVHMlJBRCAqIGNhY2hlLmZvdiAqIDAuNSkgLyBjYWNoZS56b29tO1xuXHRcdFx0XHRsZXQgeG1pbiwgeG1heDsgLy8gdHJhbnNsYXRlIHhPZmZzZXRcblxuXHRcdFx0XHRfZXllTGVmdC5lbGVtZW50c1sxMl0gPSAtZXllU2VwSGFsZjtcblx0XHRcdFx0X2V5ZVJpZ2h0LmVsZW1lbnRzWzEyXSA9IGV5ZVNlcEhhbGY7IC8vIGZvciBsZWZ0IGV5ZVxuXG5cdFx0XHRcdHhtaW4gPSAteW1heCAqIGNhY2hlLmFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdFx0eG1heCA9IHltYXggKiBjYWNoZS5hc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMF0gPSAyICogY2FjaGUubmVhciAvICh4bWF4IC0geG1pbik7XG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbOF0gPSAoeG1heCArIHhtaW4pIC8gKHhtYXggLSB4bWluKTtcblx0XHRcdFx0dGhpcy5jYW1lcmFMLnByb2plY3Rpb25NYXRyaXguY29weShwcm9qZWN0aW9uTWF0cml4KTsgLy8gZm9yIHJpZ2h0IGV5ZVxuXG5cdFx0XHRcdHhtaW4gPSAteW1heCAqIGNhY2hlLmFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdFx0eG1heCA9IHltYXggKiBjYWNoZS5hc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMF0gPSAyICogY2FjaGUubmVhciAvICh4bWF4IC0geG1pbik7XG5cdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbOF0gPSAoeG1heCArIHhtaW4pIC8gKHhtYXggLSB4bWluKTtcblx0XHRcdFx0dGhpcy5jYW1lcmFSLnByb2plY3Rpb25NYXRyaXguY29weShwcm9qZWN0aW9uTWF0cml4KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkoY2FtZXJhLm1hdHJpeFdvcmxkKS5tdWx0aXBseShfZXllTGVmdCk7XG5cdFx0XHR0aGlzLmNhbWVyYVIubWF0cml4V29ybGQuY29weShjYW1lcmEubWF0cml4V29ybGQpLm11bHRpcGx5KF9leWVSaWdodCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBDbG9jayB7XG5cdFx0Y29uc3RydWN0b3IoYXV0b1N0YXJ0ID0gdHJ1ZSkge1xuXHRcdFx0dGhpcy5hdXRvU3RhcnQgPSBhdXRvU3RhcnQ7XG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdFx0XHR0aGlzLm9sZFRpbWUgPSAwO1xuXHRcdFx0dGhpcy5lbGFwc2VkVGltZSA9IDA7XG5cdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRzdGFydCgpIHtcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gbm93KCk7XG5cdFx0XHR0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcblx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRzdG9wKCkge1xuXHRcdFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGdldEVsYXBzZWRUaW1lKCkge1xuXHRcdFx0dGhpcy5nZXREZWx0YSgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cdFx0fVxuXG5cdFx0Z2V0RGVsdGEoKSB7XG5cdFx0XHRsZXQgZGlmZiA9IDA7XG5cblx0XHRcdGlmICh0aGlzLmF1dG9TdGFydCAmJiAhdGhpcy5ydW5uaW5nKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnQoKTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLnJ1bm5pbmcpIHtcblx0XHRcdFx0Y29uc3QgbmV3VGltZSA9IG5vdygpO1xuXHRcdFx0XHRkaWZmID0gKG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUpIC8gMTAwMDtcblx0XHRcdFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcblx0XHRcdFx0dGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlmZjtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG5vdygpIHtcblx0XHRyZXR1cm4gKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlIDogcGVyZm9ybWFuY2UpLm5vdygpOyAvLyBzZWUgIzEwNzMyXG5cdH1cblxuXHRjb25zdCBfcG9zaXRpb24kMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9xdWF0ZXJuaW9uJDEgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcblxuXHRjb25zdCBfc2NhbGUkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9vcmllbnRhdGlvbiQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgQXVkaW9MaXN0ZW5lciBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQXVkaW9MaXN0ZW5lcic7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xuXHRcdFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0XHRcdHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0XHR0aGlzLmZpbHRlciA9IG51bGw7XG5cdFx0XHR0aGlzLnRpbWVEZWx0YSA9IDA7IC8vIHByaXZhdGVcblxuXHRcdFx0dGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2soKTtcblx0XHR9XG5cblx0XHRnZXRJbnB1dCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdhaW47XG5cdFx0fVxuXG5cdFx0cmVtb3ZlRmlsdGVyKCkge1xuXHRcdFx0aWYgKHRoaXMuZmlsdGVyICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuZmlsdGVyKTtcblx0XHRcdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdFx0XHR0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdFx0XHR0aGlzLmZpbHRlciA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldEZpbHRlcigpIHtcblx0XHRcdHJldHVybiB0aGlzLmZpbHRlcjtcblx0XHR9XG5cblx0XHRzZXRGaWx0ZXIodmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLmZpbHRlciAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCh0aGlzLmZpbHRlcik7XG5cdFx0XHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZmlsdGVyID0gdmFsdWU7XG5cdFx0XHR0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmZpbHRlcik7XG5cdFx0XHR0aGlzLmZpbHRlci5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRNYXN0ZXJWb2x1bWUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cdFx0fVxuXG5cdFx0c2V0TWFzdGVyVm9sdW1lKHZhbHVlKSB7XG5cdFx0XHR0aGlzLmdhaW4uZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodmFsdWUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdFx0Y29uc3QgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XG5cdFx0XHRjb25zdCB1cCA9IHRoaXMudXA7XG5cdFx0XHR0aGlzLnRpbWVEZWx0YSA9IHRoaXMuX2Nsb2NrLmdldERlbHRhKCk7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShfcG9zaXRpb24kMSwgX3F1YXRlcm5pb24kMSwgX3NjYWxlJDEpO1xuXG5cdFx0XHRfb3JpZW50YXRpb24kMS5zZXQoMCwgMCwgLTEpLmFwcGx5UXVhdGVybmlvbihfcXVhdGVybmlvbiQxKTtcblxuXHRcdFx0aWYgKGxpc3RlbmVyLnBvc2l0aW9uWCkge1xuXHRcdFx0XHQvLyBjb2RlIHBhdGggZm9yIENocm9tZSAoc2VlICMxNDM5Mylcblx0XHRcdFx0Y29uc3QgZW5kVGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIHRoaXMudGltZURlbHRhO1xuXHRcdFx0XHRsaXN0ZW5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX3Bvc2l0aW9uJDEueCwgZW5kVGltZSk7XG5cdFx0XHRcdGxpc3RlbmVyLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfcG9zaXRpb24kMS55LCBlbmRUaW1lKTtcblx0XHRcdFx0bGlzdGVuZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbiQxLnosIGVuZFRpbWUpO1xuXHRcdFx0XHRsaXN0ZW5lci5mb3J3YXJkWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfb3JpZW50YXRpb24kMS54LCBlbmRUaW1lKTtcblx0XHRcdFx0bGlzdGVuZXIuZm9yd2FyZFkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX29yaWVudGF0aW9uJDEueSwgZW5kVGltZSk7XG5cdFx0XHRcdGxpc3RlbmVyLmZvcndhcmRaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9vcmllbnRhdGlvbiQxLnosIGVuZFRpbWUpO1xuXHRcdFx0XHRsaXN0ZW5lci51cFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodXAueCwgZW5kVGltZSk7XG5cdFx0XHRcdGxpc3RlbmVyLnVwWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh1cC55LCBlbmRUaW1lKTtcblx0XHRcdFx0bGlzdGVuZXIudXBaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHVwLnosIGVuZFRpbWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGlzdGVuZXIuc2V0UG9zaXRpb24oX3Bvc2l0aW9uJDEueCwgX3Bvc2l0aW9uJDEueSwgX3Bvc2l0aW9uJDEueik7XG5cdFx0XHRcdGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKF9vcmllbnRhdGlvbiQxLngsIF9vcmllbnRhdGlvbiQxLnksIF9vcmllbnRhdGlvbiQxLnosIHVwLngsIHVwLnksIHVwLnopO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQXVkaW8gZXh0ZW5kcyBPYmplY3QzRCB7XG5cdFx0Y29uc3RydWN0b3IobGlzdGVuZXIpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQXVkaW8nO1xuXHRcdFx0dGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcblx0XHRcdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdFx0XHR0aGlzLmdhaW4uY29ubmVjdChsaXN0ZW5lci5nZXRJbnB1dCgpKTtcblx0XHRcdHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcblx0XHRcdHRoaXMuYnVmZmVyID0gbnVsbDtcblx0XHRcdHRoaXMuZGV0dW5lID0gMDtcblx0XHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5sb29wU3RhcnQgPSAwO1xuXHRcdFx0dGhpcy5sb29wRW5kID0gMDtcblx0XHRcdHRoaXMub2Zmc2V0ID0gMDtcblx0XHRcdHRoaXMuZHVyYXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XG5cdFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSB0cnVlO1xuXHRcdFx0dGhpcy5zb3VyY2UgPSBudWxsO1xuXHRcdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2VtcHR5Jztcblx0XHRcdHRoaXMuX3N0YXJ0ZWRBdCA9IDA7XG5cdFx0XHR0aGlzLl9wcm9ncmVzcyA9IDA7XG5cdFx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuZmlsdGVycyA9IFtdO1xuXHRcdH1cblxuXHRcdGdldE91dHB1dCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdhaW47XG5cdFx0fVxuXG5cdFx0c2V0Tm9kZVNvdXJjZShhdWRpb05vZGUpIHtcblx0XHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYXVkaW9Ob2RlJztcblx0XHRcdHRoaXMuc291cmNlID0gYXVkaW9Ob2RlO1xuXHRcdFx0dGhpcy5jb25uZWN0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRNZWRpYUVsZW1lbnRTb3VyY2UobWVkaWFFbGVtZW50KSB7XG5cdFx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zb3VyY2VUeXBlID0gJ21lZGlhTm9kZSc7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UobWVkaWFFbGVtZW50KTtcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0TWVkaWFTdHJlYW1Tb3VyY2UobWVkaWFTdHJlYW0pIHtcblx0XHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnbWVkaWFTdHJlYW1Ob2RlJztcblx0XHRcdHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG1lZGlhU3RyZWFtKTtcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0QnVmZmVyKGF1ZGlvQnVmZmVyKSB7XG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xuXHRcdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2J1ZmZlcic7XG5cdFx0XHRpZiAodGhpcy5hdXRvcGxheSkgdGhpcy5wbGF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRwbGF5KGRlbGF5ID0gMCkge1xuXHRcdFx0aWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICsgZGVsYXk7XG5cdFx0XHRjb25zdCBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdFx0XHRzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cdFx0XHRzb3VyY2UubG9vcCA9IHRoaXMubG9vcDtcblx0XHRcdHNvdXJjZS5sb29wU3RhcnQgPSB0aGlzLmxvb3BTdGFydDtcblx0XHRcdHNvdXJjZS5sb29wRW5kID0gdGhpcy5sb29wRW5kO1xuXHRcdFx0c291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCh0aGlzKTtcblx0XHRcdHNvdXJjZS5zdGFydCh0aGlzLl9zdGFydGVkQXQsIHRoaXMuX3Byb2dyZXNzICsgdGhpcy5vZmZzZXQsIHRoaXMuZHVyYXRpb24pO1xuXHRcdFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cdFx0XHR0aGlzLnNldERldHVuZSh0aGlzLmRldHVuZSk7XG5cdFx0XHR0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBsYXliYWNrUmF0ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb25uZWN0KCk7XG5cdFx0fVxuXG5cdFx0cGF1c2UoKSB7XG5cdFx0XHRpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIHVwZGF0ZSBjdXJyZW50IHByb2dyZXNzXG5cdFx0XHRcdHRoaXMuX3Byb2dyZXNzICs9IE1hdGgubWF4KHRoaXMuY29udGV4dC5jdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0ZWRBdCwgMCkgKiB0aGlzLnBsYXliYWNrUmF0ZTtcblxuXHRcdFx0XHRpZiAodGhpcy5sb29wID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0Ly8gZW5zdXJlIF9wcm9ncmVzcyBkb2VzIG5vdCBleGNlZWQgZHVyYXRpb24gd2l0aCBsb29wZWQgYXVkaW9zXG5cdFx0XHRcdFx0dGhpcy5fcHJvZ3Jlc3MgPSB0aGlzLl9wcm9ncmVzcyAlICh0aGlzLmR1cmF0aW9uIHx8IHRoaXMuYnVmZmVyLmR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc291cmNlLnN0b3AoKTtcblx0XHRcdFx0dGhpcy5zb3VyY2Uub25lbmRlZCA9IG51bGw7XG5cdFx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHN0b3AoKSB7XG5cdFx0XHRpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcHJvZ3Jlc3MgPSAwO1xuXHRcdFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xuXHRcdFx0dGhpcy5zb3VyY2Uub25lbmRlZCA9IG51bGw7XG5cdFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29ubmVjdCgpIHtcblx0XHRcdGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuZmlsdGVyc1swXSk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5maWx0ZXJzW2kgLSAxXS5jb25uZWN0KHRoaXMuZmlsdGVyc1tpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmZpbHRlcnNbdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGlzY29ubmVjdCgpIHtcblx0XHRcdGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KHRoaXMuZmlsdGVyc1swXSk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5maWx0ZXJzW2kgLSAxXS5kaXNjb25uZWN0KHRoaXMuZmlsdGVyc1tpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmZpbHRlcnNbdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDFdLmRpc2Nvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldEZpbHRlcnMoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maWx0ZXJzO1xuXHRcdH1cblxuXHRcdHNldEZpbHRlcnModmFsdWUpIHtcblx0XHRcdGlmICghdmFsdWUpIHZhbHVlID0gW107XG5cblx0XHRcdGlmICh0aGlzLl9jb25uZWN0ZWQgPT09IHRydWUpIHtcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cdFx0XHRcdHRoaXMuZmlsdGVycyA9IHZhbHVlLnNsaWNlKCk7XG5cdFx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWUuc2xpY2UoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RGV0dW5lKHZhbHVlKSB7XG5cdFx0XHR0aGlzLmRldHVuZSA9IHZhbHVlO1xuXHRcdFx0aWYgKHRoaXMuc291cmNlLmRldHVuZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG9ubHkgc2V0IGRldHVuZSB3aGVuIGF2YWlsYWJsZVxuXG5cdFx0XHRpZiAodGhpcy5pc1BsYXlpbmcgPT09IHRydWUpIHtcblx0XHRcdFx0dGhpcy5zb3VyY2UuZGV0dW5lLnNldFRhcmdldEF0VGltZSh0aGlzLmRldHVuZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0RGV0dW5lKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGV0dW5lO1xuXHRcdH1cblxuXHRcdGdldEZpbHRlcigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEZpbHRlcnMoKVswXTtcblx0XHR9XG5cblx0XHRzZXRGaWx0ZXIoZmlsdGVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKGZpbHRlciA/IFtmaWx0ZXJdIDogW10pO1xuXHRcdH1cblxuXHRcdHNldFBsYXliYWNrUmF0ZSh2YWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XG5cblx0XHRcdGlmICh0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VGFyZ2V0QXRUaW1lKHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsIDAuMDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRQbGF5YmFja1JhdGUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XG5cdFx0fVxuXG5cdFx0b25FbmRlZCgpIHtcblx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Z2V0TG9vcCgpIHtcblx0XHRcdGlmICh0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5sb29wO1xuXHRcdH1cblxuXHRcdHNldExvb3AodmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmxvb3AgPSB2YWx1ZTtcblxuXHRcdFx0aWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdHRoaXMuc291cmNlLmxvb3AgPSB0aGlzLmxvb3A7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldExvb3BTdGFydCh2YWx1ZSkge1xuXHRcdFx0dGhpcy5sb29wU3RhcnQgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldExvb3BFbmQodmFsdWUpIHtcblx0XHRcdHRoaXMubG9vcEVuZCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Vm9sdW1lKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xuXHRcdH1cblxuXHRcdHNldFZvbHVtZSh2YWx1ZSkge1xuXHRcdFx0dGhpcy5nYWluLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHZhbHVlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsIDAuMDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfcG9zaXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfcXVhdGVybmlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgUXVhdGVybmlvbigpO1xuXG5cdGNvbnN0IF9zY2FsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9vcmllbnRhdGlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIFBvc2l0aW9uYWxBdWRpbyBleHRlbmRzIEF1ZGlvIHtcblx0XHRjb25zdHJ1Y3RvcihsaXN0ZW5lcikge1xuXHRcdFx0c3VwZXIobGlzdGVuZXIpO1xuXHRcdFx0dGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG5cdFx0XHR0aGlzLnBhbm5lci5wYW5uaW5nTW9kZWwgPSAnSFJURic7XG5cdFx0XHR0aGlzLnBhbm5lci5jb25uZWN0KHRoaXMuZ2Fpbik7XG5cdFx0fVxuXG5cdFx0Z2V0T3V0cHV0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFubmVyO1xuXHRcdH1cblxuXHRcdGdldFJlZkRpc3RhbmNlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlO1xuXHRcdH1cblxuXHRcdHNldFJlZkRpc3RhbmNlKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnBhbm5lci5yZWZEaXN0YW5jZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Um9sbG9mZkZhY3RvcigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xuXHRcdH1cblxuXHRcdHNldFJvbGxvZmZGYWN0b3IodmFsdWUpIHtcblx0XHRcdHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldERpc3RhbmNlTW9kZWwoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcblx0XHR9XG5cblx0XHRzZXREaXN0YW5jZU1vZGVsKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRNYXhEaXN0YW5jZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhbm5lci5tYXhEaXN0YW5jZTtcblx0XHR9XG5cblx0XHRzZXRNYXhEaXN0YW5jZSh2YWx1ZSkge1xuXHRcdFx0dGhpcy5wYW5uZXIubWF4RGlzdGFuY2UgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldERpcmVjdGlvbmFsQ29uZShjb25lSW5uZXJBbmdsZSwgY29uZU91dGVyQW5nbGUsIGNvbmVPdXRlckdhaW4pIHtcblx0XHRcdHRoaXMucGFubmVyLmNvbmVJbm5lckFuZ2xlID0gY29uZUlubmVyQW5nbGU7XG5cdFx0XHR0aGlzLnBhbm5lci5jb25lT3V0ZXJBbmdsZSA9IGNvbmVPdXRlckFuZ2xlO1xuXHRcdFx0dGhpcy5wYW5uZXIuY29uZU91dGVyR2FpbiA9IGNvbmVPdXRlckdhaW47XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdFx0aWYgKHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSB0cnVlICYmIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgX3NjYWxlKTtcblxuXHRcdFx0X29yaWVudGF0aW9uLnNldCgwLCAwLCAxKS5hcHBseVF1YXRlcm5pb24oX3F1YXRlcm5pb24pO1xuXG5cdFx0XHRjb25zdCBwYW5uZXIgPSB0aGlzLnBhbm5lcjtcblxuXHRcdFx0aWYgKHBhbm5lci5wb3NpdGlvblgpIHtcblx0XHRcdFx0Ly8gY29kZSBwYXRoIGZvciBDaHJvbWUgYW5kIEZpcmVmb3ggKHNlZSAjMTQzOTMpXG5cdFx0XHRcdGNvbnN0IGVuZFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLmxpc3RlbmVyLnRpbWVEZWx0YTtcblx0XHRcdFx0cGFubmVyLnBvc2l0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfcG9zaXRpb24ueCwgZW5kVGltZSk7XG5cdFx0XHRcdHBhbm5lci5wb3NpdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX3Bvc2l0aW9uLnksIGVuZFRpbWUpO1xuXHRcdFx0XHRwYW5uZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbi56LCBlbmRUaW1lKTtcblx0XHRcdFx0cGFubmVyLm9yaWVudGF0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfb3JpZW50YXRpb24ueCwgZW5kVGltZSk7XG5cdFx0XHRcdHBhbm5lci5vcmllbnRhdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX29yaWVudGF0aW9uLnksIGVuZFRpbWUpO1xuXHRcdFx0XHRwYW5uZXIub3JpZW50YXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9vcmllbnRhdGlvbi56LCBlbmRUaW1lKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhbm5lci5zZXRQb3NpdGlvbihfcG9zaXRpb24ueCwgX3Bvc2l0aW9uLnksIF9wb3NpdGlvbi56KTtcblx0XHRcdFx0cGFubmVyLnNldE9yaWVudGF0aW9uKF9vcmllbnRhdGlvbi54LCBfb3JpZW50YXRpb24ueSwgX29yaWVudGF0aW9uLnopO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQXVkaW9BbmFseXNlciB7XG5cdFx0Y29uc3RydWN0b3IoYXVkaW8sIGZmdFNpemUgPSAyMDQ4KSB7XG5cdFx0XHR0aGlzLmFuYWx5c2VyID0gYXVkaW8uY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuXHRcdFx0dGhpcy5hbmFseXNlci5mZnRTaXplID0gZmZ0U2l6ZTtcblx0XHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuXHRcdFx0YXVkaW8uZ2V0T3V0cHV0KCkuY29ubmVjdCh0aGlzLmFuYWx5c2VyKTtcblx0XHR9XG5cblx0XHRnZXRGcmVxdWVuY3lEYXRhKCkge1xuXHRcdFx0dGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YSh0aGlzLmRhdGEpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YTtcblx0XHR9XG5cblx0XHRnZXRBdmVyYWdlRnJlcXVlbmN5KCkge1xuXHRcdFx0bGV0IHZhbHVlID0gMDtcblx0XHRcdGNvbnN0IGRhdGEgPSB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhbHVlICs9IGRhdGFbaV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAvIGRhdGEubGVuZ3RoO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgUHJvcGVydHlNaXhlciB7XG5cdFx0Y29uc3RydWN0b3IoYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSkge1xuXHRcdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcblx0XHRcdHRoaXMudmFsdWVTaXplID0gdmFsdWVTaXplO1xuXHRcdFx0bGV0IG1peEZ1bmN0aW9uLCBtaXhGdW5jdGlvbkFkZGl0aXZlLCBzZXRJZGVudGl0eTsgLy8gYnVmZmVyIGxheW91dDogWyBpbmNvbWluZyB8IGFjY3UwIHwgYWNjdTEgfCBvcmlnIHwgYWRkQWNjdSB8IChvcHRpb25hbCB3b3JrKSBdXG5cdFx0XHQvL1xuXHRcdFx0Ly8gaW50ZXJwb2xhdG9ycyBjYW4gdXNlIC5idWZmZXIgYXMgdGhlaXIgLnJlc3VsdFxuXHRcdFx0Ly8gdGhlIGRhdGEgdGhlbiBnb2VzIHRvICdpbmNvbWluZydcblx0XHRcdC8vXG5cdFx0XHQvLyAnYWNjdTAnIGFuZCAnYWNjdTEnIGFyZSB1c2VkIGZyYW1lLWludGVybGVhdmVkIGZvclxuXHRcdFx0Ly8gdGhlIGN1bXVsYXRpdmUgcmVzdWx0IGFuZCBhcmUgY29tcGFyZWQgdG8gZGV0ZWN0XG5cdFx0XHQvLyBjaGFuZ2VzXG5cdFx0XHQvL1xuXHRcdFx0Ly8gJ29yaWcnIHN0b3JlcyB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIHByb3BlcnR5XG5cdFx0XHQvL1xuXHRcdFx0Ly8gJ2FkZCcgaXMgdXNlZCBmb3IgYWRkaXRpdmUgY3VtdWxhdGl2ZSByZXN1bHRzXG5cdFx0XHQvL1xuXHRcdFx0Ly8gJ3dvcmsnIGlzIG9wdGlvbmFsIGFuZCBpcyBvbmx5IHByZXNlbnQgZm9yIHF1YXRlcm5pb24gdHlwZXMuIEl0IGlzIHVzZWRcblx0XHRcdC8vIHRvIHN0b3JlIGludGVybWVkaWF0ZSBxdWF0ZXJuaW9uIG11bHRpcGxpY2F0aW9uIHJlc3VsdHNcblxuXHRcdFx0c3dpdGNoICh0eXBlTmFtZSkge1xuXHRcdFx0XHRjYXNlICdxdWF0ZXJuaW9uJzpcblx0XHRcdFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NsZXJwO1xuXHRcdFx0XHRcdG1peEZ1bmN0aW9uQWRkaXRpdmUgPSB0aGlzLl9zbGVycEFkZGl0aXZlO1xuXHRcdFx0XHRcdHNldElkZW50aXR5ID0gdGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eVF1YXRlcm5pb247XG5cdFx0XHRcdFx0dGhpcy5idWZmZXIgPSBuZXcgRmxvYXQ2NEFycmF5KHZhbHVlU2l6ZSAqIDYpO1xuXHRcdFx0XHRcdHRoaXMuX3dvcmtJbmRleCA9IDU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0Y2FzZSAnYm9vbCc6XG5cdFx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zZWxlY3Q7IC8vIFVzZSB0aGUgcmVndWxhciBtaXggZnVuY3Rpb24gYW5kIGZvciBhZGRpdGl2ZSBvbiB0aGVzZSB0eXBlcyxcblx0XHRcdFx0XHQvLyBhZGRpdGl2ZSBpcyBub3QgcmVsZXZhbnQgZm9yIG5vbi1udW1lcmljIHR5cGVzXG5cblx0XHRcdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fc2VsZWN0O1xuXHRcdFx0XHRcdHNldElkZW50aXR5ID0gdGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eU90aGVyO1xuXHRcdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KHZhbHVlU2l6ZSAqIDUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9sZXJwO1xuXHRcdFx0XHRcdG1peEZ1bmN0aW9uQWRkaXRpdmUgPSB0aGlzLl9sZXJwQWRkaXRpdmU7XG5cdFx0XHRcdFx0c2V0SWRlbnRpdHkgPSB0aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5TnVtZXJpYztcblx0XHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDY0QXJyYXkodmFsdWVTaXplICogNSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiA9IG1peEZ1bmN0aW9uO1xuXHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUgPSBtaXhGdW5jdGlvbkFkZGl0aXZlO1xuXHRcdFx0dGhpcy5fc2V0SWRlbnRpdHkgPSBzZXRJZGVudGl0eTtcblx0XHRcdHRoaXMuX29yaWdJbmRleCA9IDM7XG5cdFx0XHR0aGlzLl9hZGRJbmRleCA9IDQ7XG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXHRcdFx0dGhpcy51c2VDb3VudCA9IDA7XG5cdFx0XHR0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcblx0XHR9IC8vIGFjY3VtdWxhdGUgZGF0YSBpbiB0aGUgJ2luY29taW5nJyByZWdpb24gaW50byAnYWNjdTxpPidcblxuXG5cdFx0YWNjdW11bGF0ZShhY2N1SW5kZXgsIHdlaWdodCkge1xuXHRcdFx0Ly8gbm90ZTogaGFwcGlseSBhY2N1bXVsYXRpbmcgbm90aGluZyB3aGVuIHdlaWdodCA9IDAsIHRoZSBjYWxsZXIga25vd3Ncblx0XHRcdC8vIHRoZSB3ZWlnaHQgYW5kIHNob3VsZG4ndCBoYXZlIG1hZGUgdGhlIGNhbGwgaW4gdGhlIGZpcnN0IHBsYWNlXG5cdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlO1xuXHRcdFx0bGV0IGN1cnJlbnRXZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQ7XG5cblx0XHRcdGlmIChjdXJyZW50V2VpZ2h0ID09PSAwKSB7XG5cdFx0XHRcdC8vIGFjY3VOIDo9IGluY29taW5nICogd2VpZ2h0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsraSkge1xuXHRcdFx0XHRcdGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGJ1ZmZlcltpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIGluY29taW5nICogd2VpZ2h0XG5cdFx0XHRcdGN1cnJlbnRXZWlnaHQgKz0gd2VpZ2h0O1xuXHRcdFx0XHRjb25zdCBtaXggPSB3ZWlnaHQgLyBjdXJyZW50V2VpZ2h0O1xuXG5cdFx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihidWZmZXIsIG9mZnNldCwgMCwgbWl4LCBzdHJpZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSBjdXJyZW50V2VpZ2h0O1xuXHRcdH0gLy8gYWNjdW11bGF0ZSBkYXRhIGluIHRoZSAnaW5jb21pbmcnIHJlZ2lvbiBpbnRvICdhZGQnXG5cblxuXHRcdGFjY3VtdWxhdGVBZGRpdGl2ZSh3ZWlnaHQpIHtcblx0XHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9hZGRJbmRleDtcblxuXHRcdFx0aWYgKHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID09PSAwKSB7XG5cdFx0XHRcdC8vIGFkZCA9IGlkZW50aXR5XG5cdFx0XHRcdHRoaXMuX3NldElkZW50aXR5KCk7XG5cdFx0XHR9IC8vIGFkZCA6PSBhZGQgKyBpbmNvbWluZyAqIHdlaWdodFxuXG5cblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbkFkZGl0aXZlKGJ1ZmZlciwgb2Zmc2V0LCAwLCB3ZWlnaHQsIHN0cmlkZSk7XG5cblx0XHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlICs9IHdlaWdodDtcblx0XHR9IC8vIGFwcGx5IHRoZSBzdGF0ZSBvZiAnYWNjdTxpPicgdG8gdGhlIGJpbmRpbmcgd2hlbiBhY2N1cyBkaWZmZXJcblxuXG5cdFx0YXBwbHkoYWNjdUluZGV4KSB7XG5cdFx0XHRjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdFx0XHRcdGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxuXHRcdFx0XHRcdFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxuXHRcdFx0XHRcdFx0d2VpZ2h0QWRkaXRpdmUgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSxcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXG5cdFx0XHRpZiAod2VpZ2h0IDwgMSkge1xuXHRcdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIG9yaWdpbmFsICogKCAxIC0gY3VtdWxhdGl2ZVdlaWdodCApXG5cdFx0XHRcdGNvbnN0IG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9vcmlnSW5kZXg7XG5cblx0XHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uKGJ1ZmZlciwgb2Zmc2V0LCBvcmlnaW5hbFZhbHVlT2Zmc2V0LCAxIC0gd2VpZ2h0LCBzdHJpZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAod2VpZ2h0QWRkaXRpdmUgPiAwKSB7XG5cdFx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgYWRkaXRpdmUgYWNjdU5cblx0XHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUoYnVmZmVyLCBvZmZzZXQsIHRoaXMuX2FkZEluZGV4ICogc3RyaWRlLCAxLCBzdHJpZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gc3RyaWRlLCBlID0gc3RyaWRlICsgc3RyaWRlOyBpICE9PSBlOyArK2kpIHtcblx0XHRcdFx0aWYgKGJ1ZmZlcltpXSAhPT0gYnVmZmVyW2kgKyBzdHJpZGVdKSB7XG5cdFx0XHRcdFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXG5cdFx0XHRcdFx0YmluZGluZy5zZXRWYWx1ZShidWZmZXIsIG9mZnNldCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IC8vIHJlbWVtYmVyIHRoZSBzdGF0ZSBvZiB0aGUgYm91bmQgcHJvcGVydHkgYW5kIGNvcHkgaXQgdG8gYm90aCBhY2N1c1xuXG5cblx0XHRzYXZlT3JpZ2luYWxTdGF0ZSgpIHtcblx0XHRcdGNvbnN0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIHRoaXMuX29yaWdJbmRleDtcblx0XHRcdGJpbmRpbmcuZ2V0VmFsdWUoYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0KTsgLy8gYWNjdVswLi4xXSA6PSBvcmlnIC0tIGluaXRpYWxseSBkZXRlY3QgY2hhbmdlcyBhZ2FpbnN0IHRoZSBvcmlnaW5hbFxuXG5cdFx0XHRmb3IgKGxldCBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKytpKSB7XG5cdFx0XHRcdGJ1ZmZlcltpXSA9IGJ1ZmZlcltvcmlnaW5hbFZhbHVlT2Zmc2V0ICsgaSAlIHN0cmlkZV07XG5cdFx0XHR9IC8vIEFkZCB0byBpZGVudGl0eSBmb3IgYWRkaXRpdmVcblxuXG5cdFx0XHR0aGlzLl9zZXRJZGVudGl0eSgpO1xuXG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXHRcdH0gLy8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcblxuXG5cdFx0cmVzdG9yZU9yaWdpbmFsU3RhdGUoKSB7XG5cdFx0XHRjb25zdCBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gdGhpcy52YWx1ZVNpemUgKiAzO1xuXHRcdFx0dGhpcy5iaW5kaW5nLnNldFZhbHVlKHRoaXMuYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0KTtcblx0XHR9XG5cblx0XHRfc2V0QWRkaXRpdmVJZGVudGl0eU51bWVyaWMoKSB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gdGhpcy5fYWRkSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblx0XHRcdGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHRoaXMudmFsdWVTaXplO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcblx0XHRcdFx0dGhpcy5idWZmZXJbaV0gPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9zZXRBZGRpdGl2ZUlkZW50aXR5UXVhdGVybmlvbigpIHtcblx0XHRcdHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCk7XG5cblx0XHRcdHRoaXMuYnVmZmVyW3RoaXMuX2FkZEluZGV4ICogdGhpcy52YWx1ZVNpemUgKyAzXSA9IDE7XG5cdFx0fVxuXG5cdFx0X3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcigpIHtcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLl9vcmlnSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblx0XHRcdGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy5fYWRkSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlU2l6ZTsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYnVmZmVyW3RhcmdldEluZGV4ICsgaV0gPSB0aGlzLmJ1ZmZlcltzdGFydEluZGV4ICsgaV07XG5cdFx0XHR9XG5cdFx0fSAvLyBtaXggZnVuY3Rpb25zXG5cblxuXHRcdF9zZWxlY3QoYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlKSB7XG5cdFx0XHRpZiAodCA+PSAwLjUpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKytpKSB7XG5cdFx0XHRcdFx0YnVmZmVyW2RzdE9mZnNldCArIGldID0gYnVmZmVyW3NyY09mZnNldCArIGldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X3NsZXJwKGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQpIHtcblx0XHRcdFF1YXRlcm5pb24uc2xlcnBGbGF0KGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQpO1xuXHRcdH1cblxuXHRcdF9zbGVycEFkZGl0aXZlKGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSkge1xuXHRcdFx0Y29uc3Qgd29ya09mZnNldCA9IHRoaXMuX3dvcmtJbmRleCAqIHN0cmlkZTsgLy8gU3RvcmUgcmVzdWx0IGluIGludGVybWVkaWF0ZSBidWZmZXIgb2Zmc2V0XG5cblx0XHRcdFF1YXRlcm5pb24ubXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoYnVmZmVyLCB3b3JrT2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQpOyAvLyBTbGVycCB0byB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdFxuXG5cdFx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdChidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgd29ya09mZnNldCwgdCk7XG5cdFx0fVxuXG5cdFx0X2xlcnAoYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlKSB7XG5cdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsraSkge1xuXHRcdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcblx0XHRcdFx0YnVmZmVyW2pdID0gYnVmZmVyW2pdICogcyArIGJ1ZmZlcltzcmNPZmZzZXQgKyBpXSAqIHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2xlcnBBZGRpdGl2ZShidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsraSkge1xuXHRcdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcblx0XHRcdFx0YnVmZmVyW2pdID0gYnVmZmVyW2pdICsgYnVmZmVyW3NyY09mZnNldCArIGldICogdDtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdC8vIENoYXJhY3RlcnMgW10uOi8gYXJlIHJlc2VydmVkIGZvciB0cmFjayBiaW5kaW5nIHN5bnRheC5cblx0Y29uc3QgX1JFU0VSVkVEX0NIQVJTX1JFID0gJ1xcXFxbXFxcXF1cXFxcLjpcXFxcLyc7XG5cblx0Y29uc3QgX3Jlc2VydmVkUmUgPSBuZXcgUmVnRXhwKCdbJyArIF9SRVNFUlZFRF9DSEFSU19SRSArICddJywgJ2cnKTsgLy8gQXR0ZW1wdHMgdG8gYWxsb3cgbm9kZSBuYW1lcyBmcm9tIGFueSBsYW5ndWFnZS4gRVM1J3MgYFxcd2AgcmVnZXhwIG1hdGNoZXNcblx0Ly8gb25seSBsYXRpbiBjaGFyYWN0ZXJzLCBhbmQgdGhlIHVuaWNvZGUgXFxwe0x9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBTb1xuXHQvLyBpbnN0ZWFkLCB3ZSBleGNsdWRlIHJlc2VydmVkIGNoYXJhY3RlcnMgYW5kIG1hdGNoIGV2ZXJ5dGhpbmcgZWxzZS5cblxuXG5cdGNvbnN0IF93b3JkQ2hhciA9ICdbXicgKyBfUkVTRVJWRURfQ0hBUlNfUkUgKyAnXSc7XG5cblx0Y29uc3QgX3dvcmRDaGFyT3JEb3QgPSAnW14nICsgX1JFU0VSVkVEX0NIQVJTX1JFLnJlcGxhY2UoJ1xcXFwuJywgJycpICsgJ10nOyAvLyBQYXJlbnQgZGlyZWN0b3JpZXMsIGRlbGltaXRlZCBieSAnLycgb3IgJzonLiBDdXJyZW50bHkgdW51c2VkLCBidXQgbXVzdFxuXHQvLyBiZSBtYXRjaGVkIHRvIHBhcnNlIHRoZSByZXN0IG9mIHRoZSB0cmFjayBuYW1lLlxuXG5cblx0Y29uc3QgX2RpcmVjdG9yeVJlID0gLygoPzpXQytbXFwvOl0pKikvLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7IC8vIFRhcmdldCBub2RlLiBNYXkgY29udGFpbiB3b3JkIGNoYXJhY3RlcnMgKGEtekEtWjAtOV8pIGFuZCAnLicgb3IgJy0nLlxuXG5cblx0Y29uc3QgX25vZGVSZSA9IC8oV0NPRCspPy8uc291cmNlLnJlcGxhY2UoJ1dDT0QnLCBfd29yZENoYXJPckRvdCk7IC8vIE9iamVjdCBvbiB0YXJnZXQgbm9kZSwgYW5kIGFjY2Vzc29yLiBNYXkgbm90IGNvbnRhaW4gcmVzZXJ2ZWRcblx0Ly8gY2hhcmFjdGVycy4gQWNjZXNzb3IgbWF5IGNvbnRhaW4gYW55IGNoYXJhY3RlciBleGNlcHQgY2xvc2luZyBicmFja2V0LlxuXG5cblx0Y29uc3QgX29iamVjdFJlID0gLyg/OlxcLihXQyspKD86XFxbKC4rKVxcXSk/KT8vLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7IC8vIFByb3BlcnR5IGFuZCBhY2Nlc3Nvci4gTWF5IG5vdCBjb250YWluIHJlc2VydmVkIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heVxuXHQvLyBjb250YWluIGFueSBub24tYnJhY2tldCBjaGFyYWN0ZXJzLlxuXG5cblx0Y29uc3QgX3Byb3BlcnR5UmUgPSAvXFwuKFdDKykoPzpcXFsoLispXFxdKT8vLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7XG5cblx0Y29uc3QgX3RyYWNrUmUgPSBuZXcgUmVnRXhwKCcnICsgJ14nICsgX2RpcmVjdG9yeVJlICsgX25vZGVSZSArIF9vYmplY3RSZSArIF9wcm9wZXJ0eVJlICsgJyQnKTtcblxuXHRjb25zdCBfc3VwcG9ydGVkT2JqZWN0TmFtZXMgPSBbJ21hdGVyaWFsJywgJ21hdGVyaWFscycsICdib25lcyddO1xuXG5cdGNsYXNzIENvbXBvc2l0ZSB7XG5cdFx0Y29uc3RydWN0b3IodGFyZ2V0R3JvdXAsIHBhdGgsIG9wdGlvbmFsUGFyc2VkUGF0aCkge1xuXHRcdFx0Y29uc3QgcGFyc2VkUGF0aCA9IG9wdGlvbmFsUGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUocGF0aCk7XG5cdFx0XHR0aGlzLl90YXJnZXRHcm91cCA9IHRhcmdldEdyb3VwO1xuXHRcdFx0dGhpcy5fYmluZGluZ3MgPSB0YXJnZXRHcm91cC5zdWJzY3JpYmVfKHBhdGgsIHBhcnNlZFBhdGgpO1xuXHRcdH1cblxuXHRcdGdldFZhbHVlKGFycmF5LCBvZmZzZXQpIHtcblx0XHRcdHRoaXMuYmluZCgpOyAvLyBiaW5kIGFsbCBiaW5kaW5nXG5cblx0XHRcdGNvbnN0IGZpcnN0VmFsaWRJbmRleCA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1tmaXJzdFZhbGlkSW5kZXhdOyAvLyBhbmQgb25seSBjYWxsIC5nZXRWYWx1ZSBvbiB0aGUgZmlyc3RcblxuXHRcdFx0aWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkgYmluZGluZy5nZXRWYWx1ZShhcnJheSwgb2Zmc2V0KTtcblx0XHR9XG5cblx0XHRzZXRWYWx1ZShhcnJheSwgb2Zmc2V0KSB7XG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0YmluZGluZ3NbaV0uc2V0VmFsdWUoYXJyYXksIG9mZnNldCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YmluZCgpIHtcblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRcdGZvciAobGV0IGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRiaW5kaW5nc1tpXS5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dW5iaW5kKCkge1xuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGJpbmRpbmdzW2ldLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9IC8vIE5vdGU6IFRoaXMgY2xhc3MgdXNlcyBhIFN0YXRlIHBhdHRlcm4gb24gYSBwZXItbWV0aG9kIGJhc2lzOlxuXHQvLyAnYmluZCcgc2V0cyAndGhpcy5nZXRWYWx1ZScgLyAnc2V0VmFsdWUnIGFuZCBzaGFkb3dzIHRoZVxuXHQvLyBwcm90b3R5cGUgdmVyc2lvbiBvZiB0aGVzZSBtZXRob2RzIHdpdGggb25lIHRoYXQgcmVwcmVzZW50c1xuXHQvLyB0aGUgYm91bmQgc3RhdGUuIFdoZW4gdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgdGhlIG1ldGhvZHNcblx0Ly8gYmVjb21lIG5vLW9wcy5cblxuXG5cdGNsYXNzIFByb3BlcnR5QmluZGluZyB7XG5cdFx0Y29uc3RydWN0b3Iocm9vdE5vZGUsIHBhdGgsIHBhcnNlZFBhdGgpIHtcblx0XHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0XHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZShwYXRoKTtcblx0XHRcdHRoaXMubm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZShyb290Tm9kZSwgdGhpcy5wYXJzZWRQYXRoLm5vZGVOYW1lKSB8fCByb290Tm9kZTtcblx0XHRcdHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTsgLy8gaW5pdGlhbCBzdGF0ZSBvZiB0aGVzZSBtZXRob2RzIHRoYXQgY2FsbHMgJ2JpbmQnXG5cblx0XHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmJvdW5kO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGNyZWF0ZShyb290LCBwYXRoLCBwYXJzZWRQYXRoKSB7XG5cdFx0XHRpZiAoIShyb290ICYmIHJvb3QuaXNBbmltYXRpb25PYmplY3RHcm91cCkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmcocm9vdCwgcGF0aCwgcGFyc2VkUGF0aCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUocm9vdCwgcGF0aCwgcGFyc2VkUGF0aCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIHVuZGVyc2NvcmVzIGFuZCByZW1vdmVzIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMgZnJvbVxuXHRcdCAqIG5vZGUgbmFtZXMsIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggcGFyc2VUcmFja05hbWUoKS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5vZGUgbmFtZSB0byBiZSBzYW5pdGl6ZWQuXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXG5cblx0XHRzdGF0aWMgc2FuaXRpemVOb2RlTmFtZShuYW1lKSB7XG5cdFx0XHRyZXR1cm4gbmFtZS5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKF9yZXNlcnZlZFJlLCAnJyk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIHBhcnNlVHJhY2tOYW1lKHRyYWNrTmFtZSkge1xuXHRcdFx0Y29uc3QgbWF0Y2hlcyA9IF90cmFja1JlLmV4ZWModHJhY2tOYW1lKTtcblxuXHRcdFx0aWYgKCFtYXRjaGVzKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUHJvcGVydHlCaW5kaW5nOiBDYW5ub3QgcGFyc2UgdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmVzdWx0cyA9IHtcblx0XHRcdFx0Ly8gZGlyZWN0b3J5TmFtZTogbWF0Y2hlc1sgMSBdLCAvLyAodHNjaHcpIGN1cnJlbnRseSB1bnVzZWRcblx0XHRcdFx0bm9kZU5hbWU6IG1hdGNoZXNbMl0sXG5cdFx0XHRcdG9iamVjdE5hbWU6IG1hdGNoZXNbM10sXG5cdFx0XHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWzRdLFxuXHRcdFx0XHRwcm9wZXJ0eU5hbWU6IG1hdGNoZXNbNV0sXG5cdFx0XHRcdC8vIHJlcXVpcmVkXG5cdFx0XHRcdHByb3BlcnR5SW5kZXg6IG1hdGNoZXNbNl1cblx0XHRcdH07XG5cdFx0XHRjb25zdCBsYXN0RG90ID0gcmVzdWx0cy5ub2RlTmFtZSAmJiByZXN1bHRzLm5vZGVOYW1lLmxhc3RJbmRleE9mKCcuJyk7XG5cblx0XHRcdGlmIChsYXN0RG90ICE9PSB1bmRlZmluZWQgJiYgbGFzdERvdCAhPT0gLTEpIHtcblx0XHRcdFx0Y29uc3Qgb2JqZWN0TmFtZSA9IHJlc3VsdHMubm9kZU5hbWUuc3Vic3RyaW5nKGxhc3REb3QgKyAxKTsgLy8gT2JqZWN0IG5hbWVzIG11c3QgYmUgY2hlY2tlZCBhZ2FpbnN0IGFuIGFsbG93bGlzdC4gT3RoZXJ3aXNlLCB0aGVyZVxuXHRcdFx0XHQvLyBpcyBubyB3YXkgdG8gcGFyc2UgJ2Zvby5iYXIuYmF6JzogJ2JheicgbXVzdCBiZSBhIHByb3BlcnR5LCBidXRcblx0XHRcdFx0Ly8gJ2JhcicgY291bGQgYmUgdGhlIG9iamVjdE5hbWUsIG9yIHBhcnQgb2YgYSBub2RlTmFtZSAod2hpY2ggY2FuXG5cdFx0XHRcdC8vIGluY2x1ZGUgJy4nIGNoYXJhY3RlcnMpLlxuXG5cdFx0XHRcdGlmIChfc3VwcG9ydGVkT2JqZWN0TmFtZXMuaW5kZXhPZihvYmplY3ROYW1lKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXN1bHRzLm5vZGVOYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoMCwgbGFzdERvdCk7XG5cdFx0XHRcdFx0cmVzdWx0cy5vYmplY3ROYW1lID0gb2JqZWN0TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUHJvcGVydHlCaW5kaW5nOiBjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmaW5kTm9kZShyb290LCBub2RlTmFtZSkge1xuXHRcdFx0aWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJycgfHwgbm9kZU5hbWUgPT09ICcuJyB8fCBub2RlTmFtZSA9PT0gLTEgfHwgbm9kZU5hbWUgPT09IHJvb3QubmFtZSB8fCBub2RlTmFtZSA9PT0gcm9vdC51dWlkKSB7XG5cdFx0XHRcdHJldHVybiByb290O1xuXHRcdFx0fSAvLyBzZWFyY2ggaW50byBza2VsZXRvbiBib25lcy5cblxuXG5cdFx0XHRpZiAocm9vdC5za2VsZXRvbikge1xuXHRcdFx0XHRjb25zdCBib25lID0gcm9vdC5za2VsZXRvbi5nZXRCb25lQnlOYW1lKG5vZGVOYW1lKTtcblxuXHRcdFx0XHRpZiAoYm9uZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxuXG5cblx0XHRcdGlmIChyb290LmNoaWxkcmVuKSB7XG5cdFx0XHRcdGNvbnN0IHNlYXJjaE5vZGVTdWJ0cmVlID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG5cblx0XHRcdFx0XHRcdGlmIChjaGlsZE5vZGUubmFtZSA9PT0gbm9kZU5hbWUgfHwgY2hpbGROb2RlLnV1aWQgPT09IG5vZGVOYW1lKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKGNoaWxkTm9kZS5jaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNvbnN0IHN1YlRyZWVOb2RlID0gc2VhcmNoTm9kZVN1YnRyZWUocm9vdC5jaGlsZHJlbik7XG5cblx0XHRcdFx0aWYgKHN1YlRyZWVOb2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN1YlRyZWVOb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gLy8gdGhlc2UgYXJlIHVzZWQgdG8gXCJiaW5kXCIgYSBub25leGlzdGVudCBwcm9wZXJ0eVxuXG5cblx0XHRfZ2V0VmFsdWVfdW5hdmFpbGFibGUoKSB7fVxuXG5cdFx0X3NldFZhbHVlX3VuYXZhaWxhYmxlKCkge30gLy8gR2V0dGVyc1xuXG5cblx0XHRfZ2V0VmFsdWVfZGlyZWN0KGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHRidWZmZXJbb2Zmc2V0XSA9IHRoaXMubm9kZVt0aGlzLnByb3BlcnR5TmFtZV07XG5cdFx0fVxuXG5cdFx0X2dldFZhbHVlX2FycmF5KGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHRjb25zdCBzb3VyY2UgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGJ1ZmZlcltvZmZzZXQrK10gPSBzb3VyY2VbaV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2dldFZhbHVlX2FycmF5RWxlbWVudChidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0YnVmZmVyW29mZnNldF0gPSB0aGlzLnJlc29sdmVkUHJvcGVydHlbdGhpcy5wcm9wZXJ0eUluZGV4XTtcblx0XHR9XG5cblx0XHRfZ2V0VmFsdWVfdG9BcnJheShidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoYnVmZmVyLCBvZmZzZXQpO1xuXHRcdH0gLy8gRGlyZWN0XG5cblxuXHRcdF9zZXRWYWx1ZV9kaXJlY3QoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdH1cblxuXHRcdF9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdF9zZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0dGhpcy50YXJnZXRPYmplY3RbdGhpcy5wcm9wZXJ0eU5hbWVdID0gYnVmZmVyW29mZnNldF07XG5cdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9IC8vIEVudGlyZUFycmF5XG5cblxuXHRcdF9zZXRWYWx1ZV9hcnJheShidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0Y29uc3QgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGRlc3RbaV0gPSBidWZmZXJbb2Zmc2V0KytdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9zZXRWYWx1ZV9hcnJheV9zZXROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0Y29uc3QgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGRlc3RbaV0gPSBidWZmZXJbb2Zmc2V0KytdO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0X3NldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRcdGNvbnN0IGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRkZXN0W2ldID0gYnVmZmVyW29mZnNldCsrXTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fSAvLyBBcnJheUVsZW1lbnRcblxuXG5cdFx0X3NldFZhbHVlX2FycmF5RWxlbWVudChidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF0gPSBidWZmZXJbb2Zmc2V0XTtcblx0XHR9XG5cblx0XHRfc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbdGhpcy5wcm9wZXJ0eUluZGV4XSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdF9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF0gPSBidWZmZXJbb2Zmc2V0XTtcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH0gLy8gSGFzVG9Gcm9tQXJyYXlcblxuXG5cdFx0X3NldFZhbHVlX2Zyb21BcnJheShidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheShidWZmZXIsIG9mZnNldCk7XG5cdFx0fVxuXG5cdFx0X3NldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheShidWZmZXIsIG9mZnNldCk7XG5cdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0X3NldFZhbHVlX2Zyb21BcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdF9nZXRWYWx1ZV91bmJvdW5kKHRhcmdldEFycmF5LCBvZmZzZXQpIHtcblx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0dGhpcy5nZXRWYWx1ZSh0YXJnZXRBcnJheSwgb2Zmc2V0KTtcblx0XHR9XG5cblx0XHRfc2V0VmFsdWVfdW5ib3VuZChzb3VyY2VBcnJheSwgb2Zmc2V0KSB7XG5cdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdHRoaXMuc2V0VmFsdWUoc291cmNlQXJyYXksIG9mZnNldCk7XG5cdFx0fSAvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXG5cblxuXHRcdGJpbmQoKSB7XG5cdFx0XHRsZXQgdGFyZ2V0T2JqZWN0ID0gdGhpcy5ub2RlO1xuXHRcdFx0Y29uc3QgcGFyc2VkUGF0aCA9IHRoaXMucGFyc2VkUGF0aDtcblx0XHRcdGNvbnN0IG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWU7XG5cdFx0XHRjb25zdCBwcm9wZXJ0eU5hbWUgPSBwYXJzZWRQYXRoLnByb3BlcnR5TmFtZTtcblx0XHRcdGxldCBwcm9wZXJ0eUluZGV4ID0gcGFyc2VkUGF0aC5wcm9wZXJ0eUluZGV4O1xuXG5cdFx0XHRpZiAoIXRhcmdldE9iamVjdCkge1xuXHRcdFx0XHR0YXJnZXRPYmplY3QgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUodGhpcy5yb290Tm9kZSwgcGFyc2VkUGF0aC5ub2RlTmFtZSkgfHwgdGhpcy5yb290Tm9kZTtcblx0XHRcdFx0dGhpcy5ub2RlID0gdGFyZ2V0T2JqZWN0O1xuXHRcdFx0fSAvLyBzZXQgZmFpbCBzdGF0ZSBzbyB3ZSBjYW4ganVzdCAncmV0dXJuJyBvbiBlcnJvclxuXG5cblx0XHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmF2YWlsYWJsZTtcblx0XHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmF2YWlsYWJsZTsgLy8gZW5zdXJlIHRoZXJlIGlzIGEgdmFsdWUgbm9kZVxuXG5cdFx0XHRpZiAoIXRhcmdldE9iamVjdCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byB1cGRhdGUgbm9kZSBmb3IgdHJhY2s6ICcgKyB0aGlzLnBhdGggKyAnIGJ1dCBpdCB3YXNuXFwndCBmb3VuZC4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2JqZWN0TmFtZSkge1xuXHRcdFx0XHRsZXQgb2JqZWN0SW5kZXggPSBwYXJzZWRQYXRoLm9iamVjdEluZGV4OyAvLyBzcGVjaWFsIGNhc2VzIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXG5cblx0XHRcdFx0c3dpdGNoIChvYmplY3ROYW1lKSB7XG5cdFx0XHRcdFx0Y2FzZSAnbWF0ZXJpYWxzJzpcblx0XHRcdFx0XHRcdGlmICghdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLicsIHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICghdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscykge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXRlcmlhbHMgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWxzIGFycmF5LicsIHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHM7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2JvbmVzJzpcblx0XHRcdFx0XHRcdGlmICghdGFyZ2V0T2JqZWN0LnNrZWxldG9uKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIGJvbmVzIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNrZWxldG9uLicsIHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9IC8vIHBvdGVudGlhbCBmdXR1cmUgb3B0aW1pemF0aW9uOiBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXJcblx0XHRcdFx0XHRcdC8vIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblxuXG5cdFx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Quc2tlbGV0b24uYm9uZXM7IC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRPYmplY3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRhcmdldE9iamVjdFtpXS5uYW1lID09PSBvYmplY3RJbmRleCkge1xuXHRcdFx0XHRcdFx0XHRcdG9iamVjdEluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0T2JqZWN0W29iamVjdE5hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gb2JqZWN0TmFtZSBvZiBub2RlIHVuZGVmaW5lZC4nLCB0aGlzKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Rbb2JqZWN0TmFtZV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob2JqZWN0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmICh0YXJnZXRPYmplY3Rbb2JqZWN0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZC4nLCB0aGlzLCB0YXJnZXRPYmplY3QpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFtvYmplY3RJbmRleF07XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gcmVzb2x2ZSBwcm9wZXJ0eVxuXG5cblx0XHRcdGNvbnN0IG5vZGVQcm9wZXJ0eSA9IHRhcmdldE9iamVjdFtwcm9wZXJ0eU5hbWVdO1xuXG5cdFx0XHRpZiAobm9kZVByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3Qgbm9kZU5hbWUgPSBwYXJzZWRQYXRoLm5vZGVOYW1lO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byB1cGRhdGUgcHJvcGVydHkgZm9yIHRyYWNrOiAnICsgbm9kZU5hbWUgKyAnLicgKyBwcm9wZXJ0eU5hbWUgKyAnIGJ1dCBpdCB3YXNuXFwndCBmb3VuZC4nLCB0YXJnZXRPYmplY3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IC8vIGRldGVybWluZSB2ZXJzaW9uaW5nIHNjaGVtZVxuXG5cblx0XHRcdGxldCB2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5vbmU7XG5cdFx0XHR0aGlzLnRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdDtcblxuXHRcdFx0aWYgKHRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIG1hdGVyaWFsXG5cdFx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTmVlZHNVcGRhdGU7XG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gbm9kZSB0cmFuc2Zvcm1cblx0XHRcdFx0dmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5NYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXHRcdFx0fSAvLyBkZXRlcm1pbmUgaG93IHRoZSBwcm9wZXJ0eSBnZXRzIGJvdW5kXG5cblxuXHRcdFx0bGV0IGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5EaXJlY3Q7XG5cblx0XHRcdGlmIChwcm9wZXJ0eUluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXG5cdFx0XHRcdGlmIChwcm9wZXJ0eU5hbWUgPT09ICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnKSB7XG5cdFx0XHRcdFx0Ly8gcG90ZW50aWFsIG9wdGltaXphdGlvbiwgc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyLCBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxuXHRcdFx0XHRcdGlmICghdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5KSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS4nLCB0aGlzKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodGFyZ2V0T2JqZWN0Lmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpIHtcblx0XHRcdFx0XHRcdGlmICghdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuJywgdGhpcyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRhcmdldE9iamVjdC5tb3JwaFRhcmdldERpY3Rpb25hcnlbcHJvcGVydHlJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eUluZGV4ID0gdGFyZ2V0T2JqZWN0Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtwcm9wZXJ0eUluZGV4XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIG9uIFRIUkVFLkdlb21ldHJ5LiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nLCB0aGlzKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuQXJyYXlFbGVtZW50O1xuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cdFx0XHRcdHRoaXMucHJvcGVydHlJbmRleCA9IHByb3BlcnR5SW5kZXg7XG5cdFx0XHR9IGVsc2UgaWYgKG5vZGVQcm9wZXJ0eS5mcm9tQXJyYXkgIT09IHVuZGVmaW5lZCAmJiBub2RlUHJvcGVydHkudG9BcnJheSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cblx0XHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkhhc0Zyb21Ub0FycmF5O1xuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZVByb3BlcnR5KSkge1xuXHRcdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRW50aXJlQXJyYXk7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXHRcdFx0fSAvLyBzZWxlY3QgZ2V0dGVyIC8gc2V0dGVyXG5cblxuXHRcdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuR2V0dGVyQnlCaW5kaW5nVHlwZVtiaW5kaW5nVHlwZV07XG5cdFx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZ1tiaW5kaW5nVHlwZV1bdmVyc2lvbmluZ107XG5cdFx0fVxuXG5cdFx0dW5iaW5kKCkge1xuXHRcdFx0dGhpcy5ub2RlID0gbnVsbDsgLy8gYmFjayB0byB0aGUgcHJvdG90eXBlIHZlcnNpb24gb2YgZ2V0VmFsdWUgLyBzZXRWYWx1ZVxuXHRcdFx0Ly8gbm90ZTogYXZvaWRpbmcgdG8gbXV0YXRlIHRoZSBzaGFwZSBvZiAndGhpcycgdmlhICdkZWxldGUnXG5cblx0XHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmJvdW5kO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XG5cdFx0fVxuXG5cdH1cblxuXHRQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlID0gQ29tcG9zaXRlO1xuXHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLkJpbmRpbmdUeXBlID0ge1xuXHRcdERpcmVjdDogMCxcblx0XHRFbnRpcmVBcnJheTogMSxcblx0XHRBcnJheUVsZW1lbnQ6IDIsXG5cdFx0SGFzRnJvbVRvQXJyYXk6IDNcblx0fTtcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5WZXJzaW9uaW5nID0ge1xuXHRcdE5vbmU6IDAsXG5cdFx0TmVlZHNVcGRhdGU6IDEsXG5cdFx0TWF0cml4V29ybGROZWVkc1VwZGF0ZTogMlxuXHR9O1xuXHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLkdldHRlckJ5QmluZGluZ1R5cGUgPSBbUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfZGlyZWN0LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV9hcnJheSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfYXJyYXlFbGVtZW50LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV90b0FycmF5XTtcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZyA9IFtbLy8gRGlyZWN0XG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2RpcmVjdCwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlLCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV0sIFsvLyBFbnRpcmVBcnJheVxuXHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVdLCBbLy8gQXJyYXlFbGVtZW50XG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudCwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlLCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV0sIFsvLyBIYXNUb0Zyb21BcnJheVxuXHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXksIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVdXTtcblxuXHQvKipcblx0ICpcblx0ICogQSBncm91cCBvZiBvYmplY3RzIHRoYXQgcmVjZWl2ZXMgYSBzaGFyZWQgYW5pbWF0aW9uIHN0YXRlLlxuXHQgKlxuXHQgKiBVc2FnZTpcblx0ICpcblx0ICpcdC0gQWRkIG9iamVjdHMgeW91IHdvdWxkIG90aGVyd2lzZSBwYXNzIGFzICdyb290JyB0byB0aGVcblx0ICpcdFx0Y29uc3RydWN0b3Igb3IgdGhlIC5jbGlwQWN0aW9uIG1ldGhvZCBvZiBBbmltYXRpb25NaXhlci5cblx0ICpcblx0ICpcdC0gSW5zdGVhZCBwYXNzIHRoaXMgb2JqZWN0IGFzICdyb290Jy5cblx0ICpcblx0ICpcdC0gWW91IGNhbiBhbHNvIGFkZCBhbmQgcmVtb3ZlIG9iamVjdHMgbGF0ZXIgd2hlbiB0aGUgbWl4ZXJcblx0ICpcdFx0aXMgcnVubmluZy5cblx0ICpcblx0ICogTm90ZTpcblx0ICpcblx0ICpcdFx0T2JqZWN0cyBvZiB0aGlzIGNsYXNzIGFwcGVhciBhcyBvbmUgb2JqZWN0IHRvIHRoZSBtaXhlcixcblx0ICpcdFx0c28gY2FjaGUgY29udHJvbCBvZiB0aGUgaW5kaXZpZHVhbCBvYmplY3RzIG11c3QgYmUgZG9uZVxuXHQgKlx0XHRvbiB0aGUgZ3JvdXAuXG5cdCAqXG5cdCAqIExpbWl0YXRpb246XG5cdCAqXG5cdCAqXHQtIFRoZSBhbmltYXRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgY29tcGF0aWJsZSBhbW9uZyB0aGVcblx0ICpcdFx0YWxsIG9iamVjdHMgaW4gdGhlIGdyb3VwLlxuXHQgKlxuXHQgKlx0LSBBIHNpbmdsZSBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBhXG5cdCAqXHRcdHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxuXHQgKi9cblxuXHRjbGFzcyBBbmltYXRpb25PYmplY3RHcm91cCB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTsgLy8gY2FjaGVkIG9iamVjdHMgZm9sbG93ZWQgYnkgdGhlIGFjdGl2ZSBvbmVzXG5cblx0XHRcdHRoaXMuX29iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSAwOyAvLyB0aHJlc2hvbGRcblx0XHRcdC8vIG5vdGU6IHJlYWQgYnkgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZVxuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0ge307XG5cdFx0XHR0aGlzLl9pbmRpY2VzQnlVVUlEID0gaW5kaWNlczsgLy8gZm9yIGJvb2trZWVwaW5nXG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGluZGljZXNbYXJndW1lbnRzW2ldLnV1aWRdID0gaTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcGF0aHMgPSBbXTsgLy8gaW5zaWRlOiBzdHJpbmdcblxuXHRcdFx0dGhpcy5fcGFyc2VkUGF0aHMgPSBbXTsgLy8gaW5zaWRlOiB7IHdlIGRvbid0IGNhcmUsIGhlcmUgfVxuXG5cdFx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyBpbnNpZGU6IEFycmF5PCBQcm9wZXJ0eUJpbmRpbmcgPlxuXG5cdFx0XHR0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGggPSB7fTsgLy8gaW5zaWRlOiBpbmRpY2VzIGluIHRoZXNlIGFycmF5c1xuXG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHR0aGlzLnN0YXRzID0ge1xuXHRcdFx0XHRvYmplY3RzOiB7XG5cdFx0XHRcdFx0Z2V0IHRvdGFsKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9vYmplY3RzLmxlbmd0aDtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Z2V0IGluVXNlKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMudG90YWwgLSBzY29wZS5uQ2FjaGVkT2JqZWN0c187XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Z2V0IGJpbmRpbmdzUGVyT2JqZWN0KCkge1xuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0YWRkKCkge1xuXHRcdFx0Y29uc3Qgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcblx0XHRcdFx0XHRcdHBhdGhzID0gdGhpcy5fcGF0aHMsXG5cdFx0XHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdFx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRcdGxldCBrbm93bk9iamVjdCA9IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c187XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1tpXSxcblx0XHRcdFx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkO1xuXHRcdFx0XHRsZXQgaW5kZXggPSBpbmRpY2VzQnlVVUlEW3V1aWRdO1xuXG5cdFx0XHRcdGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gdW5rbm93biBvYmplY3QgLT4gYWRkIGl0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXG5cdFx0XHRcdFx0aW5kZXggPSBuT2JqZWN0cysrO1xuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbdXVpZF0gPSBpbmRleDtcblx0XHRcdFx0XHRvYmplY3RzLnB1c2gob2JqZWN0KTsgLy8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdFx0YmluZGluZ3Nbal0ucHVzaChuZXcgUHJvcGVydHlCaW5kaW5nKG9iamVjdCwgcGF0aHNbal0sIHBhcnNlZFBhdGhzW2pdKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4IDwgbkNhY2hlZE9iamVjdHMpIHtcblx0XHRcdFx0XHRrbm93bk9iamVjdCA9IG9iamVjdHNbaW5kZXhdOyAvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxuXG5cdFx0XHRcdFx0Y29uc3QgZmlyc3RBY3RpdmVJbmRleCA9IC0tbkNhY2hlZE9iamVjdHMsXG5cdFx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbZmlyc3RBY3RpdmVJbmRleF07XG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFtsYXN0Q2FjaGVkT2JqZWN0LnV1aWRdID0gaW5kZXg7XG5cdFx0XHRcdFx0b2JqZWN0c1tpbmRleF0gPSBsYXN0Q2FjaGVkT2JqZWN0O1xuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbdXVpZF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbZmlyc3RBY3RpdmVJbmRleF0gPSBvYmplY3Q7IC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArK2opIHtcblx0XHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzW2pdLFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFtmaXJzdEFjdGl2ZUluZGV4XTtcblx0XHRcdFx0XHRcdGxldCBiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoW2luZGV4XTtcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFtpbmRleF0gPSBsYXN0Q2FjaGVkO1xuXG5cdFx0XHRcdFx0XHRpZiAoYmluZGluZyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHNpbmNlIHdlIGRvIG5vdCBib3RoZXIgdG8gY3JlYXRlIG5ldyBiaW5kaW5nc1xuXHRcdFx0XHRcdFx0XHQvLyBmb3Igb2JqZWN0cyB0aGF0IGFyZSBjYWNoZWQsIHRoZSBiaW5kaW5nIG1heVxuXHRcdFx0XHRcdFx0XHQvLyBvciBtYXkgbm90IGV4aXN0XG5cdFx0XHRcdFx0XHRcdGJpbmRpbmcgPSBuZXcgUHJvcGVydHlCaW5kaW5nKG9iamVjdCwgcGF0aHNbal0sIHBhcnNlZFBhdGhzW2pdKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2ZpcnN0QWN0aXZlSW5kZXhdID0gYmluZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0c1tpbmRleF0gIT09IGtub3duT2JqZWN0KSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQW5pbWF0aW9uT2JqZWN0R3JvdXA6IERpZmZlcmVudCBvYmplY3RzIHdpdGggdGhlIHNhbWUgVVVJRCAnICsgJ2RldGVjdGVkLiBDbGVhbiB0aGUgY2FjaGVzIG9yIHJlY3JlYXRlIHlvdXIgaW5mcmFzdHJ1Y3R1cmUgd2hlbiByZWxvYWRpbmcgc2NlbmVzLicpO1xuXHRcdFx0XHR9IC8vIGVsc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IHdoZXJlIHdlIHdhbnQgaXQgdG8gYmVcblxuXHRcdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblxuXHRcdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblx0XHR9XG5cblx0XHRyZW1vdmUoKSB7XG5cdFx0XHRjb25zdCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdFx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuXHRcdFx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdFx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRcdGxldCBuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRjb25zdCBvYmplY3QgPSBhcmd1bWVudHNbaV0sXG5cdFx0XHRcdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEW3V1aWRdO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID49IG5DYWNoZWRPYmplY3RzKSB7XG5cdFx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxuXHRcdFx0XHRcdGNvbnN0IGxhc3RDYWNoZWRJbmRleCA9IG5DYWNoZWRPYmplY3RzKyssXG5cdFx0XHRcdFx0XHRcdFx0Zmlyc3RBY3RpdmVPYmplY3QgPSBvYmplY3RzW2xhc3RDYWNoZWRJbmRleF07XG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFtmaXJzdEFjdGl2ZU9iamVjdC51dWlkXSA9IGluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbaW5kZXhdID0gZmlyc3RBY3RpdmVPYmplY3Q7XG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFt1dWlkXSA9IGxhc3RDYWNoZWRJbmRleDtcblx0XHRcdFx0XHRvYmplY3RzW2xhc3RDYWNoZWRJbmRleF0gPSBvYmplY3Q7IC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArK2opIHtcblx0XHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzW2pdLFxuXHRcdFx0XHRcdFx0XHRcdFx0Zmlyc3RBY3RpdmUgPSBiaW5kaW5nc0ZvclBhdGhbbGFzdENhY2hlZEluZGV4XSxcblx0XHRcdFx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbaW5kZXhdO1xuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2luZGV4XSA9IGZpcnN0QWN0aXZlO1xuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2xhc3RDYWNoZWRJbmRleF0gPSBiaW5kaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblxuXHRcdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblx0XHR9IC8vIHJlbW92ZSAmIGZvcmdldFxuXG5cblx0XHR1bmNhY2hlKCkge1xuXHRcdFx0Y29uc3Qgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcblx0XHRcdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRcdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cdFx0XHRsZXQgbkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRjb25zdCBvYmplY3QgPSBhcmd1bWVudHNbaV0sXG5cdFx0XHRcdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEW3V1aWRdO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGluZGljZXNCeVVVSURbdXVpZF07XG5cblx0XHRcdFx0XHRpZiAoaW5kZXggPCBuQ2FjaGVkT2JqZWN0cykge1xuXHRcdFx0XHRcdFx0Ly8gb2JqZWN0IGlzIGNhY2hlZCwgc2hyaW5rIHRoZSBDQUNIRUQgcmVnaW9uXG5cdFx0XHRcdFx0XHRjb25zdCBmaXJzdEFjdGl2ZUluZGV4ID0gLS1uQ2FjaGVkT2JqZWN0cyxcblx0XHRcdFx0XHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzW2ZpcnN0QWN0aXZlSW5kZXhdLFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFzdEluZGV4ID0gLS1uT2JqZWN0cyxcblx0XHRcdFx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzW2xhc3RJbmRleF07IC8vIGxhc3QgY2FjaGVkIG9iamVjdCB0YWtlcyB0aGlzIG9iamVjdCdzIHBsYWNlXG5cblx0XHRcdFx0XHRcdGluZGljZXNCeVVVSURbbGFzdENhY2hlZE9iamVjdC51dWlkXSA9IGluZGV4O1xuXHRcdFx0XHRcdFx0b2JqZWN0c1tpbmRleF0gPSBsYXN0Q2FjaGVkT2JqZWN0OyAvLyBsYXN0IG9iamVjdCBnb2VzIHRvIHRoZSBhY3RpdmF0ZWQgc2xvdCBhbmQgcG9wXG5cblx0XHRcdFx0XHRcdGluZGljZXNCeVVVSURbbGFzdE9iamVjdC51dWlkXSA9IGZpcnN0QWN0aXZlSW5kZXg7XG5cdFx0XHRcdFx0XHRvYmplY3RzW2ZpcnN0QWN0aXZlSW5kZXhdID0gbGFzdE9iamVjdDtcblx0XHRcdFx0XHRcdG9iamVjdHMucG9wKCk7IC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1tqXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFtmaXJzdEFjdGl2ZUluZGV4XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bGFzdCA9IGJpbmRpbmdzRm9yUGF0aFtsYXN0SW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbaW5kZXhdID0gbGFzdENhY2hlZDtcblx0XHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2ZpcnN0QWN0aXZlSW5kZXhdID0gbGFzdDtcblx0XHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoLnBvcCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBvYmplY3QgaXMgYWN0aXZlLCBqdXN0IHN3YXAgd2l0aCB0aGUgbGFzdCBhbmQgcG9wXG5cdFx0XHRcdFx0XHRjb25zdCBsYXN0SW5kZXggPSAtLW5PYmplY3RzLFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbbGFzdEluZGV4XTtcblxuXHRcdFx0XHRcdFx0aWYgKGxhc3RJbmRleCA+IDApIHtcblx0XHRcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFtsYXN0T2JqZWN0LnV1aWRdID0gaW5kZXg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG9iamVjdHNbaW5kZXhdID0gbGFzdE9iamVjdDtcblx0XHRcdFx0XHRcdG9iamVjdHMucG9wKCk7IC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1tqXTtcblx0XHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2luZGV4XSA9IGJpbmRpbmdzRm9yUGF0aFtsYXN0SW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSAvLyBjYWNoZWQgb3IgYWN0aXZlXG5cblx0XHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cblxuXHRcdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblxuXHRcdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblx0XHR9IC8vIEludGVybmFsIGludGVyZmFjZSB1c2VkIGJ5IGJlZnJpZW5kZWQgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZTpcblxuXG5cdFx0c3Vic2NyaWJlXyhwYXRoLCBwYXJzZWRQYXRoKSB7XG5cdFx0XHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIGJpbmRpbmdzIGZvciB0aGUgZ2l2ZW4gcGF0aCB0aGF0IGlzIGNoYW5nZWRcblx0XHRcdC8vIGFjY29yZGluZyB0byB0aGUgY29udGFpbmVkIG9iamVjdHMgaW4gdGhlIGdyb3VwXG5cdFx0XHRjb25zdCBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoO1xuXHRcdFx0bGV0IGluZGV4ID0gaW5kaWNlc0J5UGF0aFtwYXRoXTtcblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cdFx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkgcmV0dXJuIGJpbmRpbmdzW2luZGV4XTtcblx0XHRcdGNvbnN0IHBhdGhzID0gdGhpcy5fcGF0aHMsXG5cdFx0XHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0XHRcdFx0b2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRcdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aCA9IG5ldyBBcnJheShuT2JqZWN0cyk7XG5cdFx0XHRpbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRcdGluZGljZXNCeVBhdGhbcGF0aF0gPSBpbmRleDtcblx0XHRcdHBhdGhzLnB1c2gocGF0aCk7XG5cdFx0XHRwYXJzZWRQYXRocy5wdXNoKHBhcnNlZFBhdGgpO1xuXHRcdFx0YmluZGluZ3MucHVzaChiaW5kaW5nc0ZvclBhdGgpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gbkNhY2hlZE9iamVjdHMsIG4gPSBvYmplY3RzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IG9iamVjdHNbaV07XG5cdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFtpXSA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcob2JqZWN0LCBwYXRoLCBwYXJzZWRQYXRoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJpbmRpbmdzRm9yUGF0aDtcblx0XHR9XG5cblx0XHR1bnN1YnNjcmliZV8ocGF0aCkge1xuXHRcdFx0Ly8gdGVsbHMgdGhlIGdyb3VwIHRvIGZvcmdldCBhYm91dCBhIHByb3BlcnR5IHBhdGggYW5kIG5vIGxvbmdlclxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBhcnJheSBwcmV2aW91c2x5IG9idGFpbmVkIHdpdGggJ3N1YnNjcmliZV8nXG5cdFx0XHRjb25zdCBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxuXHRcdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoW3BhdGhdO1xuXG5cdFx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0XHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0XHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRcdFx0XHRsYXN0QmluZGluZ3NJbmRleCA9IGJpbmRpbmdzLmxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0XHRcdGxhc3RCaW5kaW5ncyA9IGJpbmRpbmdzW2xhc3RCaW5kaW5nc0luZGV4XSxcblx0XHRcdFx0XHRcdFx0bGFzdEJpbmRpbmdzUGF0aCA9IHBhdGhbbGFzdEJpbmRpbmdzSW5kZXhdO1xuXHRcdFx0XHRpbmRpY2VzQnlQYXRoW2xhc3RCaW5kaW5nc1BhdGhdID0gaW5kZXg7XG5cdFx0XHRcdGJpbmRpbmdzW2luZGV4XSA9IGxhc3RCaW5kaW5ncztcblx0XHRcdFx0YmluZGluZ3MucG9wKCk7XG5cdFx0XHRcdHBhcnNlZFBhdGhzW2luZGV4XSA9IHBhcnNlZFBhdGhzW2xhc3RCaW5kaW5nc0luZGV4XTtcblx0XHRcdFx0cGFyc2VkUGF0aHMucG9wKCk7XG5cdFx0XHRcdHBhdGhzW2luZGV4XSA9IHBhdGhzW2xhc3RCaW5kaW5nc0luZGV4XTtcblx0XHRcdFx0cGF0aHMucG9wKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRBbmltYXRpb25PYmplY3RHcm91cC5wcm90b3R5cGUuaXNBbmltYXRpb25PYmplY3RHcm91cCA9IHRydWU7XG5cblx0Y2xhc3MgQW5pbWF0aW9uQWN0aW9uIHtcblx0XHRjb25zdHJ1Y3RvcihtaXhlciwgY2xpcCwgbG9jYWxSb290ID0gbnVsbCwgYmxlbmRNb2RlID0gY2xpcC5ibGVuZE1vZGUpIHtcblx0XHRcdHRoaXMuX21peGVyID0gbWl4ZXI7XG5cdFx0XHR0aGlzLl9jbGlwID0gY2xpcDtcblx0XHRcdHRoaXMuX2xvY2FsUm9vdCA9IGxvY2FsUm9vdDtcblx0XHRcdHRoaXMuYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuXHRcdFx0Y29uc3QgdHJhY2tzID0gY2xpcC50cmFja3MsXG5cdFx0XHRcdFx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcblx0XHRcdFx0XHRcdGludGVycG9sYW50cyA9IG5ldyBBcnJheShuVHJhY2tzKTtcblx0XHRcdGNvbnN0IGludGVycG9sYW50U2V0dGluZ3MgPSB7XG5cdFx0XHRcdGVuZGluZ1N0YXJ0OiBaZXJvQ3VydmF0dXJlRW5kaW5nLFxuXHRcdFx0XHRlbmRpbmdFbmQ6IFplcm9DdXJ2YXR1cmVFbmRpbmdcblx0XHRcdH07XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuVHJhY2tzOyArK2kpIHtcblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnQgPSB0cmFja3NbaV0uY3JlYXRlSW50ZXJwb2xhbnQobnVsbCk7XG5cdFx0XHRcdGludGVycG9sYW50c1tpXSA9IGludGVycG9sYW50O1xuXHRcdFx0XHRpbnRlcnBvbGFudC5zZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xuXHRcdFx0dGhpcy5faW50ZXJwb2xhbnRzID0gaW50ZXJwb2xhbnRzOyAvLyBib3VuZCBieSB0aGUgbWl4ZXJcblx0XHRcdC8vIGluc2lkZTogUHJvcGVydHlNaXhlciAobWFuYWdlZCBieSB0aGUgbWl4ZXIpXG5cblx0XHRcdHRoaXMuX3Byb3BlcnR5QmluZGluZ3MgPSBuZXcgQXJyYXkoblRyYWNrcyk7XG5cdFx0XHR0aGlzLl9jYWNoZUluZGV4ID0gbnVsbDsgLy8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxuXG5cdFx0XHR0aGlzLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDsgLy8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxuXG5cdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XG5cdFx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IG51bGw7XG5cdFx0XHR0aGlzLmxvb3AgPSBMb29wUmVwZWF0O1xuXHRcdFx0dGhpcy5fbG9vcENvdW50ID0gLTE7IC8vIGdsb2JhbCBtaXhlciB0aW1lIHdoZW4gdGhlIGFjdGlvbiBpcyB0byBiZSBzdGFydGVkXG5cdFx0XHQvLyBpdCdzIHNldCBiYWNrIHRvICdudWxsJyB1cG9uIHN0YXJ0IG9mIHRoZSBhY3Rpb25cblxuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDsgLy8gc2NhbGVkIGxvY2FsIHRpbWUgb2YgdGhlIGFjdGlvblxuXHRcdFx0Ly8gZ2V0cyBjbGFtcGVkIG9yIHdyYXBwZWQgdG8gMC4uY2xpcC5kdXJhdGlvbiBhY2NvcmRpbmcgdG8gbG9vcFxuXG5cdFx0XHR0aGlzLnRpbWUgPSAwO1xuXHRcdFx0dGhpcy50aW1lU2NhbGUgPSAxO1xuXHRcdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gMTtcblx0XHRcdHRoaXMud2VpZ2h0ID0gMTtcblx0XHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XG5cdFx0XHR0aGlzLnJlcGV0aXRpb25zID0gSW5maW5pdHk7IC8vIG5vLiBvZiByZXBldGl0aW9ucyB3aGVuIGxvb3BpbmdcblxuXHRcdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTsgLy8gdHJ1ZSAtPiB6ZXJvIGVmZmVjdGl2ZSB0aW1lIHNjYWxlXG5cblx0XHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7IC8vIGZhbHNlIC0+IHplcm8gZWZmZWN0aXZlIHdlaWdodFxuXG5cdFx0XHR0aGlzLmNsYW1wV2hlbkZpbmlzaGVkID0gZmFsc2U7IC8vIGtlZXAgZmVlZGluZyB0aGUgbGFzdCBmcmFtZT9cblxuXHRcdFx0dGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID0gdHJ1ZTsgLy8gZm9yIHNtb290aCBpbnRlcnBvbGF0aW9uIHcvbyBzZXBhcmF0ZVxuXG5cdFx0XHR0aGlzLnplcm9TbG9wZUF0RW5kID0gdHJ1ZTsgLy8gY2xpcHMgZm9yIHN0YXJ0LCBsb29wIGFuZCBlbmRcblx0XHR9IC8vIFN0YXRlICYgU2NoZWR1bGluZ1xuXG5cblx0XHRwbGF5KCkge1xuXHRcdFx0dGhpcy5fbWl4ZXIuX2FjdGl2YXRlQWN0aW9uKHRoaXMpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzdG9wKCkge1xuXHRcdFx0dGhpcy5fbWl4ZXIuX2RlYWN0aXZhdGVBY3Rpb24odGhpcyk7XG5cblx0XHRcdHJldHVybiB0aGlzLnJlc2V0KCk7XG5cdFx0fVxuXG5cdFx0cmVzZXQoKSB7XG5cdFx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMudGltZSA9IDA7IC8vIHJlc3RhcnQgY2xpcFxuXG5cdFx0XHR0aGlzLl9sb29wQ291bnQgPSAtMTsgLy8gZm9yZ2V0IHByZXZpb3VzIGxvb3BzXG5cblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7IC8vIGZvcmdldCBzY2hlZHVsaW5nXG5cblx0XHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpO1xuXHRcdH1cblxuXHRcdGlzUnVubmluZygpIHtcblx0XHRcdHJldHVybiB0aGlzLmVuYWJsZWQgJiYgIXRoaXMucGF1c2VkICYmIHRoaXMudGltZVNjYWxlICE9PSAwICYmIHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCAmJiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24odGhpcyk7XG5cdFx0fSAvLyByZXR1cm4gdHJ1ZSB3aGVuIHBsYXkgaGFzIGJlZW4gY2FsbGVkXG5cblxuXHRcdGlzU2NoZWR1bGVkKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbih0aGlzKTtcblx0XHR9XG5cblx0XHRzdGFydEF0KHRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRMb29wKG1vZGUsIHJlcGV0aXRpb25zKSB7XG5cdFx0XHR0aGlzLmxvb3AgPSBtb2RlO1xuXHRcdFx0dGhpcy5yZXBldGl0aW9ucyA9IHJlcGV0aXRpb25zO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSAvLyBXZWlnaHRcblx0XHQvLyBzZXQgdGhlIHdlaWdodCBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIGZhZGluZ1xuXHRcdC8vIGFsdGhvdWdoIC5lbmFibGVkID0gZmFsc2UgeWllbGRzIGFuIGVmZmVjdGl2ZSB3ZWlnaHQgb2YgemVybywgdGhpc1xuXHRcdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAuZW5hYmxlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcblxuXG5cdFx0c2V0RWZmZWN0aXZlV2VpZ2h0KHdlaWdodCkge1xuXHRcdFx0dGhpcy53ZWlnaHQgPSB3ZWlnaHQ7IC8vIG5vdGU6IHNhbWUgbG9naWMgYXMgd2hlbiB1cGRhdGVkIGF0IHJ1bnRpbWVcblxuXHRcdFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gdGhpcy5lbmFibGVkID8gd2VpZ2h0IDogMDtcblx0XHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKTtcblx0XHR9IC8vIHJldHVybiB0aGUgd2VpZ2h0IGNvbnNpZGVyaW5nIGZhZGluZyBhbmQgLmVuYWJsZWRcblxuXG5cdFx0Z2V0RWZmZWN0aXZlV2VpZ2h0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcblx0XHR9XG5cblx0XHRmYWRlSW4oZHVyYXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyhkdXJhdGlvbiwgMCwgMSk7XG5cdFx0fVxuXG5cdFx0ZmFkZU91dChkdXJhdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKGR1cmF0aW9uLCAxLCAwKTtcblx0XHR9XG5cblx0XHRjcm9zc0ZhZGVGcm9tKGZhZGVPdXRBY3Rpb24sIGR1cmF0aW9uLCB3YXJwKSB7XG5cdFx0XHRmYWRlT3V0QWN0aW9uLmZhZGVPdXQoZHVyYXRpb24pO1xuXHRcdFx0dGhpcy5mYWRlSW4oZHVyYXRpb24pO1xuXG5cdFx0XHRpZiAod2FycCkge1xuXHRcdFx0XHRjb25zdCBmYWRlSW5EdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdGZhZGVPdXREdXJhdGlvbiA9IGZhZGVPdXRBY3Rpb24uX2NsaXAuZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdHN0YXJ0RW5kUmF0aW8gPSBmYWRlT3V0RHVyYXRpb24gLyBmYWRlSW5EdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0ZW5kU3RhcnRSYXRpbyA9IGZhZGVJbkR1cmF0aW9uIC8gZmFkZU91dER1cmF0aW9uO1xuXHRcdFx0XHRmYWRlT3V0QWN0aW9uLndhcnAoMS4wLCBzdGFydEVuZFJhdGlvLCBkdXJhdGlvbik7XG5cdFx0XHRcdHRoaXMud2FycChlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y3Jvc3NGYWRlVG8oZmFkZUluQWN0aW9uLCBkdXJhdGlvbiwgd2FycCkge1xuXHRcdFx0cmV0dXJuIGZhZGVJbkFjdGlvbi5jcm9zc0ZhZGVGcm9tKHRoaXMsIGR1cmF0aW9uLCB3YXJwKTtcblx0XHR9XG5cblx0XHRzdG9wRmFkaW5nKCkge1xuXHRcdFx0Y29uc3Qgd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuXHRcdFx0aWYgKHdlaWdodEludGVycG9sYW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcblxuXHRcdFx0XHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQod2VpZ2h0SW50ZXJwb2xhbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IC8vIFRpbWUgU2NhbGUgQ29udHJvbFxuXHRcdC8vIHNldCB0aGUgdGltZSBzY2FsZSBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIHdhcnBpbmdcblx0XHQvLyBhbHRob3VnaCAucGF1c2VkID0gdHJ1ZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHRpbWUgc2NhbGUgb2YgemVybywgdGhpc1xuXHRcdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAucGF1c2VkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXG5cblx0XHRzZXRFZmZlY3RpdmVUaW1lU2NhbGUodGltZVNjYWxlKSB7XG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcblx0XHRcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRoaXMucGF1c2VkID8gMCA6IHRpbWVTY2FsZTtcblx0XHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cdFx0fSAvLyByZXR1cm4gdGhlIHRpbWUgc2NhbGUgY29uc2lkZXJpbmcgd2FycGluZyBhbmQgLnBhdXNlZFxuXG5cblx0XHRnZXRFZmZlY3RpdmVUaW1lU2NhbGUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlO1xuXHRcdH1cblxuXHRcdHNldER1cmF0aW9uKGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuX2NsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcblx0XHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cdFx0fVxuXG5cdFx0c3luY1dpdGgoYWN0aW9uKSB7XG5cdFx0XHR0aGlzLnRpbWUgPSBhY3Rpb24udGltZTtcblx0XHRcdHRoaXMudGltZVNjYWxlID0gYWN0aW9uLnRpbWVTY2FsZTtcblx0XHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cdFx0fVxuXG5cdFx0aGFsdChkdXJhdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMud2FycCh0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUsIDAsIGR1cmF0aW9uKTtcblx0XHR9XG5cblx0XHR3YXJwKHN0YXJ0VGltZVNjYWxlLCBlbmRUaW1lU2NhbGUsIGR1cmF0aW9uKSB7XG5cdFx0XHRjb25zdCBtaXhlciA9IHRoaXMuX21peGVyLFxuXHRcdFx0XHRcdFx0bm93ID0gbWl4ZXIudGltZSxcblx0XHRcdFx0XHRcdHRpbWVTY2FsZSA9IHRoaXMudGltZVNjYWxlO1xuXHRcdFx0bGV0IGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cblx0XHRcdGlmIChpbnRlcnBvbGFudCA9PT0gbnVsbCkge1xuXHRcdFx0XHRpbnRlcnBvbGFudCA9IG1peGVyLl9sZW5kQ29udHJvbEludGVycG9sYW50KCk7XG5cdFx0XHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxuXHRcdFx0XHRcdFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xuXHRcdFx0dGltZXNbMF0gPSBub3c7XG5cdFx0XHR0aW1lc1sxXSA9IG5vdyArIGR1cmF0aW9uO1xuXHRcdFx0dmFsdWVzWzBdID0gc3RhcnRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XG5cdFx0XHR2YWx1ZXNbMV0gPSBlbmRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzdG9wV2FycGluZygpIHtcblx0XHRcdGNvbnN0IHRpbWVTY2FsZUludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cblx0XHRcdGlmICh0aW1lU2NhbGVJbnRlcnBvbGFudCAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XG5cblx0XHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KHRpbWVTY2FsZUludGVycG9sYW50KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSAvLyBPYmplY3QgQWNjZXNzb3JzXG5cblxuXHRcdGdldE1peGVyKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21peGVyO1xuXHRcdH1cblxuXHRcdGdldENsaXAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xpcDtcblx0XHR9XG5cblx0XHRnZXRSb290KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2xvY2FsUm9vdCB8fCB0aGlzLl9taXhlci5fcm9vdDtcblx0XHR9IC8vIEludGVybmFcblxuXG5cdFx0X3VwZGF0ZSh0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCkge1xuXHRcdFx0Ly8gY2FsbGVkIGJ5IHRoZSBtaXhlclxuXHRcdFx0aWYgKCF0aGlzLmVuYWJsZWQpIHtcblx0XHRcdFx0Ly8gY2FsbCAuX3VwZGF0ZVdlaWdodCgpIHRvIHVwZGF0ZSAuX2VmZmVjdGl2ZVdlaWdodFxuXHRcdFx0XHR0aGlzLl91cGRhdGVXZWlnaHQodGltZSk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWU7XG5cblx0XHRcdGlmIChzdGFydFRpbWUgIT09IG51bGwpIHtcblx0XHRcdFx0Ly8gY2hlY2sgZm9yIHNjaGVkdWxlZCBzdGFydCBvZiBhY3Rpb25cblx0XHRcdFx0Y29uc3QgdGltZVJ1bm5pbmcgPSAodGltZSAtIHN0YXJ0VGltZSkgKiB0aW1lRGlyZWN0aW9uO1xuXG5cdFx0XHRcdGlmICh0aW1lUnVubmluZyA8IDAgfHwgdGltZURpcmVjdGlvbiA9PT0gMCkge1xuXHRcdFx0XHRcdHJldHVybjsgLy8geWV0IHRvIGNvbWUgLyBkb24ndCBkZWNpZGUgd2hlbiBkZWx0YSA9IDBcblx0XHRcdFx0fSAvLyBzdGFydFxuXG5cblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDsgLy8gdW5zY2hlZHVsZVxuXG5cdFx0XHRcdGRlbHRhVGltZSA9IHRpbWVEaXJlY3Rpb24gKiB0aW1lUnVubmluZztcblx0XHRcdH0gLy8gYXBwbHkgdGltZSBzY2FsZSBhbmQgYWR2YW5jZSB0aW1lXG5cblxuXHRcdFx0ZGVsdGFUaW1lICo9IHRoaXMuX3VwZGF0ZVRpbWVTY2FsZSh0aW1lKTtcblxuXHRcdFx0Y29uc3QgY2xpcFRpbWUgPSB0aGlzLl91cGRhdGVUaW1lKGRlbHRhVGltZSk7IC8vIG5vdGU6IF91cGRhdGVUaW1lIG1heSBkaXNhYmxlIHRoZSBhY3Rpb24gcmVzdWx0aW5nIGluXG5cdFx0XHQvLyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIDBcblxuXG5cdFx0XHRjb25zdCB3ZWlnaHQgPSB0aGlzLl91cGRhdGVXZWlnaHQodGltZSk7XG5cblx0XHRcdGlmICh3ZWlnaHQgPiAwKSB7XG5cdFx0XHRcdGNvbnN0IGludGVycG9sYW50cyA9IHRoaXMuX2ludGVycG9sYW50cztcblx0XHRcdFx0Y29uc3QgcHJvcGVydHlNaXhlcnMgPSB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0XHRcdHN3aXRjaCAodGhpcy5ibGVuZE1vZGUpIHtcblx0XHRcdFx0XHRjYXNlIEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlOlxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBpbnRlcnBvbGFudHMubGVuZ3RoOyBqICE9PSBtOyArK2opIHtcblx0XHRcdFx0XHRcdFx0aW50ZXJwb2xhbnRzW2pdLmV2YWx1YXRlKGNsaXBUaW1lKTtcblx0XHRcdFx0XHRcdFx0cHJvcGVydHlNaXhlcnNbal0uYWNjdW11bGF0ZUFkZGl0aXZlKHdlaWdodCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGU6XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBtID0gaW50ZXJwb2xhbnRzLmxlbmd0aDsgaiAhPT0gbTsgKytqKSB7XG5cdFx0XHRcdFx0XHRcdGludGVycG9sYW50c1tqXS5ldmFsdWF0ZShjbGlwVGltZSk7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5TWl4ZXJzW2pdLmFjY3VtdWxhdGUoYWNjdUluZGV4LCB3ZWlnaHQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRfdXBkYXRlV2VpZ2h0KHRpbWUpIHtcblx0XHRcdGxldCB3ZWlnaHQgPSAwO1xuXG5cdFx0XHRpZiAodGhpcy5lbmFibGVkKSB7XG5cdFx0XHRcdHdlaWdodCA9IHRoaXMud2VpZ2h0O1xuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG5cdFx0XHRcdGlmIChpbnRlcnBvbGFudCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnN0IGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSh0aW1lKVswXTtcblx0XHRcdFx0XHR3ZWlnaHQgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuXHRcdFx0XHRcdGlmICh0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWzFdKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0b3BGYWRpbmcoKTtcblxuXHRcdFx0XHRcdFx0aWYgKGludGVycG9sYW50VmFsdWUgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0Ly8gZmFkZWQgb3V0LCBkaXNhYmxlXG5cdFx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0XHRyZXR1cm4gd2VpZ2h0O1xuXHRcdH1cblxuXHRcdF91cGRhdGVUaW1lU2NhbGUodGltZSkge1xuXHRcdFx0bGV0IHRpbWVTY2FsZSA9IDA7XG5cblx0XHRcdGlmICghdGhpcy5wYXVzZWQpIHtcblx0XHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG5cdFx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cblx0XHRcdFx0aWYgKGludGVycG9sYW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKHRpbWUpWzBdO1xuXHRcdFx0XHRcdHRpbWVTY2FsZSAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbMV0pIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHRcdFx0XHRcdFx0aWYgKHRpbWVTY2FsZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHQvLyBtb3Rpb24gaGFzIGhhbHRlZCwgcGF1c2Vcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gd2FycCBkb25lIC0gYXBwbHkgZmluYWwgdGltZSBzY2FsZVxuXHRcdFx0XHRcdFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGltZVNjYWxlO1xuXHRcdFx0cmV0dXJuIHRpbWVTY2FsZTtcblx0XHR9XG5cblx0XHRfdXBkYXRlVGltZShkZWx0YVRpbWUpIHtcblx0XHRcdGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbjtcblx0XHRcdGNvbnN0IGxvb3AgPSB0aGlzLmxvb3A7XG5cdFx0XHRsZXQgdGltZSA9IHRoaXMudGltZSArIGRlbHRhVGltZTtcblx0XHRcdGxldCBsb29wQ291bnQgPSB0aGlzLl9sb29wQ291bnQ7XG5cdFx0XHRjb25zdCBwaW5nUG9uZyA9IGxvb3AgPT09IExvb3BQaW5nUG9uZztcblxuXHRcdFx0aWYgKGRlbHRhVGltZSA9PT0gMCkge1xuXHRcdFx0XHRpZiAobG9vcENvdW50ID09PSAtMSkgcmV0dXJuIHRpbWU7XG5cdFx0XHRcdHJldHVybiBwaW5nUG9uZyAmJiAobG9vcENvdW50ICYgMSkgPT09IDEgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobG9vcCA9PT0gTG9vcE9uY2UpIHtcblx0XHRcdFx0aWYgKGxvb3BDb3VudCA9PT0gLTEpIHtcblx0XHRcdFx0XHQvLyBqdXN0IHN0YXJ0ZWRcblx0XHRcdFx0XHR0aGlzLl9sb29wQ291bnQgPSAwO1xuXG5cdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyh0cnVlLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRoYW5kbGVfc3RvcDoge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IGR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHR0aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdFx0dGltZSA9IDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cdFx0XHRcdFx0XHRicmVhayBoYW5kbGVfc3RvcDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodGhpcy5jbGFtcFdoZW5GaW5pc2hlZCkgdGhpcy5wYXVzZWQgPSB0cnVlO2Vsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcblxuXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJyxcblx0XHRcdFx0XHRcdGFjdGlvbjogdGhpcyxcblx0XHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lIDwgMCA/IC0xIDogMVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyByZXBldGl0aXZlIFJlcGVhdCBvciBQaW5nUG9uZ1xuXHRcdFx0XHRpZiAobG9vcENvdW50ID09PSAtMSkge1xuXHRcdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxuXHRcdFx0XHRcdGlmIChkZWx0YVRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0bG9vcENvdW50ID0gMDtcblxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyh0cnVlLCB0aGlzLnJlcGV0aXRpb25zID09PSAwLCBwaW5nUG9uZyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHdoZW4gbG9vcGluZyBpbiByZXZlcnNlIGRpcmVjdGlvbiwgdGhlIGluaXRpYWxcblx0XHRcdFx0XHRcdC8vIHRyYW5zaXRpb24gdGhyb3VnaCB6ZXJvIGNvdW50cyBhcyBhIHJlcGV0aXRpb24sXG5cdFx0XHRcdFx0XHQvLyBzbyBsZWF2ZSBsb29wQ291bnQgYXQgLTFcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3ModGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgdHJ1ZSwgcGluZ1BvbmcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0Ly8gd3JhcCBhcm91bmRcblx0XHRcdFx0XHRjb25zdCBsb29wRGVsdGEgPSBNYXRoLmZsb29yKHRpbWUgLyBkdXJhdGlvbik7IC8vIHNpZ25lZFxuXG5cdFx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcblx0XHRcdFx0XHRsb29wQ291bnQgKz0gTWF0aC5hYnMobG9vcERlbHRhKTtcblx0XHRcdFx0XHRjb25zdCBwZW5kaW5nID0gdGhpcy5yZXBldGl0aW9ucyAtIGxvb3BDb3VudDtcblxuXHRcdFx0XHRcdGlmIChwZW5kaW5nIDw9IDApIHtcblx0XHRcdFx0XHRcdC8vIGhhdmUgdG8gc3RvcCAoc3dpdGNoIHN0YXRlLCBjbGFtcCB0aW1lLCBmaXJlIGV2ZW50KVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuY2xhbXBXaGVuRmluaXNoZWQpIHRoaXMucGF1c2VkID0gdHJ1ZTtlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XG5cdFx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJyxcblx0XHRcdFx0XHRcdFx0YWN0aW9uOiB0aGlzLFxuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IGRlbHRhVGltZSA+IDAgPyAxIDogLTFcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBrZWVwIHJ1bm5pbmdcblx0XHRcdFx0XHRcdGlmIChwZW5kaW5nID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGVudGVyaW5nIHRoZSBsYXN0IHJvdW5kXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGF0U3RhcnQgPSBkZWx0YVRpbWUgPCAwO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoYXRTdGFydCwgIWF0U3RhcnQsIHBpbmdQb25nKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoZmFsc2UsIGZhbHNlLCBwaW5nUG9uZyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcblx0XHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cblx0XHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAnbG9vcCcsXG5cdFx0XHRcdFx0XHRcdGFjdGlvbjogdGhpcyxcblx0XHRcdFx0XHRcdFx0bG9vcERlbHRhOiBsb29wRGVsdGFcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBpbmdQb25nICYmIChsb29wQ291bnQgJiAxKSA9PT0gMSkge1xuXHRcdFx0XHRcdC8vIGludmVydCB0aW1lIGZvciB0aGUgXCJwb25nIHJvdW5kXCJcblx0XHRcdFx0XHRyZXR1cm4gZHVyYXRpb24gLSB0aW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aW1lO1xuXHRcdH1cblxuXHRcdF9zZXRFbmRpbmdzKGF0U3RhcnQsIGF0RW5kLCBwaW5nUG9uZykge1xuXHRcdFx0Y29uc3Qgc2V0dGluZ3MgPSB0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzO1xuXG5cdFx0XHRpZiAocGluZ1BvbmcpIHtcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBaZXJvU2xvcGVFbmRpbmc7XG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ0VuZCA9IFplcm9TbG9wZUVuZGluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGFzc3VtaW5nIGZvciBMb29wT25jZSBhdFN0YXJ0ID09IGF0RW5kID09IHRydWVcblx0XHRcdFx0aWYgKGF0U3RhcnQpIHtcblx0XHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IHRoaXMuemVyb1Nsb3BlQXRTdGFydCA/IFplcm9TbG9wZUVuZGluZyA6IFplcm9DdXJ2YXR1cmVFbmRpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBXcmFwQXJvdW5kRW5kaW5nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGF0RW5kKSB7XG5cdFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gdGhpcy56ZXJvU2xvcGVBdEVuZCA/IFplcm9TbG9wZUVuZGluZyA6IFplcm9DdXJ2YXR1cmVFbmRpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gV3JhcEFyb3VuZEVuZGluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9zY2hlZHVsZUZhZGluZyhkdXJhdGlvbiwgd2VpZ2h0Tm93LCB3ZWlnaHRUaGVuKSB7XG5cdFx0XHRjb25zdCBtaXhlciA9IHRoaXMuX21peGVyLFxuXHRcdFx0XHRcdFx0bm93ID0gbWl4ZXIudGltZTtcblx0XHRcdGxldCBpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG5cdFx0XHRpZiAoaW50ZXJwb2xhbnQgPT09IG51bGwpIHtcblx0XHRcdFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpO1xuXHRcdFx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0aW1lcyA9IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9ucyxcblx0XHRcdFx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcblx0XHRcdHRpbWVzWzBdID0gbm93O1xuXHRcdFx0dmFsdWVzWzBdID0gd2VpZ2h0Tm93O1xuXHRcdFx0dGltZXNbMV0gPSBub3cgKyBkdXJhdGlvbjtcblx0XHRcdHZhbHVlc1sxXSA9IHdlaWdodFRoZW47XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEFuaW1hdGlvbk1peGVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRjb25zdHJ1Y3Rvcihyb290KSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5fcm9vdCA9IHJvb3Q7XG5cblx0XHRcdHRoaXMuX2luaXRNZW1vcnlNYW5hZ2VyKCk7XG5cblx0XHRcdHRoaXMuX2FjY3VJbmRleCA9IDA7XG5cdFx0XHR0aGlzLnRpbWUgPSAwO1xuXHRcdFx0dGhpcy50aW1lU2NhbGUgPSAxLjA7XG5cdFx0fVxuXG5cdFx0X2JpbmRBY3Rpb24oYWN0aW9uLCBwcm90b3R5cGVBY3Rpb24pIHtcblx0XHRcdGNvbnN0IHJvb3QgPSBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290LFxuXHRcdFx0XHRcdFx0dHJhY2tzID0gYWN0aW9uLl9jbGlwLnRyYWNrcyxcblx0XHRcdFx0XHRcdG5UcmFja3MgPSB0cmFja3MubGVuZ3RoLFxuXHRcdFx0XHRcdFx0YmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3MsXG5cdFx0XHRcdFx0XHRpbnRlcnBvbGFudHMgPSBhY3Rpb24uX2ludGVycG9sYW50cyxcblx0XHRcdFx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXHRcdFx0XHRcdFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWU7XG5cdFx0XHRsZXQgYmluZGluZ3NCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFtyb290VXVpZF07XG5cblx0XHRcdGlmIChiaW5kaW5nc0J5TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGJpbmRpbmdzQnlOYW1lID0ge307XG5cdFx0XHRcdGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXSA9IGJpbmRpbmdzQnlOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gblRyYWNrczsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldLFxuXHRcdFx0XHRcdFx0XHR0cmFja05hbWUgPSB0cmFjay5uYW1lO1xuXHRcdFx0XHRsZXQgYmluZGluZyA9IGJpbmRpbmdzQnlOYW1lW3RyYWNrTmFtZV07XG5cblx0XHRcdFx0aWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGJpbmRpbmdzW2ldID0gYmluZGluZztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbaV07XG5cblx0XHRcdFx0XHRpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHQvLyBleGlzdGluZyBiaW5kaW5nLCBtYWtlIHN1cmUgdGhlIGNhY2hlIGtub3dzXG5cdFx0XHRcdFx0XHRpZiAoYmluZGluZy5fY2FjaGVJbmRleCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHQrK2JpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5fcHJvcGVydHlCaW5kaW5nc1tpXS5iaW5kaW5nLnBhcnNlZFBhdGg7XG5cdFx0XHRcdFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eU1peGVyKFByb3BlcnR5QmluZGluZy5jcmVhdGUocm9vdCwgdHJhY2tOYW1lLCBwYXRoKSwgdHJhY2suVmFsdWVUeXBlTmFtZSwgdHJhY2suZ2V0VmFsdWVTaXplKCkpO1xuXHRcdFx0XHRcdCsrYmluZGluZy5yZWZlcmVuY2VDb3VudDtcblxuXHRcdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyhiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lKTtcblxuXHRcdFx0XHRcdGJpbmRpbmdzW2ldID0gYmluZGluZztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGludGVycG9sYW50c1tpXS5yZXN1bHRCdWZmZXIgPSBiaW5kaW5nLmJ1ZmZlcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfYWN0aXZhdGVBY3Rpb24oYWN0aW9uKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2lzQWN0aXZlQWN0aW9uKGFjdGlvbikpIHtcblx0XHRcdFx0aWYgKGFjdGlvbi5fY2FjaGVJbmRleCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIHRoaXMgYWN0aW9uIGhhcyBiZWVuIGZvcmdvdHRlbiBieSB0aGUgY2FjaGUsIGJ1dCB0aGUgdXNlclxuXHRcdFx0XHRcdC8vIGFwcGVhcnMgdG8gYmUgc3RpbGwgdXNpbmcgaXQgLT4gcmViaW5kXG5cdFx0XHRcdFx0Y29uc3Qgcm9vdFV1aWQgPSAoYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCkudXVpZCxcblx0XHRcdFx0XHRcdFx0XHRjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxuXHRcdFx0XHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF07XG5cblx0XHRcdFx0XHR0aGlzLl9iaW5kQWN0aW9uKGFjdGlvbiwgYWN0aW9uc0ZvckNsaXAgJiYgYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWzBdKTtcblxuXHRcdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzOyAvLyBpbmNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRcdGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcblxuXHRcdFx0XHRcdGlmIChiaW5kaW5nLnVzZUNvdW50KysgPT09IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX2xlbmRCaW5kaW5nKGJpbmRpbmcpO1xuXG5cdFx0XHRcdFx0XHRiaW5kaW5nLnNhdmVPcmlnaW5hbFN0YXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fbGVuZEFjdGlvbihhY3Rpb24pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9kZWFjdGl2YXRlQWN0aW9uKGFjdGlvbikge1xuXHRcdFx0aWYgKHRoaXMuX2lzQWN0aXZlQWN0aW9uKGFjdGlvbikpIHtcblx0XHRcdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7IC8vIGRlY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuXG5cdFx0XHRcdFx0aWYgKC0tYmluZGluZy51c2VDb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl90YWtlQmFja0JpbmRpbmcoYmluZGluZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fdGFrZUJhY2tBY3Rpb24oYWN0aW9uKTtcblx0XHRcdH1cblx0XHR9IC8vIE1lbW9yeSBtYW5hZ2VyXG5cblxuXHRcdF9pbml0TWVtb3J5TWFuYWdlcigpIHtcblx0XHRcdHRoaXMuX2FjdGlvbnMgPSBbXTsgLy8gJ25BY3RpdmVBY3Rpb25zJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG5cblx0XHRcdHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcblx0XHRcdHRoaXMuX2FjdGlvbnNCeUNsaXAgPSB7fTsgLy8gaW5zaWRlOlxuXHRcdFx0Ly8ge1xuXHRcdFx0Ly8gXHRrbm93bkFjdGlvbnM6IEFycmF5PCBBbmltYXRpb25BY3Rpb24gPiAtIHVzZWQgYXMgcHJvdG90eXBlc1xuXHRcdFx0Ly8gXHRhY3Rpb25CeVJvb3Q6IEFuaW1hdGlvbkFjdGlvbiAtIGxvb2t1cFxuXHRcdFx0Ly8gfVxuXG5cdFx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyAnbkFjdGl2ZUJpbmRpbmdzJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG5cblx0XHRcdHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IDA7XG5cdFx0XHR0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUgPSB7fTsgLy8gaW5zaWRlOiBNYXA8IG5hbWUsIFByb3BlcnR5TWl4ZXIgPlxuXG5cdFx0XHR0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzID0gW107IC8vIHNhbWUgZ2FtZSBhcyBhYm92ZVxuXG5cdFx0XHR0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyA9IDA7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHR0aGlzLnN0YXRzID0ge1xuXHRcdFx0XHRhY3Rpb25zOiB7XG5cdFx0XHRcdFx0Z2V0IHRvdGFsKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Z2V0IGluVXNlKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQWN0aW9ucztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0YmluZGluZ3M6IHtcblx0XHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Z2V0IGluVXNlKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQmluZGluZ3M7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbnRyb2xJbnRlcnBvbGFudHM6IHtcblx0XHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2NvbnRyb2xJbnRlcnBvbGFudHMubGVuZ3RoO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gLy8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIEFuaW1hdGlvbkFjdGlvbiBvYmplY3RzXG5cblxuXHRcdF9pc0FjdGl2ZUFjdGlvbihhY3Rpb24pIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuXHRcdFx0cmV0dXJuIGluZGV4ICE9PSBudWxsICYmIGluZGV4IDwgdGhpcy5fbkFjdGl2ZUFjdGlvbnM7XG5cdFx0fVxuXG5cdFx0X2FkZEluYWN0aXZlQWN0aW9uKGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkKSB7XG5cdFx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwO1xuXHRcdFx0bGV0IGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF07XG5cblx0XHRcdGlmIChhY3Rpb25zRm9yQ2xpcCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0ge1xuXHRcdFx0XHRcdGtub3duQWN0aW9uczogW2FjdGlvbl0sXG5cdFx0XHRcdFx0YWN0aW9uQnlSb290OiB7fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSAwO1xuXHRcdFx0XHRhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXSA9IGFjdGlvbnNGb3JDbGlwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qga25vd25BY3Rpb25zID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zO1xuXHRcdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBrbm93bkFjdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRrbm93bkFjdGlvbnMucHVzaChhY3Rpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBhY3Rpb25zLmxlbmd0aDtcblx0XHRcdGFjdGlvbnMucHVzaChhY3Rpb24pO1xuXHRcdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290W3Jvb3RVdWlkXSA9IGFjdGlvbjtcblx0XHR9XG5cblx0XHRfcmVtb3ZlSW5hY3RpdmVBY3Rpb24oYWN0aW9uKSB7XG5cdFx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbYWN0aW9ucy5sZW5ndGggLSAxXSxcblx0XHRcdFx0XHRcdGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XG5cdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xuXHRcdFx0YWN0aW9uc1tjYWNoZUluZGV4XSA9IGxhc3RJbmFjdGl2ZUFjdGlvbjtcblx0XHRcdGFjdGlvbnMucG9wKCk7XG5cdFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xuXHRcdFx0Y29uc3QgY2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcblx0XHRcdFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuXHRcdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXSxcblx0XHRcdFx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnMsXG5cdFx0XHRcdFx0XHRsYXN0S25vd25BY3Rpb24gPSBrbm93bkFjdGlvbnNGb3JDbGlwW2tub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoIC0gMV0sXG5cdFx0XHRcdFx0XHRieUNsaXBDYWNoZUluZGV4ID0gYWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4O1xuXHRcdFx0bGFzdEtub3duQWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gYnlDbGlwQ2FjaGVJbmRleDtcblx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXBbYnlDbGlwQ2FjaGVJbmRleF0gPSBsYXN0S25vd25BY3Rpb247XG5cdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwLnBvcCgpO1xuXHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcblx0XHRcdGNvbnN0IGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdCxcblx0XHRcdFx0XHRcdHJvb3RVdWlkID0gKGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QpLnV1aWQ7XG5cdFx0XHRkZWxldGUgYWN0aW9uQnlSb290W3Jvb3RVdWlkXTtcblxuXHRcdFx0aWYgKGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbihhY3Rpb24pO1xuXHRcdH1cblxuXHRcdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKGFjdGlvbikge1xuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuXG5cdFx0XHRcdGlmICgtLWJpbmRpbmcucmVmZXJlbmNlQ291bnQgPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoYmluZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRfbGVuZEFjdGlvbihhY3Rpb24pIHtcblx0XHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfFx0aW5hY3RpdmUgYWN0aW9uc1x0XVxuXHRcdFx0Ly8gW1x0YWN0aXZlIGFjdGlvbnMgPnwgaW5hY3RpdmUgYWN0aW9ucyBdXG5cdFx0XHQvL1x0XHRcdFx0XHRcdFx0XHQgc1x0XHRcdFx0YVxuXHRcdFx0Ly9cdFx0XHRcdFx0XHRcdFx0XHQ8LXN3YXAtPlxuXHRcdFx0Ly9cdFx0XHRcdFx0XHRcdFx0IGFcdFx0XHRcdHNcblx0XHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMrKyxcblx0XHRcdFx0XHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zW2xhc3RBY3RpdmVJbmRleF07XG5cdFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG5cdFx0XHRhY3Rpb25zW2xhc3RBY3RpdmVJbmRleF0gPSBhY3Rpb247XG5cdFx0XHRmaXJzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdFx0YWN0aW9uc1twcmV2SW5kZXhdID0gZmlyc3RJbmFjdGl2ZUFjdGlvbjtcblx0XHR9XG5cblx0XHRfdGFrZUJhY2tBY3Rpb24oYWN0aW9uKSB7XG5cdFx0XHQvLyBbXHRhY3RpdmUgYWN0aW9uc1x0fCBpbmFjdGl2ZSBhY3Rpb25zIF1cblx0XHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfDwgaW5hY3RpdmUgYWN0aW9uc1x0XVxuXHRcdFx0Ly9cdFx0XHRcdGFcdFx0XHRcdHNcblx0XHRcdC8vXHRcdFx0XHQgPC1zd2FwLT5cblx0XHRcdC8vXHRcdFx0XHRzXHRcdFx0XHRhXG5cdFx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdFx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcblx0XHRcdFx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cdFx0XHRcdFx0XHRsYXN0QWN0aXZlQWN0aW9uID0gYWN0aW9uc1tmaXJzdEluYWN0aXZlSW5kZXhdO1xuXHRcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuXHRcdFx0YWN0aW9uc1tmaXJzdEluYWN0aXZlSW5kZXhdID0gYWN0aW9uO1xuXHRcdFx0bGFzdEFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRcdGFjdGlvbnNbcHJldkluZGV4XSA9IGxhc3RBY3RpdmVBY3Rpb247XG5cdFx0fSAvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXG5cblxuXHRcdF9hZGRJbmFjdGl2ZUJpbmRpbmcoYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSkge1xuXHRcdFx0Y29uc3QgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXHRcdFx0bGV0IGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFtyb290VXVpZF07XG5cblx0XHRcdGlmIChiaW5kaW5nQnlOYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YmluZGluZ0J5TmFtZSA9IHt9O1xuXHRcdFx0XHRiaW5kaW5nc0J5Um9vdFtyb290VXVpZF0gPSBiaW5kaW5nQnlOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRiaW5kaW5nQnlOYW1lW3RyYWNrTmFtZV0gPSBiaW5kaW5nO1xuXHRcdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRcdGJpbmRpbmdzLnB1c2goYmluZGluZyk7XG5cdFx0fVxuXG5cdFx0X3JlbW92ZUluYWN0aXZlQmluZGluZyhiaW5kaW5nKSB7XG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRcdFx0cHJvcEJpbmRpbmcgPSBiaW5kaW5nLmJpbmRpbmcsXG5cdFx0XHRcdFx0XHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXG5cdFx0XHRcdFx0XHR0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxuXHRcdFx0XHRcdFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRcdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3Rbcm9vdFV1aWRdLFxuXHRcdFx0XHRcdFx0bGFzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzW2JpbmRpbmdzLmxlbmd0aCAtIDFdLFxuXHRcdFx0XHRcdFx0Y2FjaGVJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXg7XG5cdFx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRcdGJpbmRpbmdzW2NhY2hlSW5kZXhdID0gbGFzdEluYWN0aXZlQmluZGluZztcblx0XHRcdGJpbmRpbmdzLnBvcCgpO1xuXHRcdFx0ZGVsZXRlIGJpbmRpbmdCeU5hbWVbdHJhY2tOYW1lXTtcblxuXHRcdFx0aWYgKE9iamVjdC5rZXlzKGJpbmRpbmdCeU5hbWUpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRkZWxldGUgYmluZGluZ3NCeVJvb3Rbcm9vdFV1aWRdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9sZW5kQmluZGluZyhiaW5kaW5nKSB7XG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRcdFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcblx0XHRcdFx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncysrLFxuXHRcdFx0XHRcdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1tsYXN0QWN0aXZlSW5kZXhdO1xuXHRcdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRcdGJpbmRpbmdzW2xhc3RBY3RpdmVJbmRleF0gPSBiaW5kaW5nO1xuXHRcdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0XHRiaW5kaW5nc1twcmV2SW5kZXhdID0gZmlyc3RJbmFjdGl2ZUJpbmRpbmc7XG5cdFx0fVxuXG5cdFx0X3Rha2VCYWNrQmluZGluZyhiaW5kaW5nKSB7XG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRcdFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcblx0XHRcdFx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tdGhpcy5fbkFjdGl2ZUJpbmRpbmdzLFxuXHRcdFx0XHRcdFx0bGFzdEFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1tmaXJzdEluYWN0aXZlSW5kZXhdO1xuXHRcdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRcdGJpbmRpbmdzW2ZpcnN0SW5hY3RpdmVJbmRleF0gPSBiaW5kaW5nO1xuXHRcdFx0bGFzdEFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0XHRiaW5kaW5nc1twcmV2SW5kZXhdID0gbGFzdEFjdGl2ZUJpbmRpbmc7XG5cdFx0fSAvLyBNZW1vcnkgbWFuYWdlbWVudCBvZiBJbnRlcnBvbGFudHMgZm9yIHdlaWdodCBhbmQgdGltZSBzY2FsZVxuXG5cblx0XHRfbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpIHtcblx0XHRcdGNvbnN0IGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG5cdFx0XHRcdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cysrO1xuXHRcdFx0bGV0IGludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzW2xhc3RBY3RpdmVJbmRleF07XG5cblx0XHRcdGlmIChpbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGludGVycG9sYW50ID0gbmV3IExpbmVhckludGVycG9sYW50KG5ldyBGbG9hdDMyQXJyYXkoMiksIG5ldyBGbG9hdDMyQXJyYXkoMiksIDEsIHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIpO1xuXHRcdFx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG5cdFx0XHRcdGludGVycG9sYW50c1tsYXN0QWN0aXZlSW5kZXhdID0gaW50ZXJwb2xhbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbnRlcnBvbGFudDtcblx0XHR9XG5cblx0XHRfdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoaW50ZXJwb2xhbnQpIHtcblx0XHRcdGNvbnN0IGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG5cdFx0XHRcdFx0XHRwcmV2SW5kZXggPSBpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXgsXG5cdFx0XHRcdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLXRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLFxuXHRcdFx0XHRcdFx0bGFzdEFjdGl2ZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzW2ZpcnN0SW5hY3RpdmVJbmRleF07XG5cdFx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG5cdFx0XHRpbnRlcnBvbGFudHNbZmlyc3RJbmFjdGl2ZUluZGV4XSA9IGludGVycG9sYW50O1xuXHRcdFx0bGFzdEFjdGl2ZUludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRcdGludGVycG9sYW50c1twcmV2SW5kZXhdID0gbGFzdEFjdGl2ZUludGVycG9sYW50O1xuXHRcdH0gLy8gcmV0dXJuIGFuIGFjdGlvbiBmb3IgYSBjbGlwIG9wdGlvbmFsbHkgdXNpbmcgYSBjdXN0b20gcm9vdCB0YXJnZXRcblx0XHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcblx0XHQvLyBwcmV2aW91c2x5IHVua25vd24gY2xpcC9yb290IGNvbWJpbmF0aW9uIGlzIHNwZWNpZmllZClcblxuXG5cdFx0Y2xpcEFjdGlvbihjbGlwLCBvcHRpb25hbFJvb3QsIGJsZW5kTW9kZSkge1xuXHRcdFx0Y29uc3Qgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxuXHRcdFx0XHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQ7XG5cdFx0XHRsZXQgY2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/IEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZShyb290LCBjbGlwKSA6IGNsaXA7XG5cdFx0XHRjb25zdCBjbGlwVXVpZCA9IGNsaXBPYmplY3QgIT09IG51bGwgPyBjbGlwT2JqZWN0LnV1aWQgOiBjbGlwO1xuXHRcdFx0Y29uc3QgYWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblx0XHRcdGxldCBwcm90b3R5cGVBY3Rpb24gPSBudWxsO1xuXG5cdFx0XHRpZiAoYmxlbmRNb2RlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKGNsaXBPYmplY3QgIT09IG51bGwpIHtcblx0XHRcdFx0XHRibGVuZE1vZGUgPSBjbGlwT2JqZWN0LmJsZW5kTW9kZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRibGVuZE1vZGUgPSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3QgZXhpc3RpbmdBY3Rpb24gPSBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3Rbcm9vdFV1aWRdO1xuXG5cdFx0XHRcdGlmIChleGlzdGluZ0FjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGV4aXN0aW5nQWN0aW9uLmJsZW5kTW9kZSA9PT0gYmxlbmRNb2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nQWN0aW9uO1xuXHRcdFx0XHR9IC8vIHdlIGtub3cgdGhlIGNsaXAsIHNvIHdlIGRvbid0IGhhdmUgdG8gcGFyc2UgYWxsXG5cdFx0XHRcdC8vIHRoZSBiaW5kaW5ncyBhZ2FpbiBidXQgY2FuIGp1c3QgY29weVxuXG5cblx0XHRcdFx0cHJvdG90eXBlQWN0aW9uID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWzBdOyAvLyBhbHNvLCB0YWtlIHRoZSBjbGlwIGZyb20gdGhlIHByb3RvdHlwZSBhY3Rpb25cblxuXHRcdFx0XHRpZiAoY2xpcE9iamVjdCA9PT0gbnVsbCkgY2xpcE9iamVjdCA9IHByb3RvdHlwZUFjdGlvbi5fY2xpcDtcblx0XHRcdH0gLy8gY2xpcCBtdXN0IGJlIGtub3duIHdoZW4gc3BlY2lmaWVkIHZpYSBzdHJpbmdcblxuXG5cdFx0XHRpZiAoY2xpcE9iamVjdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7IC8vIGFsbG9jYXRlIGFsbCByZXNvdXJjZXMgcmVxdWlyZWQgdG8gcnVuIGl0XG5cblx0XHRcdGNvbnN0IG5ld0FjdGlvbiA9IG5ldyBBbmltYXRpb25BY3Rpb24odGhpcywgY2xpcE9iamVjdCwgb3B0aW9uYWxSb290LCBibGVuZE1vZGUpO1xuXG5cdFx0XHR0aGlzLl9iaW5kQWN0aW9uKG5ld0FjdGlvbiwgcHJvdG90eXBlQWN0aW9uKTsgLy8gYW5kIG1ha2UgdGhlIGFjdGlvbiBrbm93biB0byB0aGUgbWVtb3J5IG1hbmFnZXJcblxuXG5cdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbihuZXdBY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCk7XG5cblx0XHRcdHJldHVybiBuZXdBY3Rpb247XG5cdFx0fSAvLyBnZXQgYW4gZXhpc3RpbmcgYWN0aW9uXG5cblxuXHRcdGV4aXN0aW5nQWN0aW9uKGNsaXAsIG9wdGlvbmFsUm9vdCkge1xuXHRcdFx0Y29uc3Qgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxuXHRcdFx0XHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXG5cdFx0XHRcdFx0XHRjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID8gQW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKHJvb3QsIGNsaXApIDogY2xpcCxcblx0XHRcdFx0XHRcdGNsaXBVdWlkID0gY2xpcE9iamVjdCA/IGNsaXBPYmplY3QudXVpZCA6IGNsaXAsXG5cdFx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbY2xpcFV1aWRdO1xuXG5cdFx0XHRpZiAoYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290W3Jvb3RVdWlkXSB8fCBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IC8vIGRlYWN0aXZhdGVzIGFsbCBwcmV2aW91c2x5IHNjaGVkdWxlZCBhY3Rpb25zXG5cblxuXHRcdHN0b3BBbGxBY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdFx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnM7XG5cblx0XHRcdGZvciAobGV0IGkgPSBuQWN0aW9ucyAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdFx0XHRcdGFjdGlvbnNbaV0uc3RvcCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IC8vIGFkdmFuY2UgdGhlIHRpbWUgYW5kIHVwZGF0ZSBhcHBseSB0aGUgYW5pbWF0aW9uXG5cblxuXHRcdHVwZGF0ZShkZWx0YVRpbWUpIHtcblx0XHRcdGRlbHRhVGltZSAqPSB0aGlzLnRpbWVTY2FsZTtcblx0XHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcblx0XHRcdFx0XHRcdHRpbWUgPSB0aGlzLnRpbWUgKz0gZGVsdGFUaW1lLFxuXHRcdFx0XHRcdFx0dGltZURpcmVjdGlvbiA9IE1hdGguc2lnbihkZWx0YVRpbWUpLFxuXHRcdFx0XHRcdFx0YWNjdUluZGV4ID0gdGhpcy5fYWNjdUluZGV4IF49IDE7IC8vIHJ1biBhY3RpdmUgYWN0aW9uc1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbkFjdGlvbnM7ICsraSkge1xuXHRcdFx0XHRjb25zdCBhY3Rpb24gPSBhY3Rpb25zW2ldO1xuXG5cdFx0XHRcdGFjdGlvbi5fdXBkYXRlKHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4KTtcblx0XHRcdH0gLy8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblxuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdFx0XHRcdG5CaW5kaW5ncyA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG5CaW5kaW5nczsgKytpKSB7XG5cdFx0XHRcdGJpbmRpbmdzW2ldLmFwcGx5KGFjY3VJbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gLy8gQWxsb3dzIHlvdSB0byBzZWVrIHRvIGEgc3BlY2lmaWMgdGltZSBpbiBhbiBhbmltYXRpb24uXG5cblxuXHRcdHNldFRpbWUodGltZUluU2Vjb25kcykge1xuXHRcdFx0dGhpcy50aW1lID0gMDsgLy8gWmVybyBvdXQgdGltZSBhdHRyaWJ1dGUgZm9yIEFuaW1hdGlvbk1peGVyIG9iamVjdDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGlvbnNbaV0udGltZSA9IDA7IC8vIFplcm8gb3V0IHRpbWUgYXR0cmlidXRlIGZvciBhbGwgYXNzb2NpYXRlZCBBbmltYXRpb25BY3Rpb24gb2JqZWN0cy5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMudXBkYXRlKHRpbWVJblNlY29uZHMpOyAvLyBVcGRhdGUgdXNlZCB0byBzZXQgZXhhY3QgdGltZS4gUmV0dXJucyBcInRoaXNcIiBBbmltYXRpb25NaXhlciBvYmplY3QuXG5cdFx0fSAvLyByZXR1cm4gdGhpcyBtaXhlcidzIHJvb3QgdGFyZ2V0IG9iamVjdFxuXG5cblx0XHRnZXRSb290KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Jvb3Q7XG5cdFx0fSAvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIGNsaXBcblxuXG5cdFx0dW5jYWNoZUNsaXAoY2xpcCkge1xuXHRcdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRcdFx0XHRjbGlwVXVpZCA9IGNsaXAudXVpZCxcblx0XHRcdFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuXHRcdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblxuXHRcdFx0aWYgKGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxuXHRcdFx0XHQvLyBpdGVyYXRpb24gc3RhdGUgYW5kIGFsc28gcmVxdWlyZSB1cGRhdGluZyB0aGUgc3RhdGUgd2UgY2FuXG5cdFx0XHRcdC8vIGp1c3QgdGhyb3cgYXdheVxuXHRcdFx0XHRjb25zdCBhY3Rpb25zVG9SZW1vdmUgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBhY3Rpb25zVG9SZW1vdmUubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0XHRjb25zdCBhY3Rpb24gPSBhY3Rpb25zVG9SZW1vdmVbaV07XG5cblx0XHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKGFjdGlvbik7XG5cblx0XHRcdFx0XHRjb25zdCBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbYWN0aW9ucy5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xuXHRcdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cdFx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRcdFx0XHRhY3Rpb25zW2NhY2hlSW5kZXhdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuXHRcdFx0XHRcdGFjdGlvbnMucG9wKCk7XG5cblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKGFjdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF07XG5cdFx0XHR9XG5cdFx0fSAvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHJvb3QgdGFyZ2V0IG9iamVjdFxuXG5cblx0XHR1bmNhY2hlUm9vdChyb290KSB7XG5cdFx0XHRjb25zdCByb290VXVpZCA9IHJvb3QudXVpZCxcblx0XHRcdFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGNsaXBVdWlkIGluIGFjdGlvbnNCeUNsaXApIHtcblx0XHRcdFx0Y29uc3QgYWN0aW9uQnlSb290ID0gYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF0uYWN0aW9uQnlSb290LFxuXHRcdFx0XHRcdFx0XHRhY3Rpb24gPSBhY3Rpb25CeVJvb3Rbcm9vdFV1aWRdO1xuXG5cdFx0XHRcdGlmIChhY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oYWN0aW9uKTtcblxuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKGFjdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRcdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3Rbcm9vdFV1aWRdO1xuXG5cdFx0XHRpZiAoYmluZGluZ0J5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgdHJhY2tOYW1lIGluIGJpbmRpbmdCeU5hbWUpIHtcblx0XHRcdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ0J5TmFtZVt0cmFja05hbWVdO1xuXHRcdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcblxuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyhiaW5kaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gLy8gcmVtb3ZlIGEgdGFyZ2V0ZWQgY2xpcCBmcm9tIHRoZSBjYWNoZVxuXG5cblx0XHR1bmNhY2hlQWN0aW9uKGNsaXAsIG9wdGlvbmFsUm9vdCkge1xuXHRcdFx0Y29uc3QgYWN0aW9uID0gdGhpcy5leGlzdGluZ0FjdGlvbihjbGlwLCBvcHRpb25hbFJvb3QpO1xuXG5cdFx0XHRpZiAoYWN0aW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oYWN0aW9uKTtcblxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbihhY3Rpb24pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0QW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlLl9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcblxuXHRjbGFzcyBVbmlmb3JtIHtcblx0XHRjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Vbmlmb3JtOiBUeXBlIHBhcmFtZXRlciBpcyBubyBsb25nZXIgbmVlZGVkLicpO1xuXHRcdFx0XHR2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBVbmlmb3JtKHRoaXMudmFsdWUuY2xvbmUgPT09IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmNsb25lKCkpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgZXh0ZW5kcyBJbnRlcmxlYXZlZEJ1ZmZlciB7XG5cdFx0Y29uc3RydWN0b3IoYXJyYXksIHN0cmlkZSwgbWVzaFBlckF0dHJpYnV0ZSA9IDEpIHtcblx0XHRcdHN1cGVyKGFycmF5LCBzdHJpZGUpO1xuXHRcdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZShkYXRhKSB7XG5cdFx0XHRjb25zdCBpYiA9IHN1cGVyLmNsb25lKGRhdGEpO1xuXHRcdFx0aWIubWVzaFBlckF0dHJpYnV0ZSA9IHRoaXMubWVzaFBlckF0dHJpYnV0ZTtcblx0XHRcdHJldHVybiBpYjtcblx0XHR9XG5cblx0XHR0b0pTT04oZGF0YSkge1xuXHRcdFx0Y29uc3QganNvbiA9IHN1cGVyLnRvSlNPTihkYXRhKTtcblx0XHRcdGpzb24uaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IHRydWU7XG5cdFx0XHRqc29uLm1lc2hQZXJBdHRyaWJ1dGUgPSB0aGlzLm1lc2hQZXJBdHRyaWJ1dGU7XG5cdFx0XHRyZXR1cm4ganNvbjtcblx0XHR9XG5cblx0fVxuXG5cdEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcblxuXHRjbGFzcyBHTEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdFx0Y29uc3RydWN0b3IoYnVmZmVyLCB0eXBlLCBpdGVtU2l6ZSwgZWxlbWVudFNpemUsIGNvdW50KSB7XG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cdFx0XHR0aGlzLmVsZW1lbnRTaXplID0gZWxlbWVudFNpemU7XG5cdFx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cdFx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXHRcdH1cblxuXHRcdHNldCBuZWVkc1VwZGF0ZSh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLnZlcnNpb24rKztcblx0XHR9XG5cblx0XHRzZXRCdWZmZXIoYnVmZmVyKSB7XG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFR5cGUodHlwZSwgZWxlbWVudFNpemUpIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0XHR0aGlzLmVsZW1lbnRTaXplID0gZWxlbWVudFNpemU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRJdGVtU2l6ZShpdGVtU2l6ZSkge1xuXHRcdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0Q291bnQoY291bnQpIHtcblx0XHRcdHRoaXMuY291bnQgPSBjb3VudDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0R0xCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmlzR0xCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdGNsYXNzIFJheWNhc3RlciB7XG5cdFx0Y29uc3RydWN0b3Iob3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIgPSAwLCBmYXIgPSBJbmZpbml0eSkge1xuXHRcdFx0dGhpcy5yYXkgPSBuZXcgUmF5KG9yaWdpbiwgZGlyZWN0aW9uKTsgLy8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdFx0dGhpcy5uZWFyID0gbmVhcjtcblx0XHRcdHRoaXMuZmFyID0gZmFyO1xuXHRcdFx0dGhpcy5jYW1lcmEgPSBudWxsO1xuXHRcdFx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG5cdFx0XHR0aGlzLnBhcmFtcyA9IHtcblx0XHRcdFx0TWVzaDoge30sXG5cdFx0XHRcdExpbmU6IHtcblx0XHRcdFx0XHR0aHJlc2hvbGQ6IDFcblx0XHRcdFx0fSxcblx0XHRcdFx0TE9EOiB7fSxcblx0XHRcdFx0UG9pbnRzOiB7XG5cdFx0XHRcdFx0dGhyZXNob2xkOiAxXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFNwcml0ZToge31cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0c2V0KG9yaWdpbiwgZGlyZWN0aW9uKSB7XG5cdFx0XHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxuXHRcdFx0dGhpcy5yYXkuc2V0KG9yaWdpbiwgZGlyZWN0aW9uKTtcblx0XHR9XG5cblx0XHRzZXRGcm9tQ2FtZXJhKGNvb3JkcywgY2FtZXJhKSB7XG5cdFx0XHRpZiAoY2FtZXJhICYmIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhKSB7XG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhLm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldChjb29yZHMueCwgY29vcmRzLnksIDAuNSkudW5wcm9qZWN0KGNhbWVyYSkuc3ViKHRoaXMucmF5Lm9yaWdpbikubm9ybWFsaXplKCk7XG5cdFx0XHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXHRcdFx0fSBlbHNlIGlmIChjYW1lcmEgJiYgY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXQoY29vcmRzLngsIGNvb3Jkcy55LCAoY2FtZXJhLm5lYXIgKyBjYW1lcmEuZmFyKSAvIChjYW1lcmEubmVhciAtIGNhbWVyYS5mYXIpKS51bnByb2plY3QoY2FtZXJhKTsgLy8gc2V0IG9yaWdpbiBpbiBwbGFuZSBvZiBjYW1lcmFcblxuXHRcdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KDAsIDAsIC0xKS50cmFuc2Zvcm1EaXJlY3Rpb24oY2FtZXJhLm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlOiAnICsgY2FtZXJhLnR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGludGVyc2VjdE9iamVjdChvYmplY3QsIHJlY3Vyc2l2ZSA9IGZhbHNlLCBpbnRlcnNlY3RzID0gW10pIHtcblx0XHRcdGludGVyc2VjdE9iamVjdChvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSk7XG5cdFx0XHRpbnRlcnNlY3RzLnNvcnQoYXNjU29ydCk7XG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RPYmplY3RzKG9iamVjdHMsIHJlY3Vyc2l2ZSA9IGZhbHNlLCBpbnRlcnNlY3RzID0gW10pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aW50ZXJzZWN0T2JqZWN0KG9iamVjdHNbaV0sIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGludGVyc2VjdHMuc29ydChhc2NTb3J0KTtcblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYXNjU29ydChhLCBiKSB7XG5cdFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUpIHtcblx0XHRpZiAob2JqZWN0LmxheWVycy50ZXN0KHJheWNhc3Rlci5sYXllcnMpKSB7XG5cdFx0XHRvYmplY3QucmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpO1xuXHRcdH1cblxuXHRcdGlmIChyZWN1cnNpdmUgPT09IHRydWUpIHtcblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoY2hpbGRyZW5baV0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXG5cdCAqXG5cdCAqIFRoZSBwb2xhciBhbmdsZSAocGhpKSBpcyBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB5LWF4aXMuIFRoZSBwb3NpdGl2ZSB5LWF4aXMgaXMgdXAuXG5cdCAqIFRoZSBhemltdXRoYWwgYW5nbGUgKHRoZXRhKSBpcyBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB6LWF4aXMuXG5cdCAqL1xuXG5cdGNsYXNzIFNwaGVyaWNhbCB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgcGhpID0gMCwgdGhldGEgPSAwKSB7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMucGhpID0gcGhpOyAvLyBwb2xhciBhbmdsZVxuXG5cdFx0XHR0aGlzLnRoZXRhID0gdGhldGE7IC8vIGF6aW11dGhhbCBhbmdsZVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXQocmFkaXVzLCBwaGksIHRoZXRhKSB7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMucGhpID0gcGhpO1xuXHRcdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShvdGhlcikge1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XG5cdFx0XHR0aGlzLnBoaSA9IG90aGVyLnBoaTtcblx0XHRcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gLy8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZSBFUFMgYW5kIFBJLUVQU1xuXG5cblx0XHRtYWtlU2FmZSgpIHtcblx0XHRcdGNvbnN0IEVQUyA9IDAuMDAwMDAxO1xuXHRcdFx0dGhpcy5waGkgPSBNYXRoLm1heChFUFMsIE1hdGgubWluKE1hdGguUEkgLSBFUFMsIHRoaXMucGhpKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tVmVjdG9yMyh2KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHYueCwgdi55LCB2LnopO1xuXHRcdH1cblxuXHRcdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoeCwgeSwgeikge1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcblxuXHRcdFx0aWYgKHRoaXMucmFkaXVzID09PSAwKSB7XG5cdFx0XHRcdHRoaXMudGhldGEgPSAwO1xuXHRcdFx0XHR0aGlzLnBoaSA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMih4LCB6KTtcblx0XHRcdFx0dGhpcy5waGkgPSBNYXRoLmFjb3MoY2xhbXAoeSAvIHRoaXMucmFkaXVzLCAtMSwgMSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DeWxpbmRyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxuXHQgKi9cblx0Y2xhc3MgQ3lsaW5kcmljYWwge1xuXHRcdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEsIHRoZXRhID0gMCwgeSA9IDApIHtcblx0XHRcdHRoaXMucmFkaXVzID0gcmFkaXVzOyAvLyBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4gdG8gYSBwb2ludCBpbiB0aGUgeC16IHBsYW5lXG5cblx0XHRcdHRoaXMudGhldGEgPSB0aGV0YTsgLy8gY291bnRlcmNsb2Nrd2lzZSBhbmdsZSBpbiB0aGUgeC16IHBsYW5lIG1lYXN1cmVkIGluIHJhZGlhbnMgZnJvbSB0aGUgcG9zaXRpdmUgei1heGlzXG5cblx0XHRcdHRoaXMueSA9IHk7IC8vIGhlaWdodCBhYm92ZSB0aGUgeC16IHBsYW5lXG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldChyYWRpdXMsIHRoZXRhLCB5KSB7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMudGhldGEgPSB0aGV0YTtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KG90aGVyKSB7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcblx0XHRcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcblx0XHRcdHRoaXMueSA9IG90aGVyLnk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tVmVjdG9yMyh2KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHYueCwgdi55LCB2LnopO1xuXHRcdH1cblxuXHRcdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoeCwgeSwgeikge1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoeCAqIHggKyB6ICogeik7XG5cdFx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMih4LCB6KTtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfdmVjdG9yJDQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxuXHRjbGFzcyBCb3gyIHtcblx0XHRjb25zdHJ1Y3RvcihtaW4gPSBuZXcgVmVjdG9yMigrSW5maW5pdHksICtJbmZpbml0eSksIG1heCA9IG5ldyBWZWN0b3IyKC1JbmZpbml0eSwgLUluZmluaXR5KSkge1xuXHRcdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0XHR0aGlzLm1heCA9IG1heDtcblx0XHR9XG5cblx0XHRzZXQobWluLCBtYXgpIHtcblx0XHRcdHRoaXMubWluLmNvcHkobWluKTtcblx0XHRcdHRoaXMubWF4LmNvcHkobWF4KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHMocG9pbnRzKSB7XG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQocG9pbnRzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBzaXplKSB7XG5cdFx0XHRjb25zdCBoYWxmU2l6ZSA9IF92ZWN0b3IkNC5jb3B5KHNpemUpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoY2VudGVyKS5zdWIoaGFsZlNpemUpO1xuXHRcdFx0dGhpcy5tYXguY29weShjZW50ZXIpLmFkZChoYWxmU2l6ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y29weShib3gpIHtcblx0XHRcdHRoaXMubWluLmNvcHkoYm94Lm1pbik7XG5cdFx0XHR0aGlzLm1heC5jb3B5KGJveC5tYXgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZUVtcHR5KCkge1xuXHRcdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArSW5maW5pdHk7XG5cdFx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC1JbmZpbml0eTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlzRW1wdHkoKSB7XG5cdFx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXHRcdFx0cmV0dXJuIHRoaXMubWF4LnggPCB0aGlzLm1pbi54IHx8IHRoaXMubWF4LnkgPCB0aGlzLm1pbi55O1xuXHRcdH1cblxuXHRcdGdldENlbnRlcih0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoMCwgMCkgOiB0YXJnZXQuYWRkVmVjdG9ycyh0aGlzLm1pbiwgdGhpcy5tYXgpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cdFx0fVxuXG5cdFx0Z2V0U2l6ZSh0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoMCwgMCkgOiB0YXJnZXQuc3ViVmVjdG9ycyh0aGlzLm1heCwgdGhpcy5taW4pO1xuXHRcdH1cblxuXHRcdGV4cGFuZEJ5UG9pbnQocG9pbnQpIHtcblx0XHRcdHRoaXMubWluLm1pbihwb2ludCk7XG5cdFx0XHR0aGlzLm1heC5tYXgocG9pbnQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXhwYW5kQnlWZWN0b3IodmVjdG9yKSB7XG5cdFx0XHR0aGlzLm1pbi5zdWIodmVjdG9yKTtcblx0XHRcdHRoaXMubWF4LmFkZCh2ZWN0b3IpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXhwYW5kQnlTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoLXNjYWxhcik7XG5cdFx0XHR0aGlzLm1heC5hZGRTY2FsYXIoc2NhbGFyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcblx0XHRcdHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fCBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcblx0XHR9XG5cblx0XHRjb250YWluc0JveChib3gpIHtcblx0XHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJiB0aGlzLm1pbi55IDw9IGJveC5taW4ueSAmJiBib3gubWF4LnkgPD0gdGhpcy5tYXgueTtcblx0XHR9XG5cblx0XHRnZXRQYXJhbWV0ZXIocG9pbnQsIHRhcmdldCkge1xuXHRcdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcblx0XHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnNldCgocG9pbnQueCAtIHRoaXMubWluLngpIC8gKHRoaXMubWF4LnggLSB0aGlzLm1pbi54KSwgKHBvaW50LnkgLSB0aGlzLm1pbi55KSAvICh0aGlzLm1heC55IC0gdGhpcy5taW4ueSkpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0XHQvLyB1c2luZyA0IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9uc1xuXHRcdFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgPyBmYWxzZSA6IHRydWU7XG5cdFx0fVxuXG5cdFx0Y2xhbXBQb2ludChwb2ludCwgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkocG9pbnQpLmNsYW1wKHRoaXMubWluLCB0aGlzLm1heCk7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2VUb1BvaW50KHBvaW50KSB7XG5cdFx0XHRjb25zdCBjbGFtcGVkUG9pbnQgPSBfdmVjdG9yJDQuY29weShwb2ludCkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KTtcblxuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIocG9pbnQpLmxlbmd0aCgpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdChib3gpIHtcblx0XHRcdHRoaXMubWluLm1heChib3gubWluKTtcblx0XHRcdHRoaXMubWF4Lm1pbihib3gubWF4KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHVuaW9uKGJveCkge1xuXHRcdFx0dGhpcy5taW4ubWluKGJveC5taW4pO1xuXHRcdFx0dGhpcy5tYXgubWF4KGJveC5tYXgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dHJhbnNsYXRlKG9mZnNldCkge1xuXHRcdFx0dGhpcy5taW4uYWRkKG9mZnNldCk7XG5cdFx0XHR0aGlzLm1heC5hZGQob2Zmc2V0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyhib3gpIHtcblx0XHRcdHJldHVybiBib3gubWluLmVxdWFscyh0aGlzLm1pbikgJiYgYm94Lm1heC5lcXVhbHModGhpcy5tYXgpO1xuXHRcdH1cblxuXHR9XG5cblx0Qm94Mi5wcm90b3R5cGUuaXNCb3gyID0gdHJ1ZTtcblxuXHRjb25zdCBfc3RhcnRQID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3N0YXJ0RW5kID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgTGluZTMge1xuXHRcdGNvbnN0cnVjdG9yKHN0YXJ0ID0gbmV3IFZlY3RvcjMoKSwgZW5kID0gbmV3IFZlY3RvcjMoKSkge1xuXHRcdFx0dGhpcy5zdGFydCA9IHN0YXJ0O1xuXHRcdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0fVxuXG5cdFx0c2V0KHN0YXJ0LCBlbmQpIHtcblx0XHRcdHRoaXMuc3RhcnQuY29weShzdGFydCk7XG5cdFx0XHR0aGlzLmVuZC5jb3B5KGVuZCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KGxpbmUpIHtcblx0XHRcdHRoaXMuc3RhcnQuY29weShsaW5lLnN0YXJ0KTtcblx0XHRcdHRoaXMuZW5kLmNvcHkobGluZS5lbmQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Q2VudGVyKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5tdWx0aXBseVNjYWxhcigwLjUpO1xuXHRcdH1cblxuXHRcdGRlbHRhKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5zdWJWZWN0b3JzKHRoaXMuZW5kLCB0aGlzLnN0YXJ0KTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVNxKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5lbmQpO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyh0aGlzLmVuZCk7XG5cdFx0fVxuXG5cdFx0YXQodCwgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZWx0YSh0YXJnZXQpLm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnN0YXJ0KTtcblx0XHR9XG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKHBvaW50LCBjbGFtcFRvTGluZSkge1xuXHRcdFx0X3N0YXJ0UC5zdWJWZWN0b3JzKHBvaW50LCB0aGlzLnN0YXJ0KTtcblxuXHRcdFx0X3N0YXJ0RW5kLnN1YlZlY3RvcnModGhpcy5lbmQsIHRoaXMuc3RhcnQpO1xuXG5cdFx0XHRjb25zdCBzdGFydEVuZDIgPSBfc3RhcnRFbmQuZG90KF9zdGFydEVuZCk7XG5cblx0XHRcdGNvbnN0IHN0YXJ0RW5kX3N0YXJ0UCA9IF9zdGFydEVuZC5kb3QoX3N0YXJ0UCk7XG5cblx0XHRcdGxldCB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG5cdFx0XHRpZiAoY2xhbXBUb0xpbmUpIHtcblx0XHRcdFx0dCA9IGNsYW1wKHQsIDAsIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9XG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50KHBvaW50LCBjbGFtcFRvTGluZSwgdGFyZ2V0KSB7XG5cdFx0XHRjb25zdCB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKHBvaW50LCBjbGFtcFRvTGluZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZWx0YSh0YXJnZXQpLm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnN0YXJ0KTtcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDQobWF0cml4KSB7XG5cdFx0XHR0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NChtYXRyaXgpO1xuXHRcdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlcXVhbHMobGluZSkge1xuXHRcdFx0cmV0dXJuIGxpbmUuc3RhcnQuZXF1YWxzKHRoaXMuc3RhcnQpICYmIGxpbmUuZW5kLmVxdWFscyh0aGlzLmVuZCk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW1tZWRpYXRlUmVuZGVyT2JqZWN0IGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKG1hdGVyaWFsKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdFx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpXG5cdFx0XHQvKiByZW5kZXJDYWxsYmFjayAqL1xuXHRcdFx0e307XG5cblx0XHRcdHRoaXMuaGFzUG9zaXRpb25zID0gZmFsc2U7XG5cdFx0XHR0aGlzLmhhc05vcm1hbHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuaGFzQ29sb3JzID0gZmFsc2U7XG5cdFx0XHR0aGlzLmhhc1V2cyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5wb3NpdGlvbkFycmF5ID0gbnVsbDtcblx0XHRcdHRoaXMubm9ybWFsQXJyYXkgPSBudWxsO1xuXHRcdFx0dGhpcy5jb2xvckFycmF5ID0gbnVsbDtcblx0XHRcdHRoaXMudXZBcnJheSA9IG51bGw7XG5cdFx0XHR0aGlzLmNvdW50ID0gMDtcblx0XHR9XG5cblx0fVxuXG5cdEltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgPSB0cnVlO1xuXG5cdGNvbnN0IF92ZWN0b3IkMyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIFNwb3RMaWdodEhlbHBlciBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcihsaWdodCwgY29sb3IpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdFx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Y29uc3QgcG9zaXRpb25zID0gWzAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEsIDAsIDEsIDAsIDAsIDAsIC0xLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAxLCAwLCAwLCAwLCAwLCAtMSwgMV07XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBqID0gMSwgbCA9IDMyOyBpIDwgbDsgaSsrLCBqKyspIHtcblx0XHRcdFx0Y29uc3QgcDEgPSBpIC8gbCAqIE1hdGguUEkgKiAyO1xuXHRcdFx0XHRjb25zdCBwMiA9IGogLyBsICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKE1hdGguY29zKHAxKSwgTWF0aC5zaW4ocDEpLCAxLCBNYXRoLmNvcyhwMiksIE1hdGguc2luKHAyKSwgMSk7XG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKTtcblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0Zm9nOiBmYWxzZSxcblx0XHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5jb25lID0gbmV3IExpbmVTZWdtZW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0dGhpcy5hZGQodGhpcy5jb25lKTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblx0XHRcdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdH1cblxuXHRcdHVwZGF0ZSgpIHtcblx0XHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHRcdGNvbnN0IGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDA7XG5cdFx0XHRjb25zdCBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4odGhpcy5saWdodC5hbmdsZSk7XG5cdFx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoKTtcblxuXHRcdFx0X3ZlY3RvciQzLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdHRoaXMuY29uZS5sb29rQXQoX3ZlY3RvciQzKTtcblxuXHRcdFx0aWYgKHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfdmVjdG9yJDIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfYm9uZU1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF9tYXRyaXhXb3JsZEludiA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNsYXNzIFNrZWxldG9uSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblx0XHRjb25zdHJ1Y3RvcihvYmplY3QpIHtcblx0XHRcdGNvbnN0IGJvbmVzID0gZ2V0Qm9uZUxpc3Qob2JqZWN0KTtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgY29sb3JzID0gW107XG5cdFx0XHRjb25zdCBjb2xvcjEgPSBuZXcgQ29sb3IoMCwgMCwgMSk7XG5cdFx0XHRjb25zdCBjb2xvcjIgPSBuZXcgQ29sb3IoMCwgMSwgMCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgYm9uZSA9IGJvbmVzW2ldO1xuXG5cdFx0XHRcdGlmIChib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUpIHtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKDAsIDAsIDApO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goMCwgMCwgMCk7XG5cdFx0XHRcdFx0Y29sb3JzLnB1c2goY29sb3IxLnIsIGNvbG9yMS5nLCBjb2xvcjEuYik7XG5cdFx0XHRcdFx0Y29sb3JzLnB1c2goY29sb3IyLnIsIGNvbG9yMi5nLCBjb2xvcjIuYik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRcdHZlcnRleENvbG9yczogdHJ1ZSxcblx0XHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlLFxuXHRcdFx0XHR0cmFuc3BhcmVudDogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0XHRzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1NrZWxldG9uSGVscGVyJztcblx0XHRcdHRoaXMuaXNTa2VsZXRvbkhlbHBlciA9IHRydWU7XG5cdFx0XHR0aGlzLnJvb3QgPSBvYmplY3Q7XG5cdFx0XHR0aGlzLmJvbmVzID0gYm9uZXM7XG5cdFx0XHR0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG5cdFx0XHRjb25zdCBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcblxuXHRcdFx0X21hdHJpeFdvcmxkSW52LmNvcHkodGhpcy5yb290Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgYm9uZSA9IGJvbmVzW2ldO1xuXG5cdFx0XHRcdGlmIChib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUpIHtcblx0XHRcdFx0XHRfYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKF9tYXRyaXhXb3JsZEludiwgYm9uZS5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdFx0XHRfdmVjdG9yJDIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKF9ib25lTWF0cml4KTtcblxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWihqLCBfdmVjdG9yJDIueCwgX3ZlY3RvciQyLnksIF92ZWN0b3IkMi56KTtcblxuXHRcdFx0XHRcdF9ib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoX21hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdFx0XHRfdmVjdG9yJDIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKF9ib25lTWF0cml4KTtcblxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWihqICsgMSwgX3ZlY3RvciQyLngsIF92ZWN0b3IkMi55LCBfdmVjdG9yJDIueik7XG5cdFx0XHRcdFx0aiArPSAyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCb25lTGlzdChvYmplY3QpIHtcblx0XHRjb25zdCBib25lTGlzdCA9IFtdO1xuXG5cdFx0aWYgKG9iamVjdCAmJiBvYmplY3QuaXNCb25lKSB7XG5cdFx0XHRib25lTGlzdC5wdXNoKG9iamVjdCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGJvbmVMaXN0LnB1c2guYXBwbHkoYm9uZUxpc3QsIGdldEJvbmVMaXN0KG9iamVjdC5jaGlsZHJlbltpXSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBib25lTGlzdDtcblx0fVxuXG5cdGNsYXNzIFBvaW50TGlnaHRIZWxwZXIgZXh0ZW5kcyBNZXNoIHtcblx0XHRjb25zdHJ1Y3RvcihsaWdodCwgc3BoZXJlU2l6ZSwgY29sb3IpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KHNwaGVyZVNpemUsIDQsIDIpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHR3aXJlZnJhbWU6IHRydWUsXG5cdFx0XHRcdGZvZzogZmFsc2UsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHRcdHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdFx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cdFx0XHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodEhlbHBlcic7XG5cdFx0XHR0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XG5cdFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHQvKlxuXHRcdFx0Ly8gVE9ETzogZGVsZXRlIHRoaXMgY29tbWVudD9cblx0XHRcdGNvbnN0IGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSggMSwgMiApO1xuXHRcdFx0Y29uc3QgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XG5cdFx0XHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XG5cdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xuXHRcdFx0Y29uc3QgZCA9IGxpZ2h0LmRpc3RhbmNlO1xuXHRcdFx0aWYgKCBkID09PSAwLjAgKSB7XG5cdFx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XG5cdFx0XHQqL1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdH1cblxuXHRcdHVwZGF0ZSgpIHtcblx0XHRcdGlmICh0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5jb2xvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcik7XG5cdFx0XHR9XG5cdFx0XHQvKlxuXHRcdFx0Y29uc3QgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XG5cdFx0XHRcdGlmICggZCA9PT0gMC4wICkge1xuXHRcdFx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cdFx0XHRcdH1cblx0XHRcdCovXG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF92ZWN0b3IkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9jb2xvcjEgPSAvKkBfX1BVUkVfXyovbmV3IENvbG9yKCk7XG5cblx0Y29uc3QgX2NvbG9yMiA9IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoKTtcblxuXHRjbGFzcyBIZW1pc3BoZXJlTGlnaHRIZWxwZXIgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdFx0Y29uc3RydWN0b3IobGlnaHQsIHNpemUsIGNvbG9yKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHRcdFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KHNpemUpO1xuXHRcdFx0Z2VvbWV0cnkucm90YXRlWShNYXRoLlBJICogMC41KTtcblx0XHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHR3aXJlZnJhbWU6IHRydWUsXG5cdFx0XHRcdGZvZzogZmFsc2UsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHRcdGlmICh0aGlzLmNvbG9yID09PSB1bmRlZmluZWQpIHRoaXMubWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXHRcdFx0Y29uc3QgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbi5jb3VudCAqIDMpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSk7XG5cdFx0XHR0aGlzLmFkZChuZXcgTWVzaChnZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCkpO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5jaGlsZHJlblswXS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLmNoaWxkcmVuWzBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHR9XG5cblx0XHR1cGRhdGUoKSB7XG5cdFx0XHRjb25zdCBtZXNoID0gdGhpcy5jaGlsZHJlblswXTtcblxuXHRcdFx0aWYgKHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCh0aGlzLmNvbG9yKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IGNvbG9ycyA9IG1lc2guZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuXG5cdFx0XHRcdF9jb2xvcjEuY29weSh0aGlzLmxpZ2h0LmNvbG9yKTtcblxuXHRcdFx0XHRfY29sb3IyLmNvcHkodGhpcy5saWdodC5ncm91bmRDb2xvcik7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjb2xvcnMuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBjb2xvciA9IGkgPCBsIC8gMiA/IF9jb2xvcjEgOiBfY29sb3IyO1xuXHRcdFx0XHRcdGNvbG9ycy5zZXRYWVooaSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXNoLmxvb2tBdChfdmVjdG9yJDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQubWF0cml4V29ybGQpLm5lZ2F0ZSgpKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEdyaWRIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXHRcdGNvbnN0cnVjdG9yKHNpemUgPSAxMCwgZGl2aXNpb25zID0gMTAsIGNvbG9yMSA9IDB4NDQ0NDQ0LCBjb2xvcjIgPSAweDg4ODg4OCkge1xuXHRcdFx0Y29sb3IxID0gbmV3IENvbG9yKGNvbG9yMSk7XG5cdFx0XHRjb2xvcjIgPSBuZXcgQ29sb3IoY29sb3IyKTtcblx0XHRcdGNvbnN0IGNlbnRlciA9IGRpdmlzaW9ucyAvIDI7XG5cdFx0XHRjb25zdCBzdGVwID0gc2l6ZSAvIGRpdmlzaW9ucztcblx0XHRcdGNvbnN0IGhhbGZTaXplID0gc2l6ZSAvIDI7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdLFxuXHRcdFx0XHRcdFx0Y29sb3JzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBqID0gMCwgayA9IC1oYWxmU2l6ZTsgaSA8PSBkaXZpc2lvbnM7IGkrKywgayArPSBzdGVwKSB7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goLWhhbGZTaXplLCAwLCBrLCBoYWxmU2l6ZSwgMCwgayk7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goaywgMCwgLWhhbGZTaXplLCBrLCAwLCBoYWxmU2l6ZSk7XG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gaSA9PT0gY2VudGVyID8gY29sb3IxIDogY29sb3IyO1xuXHRcdFx0XHRjb2xvci50b0FycmF5KGNvbG9ycywgaik7XG5cdFx0XHRcdGogKz0gMztcblx0XHRcdFx0Y29sb3IudG9BcnJheShjb2xvcnMsIGopO1xuXHRcdFx0XHRqICs9IDM7XG5cdFx0XHRcdGNvbG9yLnRvQXJyYXkoY29sb3JzLCBqKTtcblx0XHRcdFx0aiArPSAzO1xuXHRcdFx0XHRjb2xvci50b0FycmF5KGNvbG9ycywgaik7XG5cdFx0XHRcdGogKz0gMztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHR2ZXJ0ZXhDb2xvcnM6IHRydWUsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHRcdHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnR3JpZEhlbHBlcic7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBQb2xhckdyaWRIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXHRcdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEwLCByYWRpYWxzID0gMTYsIGNpcmNsZXMgPSA4LCBkaXZpc2lvbnMgPSA2NCwgY29sb3IxID0gMHg0NDQ0NDQsIGNvbG9yMiA9IDB4ODg4ODg4KSB7XG5cdFx0XHRjb2xvcjEgPSBuZXcgQ29sb3IoY29sb3IxKTtcblx0XHRcdGNvbG9yMiA9IG5ldyBDb2xvcihjb2xvcjIpO1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IGNvbG9ycyA9IFtdOyAvLyBjcmVhdGUgdGhlIHJhZGlhbHNcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gcmFkaWFsczsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHYgPSBpIC8gcmFkaWFscyAqIChNYXRoLlBJICogMik7XG5cdFx0XHRcdGNvbnN0IHggPSBNYXRoLnNpbih2KSAqIHJhZGl1cztcblx0XHRcdFx0Y29uc3QgeiA9IE1hdGguY29zKHYpICogcmFkaXVzO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKDAsIDAsIDApO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHgsIDAsIHopO1xuXHRcdFx0XHRjb25zdCBjb2xvciA9IGkgJiAxID8gY29sb3IxIDogY29sb3IyO1xuXHRcdFx0XHRjb2xvcnMucHVzaChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblx0XHRcdFx0Y29sb3JzLnB1c2goY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cdFx0XHR9IC8vIGNyZWF0ZSB0aGUgY2lyY2xlc1xuXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IGNpcmNsZXM7IGkrKykge1xuXHRcdFx0XHRjb25zdCBjb2xvciA9IGkgJiAxID8gY29sb3IxIDogY29sb3IyO1xuXHRcdFx0XHRjb25zdCByID0gcmFkaXVzIC0gcmFkaXVzIC8gY2lyY2xlcyAqIGk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBkaXZpc2lvbnM7IGorKykge1xuXHRcdFx0XHRcdC8vIGZpcnN0IHZlcnRleFxuXHRcdFx0XHRcdGxldCB2ID0gaiAvIGRpdmlzaW9ucyAqIChNYXRoLlBJICogMik7XG5cdFx0XHRcdFx0bGV0IHggPSBNYXRoLnNpbih2KSAqIHI7XG5cdFx0XHRcdFx0bGV0IHogPSBNYXRoLmNvcyh2KSAqIHI7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCh4LCAwLCB6KTtcblx0XHRcdFx0XHRjb2xvcnMucHVzaChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTsgLy8gc2Vjb25kIHZlcnRleFxuXG5cdFx0XHRcdFx0diA9IChqICsgMSkgLyBkaXZpc2lvbnMgKiAoTWF0aC5QSSAqIDIpO1xuXHRcdFx0XHRcdHggPSBNYXRoLnNpbih2KSAqIHI7XG5cdFx0XHRcdFx0eiA9IE1hdGguY29zKHYpICogcjtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHgsIDAsIHopO1xuXHRcdFx0XHRcdGNvbG9ycy5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0dmVydGV4Q29sb3JzOiB0cnVlLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHRzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BvbGFyR3JpZEhlbHBlcic7XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdjIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdjMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBEaXJlY3Rpb25hbExpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKGxpZ2h0LCBzaXplLCBjb2xvcikge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMubGlnaHQgPSBsaWdodDtcblx0XHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHRcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblx0XHRcdGlmIChzaXplID09PSB1bmRlZmluZWQpIHNpemUgPSAxO1xuXHRcdFx0bGV0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoWy1zaXplLCBzaXplLCAwLCBzaXplLCBzaXplLCAwLCBzaXplLCAtc2l6ZSwgMCwgLXNpemUsIC1zaXplLCAwLCAtc2l6ZSwgc2l6ZSwgMF0sIDMpKTtcblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0Zm9nOiBmYWxzZSxcblx0XHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5saWdodFBsYW5lID0gbmV3IExpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMuYWRkKHRoaXMubGlnaHRQbGFuZSk7XG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKFswLCAwLCAwLCAwLCAwLCAxXSwgMykpO1xuXHRcdFx0dGhpcy50YXJnZXRMaW5lID0gbmV3IExpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMuYWRkKHRoaXMudGFyZ2V0TGluZSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdH1cblxuXHRcdHVwZGF0ZSgpIHtcblx0XHRcdF92MS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdF92Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQpO1xuXG5cdFx0XHRfdjMuc3ViVmVjdG9ycyhfdjIsIF92MSk7XG5cblx0XHRcdHRoaXMubGlnaHRQbGFuZS5sb29rQXQoX3YyKTtcblxuXHRcdFx0aWYgKHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuXHRcdFx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcik7XG5cdFx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRhcmdldExpbmUubG9va0F0KF92Mik7XG5cdFx0XHR0aGlzLnRhcmdldExpbmUuc2NhbGUueiA9IF92My5sZW5ndGgoKTtcblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfY2FtZXJhID0gLypAX19QVVJFX18qL25ldyBDYW1lcmEoKTtcblx0LyoqXG5cdCAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcblx0ICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xuXHQgKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcblx0ICpcdFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxuXHQgKi9cblxuXG5cdGNsYXNzIENhbWVyYUhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdFx0Y29uc3RydWN0b3IoY2FtZXJhKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHRjb2xvcjogMHhmZmZmZmYsXG5cdFx0XHRcdHZlcnRleENvbG9yczogdHJ1ZSxcblx0XHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IGNvbG9ycyA9IFtdO1xuXHRcdFx0Y29uc3QgcG9pbnRNYXAgPSB7fTsgLy8gY29sb3JzXG5cblx0XHRcdGNvbnN0IGNvbG9yRnJ1c3R1bSA9IG5ldyBDb2xvcigweGZmYWEwMCk7XG5cdFx0XHRjb25zdCBjb2xvckNvbmUgPSBuZXcgQ29sb3IoMHhmZjAwMDApO1xuXHRcdFx0Y29uc3QgY29sb3JVcCA9IG5ldyBDb2xvcigweDAwYWFmZik7XG5cdFx0XHRjb25zdCBjb2xvclRhcmdldCA9IG5ldyBDb2xvcigweGZmZmZmZik7XG5cdFx0XHRjb25zdCBjb2xvckNyb3NzID0gbmV3IENvbG9yKDB4MzMzMzMzKTsgLy8gbmVhclxuXG5cdFx0XHRhZGRMaW5lKCduMScsICduMicsIGNvbG9yRnJ1c3R1bSk7XG5cdFx0XHRhZGRMaW5lKCduMicsICduNCcsIGNvbG9yRnJ1c3R1bSk7XG5cdFx0XHRhZGRMaW5lKCduNCcsICduMycsIGNvbG9yRnJ1c3R1bSk7XG5cdFx0XHRhZGRMaW5lKCduMycsICduMScsIGNvbG9yRnJ1c3R1bSk7IC8vIGZhclxuXG5cdFx0XHRhZGRMaW5lKCdmMScsICdmMicsIGNvbG9yRnJ1c3R1bSk7XG5cdFx0XHRhZGRMaW5lKCdmMicsICdmNCcsIGNvbG9yRnJ1c3R1bSk7XG5cdFx0XHRhZGRMaW5lKCdmNCcsICdmMycsIGNvbG9yRnJ1c3R1bSk7XG5cdFx0XHRhZGRMaW5lKCdmMycsICdmMScsIGNvbG9yRnJ1c3R1bSk7IC8vIHNpZGVzXG5cblx0XHRcdGFkZExpbmUoJ24xJywgJ2YxJywgY29sb3JGcnVzdHVtKTtcblx0XHRcdGFkZExpbmUoJ24yJywgJ2YyJywgY29sb3JGcnVzdHVtKTtcblx0XHRcdGFkZExpbmUoJ24zJywgJ2YzJywgY29sb3JGcnVzdHVtKTtcblx0XHRcdGFkZExpbmUoJ240JywgJ2Y0JywgY29sb3JGcnVzdHVtKTsgLy8gY29uZVxuXG5cdFx0XHRhZGRMaW5lKCdwJywgJ24xJywgY29sb3JDb25lKTtcblx0XHRcdGFkZExpbmUoJ3AnLCAnbjInLCBjb2xvckNvbmUpO1xuXHRcdFx0YWRkTGluZSgncCcsICduMycsIGNvbG9yQ29uZSk7XG5cdFx0XHRhZGRMaW5lKCdwJywgJ240JywgY29sb3JDb25lKTsgLy8gdXBcblxuXHRcdFx0YWRkTGluZSgndTEnLCAndTInLCBjb2xvclVwKTtcblx0XHRcdGFkZExpbmUoJ3UyJywgJ3UzJywgY29sb3JVcCk7XG5cdFx0XHRhZGRMaW5lKCd1MycsICd1MScsIGNvbG9yVXApOyAvLyB0YXJnZXRcblxuXHRcdFx0YWRkTGluZSgnYycsICd0JywgY29sb3JUYXJnZXQpO1xuXHRcdFx0YWRkTGluZSgncCcsICdjJywgY29sb3JDcm9zcyk7IC8vIGNyb3NzXG5cblx0XHRcdGFkZExpbmUoJ2NuMScsICdjbjInLCBjb2xvckNyb3NzKTtcblx0XHRcdGFkZExpbmUoJ2NuMycsICdjbjQnLCBjb2xvckNyb3NzKTtcblx0XHRcdGFkZExpbmUoJ2NmMScsICdjZjInLCBjb2xvckNyb3NzKTtcblx0XHRcdGFkZExpbmUoJ2NmMycsICdjZjQnLCBjb2xvckNyb3NzKTtcblxuXHRcdFx0ZnVuY3Rpb24gYWRkTGluZShhLCBiLCBjb2xvcikge1xuXHRcdFx0XHRhZGRQb2ludChhLCBjb2xvcik7XG5cdFx0XHRcdGFkZFBvaW50KGIsIGNvbG9yKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYWRkUG9pbnQoaWQsIGNvbG9yKSB7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goMCwgMCwgMCk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXG5cdFx0XHRcdGlmIChwb2ludE1hcFtpZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHBvaW50TWFwW2lkXSA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cG9pbnRNYXBbaWRdLnB1c2godmVydGljZXMubGVuZ3RoIC8gMyAtIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcblx0XHRcdHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQ2FtZXJhSGVscGVyJztcblx0XHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXHRcdFx0aWYgKHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgpIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdHRoaXMubWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdHVwZGF0ZSgpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcblx0XHRcdGNvbnN0IHcgPSAxLFxuXHRcdFx0XHRcdFx0aCA9IDE7IC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXggaW52ZXJzZVxuXHRcdFx0Ly8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcblxuXHRcdFx0X2NhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKTsgLy8gY2VudGVyIC8gdGFyZ2V0XG5cblxuXHRcdFx0c2V0UG9pbnQoJ2MnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIDAsIC0xKTtcblx0XHRcdHNldFBvaW50KCd0JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCAwLCAxKTsgLy8gbmVhclxuXG5cdFx0XHRzZXRQb2ludCgnbjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13LCAtaCwgLTEpO1xuXHRcdFx0c2V0UG9pbnQoJ24yJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCAtaCwgLTEpO1xuXHRcdFx0c2V0UG9pbnQoJ24zJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtdywgaCwgLTEpO1xuXHRcdFx0c2V0UG9pbnQoJ240JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCBoLCAtMSk7IC8vIGZhclxuXG5cdFx0XHRzZXRQb2ludCgnZjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13LCAtaCwgMSk7XG5cdFx0XHRzZXRQb2ludCgnZjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIC1oLCAxKTtcblx0XHRcdHNldFBvaW50KCdmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLXcsIGgsIDEpO1xuXHRcdFx0c2V0UG9pbnQoJ2Y0JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCBoLCAxKTsgLy8gdXBcblxuXHRcdFx0c2V0UG9pbnQoJ3UxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3ICogMC43LCBoICogMS4xLCAtMSk7XG5cdFx0XHRzZXRQb2ludCgndTInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13ICogMC43LCBoICogMS4xLCAtMSk7XG5cdFx0XHRzZXRQb2ludCgndTMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGggKiAyLCAtMSk7IC8vIGNyb3NzXG5cblx0XHRcdHNldFBvaW50KCdjZjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13LCAwLCAxKTtcblx0XHRcdHNldFBvaW50KCdjZjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIDAsIDEpO1xuXHRcdFx0c2V0UG9pbnQoJ2NmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLWgsIDEpO1xuXHRcdFx0c2V0UG9pbnQoJ2NmNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCwgMSk7XG5cdFx0XHRzZXRQb2ludCgnY24xJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtdywgMCwgLTEpO1xuXHRcdFx0c2V0UG9pbnQoJ2NuMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgMCwgLTEpO1xuXHRcdFx0c2V0UG9pbnQoJ2NuMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLWgsIC0xKTtcblx0XHRcdHNldFBvaW50KCdjbjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGgsIC0xKTtcblx0XHRcdGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblx0XHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRQb2ludChwb2ludCwgcG9pbnRNYXAsIGdlb21ldHJ5LCBjYW1lcmEsIHgsIHksIHopIHtcblx0XHRfdmVjdG9yLnNldCh4LCB5LCB6KS51bnByb2plY3QoY2FtZXJhKTtcblxuXHRcdGNvbnN0IHBvaW50cyA9IHBvaW50TWFwW3BvaW50XTtcblxuXHRcdGlmIChwb2ludHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVoocG9pbnRzW2ldLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRjb25zdCBfYm94ID0gLypAX19QVVJFX18qL25ldyBCb3gzKCk7XG5cblx0Y2xhc3MgQm94SGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblx0XHRjb25zdHJ1Y3RvcihvYmplY3QsIGNvbG9yID0gMHhmZmZmMDApIHtcblx0XHRcdGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDddKTtcblx0XHRcdGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoOCAqIDMpO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoaW5kaWNlcywgMSkpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG5cdFx0XHRzdXBlcihnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0Y29sb3I6IGNvbG9yLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSkpO1xuXHRcdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQm94SGVscGVyJztcblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHR1cGRhdGUob2JqZWN0KSB7XG5cdFx0XHRpZiAob2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Cb3hIZWxwZXI6IC51cGRhdGUoKSBoYXMgbm8gbG9uZ2VyIGFyZ3VtZW50cy4nKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMub2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0X2JveC5zZXRGcm9tT2JqZWN0KHRoaXMub2JqZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF9ib3guaXNFbXB0eSgpKSByZXR1cm47XG5cdFx0XHRjb25zdCBtaW4gPSBfYm94Lm1pbjtcblx0XHRcdGNvbnN0IG1heCA9IF9ib3gubWF4O1xuXHRcdFx0Lypcblx0XHRcdFx0NV9fX180XG5cdFx0XHQxL19fXzAvfFxuXHRcdFx0fCA2X198Xzdcblx0XHRcdDIvX19fMy9cblx0XHRcdFx0MDogbWF4LngsIG1heC55LCBtYXguelxuXHRcdFx0MTogbWluLngsIG1heC55LCBtYXguelxuXHRcdFx0MjogbWluLngsIG1pbi55LCBtYXguelxuXHRcdFx0MzogbWF4LngsIG1pbi55LCBtYXguelxuXHRcdFx0NDogbWF4LngsIG1heC55LCBtaW4uelxuXHRcdFx0NTogbWluLngsIG1heC55LCBtaW4uelxuXHRcdFx0NjogbWluLngsIG1pbi55LCBtaW4uelxuXHRcdFx0NzogbWF4LngsIG1pbi55LCBtaW4uelxuXHRcdFx0Ki9cblxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBhcnJheSA9IHBvc2l0aW9uLmFycmF5O1xuXHRcdFx0YXJyYXlbMF0gPSBtYXgueDtcblx0XHRcdGFycmF5WzFdID0gbWF4Lnk7XG5cdFx0XHRhcnJheVsyXSA9IG1heC56O1xuXHRcdFx0YXJyYXlbM10gPSBtaW4ueDtcblx0XHRcdGFycmF5WzRdID0gbWF4Lnk7XG5cdFx0XHRhcnJheVs1XSA9IG1heC56O1xuXHRcdFx0YXJyYXlbNl0gPSBtaW4ueDtcblx0XHRcdGFycmF5WzddID0gbWluLnk7XG5cdFx0XHRhcnJheVs4XSA9IG1heC56O1xuXHRcdFx0YXJyYXlbOV0gPSBtYXgueDtcblx0XHRcdGFycmF5WzEwXSA9IG1pbi55O1xuXHRcdFx0YXJyYXlbMTFdID0gbWF4Lno7XG5cdFx0XHRhcnJheVsxMl0gPSBtYXgueDtcblx0XHRcdGFycmF5WzEzXSA9IG1heC55O1xuXHRcdFx0YXJyYXlbMTRdID0gbWluLno7XG5cdFx0XHRhcnJheVsxNV0gPSBtaW4ueDtcblx0XHRcdGFycmF5WzE2XSA9IG1heC55O1xuXHRcdFx0YXJyYXlbMTddID0gbWluLno7XG5cdFx0XHRhcnJheVsxOF0gPSBtaW4ueDtcblx0XHRcdGFycmF5WzE5XSA9IG1pbi55O1xuXHRcdFx0YXJyYXlbMjBdID0gbWluLno7XG5cdFx0XHRhcnJheVsyMV0gPSBtYXgueDtcblx0XHRcdGFycmF5WzIyXSA9IG1pbi55O1xuXHRcdFx0YXJyYXlbMjNdID0gbWluLno7XG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXHRcdH1cblxuXHRcdHNldEZyb21PYmplY3Qob2JqZWN0KSB7XG5cdFx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0TGluZVNlZ21lbnRzLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcywgc291cmNlKTtcblx0XHRcdHRoaXMub2JqZWN0ID0gc291cmNlLm9iamVjdDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQm94M0hlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdFx0Y29uc3RydWN0b3IoYm94LCBjb2xvciA9IDB4ZmZmZjAwKSB7XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3XSk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbnMgPSBbMSwgMSwgMSwgLTEsIDEsIDEsIC0xLCAtMSwgMSwgMSwgLTEsIDEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIC0xLCAtMSwgLTEsIDEsIC0xLCAtMV07XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgobmV3IEJ1ZmZlckF0dHJpYnV0ZShpbmRpY2VzLCAxKSk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG5cdFx0XHRzdXBlcihnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0Y29sb3I6IGNvbG9yLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSkpO1xuXHRcdFx0dGhpcy5ib3ggPSBib3g7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQm94M0hlbHBlcic7XG5cdFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXHRcdH1cblxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG5cdFx0XHRjb25zdCBib3ggPSB0aGlzLmJveDtcblx0XHRcdGlmIChib3guaXNFbXB0eSgpKSByZXR1cm47XG5cdFx0XHRib3guZ2V0Q2VudGVyKHRoaXMucG9zaXRpb24pO1xuXHRcdFx0Ym94LmdldFNpemUodGhpcy5zY2FsZSk7XG5cdFx0XHR0aGlzLnNjYWxlLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cdFx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBQbGFuZUhlbHBlciBleHRlbmRzIExpbmUge1xuXHRcdGNvbnN0cnVjdG9yKHBsYW5lLCBzaXplID0gMSwgaGV4ID0gMHhmZmZmMDApIHtcblx0XHRcdGNvbnN0IGNvbG9yID0gaGV4O1xuXHRcdFx0Y29uc3QgcG9zaXRpb25zID0gWzEsIC0xLCAxLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAxLCAxLCAxLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMCwgMCwgMF07XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpO1xuXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0XHRzdXBlcihnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0Y29sb3I6IGNvbG9yLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSkpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BsYW5lSGVscGVyJztcblx0XHRcdHRoaXMucGxhbmUgPSBwbGFuZTtcblx0XHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cdFx0XHRjb25zdCBwb3NpdGlvbnMyID0gWzEsIDEsIDEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIDEsIDEsIDEsIC0xLCAtMSwgMSwgMSwgLTEsIDFdO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeTIuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uczIsIDMpKTtcblx0XHRcdGdlb21ldHJ5Mi5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblx0XHRcdHRoaXMuYWRkKG5ldyBNZXNoKGdlb21ldHJ5MiwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0Y29sb3I6IGNvbG9yLFxuXHRcdFx0XHRvcGFjaXR5OiAwLjIsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHRcdH0pKSk7XG5cdFx0fVxuXG5cdFx0dXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcblx0XHRcdGxldCBzY2FsZSA9IC10aGlzLnBsYW5lLmNvbnN0YW50O1xuXHRcdFx0aWYgKE1hdGguYWJzKHNjYWxlKSA8IDFlLTgpIHNjYWxlID0gMWUtODsgLy8gc2lnbiBkb2VzIG5vdCBtYXR0ZXJcblxuXHRcdFx0dGhpcy5zY2FsZS5zZXQoMC41ICogdGhpcy5zaXplLCAwLjUgKiB0aGlzLnNpemUsIHNjYWxlKTtcblx0XHRcdHRoaXMuY2hpbGRyZW5bMF0ubWF0ZXJpYWwuc2lkZSA9IHNjYWxlIDwgMCA/IEJhY2tTaWRlIDogRnJvbnRTaWRlOyAvLyByZW5kZXJlciBmbGlwcyBzaWRlIHdoZW4gZGV0ZXJtaW5hbnQgPCAwOyBmbGlwcGluZyBub3Qgd2FudGVkIGhlcmVcblxuXHRcdFx0dGhpcy5sb29rQXQodGhpcy5wbGFuZS5ub3JtYWwpO1xuXHRcdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX2F4aXMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRsZXQgX2xpbmVHZW9tZXRyeSwgX2NvbmVHZW9tZXRyeTtcblxuXHRjbGFzcyBBcnJvd0hlbHBlciBleHRlbmRzIE9iamVjdDNEIHtcblx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cdFx0Y29uc3RydWN0b3IoZGlyID0gbmV3IFZlY3RvcjMoMCwgMCwgMSksIG9yaWdpbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApLCBsZW5ndGggPSAxLCBjb2xvciA9IDB4ZmZmZjAwLCBoZWFkTGVuZ3RoID0gbGVuZ3RoICogMC4yLCBoZWFkV2lkdGggPSBoZWFkTGVuZ3RoICogMC4yKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0Fycm93SGVscGVyJztcblxuXHRcdFx0aWYgKF9saW5lR2VvbWV0cnkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRfbGluZUdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdFx0X2xpbmVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoWzAsIDAsIDAsIDAsIDEsIDBdLCAzKSk7XG5cblx0XHRcdFx0X2NvbmVHZW9tZXRyeSA9IG5ldyBDeWxpbmRlckdlb21ldHJ5KDAsIDAuNSwgMSwgNSwgMSk7XG5cblx0XHRcdFx0X2NvbmVHZW9tZXRyeS50cmFuc2xhdGUoMCwgLTAuNSwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucG9zaXRpb24uY29weShvcmlnaW4pO1xuXHRcdFx0dGhpcy5saW5lID0gbmV3IExpbmUoX2xpbmVHZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0Y29sb3I6IGNvbG9yLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSkpO1xuXHRcdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuYWRkKHRoaXMubGluZSk7XG5cdFx0XHR0aGlzLmNvbmUgPSBuZXcgTWVzaChfY29uZUdlb21ldHJ5LCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHRjb2xvcjogY29sb3IsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KSk7XG5cdFx0XHR0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5hZGQodGhpcy5jb25lKTtcblx0XHRcdHRoaXMuc2V0RGlyZWN0aW9uKGRpcik7XG5cdFx0XHR0aGlzLnNldExlbmd0aChsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCk7XG5cdFx0fVxuXG5cdFx0c2V0RGlyZWN0aW9uKGRpcikge1xuXHRcdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdFx0aWYgKGRpci55ID4gMC45OTk5OSkge1xuXHRcdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KDAsIDAsIDAsIDEpO1xuXHRcdFx0fSBlbHNlIGlmIChkaXIueSA8IC0wLjk5OTk5KSB7XG5cdFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoMSwgMCwgMCwgMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfYXhpcy5zZXQoZGlyLnosIDAsIC1kaXIueCkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0Y29uc3QgcmFkaWFucyA9IE1hdGguYWNvcyhkaXIueSk7XG5cdFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKF9heGlzLCByYWRpYW5zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXRMZW5ndGgobGVuZ3RoLCBoZWFkTGVuZ3RoID0gbGVuZ3RoICogMC4yLCBoZWFkV2lkdGggPSBoZWFkTGVuZ3RoICogMC4yKSB7XG5cdFx0XHR0aGlzLmxpbmUuc2NhbGUuc2V0KDEsIE1hdGgubWF4KDAuMDAwMSwgbGVuZ3RoIC0gaGVhZExlbmd0aCksIDEpOyAvLyBzZWUgIzE3NDU4XG5cblx0XHRcdHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcblx0XHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGgpO1xuXHRcdFx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XG5cdFx0XHR0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XG5cdFx0fVxuXG5cdFx0c2V0Q29sb3IoY29sb3IpIHtcblx0XHRcdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoY29sb3IpO1xuXHRcdFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldChjb2xvcik7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLmxpbmUuY29weShzb3VyY2UubGluZSk7XG5cdFx0XHR0aGlzLmNvbmUuY29weShzb3VyY2UuY29uZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEF4ZXNIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXHRcdGNvbnN0cnVjdG9yKHNpemUgPSAxKSB7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFswLCAwLCAwLCBzaXplLCAwLCAwLCAwLCAwLCAwLCAwLCBzaXplLCAwLCAwLCAwLCAwLCAwLCAwLCBzaXplXTtcblx0XHRcdGNvbnN0IGNvbG9ycyA9IFsxLCAwLCAwLCAxLCAwLjYsIDAsIDAsIDEsIDAsIDAuNiwgMSwgMCwgMCwgMCwgMSwgMCwgMC42LCAxXTtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0dmVydGV4Q29sb3JzOiB0cnVlLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHRzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0F4ZXNIZWxwZXInO1xuXHRcdH1cblxuXHRcdHNldENvbG9ycyh4QXhpc0NvbG9yLCB5QXhpc0NvbG9yLCB6QXhpc0NvbG9yKSB7XG5cdFx0XHRjb25zdCBjb2xvciA9IG5ldyBDb2xvcigpO1xuXHRcdFx0Y29uc3QgYXJyYXkgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXk7XG5cdFx0XHRjb2xvci5zZXQoeEF4aXNDb2xvcik7XG5cdFx0XHRjb2xvci50b0FycmF5KGFycmF5LCAwKTtcblx0XHRcdGNvbG9yLnRvQXJyYXkoYXJyYXksIDMpO1xuXHRcdFx0Y29sb3Iuc2V0KHlBeGlzQ29sb3IpO1xuXHRcdFx0Y29sb3IudG9BcnJheShhcnJheSwgNik7XG5cdFx0XHRjb2xvci50b0FycmF5KGFycmF5LCA5KTtcblx0XHRcdGNvbG9yLnNldCh6QXhpc0NvbG9yKTtcblx0XHRcdGNvbG9yLnRvQXJyYXkoYXJyYXksIDEyKTtcblx0XHRcdGNvbG9yLnRvQXJyYXkoYXJyYXksIDE1KTtcblx0XHRcdHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF9mbG9hdFZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuXG5cdGNvbnN0IF9pbnQzMlZpZXcgPSBuZXcgSW50MzJBcnJheShfZmxvYXRWaWV3LmJ1ZmZlcik7XG5cblx0Y2xhc3MgRGF0YVV0aWxzIHtcblx0XHQvLyBDb252ZXJ0cyBmbG9hdDMyIHRvIGZsb2F0MTYgKHN0b3JlZCBhcyB1aW50MTYgdmFsdWUpLlxuXHRcdHN0YXRpYyB0b0hhbGZGbG9hdCh2YWwpIHtcblx0XHRcdC8vIFNvdXJjZTogaHR0cDovL2dhbWVkZXYuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE3MzI2L2NvbnZlcnNpb24tb2YtYS1udW1iZXItZnJvbS1zaW5nbGUtcHJlY2lzaW9uLWZsb2F0aW5nLXBvaW50LXJlcHJlc2VudGF0aW9uLXRvLWEvMTc0MTAjMTc0MTBcblxuXHRcdFx0LyogVGhpcyBtZXRob2QgaXMgZmFzdGVyIHRoYW4gdGhlIE9wZW5FWFIgaW1wbGVtZW50YXRpb24gKHZlcnkgb2Z0ZW5cblx0XHRcdCogdXNlZCwgZWcuIGluIE9ncmUpLCB3aXRoIHRoZSBhZGRpdGlvbmFsIGJlbmVmaXQgb2Ygcm91bmRpbmcsIGluc3BpcmVkXG5cdFx0XHQqIGJ5IEphbWVzIFR1cnNhP3MgaGFsZi1wcmVjaXNpb24gY29kZS4gKi9cblx0XHRcdF9mbG9hdFZpZXdbMF0gPSB2YWw7XG5cdFx0XHRjb25zdCB4ID0gX2ludDMyVmlld1swXTtcblx0XHRcdGxldCBiaXRzID0geCA+PiAxNiAmIDB4ODAwMDtcblx0XHRcdC8qIEdldCB0aGUgc2lnbiAqL1xuXG5cdFx0XHRsZXQgbSA9IHggPj4gMTIgJiAweDA3ZmY7XG5cdFx0XHQvKiBLZWVwIG9uZSBleHRyYSBiaXQgZm9yIHJvdW5kaW5nICovXG5cblx0XHRcdGNvbnN0IGUgPSB4ID4+IDIzICYgMHhmZjtcblx0XHRcdC8qIFVzaW5nIGludCBpcyBmYXN0ZXIgaGVyZSAqL1xuXG5cdFx0XHQvKiBJZiB6ZXJvLCBvciBkZW5vcm1hbCwgb3IgZXhwb25lbnQgdW5kZXJmbG93cyB0b28gbXVjaCBmb3IgYSBkZW5vcm1hbFxuXHRcdFx0XHQqIGhhbGYsIHJldHVybiBzaWduZWQgemVyby4gKi9cblxuXHRcdFx0aWYgKGUgPCAxMDMpIHJldHVybiBiaXRzO1xuXHRcdFx0LyogSWYgTmFOLCByZXR1cm4gTmFOLiBJZiBJbmYgb3IgZXhwb25lbnQgb3ZlcmZsb3csIHJldHVybiBJbmYuICovXG5cblx0XHRcdGlmIChlID4gMTQyKSB7XG5cdFx0XHRcdGJpdHMgfD0gMHg3YzAwO1xuXHRcdFx0XHQvKiBJZiBleHBvbmVudCB3YXMgMHhmZiBhbmQgb25lIG1hbnRpc3NhIGJpdCB3YXMgc2V0LCBpdCBtZWFucyBOYU4sXG5cdFx0XHRcdFx0XHRcdCogbm90IEluZiwgc28gbWFrZSBzdXJlIHdlIHNldCBvbmUgbWFudGlzc2EgYml0IHRvby4gKi9cblxuXHRcdFx0XHRiaXRzIHw9IChlID09IDI1NSA/IDAgOiAxKSAmJiB4ICYgMHgwMDdmZmZmZjtcblx0XHRcdFx0cmV0dXJuIGJpdHM7XG5cdFx0XHR9XG5cdFx0XHQvKiBJZiBleHBvbmVudCB1bmRlcmZsb3dzIGJ1dCBub3QgdG9vIG11Y2gsIHJldHVybiBhIGRlbm9ybWFsICovXG5cblxuXHRcdFx0aWYgKGUgPCAxMTMpIHtcblx0XHRcdFx0bSB8PSAweDA4MDA7XG5cdFx0XHRcdC8qIEV4dHJhIHJvdW5kaW5nIG1heSBvdmVyZmxvdyBhbmQgc2V0IG1hbnRpc3NhIHRvIDAgYW5kIGV4cG9uZW50XG5cdFx0XHRcdFx0KiB0byAxLCB3aGljaCBpcyBPSy4gKi9cblxuXHRcdFx0XHRiaXRzIHw9IChtID4+IDExNCAtIGUpICsgKG0gPj4gMTEzIC0gZSAmIDEpO1xuXHRcdFx0XHRyZXR1cm4gYml0cztcblx0XHRcdH1cblxuXHRcdFx0Yml0cyB8PSBlIC0gMTEyIDw8IDEwIHwgbSA+PiAxO1xuXHRcdFx0LyogRXh0cmEgcm91bmRpbmcuIEFuIG92ZXJmbG93IHdpbGwgc2V0IG1hbnRpc3NhIHRvIDAgYW5kIGluY3JlbWVudFxuXHRcdFx0XHQqIHRoZSBleHBvbmVudCwgd2hpY2ggaXMgT0suICovXG5cblx0XHRcdGJpdHMgKz0gbSAmIDE7XG5cdFx0XHRyZXR1cm4gYml0cztcblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IExpbmVTdHJpcCA9IDA7XG5cdGNvbnN0IExpbmVQaWVjZXMgPSAxO1xuXHRjb25zdCBOb0NvbG9ycyA9IDA7XG5cdGNvbnN0IEZhY2VDb2xvcnMgPSAxO1xuXHRjb25zdCBWZXJ0ZXhDb2xvcnMgPSAyO1xuXHRmdW5jdGlvbiBNZXNoRmFjZU1hdGVyaWFsKG1hdGVyaWFscykge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYW4gQXJyYXkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXHR9XG5cdGZ1bmN0aW9uIE11bHRpTWF0ZXJpYWwobWF0ZXJpYWxzID0gW10pIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk11bHRpTWF0ZXJpYWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGFuIEFycmF5IGluc3RlYWQuJyk7XG5cdFx0bWF0ZXJpYWxzLmlzTXVsdGlNYXRlcmlhbCA9IHRydWU7XG5cdFx0bWF0ZXJpYWxzLm1hdGVyaWFscyA9IG1hdGVyaWFscztcblxuXHRcdG1hdGVyaWFscy5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBtYXRlcmlhbHMuc2xpY2UoKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIG1hdGVyaWFscztcblx0fVxuXHRmdW5jdGlvbiBQb2ludENsb3VkKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHR9XG5cdGZ1bmN0aW9uIFBhcnRpY2xlKG1hdGVyaWFsKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5QYXJ0aWNsZSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlNwcml0ZS4nKTtcblx0XHRyZXR1cm4gbmV3IFNwcml0ZShtYXRlcmlhbCk7XG5cdH1cblx0ZnVuY3Rpb24gUGFydGljbGVTeXN0ZW0oZ2VvbWV0cnksIG1hdGVyaWFsKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5QYXJ0aWNsZVN5c3RlbSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHR9XG5cdGZ1bmN0aW9uIFBvaW50Q2xvdWRNYXRlcmlhbChwYXJhbWV0ZXJzKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKHBhcmFtZXRlcnMpO1xuXHR9XG5cdGZ1bmN0aW9uIFBhcnRpY2xlQmFzaWNNYXRlcmlhbChwYXJhbWV0ZXJzKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKHBhcmFtZXRlcnMpO1xuXHR9XG5cdGZ1bmN0aW9uIFBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwocGFyYW1ldGVycykge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicpO1xuXHRcdHJldHVybiBuZXcgUG9pbnRzTWF0ZXJpYWwocGFyYW1ldGVycyk7XG5cdH1cblx0ZnVuY3Rpb24gVmVydGV4KHgsIHksIHopIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlcnRleCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuVmVjdG9yMyBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgVmVjdG9yMyh4LCB5LCB6KTtcblx0fSAvL1xuXG5cdGZ1bmN0aW9uIER5bmFtaWNCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCkuc2V0VXNhZ2UoIFRIUkVFLkR5bmFtaWNEcmF3VXNhZ2UgKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkuc2V0VXNhZ2UoRHluYW1pY0RyYXdVc2FnZSk7XG5cdH1cblx0ZnVuY3Rpb24gSW50OEF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkludDhBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQ4QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IEludDhCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKTtcblx0fVxuXHRmdW5jdGlvbiBVaW50OEF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlVpbnQ4QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDhCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgVWludDhCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKTtcblx0fVxuXHRmdW5jdGlvbiBVaW50OENsYW1wZWRBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5VaW50OENsYW1wZWRBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSk7XG5cdH1cblx0ZnVuY3Rpb24gSW50MTZBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbnQxNkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDE2QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IEludDE2QnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSk7XG5cdH1cblx0ZnVuY3Rpb24gVWludDE2QXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVWludDE2QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDE2QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpO1xuXHR9XG5cdGZ1bmN0aW9uIEludDMyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuSW50MzJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBJbnQzMkJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpO1xuXHR9XG5cdGZ1bmN0aW9uIFVpbnQzMkF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlVpbnQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLlVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKTtcblx0fVxuXHRmdW5jdGlvbiBGbG9hdDMyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpO1xuXHR9XG5cdGZ1bmN0aW9uIEZsb2F0NjRBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5GbG9hdDY0QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDY0QnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSk7XG5cdH0gLy9cblxuXHRDdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29uc3RydWN0LCBnZXRQb2ludCkge1xuXHRcdGNvbnNvbGUubG9nKCdUSFJFRS5DdXJ2ZS5jcmVhdGUoKSBoYXMgYmVlbiBkZXByZWNhdGVkJyk7XG5cdFx0Y29uc3RydWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ3VydmUucHJvdG90eXBlKTtcblx0XHRjb25zdHJ1Y3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0O1xuXHRcdGNvbnN0cnVjdC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBnZXRQb2ludDtcblx0XHRyZXR1cm4gY29uc3RydWN0O1xuXHR9OyAvL1xuXG5cblx0UGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlBhdGg6IC5mcm9tUG9pbnRzKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbVBvaW50cygpLicpO1xuXHRcdHJldHVybiB0aGlzLnNldEZyb21Qb2ludHMocG9pbnRzKTtcblx0fTsgLy9cblxuXG5cdGZ1bmN0aW9uIEF4aXNIZWxwZXIoc2l6ZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQXhpc0hlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkF4ZXNIZWxwZXIuJyk7XG5cdFx0cmV0dXJuIG5ldyBBeGVzSGVscGVyKHNpemUpO1xuXHR9XG5cdGZ1bmN0aW9uIEJvdW5kaW5nQm94SGVscGVyKG9iamVjdCwgY29sb3IpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJvdW5kaW5nQm94SGVscGVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIENyZWF0aW5nIGEgVEhSRUUuQm94SGVscGVyIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBCb3hIZWxwZXIob2JqZWN0LCBjb2xvcik7XG5cdH1cblx0ZnVuY3Rpb24gRWRnZXNIZWxwZXIob2JqZWN0LCBoZXgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkVkZ2VzSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5FZGdlc0dlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBMaW5lU2VnbWVudHMobmV3IEVkZ2VzR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5KSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiBoZXggIT09IHVuZGVmaW5lZCA/IGhleCA6IDB4ZmZmZmZmXG5cdFx0fSkpO1xuXHR9XG5cblx0R3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkdyaWRIZWxwZXI6IHNldENvbG9ycygpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBhc3MgdGhlbSBpbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZC4nKTtcblx0fTtcblxuXHRTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlNrZWxldG9uSGVscGVyOiB1cGRhdGUoKSBubyBsb25nZXIgbmVlZHMgdG8gYmUgY2FsbGVkLicpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFdpcmVmcmFtZUhlbHBlcihvYmplY3QsIGhleCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2lyZWZyYW1lSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKG5ldyBXaXJlZnJhbWVHZW9tZXRyeShvYmplY3QuZ2VvbWV0cnkpLCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IGhleCAhPT0gdW5kZWZpbmVkID8gaGV4IDogMHhmZmZmZmZcblx0XHR9KSk7XG5cdH0gLy9cblxuXHRMb2FkZXIucHJvdG90eXBlLmV4dHJhY3RVcmxCYXNlID0gZnVuY3Rpb24gKHVybCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTG9hZGVyOiAuZXh0cmFjdFVybEJhc2UoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpO1xuXHR9O1xuXG5cdExvYWRlci5IYW5kbGVycyA9IHtcblx0XHRhZGQ6IGZ1bmN0aW9uICgpXG5cdFx0LyogcmVnZXgsIGxvYWRlciAqL1xuXHRcdHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkxvYWRlcjogSGFuZGxlcnMuYWRkKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIExvYWRpbmdNYW5hZ2VyLmFkZEhhbmRsZXIoKSBpbnN0ZWFkLicpO1xuXHRcdH0sXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKVxuXHRcdC8qIGZpbGUgKi9cblx0XHR7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Mb2FkZXI6IEhhbmRsZXJzLmdldCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBMb2FkaW5nTWFuYWdlci5nZXRIYW5kbGVyKCkgaW5zdGVhZC4nKTtcblx0XHR9XG5cdH07XG5cdGZ1bmN0aW9uIFhIUkxvYWRlcihtYW5hZ2VyKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5YSFJMb2FkZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5GaWxlTG9hZGVyLicpO1xuXHRcdHJldHVybiBuZXcgRmlsZUxvYWRlcihtYW5hZ2VyKTtcblx0fVxuXHRmdW5jdGlvbiBCaW5hcnlUZXh0dXJlTG9hZGVyKG1hbmFnZXIpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5EYXRhVGV4dHVyZUxvYWRlci4nKTtcblx0XHRyZXR1cm4gbmV3IERhdGFUZXh0dXJlTG9hZGVyKG1hbmFnZXIpO1xuXHR9IC8vXG5cblx0Qm94Mi5wcm90b3R5cGUuY2VudGVyID0gZnVuY3Rpb24gKG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Cb3gyOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKG9wdGlvbmFsVGFyZ2V0KTtcblx0fTtcblxuXHRCb3gyLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveDI6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG5cdH07XG5cblx0Qm94Mi5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25Cb3ggPSBmdW5jdGlvbiAoYm94KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Cb3gyOiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveChib3gpO1xuXHR9O1xuXG5cdEJveDIucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAob3B0aW9uYWxUYXJnZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveDI6IC5zaXplKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0U2l6ZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldFNpemUob3B0aW9uYWxUYXJnZXQpO1xuXHR9OyAvL1xuXG5cblx0Qm94My5wcm90b3R5cGUuY2VudGVyID0gZnVuY3Rpb24gKG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Cb3gzOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKG9wdGlvbmFsVGFyZ2V0KTtcblx0fTtcblxuXHRCb3gzLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveDM6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG5cdH07XG5cblx0Qm94My5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25Cb3ggPSBmdW5jdGlvbiAoYm94KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveChib3gpO1xuXHR9O1xuXG5cdEJveDMucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uU3BoZXJlID0gZnVuY3Rpb24gKHNwaGVyZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoc3BoZXJlKTtcblx0fTtcblxuXHRCb3gzLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Cb3gzOiAuc2l6ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldFNpemUoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRTaXplKG9wdGlvbmFsVGFyZ2V0KTtcblx0fTsgLy9cblxuXG5cdFNwaGVyZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5TcGhlcmU6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG5cdH07IC8vXG5cblxuXHRGcnVzdHVtLnByb3RvdHlwZS5zZXRGcm9tTWF0cml4ID0gZnVuY3Rpb24gKG0pIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkZydXN0dW06IC5zZXRGcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChtKTtcblx0fTsgLy9cblxuXG5cdExpbmUzLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbiAob3B0aW9uYWxUYXJnZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpbmUzOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKG9wdGlvbmFsVGFyZ2V0KTtcblx0fTsgLy9cblxuXG5cdE1hdHJpeDMucHJvdG90eXBlLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0ID0gZnVuY3Rpb24gKGFycmF5LCBvZmZzZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDM6IC5mbGF0dGVuVG9BcnJheU9mZnNldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAudG9BcnJheSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIHRoaXMudG9BcnJheShhcnJheSwgb2Zmc2V0KTtcblx0fTtcblxuXHRNYXRyaXgzLnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjMgPSBmdW5jdGlvbiAodmVjdG9yKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDModGhpcyk7XG5cdH07XG5cblx0TWF0cml4My5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3IzQXJyYXkgPSBmdW5jdGlvbiAoKVxuXHQvKiBhICovXG5cdHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdE1hdHJpeDMucHJvdG90eXBlLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXgzOiAuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhdHRyaWJ1dGUuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBhdHRyaWJ1dGUuYXBwbHlNYXRyaXgzKHRoaXMpO1xuXHR9O1xuXG5cdE1hdHJpeDMucHJvdG90eXBlLmFwcGx5VG9WZWN0b3IzQXJyYXkgPSBmdW5jdGlvbiAoKVxuXHQvKiBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKi9cblx0e1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk1hdHJpeDM6IC5hcHBseVRvVmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRNYXRyaXgzLnByb3RvdHlwZS5nZXRJbnZlcnNlID0gZnVuY3Rpb24gKG1hdHJpeCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4MzogLmdldEludmVyc2UoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbWF0cml4SW52LmNvcHkoIG1hdHJpeCApLmludmVydCgpOyBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiB0aGlzLmNvcHkobWF0cml4KS5pbnZlcnQoKTtcblx0fTsgLy9cblxuXG5cdE1hdHJpeDQucHJvdG90eXBlLmV4dHJhY3RQb3NpdGlvbiA9IGZ1bmN0aW9uIChtKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuY29weVBvc2l0aW9uKG0pO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0ID0gZnVuY3Rpb24gKGFycmF5LCBvZmZzZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDQ6IC5mbGF0dGVuVG9BcnJheU9mZnNldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAudG9BcnJheSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIHRoaXMudG9BcnJheShhcnJheSwgb2Zmc2V0KTtcblx0fTtcblxuXHRNYXRyaXg0LnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDQ6IC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IFZlY3RvcjMoKS5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDMpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24gPSBmdW5jdGlvbiAocSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLicpO1xuXHRcdHJldHVybiB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLm11bHRpcGx5VG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVRvQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yMyA9IGZ1bmN0aW9uICh2ZWN0b3IpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCh0aGlzKTtcblx0fTtcblxuXHRNYXRyaXg0LnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjQgPSBmdW5jdGlvbiAodmVjdG9yKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQodGhpcyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3IzQXJyYXkgPSBmdW5jdGlvbiAoKVxuXHQvKiBhICovXG5cdHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLnJvdGF0ZUF4aXMgPSBmdW5jdGlvbiAodikge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyk7XG5cdFx0di50cmFuc2Zvcm1EaXJlY3Rpb24odGhpcyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUuY3Jvc3NWZWN0b3IgPSBmdW5jdGlvbiAodmVjdG9yKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAuY3Jvc3NWZWN0b3IoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCh0aGlzKTtcblx0fTtcblxuXHRNYXRyaXg0LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUucm90YXRlWCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUucm90YXRlWSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUucm90YXRlWiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUucm90YXRlQnlBeGlzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhdHRyaWJ1dGUuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBhdHRyaWJ1dGUuYXBwbHlNYXRyaXg0KHRoaXMpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLmFwcGx5VG9WZWN0b3IzQXJyYXkgPSBmdW5jdGlvbiAoKVxuXHQvKiBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKi9cblx0e1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk1hdHJpeDQ6IC5hcHBseVRvVmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRNYXRyaXg0LnByb3RvdHlwZS5tYWtlRnJ1c3R1bSA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4NDogLm1ha2VGcnVzdHVtKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5tYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdGhpcy5tYWtlUGVyc3BlY3RpdmUobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLmdldEludmVyc2UgPSBmdW5jdGlvbiAobWF0cml4KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAuZ2V0SW52ZXJzZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBtYXRyaXhJbnYuY29weSggbWF0cml4ICkuaW52ZXJ0KCk7IGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIHRoaXMuY29weShtYXRyaXgpLmludmVydCgpO1xuXHR9OyAvL1xuXG5cblx0UGxhbmUucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5QbGFuZTogLmlzSW50ZXJzZWN0aW9uTGluZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNMaW5lKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0xpbmUobGluZSk7XG5cdH07IC8vXG5cblxuXHRRdWF0ZXJuaW9uLnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjMgPSBmdW5jdGlvbiAodmVjdG9yKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbih0aGlzKTtcblx0fTtcblxuXHRRdWF0ZXJuaW9uLnByb3RvdHlwZS5pbnZlcnNlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuUXVhdGVybmlvbjogLmludmVyc2UoKSBoYXMgYmVlbiByZW5hbWVkIHRvIGludmVydCgpLicpO1xuXHRcdHJldHVybiB0aGlzLmludmVydCgpO1xuXHR9OyAvL1xuXG5cblx0UmF5LnByb3RvdHlwZS5pc0ludGVyc2VjdGlvbkJveCA9IGZ1bmN0aW9uIChib3gpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicpO1xuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goYm94KTtcblx0fTtcblxuXHRSYXkucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uUGxhbmUgPSBmdW5jdGlvbiAocGxhbmUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uUGxhbmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzUGxhbmUoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzUGxhbmUocGxhbmUpO1xuXHR9O1xuXG5cdFJheS5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25TcGhlcmUgPSBmdW5jdGlvbiAoc3BoZXJlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvblNwaGVyZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNTcGhlcmUoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSk7XG5cdH07IC8vXG5cblxuXHRUcmlhbmdsZS5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlRyaWFuZ2xlOiAuYXJlYSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldEFyZWEoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRBcmVhKCk7XG5cdH07XG5cblx0VHJpYW5nbGUucHJvdG90eXBlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCwgdGFyZ2V0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5UcmlhbmdsZTogLmJhcnljb29yZEZyb21Qb2ludCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldEJhcnljb29yZCgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldEJhcnljb29yZChwb2ludCwgdGFyZ2V0KTtcblx0fTtcblxuXHRUcmlhbmdsZS5wcm90b3R5cGUubWlkcG9pbnQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5UcmlhbmdsZTogLm1pZHBvaW50KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0TWlkcG9pbnQoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRNaWRwb2ludCh0YXJnZXQpO1xuXHR9O1xuXG5cdFRyaWFuZ2xlLnByb3RvdHlwZW5vcm1hbCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlRyaWFuZ2xlOiAubm9ybWFsKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Tm9ybWFsKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Tm9ybWFsKHRhcmdldCk7XG5cdH07XG5cblx0VHJpYW5nbGUucHJvdG90eXBlLnBsYW5lID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVHJpYW5nbGU6IC5wbGFuZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldFBsYW5lKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGxhbmUodGFyZ2V0KTtcblx0fTtcblxuXHRUcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQsIGEsIGIsIGMsIHRhcmdldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVHJpYW5nbGU6IC5iYXJ5Y29vcmRGcm9tUG9pbnQoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRCYXJ5Y29vcmQoKS4nKTtcblx0XHRyZXR1cm4gVHJpYW5nbGUuZ2V0QmFyeWNvb3JkKHBvaW50LCBhLCBiLCBjLCB0YXJnZXQpO1xuXHR9O1xuXG5cdFRyaWFuZ2xlLm5vcm1hbCA9IGZ1bmN0aW9uIChhLCBiLCBjLCB0YXJnZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlRyaWFuZ2xlOiAubm9ybWFsKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Tm9ybWFsKCkuJyk7XG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldE5vcm1hbChhLCBiLCBjLCB0YXJnZXQpO1xuXHR9OyAvL1xuXG5cblx0U2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHMgPSBmdW5jdGlvbiAoZGl2aXNpb25zKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5TaGFwZTogLmV4dHJhY3RBbGxQb2ludHMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLmV4dHJhY3RQb2ludHMoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiB0aGlzLmV4dHJhY3RQb2ludHMoZGl2aXNpb25zKTtcblx0fTtcblxuXHRTaGFwZS5wcm90b3R5cGUuZXh0cnVkZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5TaGFwZTogLmV4dHJ1ZGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXh0cnVkZUdlb21ldHJ5KCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IEV4dHJ1ZGVHZW9tZXRyeSh0aGlzLCBvcHRpb25zKTtcblx0fTtcblxuXHRTaGFwZS5wcm90b3R5cGUubWFrZUdlb21ldHJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlNoYXBlOiAubWFrZUdlb21ldHJ5KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFNoYXBlR2VvbWV0cnkoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgU2hhcGVHZW9tZXRyeSh0aGlzLCBvcHRpb25zKTtcblx0fTsgLy9cblxuXG5cdFZlY3RvcjIucHJvdG90eXBlLmZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IyOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCk7XG5cdH07XG5cblx0VmVjdG9yMi5wcm90b3R5cGUuZGlzdGFuY2VUb01hbmhhdHRhbiA9IGZ1bmN0aW9uICh2KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IyOiAuZGlzdGFuY2VUb01hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkRpc3RhbmNlVG8oKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5EaXN0YW5jZVRvKHYpO1xuXHR9O1xuXG5cdFZlY3RvcjIucHJvdG90eXBlLmxlbmd0aE1hbmhhdHRhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjI6IC5sZW5ndGhNYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5MZW5ndGgoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5MZW5ndGgoKTtcblx0fTsgLy9cblxuXG5cdFZlY3RvcjMucHJvdG90eXBlLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicpO1xuXHR9O1xuXG5cdFZlY3RvcjMucHJvdG90eXBlLnNldEV1bGVyRnJvbVF1YXRlcm5pb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicpO1xuXHR9O1xuXG5cdFZlY3RvcjMucHJvdG90eXBlLmdldFBvc2l0aW9uRnJvbU1hdHJpeCA9IGZ1bmN0aW9uIChtKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKG0pO1xuXHR9O1xuXG5cdFZlY3RvcjMucHJvdG90eXBlLmdldFNjYWxlRnJvbU1hdHJpeCA9IGZ1bmN0aW9uIChtKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiAuZ2V0U2NhbGVGcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFNjYWxlKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFNjYWxlKG0pO1xuXHR9O1xuXG5cdFZlY3RvcjMucHJvdG90eXBlLmdldENvbHVtbkZyb21NYXRyaXggPSBmdW5jdGlvbiAoaW5kZXgsIG1hdHJpeCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogLmdldENvbHVtbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4Q29sdW1uKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtYXRyaXgsIGluZGV4KTtcblx0fTtcblxuXHRWZWN0b3IzLnByb3RvdHlwZS5hcHBseVByb2plY3Rpb24gPSBmdW5jdGlvbiAobSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogLmFwcGx5UHJvamVjdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuYXBwbHlNYXRyaXg0KCBtICkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQobSk7XG5cdH07XG5cblx0VmVjdG9yMy5wcm90b3R5cGUuZnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjM6IC5mcm9tQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0KTtcblx0fTtcblxuXHRWZWN0b3IzLnByb3RvdHlwZS5kaXN0YW5jZVRvTWFuaGF0dGFuID0gZnVuY3Rpb24gKHYpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjM6IC5kaXN0YW5jZVRvTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuRGlzdGFuY2VUbygpLicpO1xuXHRcdHJldHVybiB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlVG8odik7XG5cdH07XG5cblx0VmVjdG9yMy5wcm90b3R5cGUubGVuZ3RoTWFuaGF0dGFuID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogLmxlbmd0aE1hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkxlbmd0aCgpLicpO1xuXHRcdHJldHVybiB0aGlzLm1hbmhhdHRhbkxlbmd0aCgpO1xuXHR9OyAvL1xuXG5cblx0VmVjdG9yNC5wcm90b3R5cGUuZnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjQ6IC5mcm9tQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0KTtcblx0fTtcblxuXHRWZWN0b3I0LnByb3RvdHlwZS5sZW5ndGhNYW5oYXR0YW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3I0OiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuTGVuZ3RoKCk7XG5cdH07IC8vXG5cblxuXHRPYmplY3QzRC5wcm90b3R5cGUuZ2V0Q2hpbGRCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5TmFtZShuYW1lKTtcblx0fTtcblxuXHRPYmplY3QzRC5wcm90b3R5cGUucmVuZGVyRGVwdGggPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3QzRDogLnJlbmRlckRlcHRoIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAucmVuZGVyT3JkZXIsIGluc3RlYWQuJyk7XG5cdH07XG5cblx0T2JqZWN0M0QucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkaXN0YW5jZSwgYXhpcykge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0M0Q6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhheGlzLCBkaXN0YW5jZSk7XG5cdH07XG5cblx0T2JqZWN0M0QucHJvdG90eXBlLmdldFdvcmxkUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuT2JqZWN0M0Q6IC5nZXRXb3JsZFJvdGF0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLk9iamVjdDNELmdldFdvcmxkUXVhdGVybmlvbiggdGFyZ2V0ICkgaW5zdGVhZC4nKTtcblx0fTtcblxuXHRPYmplY3QzRC5wcm90b3R5cGUuYXBwbHlNYXRyaXggPSBmdW5jdGlvbiAobWF0cml4KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3QzRDogLmFwcGx5TWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuYXBwbHlNYXRyaXg0KCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG5cdH07XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoT2JqZWN0M0QucHJvdG90eXBlLCB7XG5cdFx0ZXVsZXJPcmRlcjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyk7XG5cdFx0XHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHVzZVF1YXRlcm5pb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicpO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0TWVzaC5wcm90b3R5cGUuc2V0RHJhd01vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTWVzaDogLnNldERyYXdNb2RlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIHJlbmRlcmVyIG5vdyBhbHdheXMgYXNzdW1lcyBUSFJFRS5UcmlhbmdsZXNEcmF3TW9kZS4gVHJhbnNmb3JtIHlvdXIgZ2VvbWV0cnkgdmlhIEJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpIGlmIG5lY2Vzc2FyeS4nKTtcblx0fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhNZXNoLnByb3RvdHlwZSwge1xuXHRcdGRyYXdNb2RlOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTWVzaDogLmRyYXdNb2RlIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSByZW5kZXJlciBub3cgYWx3YXlzIGFzc3VtZXMgVEhSRUUuVHJpYW5nbGVzRHJhd01vZGUuJyk7XG5cdFx0XHRcdHJldHVybiBUcmlhbmdsZXNEcmF3TW9kZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTWVzaDogLmRyYXdNb2RlIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSByZW5kZXJlciBub3cgYWx3YXlzIGFzc3VtZXMgVEhSRUUuVHJpYW5nbGVzRHJhd01vZGUuIFRyYW5zZm9ybSB5b3VyIGdlb21ldHJ5IHZpYSBCdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKSBpZiBuZWNlc3NhcnkuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRTa2lubmVkTWVzaC5wcm90b3R5cGUuaW5pdEJvbmVzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlNraW5uZWRNZXNoOiBpbml0Qm9uZXMoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9OyAvL1xuXG5cblx0UGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoZm9jYWxMZW5ndGgsIGZpbG1HYXVnZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEuc2V0TGVucyBpcyBkZXByZWNhdGVkLiAnICsgJ1VzZSAuc2V0Rm9jYWxMZW5ndGggYW5kIC5maWxtR2F1Z2UgZm9yIGEgcGhvdG9ncmFwaGljIHNldHVwLicpO1xuXHRcdGlmIChmaWxtR2F1Z2UgIT09IHVuZGVmaW5lZCkgdGhpcy5maWxtR2F1Z2UgPSBmaWxtR2F1Z2U7XG5cdFx0dGhpcy5zZXRGb2NhbExlbmd0aChmb2NhbExlbmd0aCk7XG5cdH07IC8vXG5cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhMaWdodC5wcm90b3R5cGUsIHtcblx0XHRvbmx5U2hhZG93OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLm9ubHlTaGFkb3cgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYUZvdjoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZvdiBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZm92LicpO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuZm92ID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFMZWZ0OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTGVmdCBpcyBub3cgLnNoYWRvdy5jYW1lcmEubGVmdC4nKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmxlZnQgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYVJpZ2h0OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhUmlnaHQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLnJpZ2h0LicpO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEucmlnaHQgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYVRvcDoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVRvcCBpcyBub3cgLnNoYWRvdy5jYW1lcmEudG9wLicpO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEudG9wID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFCb3R0b206IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFCb3R0b20gaXMgbm93IC5zaGFkb3cuY2FtZXJhLmJvdHRvbS4nKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmJvdHRvbSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Q2FtZXJhTmVhcjoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYU5lYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLm5lYXIuJyk7XG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5uZWFyID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFGYXI6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFGYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmZhci4nKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZhciA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Q2FtZXJhVmlzaWJsZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFWaXNpYmxlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3cuY2FtZXJhICkgaW5zdGVhZC4nKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0JpYXM6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTGlnaHQ6IC5zaGFkb3dCaWFzIGlzIG5vdyAuc2hhZG93LmJpYXMuJyk7XG5cdFx0XHRcdHRoaXMuc2hhZG93LmJpYXMgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0RhcmtuZXNzOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd0RhcmtuZXNzIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dNYXBXaWR0aDoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd01hcFdpZHRoIGlzIG5vdyAuc2hhZG93Lm1hcFNpemUud2lkdGguJyk7XG5cdFx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUud2lkdGggPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd01hcEhlaWdodDoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd01hcEhlaWdodCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLmhlaWdodC4nKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pOyAvL1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcblx0XHRsZW5ndGg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmNvdW50IGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGR5bmFtaWM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmR5bmFtaWMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC51c2FnZSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy51c2FnZSA9PT0gRHluYW1pY0RyYXdVc2FnZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpXG5cdFx0XHQvKiB2YWx1ZSAqL1xuXHRcdFx0e1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmR5bmFtaWMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC51c2FnZSBpbnN0ZWFkLicpO1xuXHRcdFx0XHR0aGlzLnNldFVzYWdlKER5bmFtaWNEcmF3VXNhZ2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5zZXREeW5hbWljID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5zZXREeW5hbWljKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5zZXRVc2FnZSgpIGluc3RlYWQuJyk7XG5cdFx0dGhpcy5zZXRVc2FnZSh2YWx1ZSA9PT0gdHJ1ZSA/IER5bmFtaWNEcmF3VXNhZ2UgOiBTdGF0aWNEcmF3VXNhZ2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weUluZGljZXNBcnJheSA9IGZ1bmN0aW9uICgpXG5cdC8qIGluZGljZXMgKi9cblx0e1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmNvcHlJbmRpY2VzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9LCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLnNldEFycmF5ID0gZnVuY3Rpb24gKClcblx0LyogYXJyYXkgKi9cblx0e1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLnNldEFycmF5IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBCdWZmZXJHZW9tZXRyeSAuc2V0QXR0cmlidXRlIHRvIHJlcGxhY2UvcmVzaXplIGF0dHJpYnV0ZSBidWZmZXJzJyk7XG5cdH07IC8vXG5cblx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS4nKTtcblx0XHR0aGlzLnNldEluZGV4KGluZGV4KTtcblx0fTtcblxuXHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIGF0dHJpYnV0ZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRBdHRyaWJ1dGUoKS4nKTtcblxuXHRcdGlmICghKGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCdWZmZXJBdHRyaWJ1dGUpICYmICEoYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xuXHRcdH1cblxuXHRcdGlmIChuYW1lID09PSAnaW5kZXgnKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyk7XG5cdFx0XHR0aGlzLnNldEluZGV4KGF0dHJpYnV0ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cmlidXRlKTtcblx0fTtcblxuXHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYWRkRHJhd0NhbGwgPSBmdW5jdGlvbiAoc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCkge1xuXHRcdGlmIChpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyk7XG5cdFx0fVxuXG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgaXMgbm93IC5hZGRHcm91cCgpLicpO1xuXHRcdHRoaXMuYWRkR3JvdXAoc3RhcnQsIGNvdW50KTtcblx0fTtcblxuXHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xlYXJEcmF3Q2FsbHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicpO1xuXHRcdHRoaXMuY2xlYXJHcm91cHMoKTtcblx0fTtcblxuXHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZU9mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVPZmZzZXRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAucmVtb3ZlQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZGVsZXRlQXR0cmlidXRlKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZGVsZXRlQXR0cmlidXRlKG5hbWUpO1xuXHR9O1xuXG5cdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hcHBseU1hdHJpeCA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYXBwbHlNYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5hcHBseU1hdHJpeDQoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQobWF0cml4KTtcblx0fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUsIHtcblx0XHRkcmF3Y2FsbHM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmRyYXdjYWxscyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdyb3Vwcztcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9mZnNldHM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAub2Zmc2V0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdyb3Vwcztcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5zZXREeW5hbWljID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlcjogLnNldER5bmFtaWMoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnNldFVzYWdlKCkgaW5zdGVhZC4nKTtcblx0XHR0aGlzLnNldFVzYWdlKHZhbHVlID09PSB0cnVlID8gRHluYW1pY0RyYXdVc2FnZSA6IFN0YXRpY0RyYXdVc2FnZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0SW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLnNldEFycmF5ID0gZnVuY3Rpb24gKClcblx0LyogYXJyYXkgKi9cblx0e1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkludGVybGVhdmVkQnVmZmVyOiAuc2V0QXJyYXkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEJ1ZmZlckdlb21ldHJ5IC5zZXRBdHRyaWJ1dGUgdG8gcmVwbGFjZS9yZXNpemUgYXR0cmlidXRlIGJ1ZmZlcnMnKTtcblx0fTsgLy9cblxuXG5cdEV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuZ2V0QXJyYXlzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogLmdldEFycmF5cygpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0RXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiAuYWRkU2hhcGVMaXN0KCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogLmFkZFNoYXBlKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTsgLy9cblxuXG5cdFNjZW5lLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlNjZW5lOiAuZGlzcG9zZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07IC8vXG5cblxuXHRVbmlmb3JtLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlVuaWZvcm06IC5vblVwZGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBvYmplY3Qub25CZWZvcmVSZW5kZXIoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9OyAvL1xuXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWF0ZXJpYWwucHJvdG90eXBlLCB7XG5cdFx0d3JhcEFyb3VuZDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0ZXJpYWw6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0ZXJpYWw6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvdmVyZHJhdzoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0ZXJpYWw6IC5vdmVyZHJhdyBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdGVyaWFsOiAub3ZlcmRyYXcgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHdyYXBSR0I6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdGVyaWFsOiAud3JhcFJHQiBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbG9yKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkaW5nOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC5zaGFkaW5nIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB0aGUgYm9vbGVhbiAuZmxhdFNoYWRpbmcgaW5zdGVhZC4nKTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyk7XG5cdFx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSB2YWx1ZSA9PT0gRmxhdFNoYWRpbmc7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdGVuY2lsTWFzazoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC5zdGVuY2lsTWFzayBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnN0ZW5jaWxGdW5jTWFzayBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdGVuY2lsRnVuY01hc2s7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLnN0ZW5jaWxNYXNrIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuc3RlbmNpbEZ1bmNNYXNrIGluc3RlYWQuJyk7XG5cdFx0XHRcdHRoaXMuc3RlbmNpbEZ1bmNNYXNrID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR2ZXJ0ZXhUYW5nZW50czoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC52ZXJ0ZXhUYW5nZW50cyBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAudmVydGV4VGFuZ2VudHMgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUsIHtcblx0XHRkZXJpdmF0aXZlczoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcztcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLiBTaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLicpO1xuXHRcdFx0XHR0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pOyAvL1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmNsZWFyVGFyZ2V0ID0gZnVuY3Rpb24gKHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuY2xlYXJUYXJnZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnNldFJlbmRlclRhcmdldCgpIGFuZCAuY2xlYXIoKSBpbnN0ZWFkLicpO1xuXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0dGhpcy5jbGVhcihjb2xvciwgZGVwdGgsIHN0ZW5jaWwpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hbmltYXRlKCkgaXMgbm93IC5zZXRBbmltYXRpb25Mb29wKCkuJyk7XG5cdFx0dGhpcy5zZXRBbmltYXRpb25Mb29wKGNhbGxiYWNrKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdldEN1cnJlbnRSZW5kZXJUYXJnZXQoKSBpcyBub3cgLmdldFJlbmRlclRhcmdldCgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldFJlbmRlclRhcmdldCgpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmdldE1heEFuaXNvdHJvcHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0TWF4QW5pc290cm9weSgpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nZXRQcmVjaXNpb24oKSBpcyBub3cgLmNhcGFiaWxpdGllcy5wcmVjaXNpb24uJyk7XG5cdFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZXNldEdMU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAucmVzZXRHTFN0YXRlKCkgaXMgbm93IC5zdGF0ZS5yZXNldCgpLicpO1xuXHRcdHJldHVybiB0aGlzLnN0YXRlLnJlc2V0KCk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc3VwcG9ydHNGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2Zsb2F0XFwnICkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfaGFsZl9mbG9hdFxcJyApLicpO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcJyApLicpO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQyA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXFwnICkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xcJyApLicpO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zdXBwb3J0c0JsZW5kTWluTWF4ID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQmxlbmRNaW5NYXgoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdFWFRfYmxlbmRfbWlubWF4XFwnICkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoJ0VYVF9ibGVuZF9taW5tYXgnKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMoKSBpcyBub3cgLmNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcy4nKTtcblx0XHRyZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXM7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFwnICkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5lbmFibGVTY2lzc29yVGVzdCA9IGZ1bmN0aW9uIChib29sZWFuKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZW5hYmxlU2Npc3NvclRlc3QoKSBpcyBub3cgLnNldFNjaXNzb3JUZXN0KCkuJyk7XG5cdFx0dGhpcy5zZXRTY2lzc29yVGVzdChib29sZWFuKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5pbml0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5hZGRQcmVQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5hZGRQb3N0UGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFBvc3RQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZVNoYWRvd01hcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldEZhY2VDdWxsaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldEZhY2VDdWxsaW5nKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5hbGxvY1RleHR1cmVVbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFsbG9jVGV4dHVyZVVuaXQoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2V0VGV4dHVyZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0VGV4dHVyZTJEID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldFRleHR1cmUyRCgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0VGV4dHVyZUN1YmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2V0VGV4dHVyZUN1YmUoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmdldEFjdGl2ZU1pcE1hcExldmVsID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdldEFjdGl2ZU1pcE1hcExldmVsKCkgaXMgbm93IC5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldEFjdGl2ZU1pcG1hcExldmVsKCk7XG5cdH07XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViR0xSZW5kZXJlci5wcm90b3R5cGUsIHtcblx0XHRzaGFkb3dNYXBFbmFibGVkOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLmVuYWJsZWQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRW5hYmxlZCBpcyBub3cgLnNoYWRvd01hcC5lbmFibGVkLicpO1xuXHRcdFx0XHR0aGlzLnNoYWRvd01hcC5lbmFibGVkID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dNYXBUeXBlOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLnR5cGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicpO1xuXHRcdFx0XHR0aGlzLnNoYWRvd01hcC50eXBlID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dNYXBDdWxsRmFjZToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEN1bGxGYWNlIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKVxuXHRcdFx0LyogdmFsdWUgKi9cblx0XHRcdHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IE1hdGVyaWFsLnNoYWRvd1NpZGUgaW5zdGVhZC4nKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvbnRleHQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5jb250ZXh0IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuZ2V0Q29udGV4dCgpIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldENvbnRleHQoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHZyOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAudnIgaGFzIGJlZW4gcmVuYW1lZCB0byAueHInKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMueHI7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnYW1tYUlucHV0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2FtbWFJbnB1dCBoYXMgYmVlbiByZW1vdmVkLiBTZXQgdGhlIGVuY29kaW5nIGZvciB0ZXh0dXJlcyB2aWEgVGV4dHVyZS5lbmNvZGluZyBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdhbW1hSW5wdXQgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IHRoZSBlbmNvZGluZyBmb3IgdGV4dHVyZXMgdmlhIFRleHR1cmUuZW5jb2RpbmcgaW5zdGVhZC4nKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdhbW1hT3V0cHV0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2FtbWFPdXRwdXQgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IFdlYkdMUmVuZGVyZXIub3V0cHV0RW5jb2RpbmcgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdhbW1hT3V0cHV0IGhhcyBiZWVuIHJlbW92ZWQuIFNldCBXZWJHTFJlbmRlcmVyLm91dHB1dEVuY29kaW5nIGluc3RlYWQuJyk7XG5cdFx0XHRcdHRoaXMub3V0cHV0RW5jb2RpbmcgPSB2YWx1ZSA9PT0gdHJ1ZSA/IHNSR0JFbmNvZGluZyA6IExpbmVhckVuY29kaW5nO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dG9uZU1hcHBpbmdXaGl0ZVBvaW50OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAudG9uZU1hcHBpbmdXaGl0ZVBvaW50IGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdFx0XHRcdHJldHVybiAxLjA7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnRvbmVNYXBwaW5nV2hpdGVQb2ludCBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYkdMU2hhZG93TWFwLnByb3RvdHlwZSwge1xuXHRcdGN1bGxGYWNlOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLmN1bGxGYWNlIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKVxuXHRcdFx0LyogY3VsbEZhY2UgKi9cblx0XHRcdHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLmN1bGxGYWNlIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW5kZXJSZXZlcnNlU2lkZWQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAucmVuZGVyUmV2ZXJzZVNpZGVkIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcC5yZW5kZXJSZXZlcnNlU2lkZWQgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IE1hdGVyaWFsLnNoYWRvd1NpZGUgaW5zdGVhZC4nKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbmRlclNpbmdsZVNpZGVkOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLnJlbmRlclNpbmdsZVNpZGVkIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcC5yZW5kZXJTaW5nbGVTaWRlZCBoYXMgYmVlbiByZW1vdmVkLiBTZXQgTWF0ZXJpYWwuc2hhZG93U2lkZSBpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdGZ1bmN0aW9uIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSBpcyBub3cgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KCBzaXplLCBvcHRpb25zICkuJyk7XG5cdFx0cmV0dXJuIG5ldyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQod2lkdGgsIG9wdGlvbnMpO1xuXHR9IC8vXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XG5cdFx0d3JhcFM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS53cmFwUyA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0d3JhcFQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBUO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS53cmFwVCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWFnRmlsdGVyOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcjtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWFnRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5tYWdGaWx0ZXIuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG1pbkZpbHRlcjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5taW5GaWx0ZXI7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicpO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmlzb3Ryb3B5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUuYW5pc290cm9weTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nKTtcblx0XHRcdFx0dGhpcy50ZXh0dXJlLmFuaXNvdHJvcHkgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9mZnNldDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5vZmZzZXQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm9mZnNldCBpcyBub3cgLnRleHR1cmUub2Zmc2V0LicpO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUub2Zmc2V0ID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXBlYXQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUucmVwZWF0O1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nKTtcblx0XHRcdFx0dGhpcy50ZXh0dXJlLnJlcGVhdCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zm9ybWF0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmZvcm1hdDtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5mb3JtYXQgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHR5cGU6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS50eXBlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC50eXBlIGlzIG5vdyAudGV4dHVyZS50eXBlLicpO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUudHlwZSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2VuZXJhdGVNaXBtYXBzOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pOyAvL1xuXG5cdEF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGZpbGUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkF1ZGlvOiAubG9hZCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQXVkaW9Mb2FkZXIgaW5zdGVhZC4nKTtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0Y29uc3QgYXVkaW9Mb2FkZXIgPSBuZXcgQXVkaW9Mb2FkZXIoKTtcblx0XHRhdWRpb0xvYWRlci5sb2FkKGZpbGUsIGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdHNjb3BlLnNldEJ1ZmZlcihidWZmZXIpO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEF1ZGlvQW5hbHlzZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BdWRpb0FuYWx5c2VyOiAuZ2V0RGF0YSgpIGlzIG5vdyAuZ2V0RnJlcXVlbmN5RGF0YSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcblx0fTsgLy9cblxuXG5cdEN1YmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNjZW5lKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5DdWJlQ2FtZXJhOiAudXBkYXRlQ3ViZU1hcCgpIGlzIG5vdyAudXBkYXRlKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKHJlbmRlcmVyLCBzY2VuZSk7XG5cdH07XG5cblx0Q3ViZUNhbWVyYS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQ3ViZUNhbWVyYTogLmNsZWFyKCkgaXMgbm93IC5yZW5kZXJUYXJnZXQuY2xlYXIoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQuY2xlYXIocmVuZGVyZXIsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCk7XG5cdH07XG5cblx0SW1hZ2VVdGlscy5jcm9zc09yaWdpbiA9IHVuZGVmaW5lZDtcblxuXHRJbWFnZVV0aWxzLmxvYWRUZXh0dXJlID0gZnVuY3Rpb24gKHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5UZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nKTtcblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblx0XHRjb25zdCB0ZXh0dXJlID0gbG9hZGVyLmxvYWQodXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvcik7XG5cdFx0aWYgKG1hcHBpbmcpIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH07XG5cblx0SW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUgPSBmdW5jdGlvbiAodXJscywgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicpO1xuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBDdWJlVGV4dHVyZUxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblx0XHRjb25zdCB0ZXh0dXJlID0gbG9hZGVyLmxvYWQodXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IpO1xuXHRcdGlmIChtYXBwaW5nKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9O1xuXG5cdEltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nKTtcblx0fTtcblxuXHRJbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nKTtcblx0fTsgLy9cblxuXG5cdGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIHJlbW92ZWQnKTtcblx0fSAvL1xuXG5cdGZ1bmN0aW9uIEpTT05Mb2FkZXIoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuSlNPTkxvYWRlciBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9IC8vXG5cblx0Y29uc3QgU2NlbmVVdGlscyA9IHtcblx0XHRjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoKVxuXHRcdC8qIGdlb21ldHJ5LCBtYXRlcmlhbHMgKi9cblx0XHR7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5TY2VuZVV0aWxzIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qc20vdXRpbHMvU2NlbmVVdGlscy5qcycpO1xuXHRcdH0sXG5cdFx0ZGV0YWNoOiBmdW5jdGlvbiAoKVxuXHRcdC8qIGNoaWxkLCBwYXJlbnQsIHNjZW5lICovXG5cdFx0e1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuU2NlbmVVdGlscyBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanNtL3V0aWxzL1NjZW5lVXRpbHMuanMnKTtcblx0XHR9LFxuXHRcdGF0dGFjaDogZnVuY3Rpb24gKClcblx0XHQvKiBjaGlsZCwgc2NlbmUsIHBhcmVudCAqL1xuXHRcdHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlNjZW5lVXRpbHMgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzbS91dGlscy9TY2VuZVV0aWxzLmpzJyk7XG5cdFx0fVxuXHR9OyAvL1xuXG5cdGZ1bmN0aW9uIExlbnNGbGFyZSgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5MZW5zRmxhcmUgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzbS9vYmplY3RzL0xlbnNmbGFyZS5qcycpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblx0XHRfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3JlZ2lzdGVyJywge1xuXHRcdFx0ZGV0YWlsOiB7XG5cdFx0XHRcdHJldmlzaW9uOiBSRVZJU0lPTlxuXHRcdFx0fVxuXHRcdH0pKTtcblx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cblx0fVxuXG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdGlmICh3aW5kb3cuX19USFJFRV9fKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1dBUk5JTkc6IE11bHRpcGxlIGluc3RhbmNlcyBvZiBUaHJlZS5qcyBiZWluZyBpbXBvcnRlZC4nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93Ll9fVEhSRUVfXyA9IFJFVklTSU9OO1xuXHRcdH1cblx0fVxuXG5cdGV4cG9ydHMuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nID0gQUNFU0ZpbG1pY1RvbmVNYXBwaW5nO1xuXHRleHBvcnRzLkFkZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG5cdGV4cG9ydHMuQWRkT3BlcmF0aW9uID0gQWRkT3BlcmF0aW9uO1xuXHRleHBvcnRzLkFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlID0gQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGU7XG5cdGV4cG9ydHMuQWRkaXRpdmVCbGVuZGluZyA9IEFkZGl0aXZlQmxlbmRpbmc7XG5cdGV4cG9ydHMuQWxwaGFGb3JtYXQgPSBBbHBoYUZvcm1hdDtcblx0ZXhwb3J0cy5BbHdheXNEZXB0aCA9IEFsd2F5c0RlcHRoO1xuXHRleHBvcnRzLkFsd2F5c1N0ZW5jaWxGdW5jID0gQWx3YXlzU3RlbmNpbEZ1bmM7XG5cdGV4cG9ydHMuQW1iaWVudExpZ2h0ID0gQW1iaWVudExpZ2h0O1xuXHRleHBvcnRzLkFtYmllbnRMaWdodFByb2JlID0gQW1iaWVudExpZ2h0UHJvYmU7XG5cdGV4cG9ydHMuQW5pbWF0aW9uQ2xpcCA9IEFuaW1hdGlvbkNsaXA7XG5cdGV4cG9ydHMuQW5pbWF0aW9uTG9hZGVyID0gQW5pbWF0aW9uTG9hZGVyO1xuXHRleHBvcnRzLkFuaW1hdGlvbk1peGVyID0gQW5pbWF0aW9uTWl4ZXI7XG5cdGV4cG9ydHMuQW5pbWF0aW9uT2JqZWN0R3JvdXAgPSBBbmltYXRpb25PYmplY3RHcm91cDtcblx0ZXhwb3J0cy5BbmltYXRpb25VdGlscyA9IEFuaW1hdGlvblV0aWxzO1xuXHRleHBvcnRzLkFyY0N1cnZlID0gQXJjQ3VydmU7XG5cdGV4cG9ydHMuQXJyYXlDYW1lcmEgPSBBcnJheUNhbWVyYTtcblx0ZXhwb3J0cy5BcnJvd0hlbHBlciA9IEFycm93SGVscGVyO1xuXHRleHBvcnRzLkF1ZGlvID0gQXVkaW87XG5cdGV4cG9ydHMuQXVkaW9BbmFseXNlciA9IEF1ZGlvQW5hbHlzZXI7XG5cdGV4cG9ydHMuQXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0O1xuXHRleHBvcnRzLkF1ZGlvTGlzdGVuZXIgPSBBdWRpb0xpc3RlbmVyO1xuXHRleHBvcnRzLkF1ZGlvTG9hZGVyID0gQXVkaW9Mb2FkZXI7XG5cdGV4cG9ydHMuQXhlc0hlbHBlciA9IEF4ZXNIZWxwZXI7XG5cdGV4cG9ydHMuQXhpc0hlbHBlciA9IEF4aXNIZWxwZXI7XG5cdGV4cG9ydHMuQmFja1NpZGUgPSBCYWNrU2lkZTtcblx0ZXhwb3J0cy5CYXNpY0RlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nO1xuXHRleHBvcnRzLkJhc2ljU2hhZG93TWFwID0gQmFzaWNTaGFkb3dNYXA7XG5cdGV4cG9ydHMuQmluYXJ5VGV4dHVyZUxvYWRlciA9IEJpbmFyeVRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuQm9uZSA9IEJvbmU7XG5cdGV4cG9ydHMuQm9vbGVhbktleWZyYW1lVHJhY2sgPSBCb29sZWFuS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5Cb3VuZGluZ0JveEhlbHBlciA9IEJvdW5kaW5nQm94SGVscGVyO1xuXHRleHBvcnRzLkJveDIgPSBCb3gyO1xuXHRleHBvcnRzLkJveDMgPSBCb3gzO1xuXHRleHBvcnRzLkJveDNIZWxwZXIgPSBCb3gzSGVscGVyO1xuXHRleHBvcnRzLkJveEJ1ZmZlckdlb21ldHJ5ID0gQm94R2VvbWV0cnk7XG5cdGV4cG9ydHMuQm94R2VvbWV0cnkgPSBCb3hHZW9tZXRyeTtcblx0ZXhwb3J0cy5Cb3hIZWxwZXIgPSBCb3hIZWxwZXI7XG5cdGV4cG9ydHMuQnVmZmVyQXR0cmlidXRlID0gQnVmZmVyQXR0cmlidXRlO1xuXHRleHBvcnRzLkJ1ZmZlckdlb21ldHJ5ID0gQnVmZmVyR2VvbWV0cnk7XG5cdGV4cG9ydHMuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBCdWZmZXJHZW9tZXRyeUxvYWRlcjtcblx0ZXhwb3J0cy5CeXRlVHlwZSA9IEJ5dGVUeXBlO1xuXHRleHBvcnRzLkNhY2hlID0gQ2FjaGU7XG5cdGV4cG9ydHMuQ2FtZXJhID0gQ2FtZXJhO1xuXHRleHBvcnRzLkNhbWVyYUhlbHBlciA9IENhbWVyYUhlbHBlcjtcblx0ZXhwb3J0cy5DYW52YXNSZW5kZXJlciA9IENhbnZhc1JlbmRlcmVyO1xuXHRleHBvcnRzLkNhbnZhc1RleHR1cmUgPSBDYW52YXNUZXh0dXJlO1xuXHRleHBvcnRzLkNhdG11bGxSb21DdXJ2ZTMgPSBDYXRtdWxsUm9tQ3VydmUzO1xuXHRleHBvcnRzLkNpbmVvblRvbmVNYXBwaW5nID0gQ2luZW9uVG9uZU1hcHBpbmc7XG5cdGV4cG9ydHMuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBDaXJjbGVHZW9tZXRyeTtcblx0ZXhwb3J0cy5DaXJjbGVHZW9tZXRyeSA9IENpcmNsZUdlb21ldHJ5O1xuXHRleHBvcnRzLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRleHBvcnRzLkNsb2NrID0gQ2xvY2s7XG5cdGV4cG9ydHMuQ29sb3IgPSBDb2xvcjtcblx0ZXhwb3J0cy5Db2xvcktleWZyYW1lVHJhY2sgPSBDb2xvcktleWZyYW1lVHJhY2s7XG5cdGV4cG9ydHMuQ29tcHJlc3NlZFRleHR1cmUgPSBDb21wcmVzc2VkVGV4dHVyZTtcblx0ZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IENvbXByZXNzZWRUZXh0dXJlTG9hZGVyO1xuXHRleHBvcnRzLkNvbmVCdWZmZXJHZW9tZXRyeSA9IENvbmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5Db25lR2VvbWV0cnkgPSBDb25lR2VvbWV0cnk7XG5cdGV4cG9ydHMuQ3ViZUNhbWVyYSA9IEN1YmVDYW1lcmE7XG5cdGV4cG9ydHMuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXHRleHBvcnRzLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcblx0ZXhwb3J0cy5DdWJlVGV4dHVyZSA9IEN1YmVUZXh0dXJlO1xuXHRleHBvcnRzLkN1YmVUZXh0dXJlTG9hZGVyID0gQ3ViZVRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZztcblx0ZXhwb3J0cy5DdWJlVVZSZWZyYWN0aW9uTWFwcGluZyA9IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nO1xuXHRleHBvcnRzLkN1YmljQmV6aWVyQ3VydmUgPSBDdWJpY0JlemllckN1cnZlO1xuXHRleHBvcnRzLkN1YmljQmV6aWVyQ3VydmUzID0gQ3ViaWNCZXppZXJDdXJ2ZTM7XG5cdGV4cG9ydHMuQ3ViaWNJbnRlcnBvbGFudCA9IEN1YmljSW50ZXJwb2xhbnQ7XG5cdGV4cG9ydHMuQ3VsbEZhY2VCYWNrID0gQ3VsbEZhY2VCYWNrO1xuXHRleHBvcnRzLkN1bGxGYWNlRnJvbnQgPSBDdWxsRmFjZUZyb250O1xuXHRleHBvcnRzLkN1bGxGYWNlRnJvbnRCYWNrID0gQ3VsbEZhY2VGcm9udEJhY2s7XG5cdGV4cG9ydHMuQ3VsbEZhY2VOb25lID0gQ3VsbEZhY2VOb25lO1xuXHRleHBvcnRzLkN1cnZlID0gQ3VydmU7XG5cdGV4cG9ydHMuQ3VydmVQYXRoID0gQ3VydmVQYXRoO1xuXHRleHBvcnRzLkN1c3RvbUJsZW5kaW5nID0gQ3VzdG9tQmxlbmRpbmc7XG5cdGV4cG9ydHMuQ3VzdG9tVG9uZU1hcHBpbmcgPSBDdXN0b21Ub25lTWFwcGluZztcblx0ZXhwb3J0cy5DeWxpbmRlckJ1ZmZlckdlb21ldHJ5ID0gQ3lsaW5kZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5DeWxpbmRlckdlb21ldHJ5ID0gQ3lsaW5kZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5DeWxpbmRyaWNhbCA9IEN5bGluZHJpY2FsO1xuXHRleHBvcnRzLkRhdGFUZXh0dXJlID0gRGF0YVRleHR1cmU7XG5cdGV4cG9ydHMuRGF0YVRleHR1cmUyREFycmF5ID0gRGF0YVRleHR1cmUyREFycmF5O1xuXHRleHBvcnRzLkRhdGFUZXh0dXJlM0QgPSBEYXRhVGV4dHVyZTNEO1xuXHRleHBvcnRzLkRhdGFUZXh0dXJlTG9hZGVyID0gRGF0YVRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuRGF0YVV0aWxzID0gRGF0YVV0aWxzO1xuXHRleHBvcnRzLkRlY3JlbWVudFN0ZW5jaWxPcCA9IERlY3JlbWVudFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5EZWNyZW1lbnRXcmFwU3RlbmNpbE9wID0gRGVjcmVtZW50V3JhcFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cdGV4cG9ydHMuRGVwdGhGb3JtYXQgPSBEZXB0aEZvcm1hdDtcblx0ZXhwb3J0cy5EZXB0aFN0ZW5jaWxGb3JtYXQgPSBEZXB0aFN0ZW5jaWxGb3JtYXQ7XG5cdGV4cG9ydHMuRGVwdGhUZXh0dXJlID0gRGVwdGhUZXh0dXJlO1xuXHRleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHQgPSBEaXJlY3Rpb25hbExpZ2h0O1xuXHRleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBEaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xuXHRleHBvcnRzLkRpc2NyZXRlSW50ZXJwb2xhbnQgPSBEaXNjcmV0ZUludGVycG9sYW50O1xuXHRleHBvcnRzLkRvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XG5cdGV4cG9ydHMuRG9kZWNhaGVkcm9uR2VvbWV0cnkgPSBEb2RlY2FoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5Eb3VibGVTaWRlID0gRG91YmxlU2lkZTtcblx0ZXhwb3J0cy5Ec3RBbHBoYUZhY3RvciA9IERzdEFscGhhRmFjdG9yO1xuXHRleHBvcnRzLkRzdENvbG9yRmFjdG9yID0gRHN0Q29sb3JGYWN0b3I7XG5cdGV4cG9ydHMuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9IER5bmFtaWNCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuRHluYW1pY0NvcHlVc2FnZSA9IER5bmFtaWNDb3B5VXNhZ2U7XG5cdGV4cG9ydHMuRHluYW1pY0RyYXdVc2FnZSA9IER5bmFtaWNEcmF3VXNhZ2U7XG5cdGV4cG9ydHMuRHluYW1pY1JlYWRVc2FnZSA9IER5bmFtaWNSZWFkVXNhZ2U7XG5cdGV4cG9ydHMuRWRnZXNHZW9tZXRyeSA9IEVkZ2VzR2VvbWV0cnk7XG5cdGV4cG9ydHMuRWRnZXNIZWxwZXIgPSBFZGdlc0hlbHBlcjtcblx0ZXhwb3J0cy5FbGxpcHNlQ3VydmUgPSBFbGxpcHNlQ3VydmU7XG5cdGV4cG9ydHMuRXF1YWxEZXB0aCA9IEVxdWFsRGVwdGg7XG5cdGV4cG9ydHMuRXF1YWxTdGVuY2lsRnVuYyA9IEVxdWFsU3RlbmNpbEZ1bmM7XG5cdGV4cG9ydHMuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcblx0ZXhwb3J0cy5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nO1xuXHRleHBvcnRzLkV1bGVyID0gRXVsZXI7XG5cdGV4cG9ydHMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xuXHRleHBvcnRzLkV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSA9IEV4dHJ1ZGVHZW9tZXRyeTtcblx0ZXhwb3J0cy5FeHRydWRlR2VvbWV0cnkgPSBFeHRydWRlR2VvbWV0cnk7XG5cdGV4cG9ydHMuRmFjZUNvbG9ycyA9IEZhY2VDb2xvcnM7XG5cdGV4cG9ydHMuRmlsZUxvYWRlciA9IEZpbGVMb2FkZXI7XG5cdGV4cG9ydHMuRmxhdFNoYWRpbmcgPSBGbGF0U2hhZGluZztcblx0ZXhwb3J0cy5GbG9hdDE2QnVmZmVyQXR0cmlidXRlID0gRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdDMyQXR0cmlidXRlID0gRmxvYXQzMkF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdDMyQnVmZmVyQXR0cmlidXRlID0gRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdDY0QXR0cmlidXRlID0gRmxvYXQ2NEF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdDY0QnVmZmVyQXR0cmlidXRlID0gRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdFR5cGUgPSBGbG9hdFR5cGU7XG5cdGV4cG9ydHMuRm9nID0gRm9nO1xuXHRleHBvcnRzLkZvZ0V4cDIgPSBGb2dFeHAyO1xuXHRleHBvcnRzLkZvbnQgPSBGb250O1xuXHRleHBvcnRzLkZvbnRMb2FkZXIgPSBGb250TG9hZGVyO1xuXHRleHBvcnRzLkZyb250U2lkZSA9IEZyb250U2lkZTtcblx0ZXhwb3J0cy5GcnVzdHVtID0gRnJ1c3R1bTtcblx0ZXhwb3J0cy5HTEJ1ZmZlckF0dHJpYnV0ZSA9IEdMQnVmZmVyQXR0cmlidXRlO1xuXHRleHBvcnRzLkdMU0wxID0gR0xTTDE7XG5cdGV4cG9ydHMuR0xTTDMgPSBHTFNMMztcblx0ZXhwb3J0cy5HYW1tYUVuY29kaW5nID0gR2FtbWFFbmNvZGluZztcblx0ZXhwb3J0cy5HcmVhdGVyRGVwdGggPSBHcmVhdGVyRGVwdGg7XG5cdGV4cG9ydHMuR3JlYXRlckVxdWFsRGVwdGggPSBHcmVhdGVyRXF1YWxEZXB0aDtcblx0ZXhwb3J0cy5HcmVhdGVyRXF1YWxTdGVuY2lsRnVuYyA9IEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jO1xuXHRleHBvcnRzLkdyZWF0ZXJTdGVuY2lsRnVuYyA9IEdyZWF0ZXJTdGVuY2lsRnVuYztcblx0ZXhwb3J0cy5HcmlkSGVscGVyID0gR3JpZEhlbHBlcjtcblx0ZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xuXHRleHBvcnRzLkhhbGZGbG9hdFR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuXHRleHBvcnRzLkhlbWlzcGhlcmVMaWdodCA9IEhlbWlzcGhlcmVMaWdodDtcblx0ZXhwb3J0cy5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBIZW1pc3BoZXJlTGlnaHRIZWxwZXI7XG5cdGV4cG9ydHMuSGVtaXNwaGVyZUxpZ2h0UHJvYmUgPSBIZW1pc3BoZXJlTGlnaHRQcm9iZTtcblx0ZXhwb3J0cy5JY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5JY29zYWhlZHJvbkdlb21ldHJ5ID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5JbWFnZUJpdG1hcExvYWRlciA9IEltYWdlQml0bWFwTG9hZGVyO1xuXHRleHBvcnRzLkltYWdlTG9hZGVyID0gSW1hZ2VMb2FkZXI7XG5cdGV4cG9ydHMuSW1hZ2VVdGlscyA9IEltYWdlVXRpbHM7XG5cdGV4cG9ydHMuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xuXHRleHBvcnRzLkluY3JlbWVudFN0ZW5jaWxPcCA9IEluY3JlbWVudFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5JbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gSW5jcmVtZW50V3JhcFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xuXHRleHBvcnRzLkluc3RhbmNlZE1lc2ggPSBJbnN0YW5jZWRNZXNoO1xuXHRleHBvcnRzLkludDE2QXR0cmlidXRlID0gSW50MTZBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50MTZCdWZmZXJBdHRyaWJ1dGUgPSBJbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5JbnQzMkF0dHJpYnV0ZSA9IEludDMyQXR0cmlidXRlO1xuXHRleHBvcnRzLkludDMyQnVmZmVyQXR0cmlidXRlID0gSW50MzJCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50OEF0dHJpYnV0ZSA9IEludDhBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50OEJ1ZmZlckF0dHJpYnV0ZSA9IEludDhCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50VHlwZSA9IEludFR5cGU7XG5cdGV4cG9ydHMuSW50ZXJsZWF2ZWRCdWZmZXIgPSBJbnRlcmxlYXZlZEJ1ZmZlcjtcblx0ZXhwb3J0cy5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlO1xuXHRleHBvcnRzLkludGVycG9sYW50ID0gSW50ZXJwb2xhbnQ7XG5cdGV4cG9ydHMuSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IEludGVycG9sYXRlRGlzY3JldGU7XG5cdGV4cG9ydHMuSW50ZXJwb2xhdGVMaW5lYXIgPSBJbnRlcnBvbGF0ZUxpbmVhcjtcblx0ZXhwb3J0cy5JbnRlcnBvbGF0ZVNtb290aCA9IEludGVycG9sYXRlU21vb3RoO1xuXHRleHBvcnRzLkludmVydFN0ZW5jaWxPcCA9IEludmVydFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5KU09OTG9hZGVyID0gSlNPTkxvYWRlcjtcblx0ZXhwb3J0cy5LZWVwU3RlbmNpbE9wID0gS2VlcFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5LZXlmcmFtZVRyYWNrID0gS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5MT0QgPSBMT0Q7XG5cdGV4cG9ydHMuTGF0aGVCdWZmZXJHZW9tZXRyeSA9IExhdGhlR2VvbWV0cnk7XG5cdGV4cG9ydHMuTGF0aGVHZW9tZXRyeSA9IExhdGhlR2VvbWV0cnk7XG5cdGV4cG9ydHMuTGF5ZXJzID0gTGF5ZXJzO1xuXHRleHBvcnRzLkxlbnNGbGFyZSA9IExlbnNGbGFyZTtcblx0ZXhwb3J0cy5MZXNzRGVwdGggPSBMZXNzRGVwdGg7XG5cdGV4cG9ydHMuTGVzc0VxdWFsRGVwdGggPSBMZXNzRXF1YWxEZXB0aDtcblx0ZXhwb3J0cy5MZXNzRXF1YWxTdGVuY2lsRnVuYyA9IExlc3NFcXVhbFN0ZW5jaWxGdW5jO1xuXHRleHBvcnRzLkxlc3NTdGVuY2lsRnVuYyA9IExlc3NTdGVuY2lsRnVuYztcblx0ZXhwb3J0cy5MaWdodCA9IExpZ2h0O1xuXHRleHBvcnRzLkxpZ2h0UHJvYmUgPSBMaWdodFByb2JlO1xuXHRleHBvcnRzLkxpbmUgPSBMaW5lO1xuXHRleHBvcnRzLkxpbmUzID0gTGluZTM7XG5cdGV4cG9ydHMuTGluZUJhc2ljTWF0ZXJpYWwgPSBMaW5lQmFzaWNNYXRlcmlhbDtcblx0ZXhwb3J0cy5MaW5lQ3VydmUgPSBMaW5lQ3VydmU7XG5cdGV4cG9ydHMuTGluZUN1cnZlMyA9IExpbmVDdXJ2ZTM7XG5cdGV4cG9ydHMuTGluZURhc2hlZE1hdGVyaWFsID0gTGluZURhc2hlZE1hdGVyaWFsO1xuXHRleHBvcnRzLkxpbmVMb29wID0gTGluZUxvb3A7XG5cdGV4cG9ydHMuTGluZVBpZWNlcyA9IExpbmVQaWVjZXM7XG5cdGV4cG9ydHMuTGluZVNlZ21lbnRzID0gTGluZVNlZ21lbnRzO1xuXHRleHBvcnRzLkxpbmVTdHJpcCA9IExpbmVTdHJpcDtcblx0ZXhwb3J0cy5MaW5lYXJFbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xuXHRleHBvcnRzLkxpbmVhckZpbHRlciA9IExpbmVhckZpbHRlcjtcblx0ZXhwb3J0cy5MaW5lYXJJbnRlcnBvbGFudCA9IExpbmVhckludGVycG9sYW50O1xuXHRleHBvcnRzLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblx0ZXhwb3J0cy5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcjtcblx0ZXhwb3J0cy5MaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgPSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XG5cdGV4cG9ydHMuTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXI7XG5cdGV4cG9ydHMuTGluZWFyVG9uZU1hcHBpbmcgPSBMaW5lYXJUb25lTWFwcGluZztcblx0ZXhwb3J0cy5Mb2FkZXIgPSBMb2FkZXI7XG5cdGV4cG9ydHMuTG9hZGVyVXRpbHMgPSBMb2FkZXJVdGlscztcblx0ZXhwb3J0cy5Mb2FkaW5nTWFuYWdlciA9IExvYWRpbmdNYW5hZ2VyO1xuXHRleHBvcnRzLkxvZ0x1dkVuY29kaW5nID0gTG9nTHV2RW5jb2Rpbmc7XG5cdGV4cG9ydHMuTG9vcE9uY2UgPSBMb29wT25jZTtcblx0ZXhwb3J0cy5Mb29wUGluZ1BvbmcgPSBMb29wUGluZ1Bvbmc7XG5cdGV4cG9ydHMuTG9vcFJlcGVhdCA9IExvb3BSZXBlYXQ7XG5cdGV4cG9ydHMuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSBMdW1pbmFuY2VBbHBoYUZvcm1hdDtcblx0ZXhwb3J0cy5MdW1pbmFuY2VGb3JtYXQgPSBMdW1pbmFuY2VGb3JtYXQ7XG5cdGV4cG9ydHMuTU9VU0UgPSBNT1VTRTtcblx0ZXhwb3J0cy5NYXRlcmlhbCA9IE1hdGVyaWFsO1xuXHRleHBvcnRzLk1hdGVyaWFsTG9hZGVyID0gTWF0ZXJpYWxMb2FkZXI7XG5cdGV4cG9ydHMuTWF0aCA9IE1hdGhVdGlscztcblx0ZXhwb3J0cy5NYXRoVXRpbHMgPSBNYXRoVXRpbHM7XG5cdGV4cG9ydHMuTWF0cml4MyA9IE1hdHJpeDM7XG5cdGV4cG9ydHMuTWF0cml4NCA9IE1hdHJpeDQ7XG5cdGV4cG9ydHMuTWF4RXF1YXRpb24gPSBNYXhFcXVhdGlvbjtcblx0ZXhwb3J0cy5NZXNoID0gTWVzaDtcblx0ZXhwb3J0cy5NZXNoQmFzaWNNYXRlcmlhbCA9IE1lc2hCYXNpY01hdGVyaWFsO1xuXHRleHBvcnRzLk1lc2hEZXB0aE1hdGVyaWFsID0gTWVzaERlcHRoTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaERpc3RhbmNlTWF0ZXJpYWwgPSBNZXNoRGlzdGFuY2VNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoRmFjZU1hdGVyaWFsID0gTWVzaEZhY2VNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoTGFtYmVydE1hdGVyaWFsID0gTWVzaExhbWJlcnRNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoTWF0Y2FwTWF0ZXJpYWwgPSBNZXNoTWF0Y2FwTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaE5vcm1hbE1hdGVyaWFsID0gTWVzaE5vcm1hbE1hdGVyaWFsO1xuXHRleHBvcnRzLk1lc2hQaG9uZ01hdGVyaWFsID0gTWVzaFBob25nTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoU3RhbmRhcmRNYXRlcmlhbCA9IE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuXHRleHBvcnRzLk1lc2hUb29uTWF0ZXJpYWwgPSBNZXNoVG9vbk1hdGVyaWFsO1xuXHRleHBvcnRzLk1pbkVxdWF0aW9uID0gTWluRXF1YXRpb247XG5cdGV4cG9ydHMuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XG5cdGV4cG9ydHMuTWl4T3BlcmF0aW9uID0gTWl4T3BlcmF0aW9uO1xuXHRleHBvcnRzLk11bHRpTWF0ZXJpYWwgPSBNdWx0aU1hdGVyaWFsO1xuXHRleHBvcnRzLk11bHRpcGx5QmxlbmRpbmcgPSBNdWx0aXBseUJsZW5kaW5nO1xuXHRleHBvcnRzLk11bHRpcGx5T3BlcmF0aW9uID0gTXVsdGlwbHlPcGVyYXRpb247XG5cdGV4cG9ydHMuTmVhcmVzdEZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG5cdGV4cG9ydHMuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cdGV4cG9ydHMuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcjtcblx0ZXhwb3J0cy5OZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyID0gTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcjtcblx0ZXhwb3J0cy5OZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciA9IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyO1xuXHRleHBvcnRzLk5ldmVyRGVwdGggPSBOZXZlckRlcHRoO1xuXHRleHBvcnRzLk5ldmVyU3RlbmNpbEZ1bmMgPSBOZXZlclN0ZW5jaWxGdW5jO1xuXHRleHBvcnRzLk5vQmxlbmRpbmcgPSBOb0JsZW5kaW5nO1xuXHRleHBvcnRzLk5vQ29sb3JzID0gTm9Db2xvcnM7XG5cdGV4cG9ydHMuTm9Ub25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG5cdGV4cG9ydHMuTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlID0gTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlO1xuXHRleHBvcnRzLk5vcm1hbEJsZW5kaW5nID0gTm9ybWFsQmxlbmRpbmc7XG5cdGV4cG9ydHMuTm90RXF1YWxEZXB0aCA9IE5vdEVxdWFsRGVwdGg7XG5cdGV4cG9ydHMuTm90RXF1YWxTdGVuY2lsRnVuYyA9IE5vdEVxdWFsU3RlbmNpbEZ1bmM7XG5cdGV4cG9ydHMuTnVtYmVyS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG5cdGV4cG9ydHMuT2JqZWN0M0QgPSBPYmplY3QzRDtcblx0ZXhwb3J0cy5PYmplY3RMb2FkZXIgPSBPYmplY3RMb2FkZXI7XG5cdGV4cG9ydHMuT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSBPYmplY3RTcGFjZU5vcm1hbE1hcDtcblx0ZXhwb3J0cy5PY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBPY3RhaGVkcm9uR2VvbWV0cnk7XG5cdGV4cG9ydHMuT2N0YWhlZHJvbkdlb21ldHJ5ID0gT2N0YWhlZHJvbkdlb21ldHJ5O1xuXHRleHBvcnRzLk9uZUZhY3RvciA9IE9uZUZhY3Rvcjtcblx0ZXhwb3J0cy5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gT25lTWludXNEc3RBbHBoYUZhY3Rvcjtcblx0ZXhwb3J0cy5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gT25lTWludXNEc3RDb2xvckZhY3Rvcjtcblx0ZXhwb3J0cy5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gT25lTWludXNTcmNBbHBoYUZhY3Rvcjtcblx0ZXhwb3J0cy5PbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gT25lTWludXNTcmNDb2xvckZhY3Rvcjtcblx0ZXhwb3J0cy5PcnRob2dyYXBoaWNDYW1lcmEgPSBPcnRob2dyYXBoaWNDYW1lcmE7XG5cdGV4cG9ydHMuUENGU2hhZG93TWFwID0gUENGU2hhZG93TWFwO1xuXHRleHBvcnRzLlBDRlNvZnRTaGFkb3dNYXAgPSBQQ0ZTb2Z0U2hhZG93TWFwO1xuXHRleHBvcnRzLlBNUkVNR2VuZXJhdG9yID0gUE1SRU1HZW5lcmF0b3I7XG5cdGV4cG9ydHMuUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5ID0gUGFyYW1ldHJpY0dlb21ldHJ5O1xuXHRleHBvcnRzLlBhcmFtZXRyaWNHZW9tZXRyeSA9IFBhcmFtZXRyaWNHZW9tZXRyeTtcblx0ZXhwb3J0cy5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xuXHRleHBvcnRzLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IFBhcnRpY2xlQmFzaWNNYXRlcmlhbDtcblx0ZXhwb3J0cy5QYXJ0aWNsZVN5c3RlbSA9IFBhcnRpY2xlU3lzdGVtO1xuXHRleHBvcnRzLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgPSBQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsO1xuXHRleHBvcnRzLlBhdGggPSBQYXRoO1xuXHRleHBvcnRzLlBlcnNwZWN0aXZlQ2FtZXJhID0gUGVyc3BlY3RpdmVDYW1lcmE7XG5cdGV4cG9ydHMuUGxhbmUgPSBQbGFuZTtcblx0ZXhwb3J0cy5QbGFuZUJ1ZmZlckdlb21ldHJ5ID0gUGxhbmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5QbGFuZUdlb21ldHJ5ID0gUGxhbmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5QbGFuZUhlbHBlciA9IFBsYW5lSGVscGVyO1xuXHRleHBvcnRzLlBvaW50Q2xvdWQgPSBQb2ludENsb3VkO1xuXHRleHBvcnRzLlBvaW50Q2xvdWRNYXRlcmlhbCA9IFBvaW50Q2xvdWRNYXRlcmlhbDtcblx0ZXhwb3J0cy5Qb2ludExpZ2h0ID0gUG9pbnRMaWdodDtcblx0ZXhwb3J0cy5Qb2ludExpZ2h0SGVscGVyID0gUG9pbnRMaWdodEhlbHBlcjtcblx0ZXhwb3J0cy5Qb2ludHMgPSBQb2ludHM7XG5cdGV4cG9ydHMuUG9pbnRzTWF0ZXJpYWwgPSBQb2ludHNNYXRlcmlhbDtcblx0ZXhwb3J0cy5Qb2xhckdyaWRIZWxwZXIgPSBQb2xhckdyaWRIZWxwZXI7XG5cdGV4cG9ydHMuUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gUG9seWhlZHJvbkdlb21ldHJ5O1xuXHRleHBvcnRzLlBvbHloZWRyb25HZW9tZXRyeSA9IFBvbHloZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5Qb3NpdGlvbmFsQXVkaW8gPSBQb3NpdGlvbmFsQXVkaW87XG5cdGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nID0gUHJvcGVydHlCaW5kaW5nO1xuXHRleHBvcnRzLlByb3BlcnR5TWl4ZXIgPSBQcm9wZXJ0eU1peGVyO1xuXHRleHBvcnRzLlF1YWRyYXRpY0JlemllckN1cnZlID0gUXVhZHJhdGljQmV6aWVyQ3VydmU7XG5cdGV4cG9ydHMuUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gUXVhZHJhdGljQmV6aWVyQ3VydmUzO1xuXHRleHBvcnRzLlF1YXRlcm5pb24gPSBRdWF0ZXJuaW9uO1xuXHRleHBvcnRzLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cdGV4cG9ydHMuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50ID0gUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50O1xuXHRleHBvcnRzLlJFVklTSU9OID0gUkVWSVNJT047XG5cdGV4cG9ydHMuUkdCQURlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmc7XG5cdGV4cG9ydHMuUkdCQUZvcm1hdCA9IFJHQkFGb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQUludGVnZXJGb3JtYXQgPSBSR0JBSW50ZWdlckZvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfMTB4MTBfRm9ybWF0ID0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfMTB4NV9Gb3JtYXQgPSBSR0JBX0FTVENfMTB4NV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzEweDZfRm9ybWF0ID0gUkdCQV9BU1RDXzEweDZfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ18xMHg4X0Zvcm1hdCA9IFJHQkFfQVNUQ18xMHg4X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfMTJ4MTBfRm9ybWF0ID0gUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfMTJ4MTJfRm9ybWF0ID0gUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfNHg0X0Zvcm1hdCA9IFJHQkFfQVNUQ180eDRfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ181eDRfRm9ybWF0ID0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSBSR0JBX0FTVENfNXg1X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfNng1X0Zvcm1hdCA9IFJHQkFfQVNUQ182eDVfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ182eDZfRm9ybWF0ID0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSBSR0JBX0FTVENfOHg1X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfOHg2X0Zvcm1hdCA9IFJHQkFfQVNUQ184eDZfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ184eDhfRm9ybWF0ID0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9CUFRDX0Zvcm1hdCA9IFJHQkFfQlBUQ19Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9FVEMyX0VBQ19Gb3JtYXQgPSBSR0JBX0VUQzJfRUFDX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSBSR0JBX1MzVENfRFhUM19Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkRFbmNvZGluZyA9IFJHQkRFbmNvZGluZztcblx0ZXhwb3J0cy5SR0JFRW5jb2RpbmcgPSBSR0JFRW5jb2Rpbmc7XG5cdGV4cG9ydHMuUkdCRUZvcm1hdCA9IFJHQkVGb3JtYXQ7XG5cdGV4cG9ydHMuUkdCRm9ybWF0ID0gUkdCRm9ybWF0O1xuXHRleHBvcnRzLlJHQkludGVnZXJGb3JtYXQgPSBSR0JJbnRlZ2VyRm9ybWF0O1xuXHRleHBvcnRzLlJHQk0xNkVuY29kaW5nID0gUkdCTTE2RW5jb2Rpbmc7XG5cdGV4cG9ydHMuUkdCTTdFbmNvZGluZyA9IFJHQk03RW5jb2Rpbmc7XG5cdGV4cG9ydHMuUkdCX0VUQzFfRm9ybWF0ID0gUkdCX0VUQzFfRm9ybWF0O1xuXHRleHBvcnRzLlJHQl9FVEMyX0Zvcm1hdCA9IFJHQl9FVEMyX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0O1xuXHRleHBvcnRzLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JfUzNUQ19EWFQxX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0Zvcm1hdCA9IFJHRm9ybWF0O1xuXHRleHBvcnRzLlJHSW50ZWdlckZvcm1hdCA9IFJHSW50ZWdlckZvcm1hdDtcblx0ZXhwb3J0cy5SYXdTaGFkZXJNYXRlcmlhbCA9IFJhd1NoYWRlck1hdGVyaWFsO1xuXHRleHBvcnRzLlJheSA9IFJheTtcblx0ZXhwb3J0cy5SYXljYXN0ZXIgPSBSYXljYXN0ZXI7XG5cdGV4cG9ydHMuUmVjdEFyZWFMaWdodCA9IFJlY3RBcmVhTGlnaHQ7XG5cdGV4cG9ydHMuUmVkRm9ybWF0ID0gUmVkRm9ybWF0O1xuXHRleHBvcnRzLlJlZEludGVnZXJGb3JtYXQgPSBSZWRJbnRlZ2VyRm9ybWF0O1xuXHRleHBvcnRzLlJlaW5oYXJkVG9uZU1hcHBpbmcgPSBSZWluaGFyZFRvbmVNYXBwaW5nO1xuXHRleHBvcnRzLlJlcGVhdFdyYXBwaW5nID0gUmVwZWF0V3JhcHBpbmc7XG5cdGV4cG9ydHMuUmVwbGFjZVN0ZW5jaWxPcCA9IFJlcGxhY2VTdGVuY2lsT3A7XG5cdGV4cG9ydHMuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbjtcblx0ZXhwb3J0cy5SaW5nQnVmZmVyR2VvbWV0cnkgPSBSaW5nR2VvbWV0cnk7XG5cdGV4cG9ydHMuUmluZ0dlb21ldHJ5ID0gUmluZ0dlb21ldHJ5O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0Zvcm1hdCA9IFNSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0Zvcm1hdDtcblx0ZXhwb3J0cy5TUkdCOF9BTFBIQThfQVNUQ18xMHg1X0Zvcm1hdCA9IFNSR0I4X0FMUEhBOF9BU1RDXzEweDVfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzEweDZfRm9ybWF0ID0gU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9Gb3JtYXQ7XG5cdGV4cG9ydHMuU1JHQjhfQUxQSEE4X0FTVENfMTB4OF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ18xMHg4X0Zvcm1hdDtcblx0ZXhwb3J0cy5TUkdCOF9BTFBIQThfQVNUQ18xMngxMF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ18xMngxMF9Gb3JtYXQ7XG5cdGV4cG9ydHMuU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTJfRm9ybWF0ID0gU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTJfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzR4NF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ180eDRfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzV4NF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ181eDRfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzV4NV9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ181eDVfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzZ4NV9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ182eDVfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzZ4Nl9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ182eDZfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzh4NV9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ184eDVfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzh4Nl9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ184eDZfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzh4OF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ184eDhfRm9ybWF0O1xuXHRleHBvcnRzLlNjZW5lID0gU2NlbmU7XG5cdGV4cG9ydHMuU2NlbmVVdGlscyA9IFNjZW5lVXRpbHM7XG5cdGV4cG9ydHMuU2hhZGVyQ2h1bmsgPSBTaGFkZXJDaHVuaztcblx0ZXhwb3J0cy5TaGFkZXJMaWIgPSBTaGFkZXJMaWI7XG5cdGV4cG9ydHMuU2hhZGVyTWF0ZXJpYWwgPSBTaGFkZXJNYXRlcmlhbDtcblx0ZXhwb3J0cy5TaGFkb3dNYXRlcmlhbCA9IFNoYWRvd01hdGVyaWFsO1xuXHRleHBvcnRzLlNoYXBlID0gU2hhcGU7XG5cdGV4cG9ydHMuU2hhcGVCdWZmZXJHZW9tZXRyeSA9IFNoYXBlR2VvbWV0cnk7XG5cdGV4cG9ydHMuU2hhcGVHZW9tZXRyeSA9IFNoYXBlR2VvbWV0cnk7XG5cdGV4cG9ydHMuU2hhcGVQYXRoID0gU2hhcGVQYXRoO1xuXHRleHBvcnRzLlNoYXBlVXRpbHMgPSBTaGFwZVV0aWxzO1xuXHRleHBvcnRzLlNob3J0VHlwZSA9IFNob3J0VHlwZTtcblx0ZXhwb3J0cy5Ta2VsZXRvbiA9IFNrZWxldG9uO1xuXHRleHBvcnRzLlNrZWxldG9uSGVscGVyID0gU2tlbGV0b25IZWxwZXI7XG5cdGV4cG9ydHMuU2tpbm5lZE1lc2ggPSBTa2lubmVkTWVzaDtcblx0ZXhwb3J0cy5TbW9vdGhTaGFkaW5nID0gU21vb3RoU2hhZGluZztcblx0ZXhwb3J0cy5TcGhlcmUgPSBTcGhlcmU7XG5cdGV4cG9ydHMuU3BoZXJlQnVmZmVyR2VvbWV0cnkgPSBTcGhlcmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5TcGhlcmVHZW9tZXRyeSA9IFNwaGVyZUdlb21ldHJ5O1xuXHRleHBvcnRzLlNwaGVyaWNhbCA9IFNwaGVyaWNhbDtcblx0ZXhwb3J0cy5TcGhlcmljYWxIYXJtb25pY3MzID0gU3BoZXJpY2FsSGFybW9uaWNzMztcblx0ZXhwb3J0cy5TcGxpbmVDdXJ2ZSA9IFNwbGluZUN1cnZlO1xuXHRleHBvcnRzLlNwb3RMaWdodCA9IFNwb3RMaWdodDtcblx0ZXhwb3J0cy5TcG90TGlnaHRIZWxwZXIgPSBTcG90TGlnaHRIZWxwZXI7XG5cdGV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xuXHRleHBvcnRzLlNwcml0ZU1hdGVyaWFsID0gU3ByaXRlTWF0ZXJpYWw7XG5cdGV4cG9ydHMuU3JjQWxwaGFGYWN0b3IgPSBTcmNBbHBoYUZhY3Rvcjtcblx0ZXhwb3J0cy5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gU3JjQWxwaGFTYXR1cmF0ZUZhY3Rvcjtcblx0ZXhwb3J0cy5TcmNDb2xvckZhY3RvciA9IFNyY0NvbG9yRmFjdG9yO1xuXHRleHBvcnRzLlN0YXRpY0NvcHlVc2FnZSA9IFN0YXRpY0NvcHlVc2FnZTtcblx0ZXhwb3J0cy5TdGF0aWNEcmF3VXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5cdGV4cG9ydHMuU3RhdGljUmVhZFVzYWdlID0gU3RhdGljUmVhZFVzYWdlO1xuXHRleHBvcnRzLlN0ZXJlb0NhbWVyYSA9IFN0ZXJlb0NhbWVyYTtcblx0ZXhwb3J0cy5TdHJlYW1Db3B5VXNhZ2UgPSBTdHJlYW1Db3B5VXNhZ2U7XG5cdGV4cG9ydHMuU3RyZWFtRHJhd1VzYWdlID0gU3RyZWFtRHJhd1VzYWdlO1xuXHRleHBvcnRzLlN0cmVhbVJlYWRVc2FnZSA9IFN0cmVhbVJlYWRVc2FnZTtcblx0ZXhwb3J0cy5TdHJpbmdLZXlmcmFtZVRyYWNrID0gU3RyaW5nS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5TdWJ0cmFjdEVxdWF0aW9uID0gU3VidHJhY3RFcXVhdGlvbjtcblx0ZXhwb3J0cy5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gU3VidHJhY3RpdmVCbGVuZGluZztcblx0ZXhwb3J0cy5UT1VDSCA9IFRPVUNIO1xuXHRleHBvcnRzLlRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0ZXhwb3J0cy5UZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5UZXRyYWhlZHJvbkdlb21ldHJ5ID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5UZXh0QnVmZmVyR2VvbWV0cnkgPSBUZXh0R2VvbWV0cnk7XG5cdGV4cG9ydHMuVGV4dEdlb21ldHJ5ID0gVGV4dEdlb21ldHJ5O1xuXHRleHBvcnRzLlRleHR1cmUgPSBUZXh0dXJlO1xuXHRleHBvcnRzLlRleHR1cmVMb2FkZXIgPSBUZXh0dXJlTG9hZGVyO1xuXHRleHBvcnRzLlRvcnVzQnVmZmVyR2VvbWV0cnkgPSBUb3J1c0dlb21ldHJ5O1xuXHRleHBvcnRzLlRvcnVzR2VvbWV0cnkgPSBUb3J1c0dlb21ldHJ5O1xuXHRleHBvcnRzLlRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5ID0gVG9ydXNLbm90R2VvbWV0cnk7XG5cdGV4cG9ydHMuVG9ydXNLbm90R2VvbWV0cnkgPSBUb3J1c0tub3RHZW9tZXRyeTtcblx0ZXhwb3J0cy5UcmlhbmdsZSA9IFRyaWFuZ2xlO1xuXHRleHBvcnRzLlRyaWFuZ2xlRmFuRHJhd01vZGUgPSBUcmlhbmdsZUZhbkRyYXdNb2RlO1xuXHRleHBvcnRzLlRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZTtcblx0ZXhwb3J0cy5UcmlhbmdsZXNEcmF3TW9kZSA9IFRyaWFuZ2xlc0RyYXdNb2RlO1xuXHRleHBvcnRzLlR1YmVCdWZmZXJHZW9tZXRyeSA9IFR1YmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5UdWJlR2VvbWV0cnkgPSBUdWJlR2VvbWV0cnk7XG5cdGV4cG9ydHMuVVZNYXBwaW5nID0gVVZNYXBwaW5nO1xuXHRleHBvcnRzLlVpbnQxNkF0dHJpYnV0ZSA9IFVpbnQxNkF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50MTZCdWZmZXJBdHRyaWJ1dGUgPSBVaW50MTZCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuVWludDMyQXR0cmlidXRlID0gVWludDMyQXR0cmlidXRlO1xuXHRleHBvcnRzLlVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50OEF0dHJpYnV0ZSA9IFVpbnQ4QXR0cmlidXRlO1xuXHRleHBvcnRzLlVpbnQ4QnVmZmVyQXR0cmlidXRlID0gVWludDhCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuVWludDhDbGFtcGVkQXR0cmlidXRlID0gVWludDhDbGFtcGVkQXR0cmlidXRlO1xuXHRleHBvcnRzLlVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5Vbmlmb3JtID0gVW5pZm9ybTtcblx0ZXhwb3J0cy5Vbmlmb3Jtc0xpYiA9IFVuaWZvcm1zTGliO1xuXHRleHBvcnRzLlVuaWZvcm1zVXRpbHMgPSBVbmlmb3Jtc1V0aWxzO1xuXHRleHBvcnRzLlVuc2lnbmVkQnl0ZVR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlO1xuXHRleHBvcnRzLlVuc2lnbmVkSW50MjQ4VHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcblx0ZXhwb3J0cy5VbnNpZ25lZEludFR5cGUgPSBVbnNpZ25lZEludFR5cGU7XG5cdGV4cG9ydHMuVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlO1xuXHRleHBvcnRzLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZTtcblx0ZXhwb3J0cy5VbnNpZ25lZFNob3J0NTY1VHlwZSA9IFVuc2lnbmVkU2hvcnQ1NjVUeXBlO1xuXHRleHBvcnRzLlVuc2lnbmVkU2hvcnRUeXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XG5cdGV4cG9ydHMuVlNNU2hhZG93TWFwID0gVlNNU2hhZG93TWFwO1xuXHRleHBvcnRzLlZlY3RvcjIgPSBWZWN0b3IyO1xuXHRleHBvcnRzLlZlY3RvcjMgPSBWZWN0b3IzO1xuXHRleHBvcnRzLlZlY3RvcjQgPSBWZWN0b3I0O1xuXHRleHBvcnRzLlZlY3RvcktleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuXHRleHBvcnRzLlZlcnRleCA9IFZlcnRleDtcblx0ZXhwb3J0cy5WZXJ0ZXhDb2xvcnMgPSBWZXJ0ZXhDb2xvcnM7XG5cdGV4cG9ydHMuVmlkZW9UZXh0dXJlID0gVmlkZW9UZXh0dXJlO1xuXHRleHBvcnRzLldlYkdMMVJlbmRlcmVyID0gV2ViR0wxUmVuZGVyZXI7XG5cdGV4cG9ydHMuV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID0gV2ViR0xDdWJlUmVuZGVyVGFyZ2V0O1xuXHRleHBvcnRzLldlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID0gV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHM7XG5cdGV4cG9ydHMuV2ViR0xNdWx0aXNhbXBsZVJlbmRlclRhcmdldCA9IFdlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQ7XG5cdGV4cG9ydHMuV2ViR0xSZW5kZXJUYXJnZXQgPSBXZWJHTFJlbmRlclRhcmdldDtcblx0ZXhwb3J0cy5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBXZWJHTFJlbmRlclRhcmdldEN1YmU7XG5cdGV4cG9ydHMuV2ViR0xSZW5kZXJlciA9IFdlYkdMUmVuZGVyZXI7XG5cdGV4cG9ydHMuV2ViR0xVdGlscyA9IFdlYkdMVXRpbHM7XG5cdGV4cG9ydHMuV2lyZWZyYW1lR2VvbWV0cnkgPSBXaXJlZnJhbWVHZW9tZXRyeTtcblx0ZXhwb3J0cy5XaXJlZnJhbWVIZWxwZXIgPSBXaXJlZnJhbWVIZWxwZXI7XG5cdGV4cG9ydHMuV3JhcEFyb3VuZEVuZGluZyA9IFdyYXBBcm91bmRFbmRpbmc7XG5cdGV4cG9ydHMuWEhSTG9hZGVyID0gWEhSTG9hZGVyO1xuXHRleHBvcnRzLlplcm9DdXJ2YXR1cmVFbmRpbmcgPSBaZXJvQ3VydmF0dXJlRW5kaW5nO1xuXHRleHBvcnRzLlplcm9GYWN0b3IgPSBaZXJvRmFjdG9yO1xuXHRleHBvcnRzLlplcm9TbG9wZUVuZGluZyA9IFplcm9TbG9wZUVuZGluZztcblx0ZXhwb3J0cy5aZXJvU3RlbmNpbE9wID0gWmVyb1N0ZW5jaWxPcDtcblx0ZXhwb3J0cy5zUkdCRW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIiggZnVuY3Rpb24gKCkge1xuXG5cdC8vIFVubGlrZSBUcmFja2JhbGxDb250cm9scywgaXQgbWFpbnRhaW5zIHRoZSBcInVwXCIgZGlyZWN0aW9uIG9iamVjdC51cCAoK1kgYnkgZGVmYXVsdCkuXG5cdC8vXG5cdC8vICAgIE9yYml0IC0gbGVmdCBtb3VzZSAvIHRvdWNoOiBvbmUtZmluZ2VyIG1vdmVcblx0Ly8gICAgWm9vbSAtIG1pZGRsZSBtb3VzZSwgb3IgbW91c2V3aGVlbCAvIHRvdWNoOiB0d28tZmluZ2VyIHNwcmVhZCBvciBzcXVpc2hcblx0Ly8gICAgUGFuIC0gcmlnaHQgbW91c2UsIG9yIGxlZnQgbW91c2UgKyBjdHJsL21ldGEvc2hpZnRLZXksIG9yIGFycm93IGtleXMgLyB0b3VjaDogdHdvLWZpbmdlciBtb3ZlXG5cblx0Y29uc3QgX2NoYW5nZUV2ZW50ID0ge1xuXHRcdHR5cGU6ICdjaGFuZ2UnXG5cdH07XG5cdGNvbnN0IF9zdGFydEV2ZW50ID0ge1xuXHRcdHR5cGU6ICdzdGFydCdcblx0fTtcblx0Y29uc3QgX2VuZEV2ZW50ID0ge1xuXHRcdHR5cGU6ICdlbmQnXG5cdH07XG5cblx0Y2xhc3MgT3JiaXRDb250cm9scyBleHRlbmRzIFRIUkVFLkV2ZW50RGlzcGF0Y2hlciB7XG5cblx0XHRjb25zdHJ1Y3Rvciggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0aWYgKCBkb21FbGVtZW50ID09PSB1bmRlZmluZWQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiBUaGUgc2Vjb25kIHBhcmFtZXRlciBcImRvbUVsZW1lbnRcIiBpcyBub3cgbWFuZGF0b3J5LicgKTtcblx0XHRcdGlmICggZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgKSBjb25zb2xlLmVycm9yKCAnVEhSRUUuT3JiaXRDb250cm9sczogXCJkb2N1bWVudFwiIHNob3VsZCBub3QgYmUgdXNlZCBhcyB0aGUgdGFyZ2V0IFwiZG9tRWxlbWVudFwiLiBQbGVhc2UgdXNlIFwicmVuZGVyZXIuZG9tRWxlbWVudFwiIGluc3RlYWQuJyApO1xuXHRcdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXHRcdFx0dGhpcy5kb21FbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnOyAvLyBkaXNhYmxlIHRvdWNoIHNjcm9sbFxuXHRcdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG5cblx0XHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7IC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBvYmplY3Qgb3JiaXRzIGFyb3VuZFxuXG5cdFx0XHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7IC8vIEhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0ICggUGVyc3BlY3RpdmVDYW1lcmEgb25seSApXG5cblx0XHRcdHRoaXMubWluRGlzdGFuY2UgPSAwO1xuXHRcdFx0dGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5OyAvLyBIb3cgZmFyIHlvdSBjYW4gem9vbSBpbiBhbmQgb3V0ICggT3J0aG9ncmFwaGljQ2FtZXJhIG9ubHkgKVxuXG5cdFx0XHR0aGlzLm1pblpvb20gPSAwO1xuXHRcdFx0dGhpcy5tYXhab29tID0gSW5maW5pdHk7IC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCB2ZXJ0aWNhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuXHRcdFx0Ly8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG5cblx0XHRcdHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcblxuXHRcdFx0dGhpcy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSTsgLy8gcmFkaWFuc1xuXHRcdFx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IGhvcml6b250YWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cblx0XHRcdC8vIElmIHNldCwgdGhlIGludGVydmFsIFsgbWluLCBtYXggXSBtdXN0IGJlIGEgc3ViLWludGVydmFsIG9mIFsgLSAyIFBJLCAyIFBJIF0sIHdpdGggKCBtYXggLSBtaW4gPCAyIFBJIClcblxuXHRcdFx0dGhpcy5taW5BemltdXRoQW5nbGUgPSAtIEluZmluaXR5OyAvLyByYWRpYW5zXG5cblx0XHRcdHRoaXMubWF4QXppbXV0aEFuZ2xlID0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblx0XHRcdC8vIFNldCB0byB0cnVlIHRvIGVuYWJsZSBkYW1waW5nIChpbmVydGlhKVxuXHRcdFx0Ly8gSWYgZGFtcGluZyBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3BcblxuXHRcdFx0dGhpcy5lbmFibGVEYW1waW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLmRhbXBpbmdGYWN0b3IgPSAwLjA1OyAvLyBUaGlzIG9wdGlvbiBhY3R1YWxseSBlbmFibGVzIGRvbGx5aW5nIGluIGFuZCBvdXQ7IGxlZnQgYXMgXCJ6b29tXCIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZ1xuXG5cdFx0XHR0aGlzLmVuYWJsZVpvb20gPSB0cnVlO1xuXHRcdFx0dGhpcy56b29tU3BlZWQgPSAxLjA7IC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHJvdGF0aW5nXG5cblx0XHRcdHRoaXMuZW5hYmxlUm90YXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMucm90YXRlU3BlZWQgPSAxLjA7IC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHBhbm5pbmdcblxuXHRcdFx0dGhpcy5lbmFibGVQYW4gPSB0cnVlO1xuXHRcdFx0dGhpcy5wYW5TcGVlZCA9IDEuMDtcblx0XHRcdHRoaXMuc2NyZWVuU3BhY2VQYW5uaW5nID0gdHJ1ZTsgLy8gaWYgZmFsc2UsIHBhbiBvcnRob2dvbmFsIHRvIHdvcmxkLXNwYWNlIGRpcmVjdGlvbiBjYW1lcmEudXBcblxuXHRcdFx0dGhpcy5rZXlQYW5TcGVlZCA9IDcuMDsgLy8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuXHRcdFx0Ly8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcblx0XHRcdC8vIElmIGF1dG8tcm90YXRlIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxuXG5cdFx0XHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuYXV0b1JvdGF0ZVNwZWVkID0gMi4wOyAvLyAzMCBzZWNvbmRzIHBlciBvcmJpdCB3aGVuIGZwcyBpcyA2MFxuXHRcdFx0Ly8gVGhlIGZvdXIgYXJyb3cga2V5c1xuXG5cdFx0XHR0aGlzLmtleXMgPSB7XG5cdFx0XHRcdExFRlQ6ICdBcnJvd0xlZnQnLFxuXHRcdFx0XHRVUDogJ0Fycm93VXAnLFxuXHRcdFx0XHRSSUdIVDogJ0Fycm93UmlnaHQnLFxuXHRcdFx0XHRCT1RUT006ICdBcnJvd0Rvd24nXG5cdFx0XHR9OyAvLyBNb3VzZSBidXR0b25zXG5cblx0XHRcdHRoaXMubW91c2VCdXR0b25zID0ge1xuXHRcdFx0XHRMRUZUOiBUSFJFRS5NT1VTRS5ST1RBVEUsXG5cdFx0XHRcdE1JRERMRTogVEhSRUUuTU9VU0UuRE9MTFksXG5cdFx0XHRcdFJJR0hUOiBUSFJFRS5NT1VTRS5QQU5cblx0XHRcdH07IC8vIFRvdWNoIGZpbmdlcnNcblxuXHRcdFx0dGhpcy50b3VjaGVzID0ge1xuXHRcdFx0XHRPTkU6IFRIUkVFLlRPVUNILlJPVEFURSxcblx0XHRcdFx0VFdPOiBUSFJFRS5UT1VDSC5ET0xMWV9QQU5cblx0XHRcdH07IC8vIGZvciByZXNldFxuXG5cdFx0XHR0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXHRcdFx0dGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuXHRcdFx0dGhpcy56b29tMCA9IHRoaXMub2JqZWN0Lnpvb207IC8vIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnQgZm9yIGtleSBldmVudHNcblxuXHRcdFx0dGhpcy5fZG9tRWxlbWVudEtleUV2ZW50cyA9IG51bGw7IC8vXG5cdFx0XHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRcdFx0Ly9cblxuXHRcdFx0dGhpcy5nZXRQb2xhckFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiBzcGhlcmljYWwucGhpO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiBzcGhlcmljYWwudGhldGE7XG5cblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMub2JqZWN0LnBvc2l0aW9uLmRpc3RhbmNlVG8oIHRoaXMudGFyZ2V0ICk7XG5cblx0XHRcdH07XG5cblx0XHRcdHRoaXMubGlzdGVuVG9LZXlFdmVudHMgPSBmdW5jdGlvbiAoIGRvbUVsZW1lbnQgKSB7XG5cblx0XHRcdFx0ZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biApO1xuXHRcdFx0XHR0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzID0gZG9tRWxlbWVudDtcblxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zYXZlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0c2NvcGUudGFyZ2V0MC5jb3B5KCBzY29wZS50YXJnZXQgKTtcblx0XHRcdFx0c2NvcGUucG9zaXRpb24wLmNvcHkoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdFx0XHRzY29wZS56b29tMCA9IHNjb3BlLm9iamVjdC56b29tO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHNjb3BlLnRhcmdldC5jb3B5KCBzY29wZS50YXJnZXQwICk7XG5cdFx0XHRcdHNjb3BlLm9iamVjdC5wb3NpdGlvbi5jb3B5KCBzY29wZS5wb3NpdGlvbjAgKTtcblx0XHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBzY29wZS56b29tMDtcblx0XHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX2NoYW5nZUV2ZW50ICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdH07IC8vIHRoaXMgbWV0aG9kIGlzIGV4cG9zZWQsIGJ1dCBwZXJoYXBzIGl0IHdvdWxkIGJlIGJldHRlciBpZiB3ZSBjYW4gbWFrZSBpdCBwcml2YXRlLi4uXG5cblxuXHRcdFx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTsgLy8gc28gY2FtZXJhLnVwIGlzIHRoZSBvcmJpdCBheGlzXG5cblx0XHRcdFx0Y29uc3QgcXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKCBvYmplY3QudXAsIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblx0XHRcdFx0Y29uc3QgcXVhdEludmVyc2UgPSBxdWF0LmNsb25lKCkuaW52ZXJ0KCk7XG5cdFx0XHRcdGNvbnN0IGxhc3RQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdGNvbnN0IGxhc3RRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0XHRcdFx0Y29uc3QgdHdvUEkgPSAyICogTWF0aC5QSTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuXHRcdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7IC8vIHJvdGF0ZSBvZmZzZXQgdG8gXCJ5LWF4aXMtaXMtdXBcIiBzcGFjZVxuXG5cdFx0XHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdCApOyAvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXG5cblx0XHRcdFx0XHRzcGhlcmljYWwuc2V0RnJvbVZlY3RvcjMoIG9mZnNldCApO1xuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5hdXRvUm90YXRlICYmIHN0YXRlID09PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRcdFx0XHRyb3RhdGVMZWZ0KCBnZXRBdXRvUm90YXRpb25BbmdsZSgpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZURhbXBpbmcgKSB7XG5cblx0XHRcdFx0XHRcdHNwaGVyaWNhbC50aGV0YSArPSBzcGhlcmljYWxEZWx0YS50aGV0YSAqIHNjb3BlLmRhbXBpbmdGYWN0b3I7XG5cdFx0XHRcdFx0XHRzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaSAqIHNjb3BlLmRhbXBpbmdGYWN0b3I7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRzcGhlcmljYWwudGhldGEgKz0gc3BoZXJpY2FsRGVsdGEudGhldGE7XG5cdFx0XHRcdFx0XHRzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaTtcblxuXHRcdFx0XHRcdH0gLy8gcmVzdHJpY3QgdGhldGEgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXG5cblx0XHRcdFx0XHRsZXQgbWluID0gc2NvcGUubWluQXppbXV0aEFuZ2xlO1xuXHRcdFx0XHRcdGxldCBtYXggPSBzY29wZS5tYXhBemltdXRoQW5nbGU7XG5cblx0XHRcdFx0XHRpZiAoIGlzRmluaXRlKCBtaW4gKSAmJiBpc0Zpbml0ZSggbWF4ICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbWluIDwgLSBNYXRoLlBJICkgbWluICs9IHR3b1BJOyBlbHNlIGlmICggbWluID4gTWF0aC5QSSApIG1pbiAtPSB0d29QSTtcblx0XHRcdFx0XHRcdGlmICggbWF4IDwgLSBNYXRoLlBJICkgbWF4ICs9IHR3b1BJOyBlbHNlIGlmICggbWF4ID4gTWF0aC5QSSApIG1heCAtPSB0d29QSTtcblxuXHRcdFx0XHRcdFx0aWYgKCBtaW4gPD0gbWF4ICkge1xuXG5cdFx0XHRcdFx0XHRcdHNwaGVyaWNhbC50aGV0YSA9IE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHNwaGVyaWNhbC50aGV0YSApICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0c3BoZXJpY2FsLnRoZXRhID0gc3BoZXJpY2FsLnRoZXRhID4gKCBtaW4gKyBtYXggKSAvIDIgPyBNYXRoLm1heCggbWluLCBzcGhlcmljYWwudGhldGEgKSA6IE1hdGgubWluKCBtYXgsIHNwaGVyaWNhbC50aGV0YSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cblxuXHRcdFx0XHRcdHNwaGVyaWNhbC5waGkgPSBNYXRoLm1heCggc2NvcGUubWluUG9sYXJBbmdsZSwgTWF0aC5taW4oIHNjb3BlLm1heFBvbGFyQW5nbGUsIHNwaGVyaWNhbC5waGkgKSApO1xuXHRcdFx0XHRcdHNwaGVyaWNhbC5tYWtlU2FmZSgpO1xuXHRcdFx0XHRcdHNwaGVyaWNhbC5yYWRpdXMgKj0gc2NhbGU7IC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cblx0XHRcdFx0XHRzcGhlcmljYWwucmFkaXVzID0gTWF0aC5tYXgoIHNjb3BlLm1pbkRpc3RhbmNlLCBNYXRoLm1pbiggc2NvcGUubWF4RGlzdGFuY2UsIHNwaGVyaWNhbC5yYWRpdXMgKSApOyAvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlRGFtcGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0c2NvcGUudGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggcGFuT2Zmc2V0LCBzY29wZS5kYW1waW5nRmFjdG9yICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRzY29wZS50YXJnZXQuYWRkKCBwYW5PZmZzZXQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9mZnNldC5zZXRGcm9tU3BoZXJpY2FsKCBzcGhlcmljYWwgKTsgLy8gcm90YXRlIG9mZnNldCBiYWNrIHRvIFwiY2FtZXJhLXVwLXZlY3Rvci1pcy11cFwiIHNwYWNlXG5cblx0XHRcdFx0XHRvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0SW52ZXJzZSApO1xuXHRcdFx0XHRcdHBvc2l0aW9uLmNvcHkoIHNjb3BlLnRhcmdldCApLmFkZCggb2Zmc2V0ICk7XG5cdFx0XHRcdFx0c2NvcGUub2JqZWN0Lmxvb2tBdCggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdHNwaGVyaWNhbERlbHRhLnRoZXRhICo9IDEgLSBzY29wZS5kYW1waW5nRmFjdG9yO1xuXHRcdFx0XHRcdFx0c3BoZXJpY2FsRGVsdGEucGhpICo9IDEgLSBzY29wZS5kYW1waW5nRmFjdG9yO1xuXHRcdFx0XHRcdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c3BoZXJpY2FsRGVsdGEuc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRcdFx0XHRwYW5PZmZzZXQuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzY2FsZSA9IDE7IC8vIHVwZGF0ZSBjb25kaXRpb24gaXM6XG5cdFx0XHRcdFx0Ly8gbWluKGNhbWVyYSBkaXNwbGFjZW1lbnQsIGNhbWVyYSByb3RhdGlvbiBpbiByYWRpYW5zKV4yID4gRVBTXG5cdFx0XHRcdFx0Ly8gdXNpbmcgc21hbGwtYW5nbGUgYXBwcm94aW1hdGlvbiBjb3MoeC8yKSA9IDEgLSB4XjIgLyA4XG5cblx0XHRcdFx0XHRpZiAoIHpvb21DaGFuZ2VkIHx8IGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggc2NvcGUub2JqZWN0LnBvc2l0aW9uICkgPiBFUFMgfHwgOCAqICggMSAtIGxhc3RRdWF0ZXJuaW9uLmRvdCggc2NvcGUub2JqZWN0LnF1YXRlcm5pb24gKSApID4gRVBTICkge1xuXG5cdFx0XHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfY2hhbmdlRXZlbnQgKTtcblx0XHRcdFx0XHRcdGxhc3RQb3NpdGlvbi5jb3B5KCBzY29wZS5vYmplY3QucG9zaXRpb24gKTtcblx0XHRcdFx0XHRcdGxhc3RRdWF0ZXJuaW9uLmNvcHkoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICk7XG5cdFx0XHRcdFx0XHR6b29tQ2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fSgpO1xuXG5cdFx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51ICk7XG5cdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biApO1xuXHRcdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVyY2FuY2VsJywgb25Qb2ludGVyQ2FuY2VsICk7XG5cdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgb25Nb3VzZVdoZWVsICk7XG5cdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSApO1xuXHRcdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVydXAnLCBvblBvaW50ZXJVcCApO1xuXG5cdFx0XHRcdGlmICggc2NvcGUuX2RvbUVsZW1lbnRLZXlFdmVudHMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5fZG9tRWxlbWVudEtleUV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biApO1xuXG5cdFx0XHRcdH0gLy9zY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7IC8vIHNob3VsZCB0aGlzIGJlIGFkZGVkIGhlcmU/XG5cblx0XHRcdH07IC8vXG5cdFx0XHQvLyBpbnRlcm5hbHNcblx0XHRcdC8vXG5cblxuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29uc3QgU1RBVEUgPSB7XG5cdFx0XHRcdE5PTkU6IC0gMSxcblx0XHRcdFx0Uk9UQVRFOiAwLFxuXHRcdFx0XHRET0xMWTogMSxcblx0XHRcdFx0UEFOOiAyLFxuXHRcdFx0XHRUT1VDSF9ST1RBVEU6IDMsXG5cdFx0XHRcdFRPVUNIX1BBTjogNCxcblx0XHRcdFx0VE9VQ0hfRE9MTFlfUEFOOiA1LFxuXHRcdFx0XHRUT1VDSF9ET0xMWV9ST1RBVEU6IDZcblx0XHRcdH07XG5cdFx0XHRsZXQgc3RhdGUgPSBTVEFURS5OT05FO1xuXHRcdFx0Y29uc3QgRVBTID0gMC4wMDAwMDE7IC8vIGN1cnJlbnQgcG9zaXRpb24gaW4gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG5cblx0XHRcdGNvbnN0IHNwaGVyaWNhbCA9IG5ldyBUSFJFRS5TcGhlcmljYWwoKTtcblx0XHRcdGNvbnN0IHNwaGVyaWNhbERlbHRhID0gbmV3IFRIUkVFLlNwaGVyaWNhbCgpO1xuXHRcdFx0bGV0IHNjYWxlID0gMTtcblx0XHRcdGNvbnN0IHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRsZXQgem9vbUNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHJvdGF0ZVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHJvdGF0ZUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0XHRjb25zdCByb3RhdGVEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0XHRjb25zdCBwYW5TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0XHRjb25zdCBwYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgcGFuRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgZG9sbHlTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0XHRjb25zdCBkb2xseUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0XHRjb25zdCBkb2xseURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHBvaW50ZXJzID0gW107XG5cdFx0XHRjb25zdCBwb2ludGVyUG9zaXRpb25zID0ge307XG5cblx0XHRcdGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuXG5cdFx0XHRcdHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0Wm9vbVNjYWxlKCkge1xuXG5cdFx0XHRcdHJldHVybiBNYXRoLnBvdyggMC45NSwgc2NvcGUuem9vbVNwZWVkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcm90YXRlTGVmdCggYW5nbGUgKSB7XG5cblx0XHRcdFx0c3BoZXJpY2FsRGVsdGEudGhldGEgLT0gYW5nbGU7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcm90YXRlVXAoIGFuZ2xlICkge1xuXG5cdFx0XHRcdHNwaGVyaWNhbERlbHRhLnBoaSAtPSBhbmdsZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwYW5MZWZ0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnN0IHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuTGVmdCggZGlzdGFuY2UsIG9iamVjdE1hdHJpeCApIHtcblxuXHRcdFx0XHRcdHYuc2V0RnJvbU1hdHJpeENvbHVtbiggb2JqZWN0TWF0cml4LCAwICk7IC8vIGdldCBYIGNvbHVtbiBvZiBvYmplY3RNYXRyaXhcblxuXHRcdFx0XHRcdHYubXVsdGlwbHlTY2FsYXIoIC0gZGlzdGFuY2UgKTtcblx0XHRcdFx0XHRwYW5PZmZzZXQuYWRkKCB2ICk7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fSgpO1xuXG5cdFx0XHRjb25zdCBwYW5VcCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zdCB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHBhblVwKCBkaXN0YW5jZSwgb2JqZWN0TWF0cml4ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5zY3JlZW5TcGFjZVBhbm5pbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdHYuc2V0RnJvbU1hdHJpeENvbHVtbiggb2JqZWN0TWF0cml4LCAxICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMCApO1xuXHRcdFx0XHRcdFx0di5jcm9zc1ZlY3RvcnMoIHNjb3BlLm9iamVjdC51cCwgdiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0di5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKTtcblx0XHRcdFx0XHRwYW5PZmZzZXQuYWRkKCB2ICk7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fSgpOyAvLyBkZWx0YVggYW5kIGRlbHRhWSBhcmUgaW4gcGl4ZWxzOyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcblxuXG5cdFx0XHRjb25zdCBwYW4gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHBhbiggZGVsdGFYLCBkZWx0YVkgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0XHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHBlcnNwZWN0aXZlXG5cdFx0XHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IHNjb3BlLm9iamVjdC5wb3NpdGlvbjtcblx0XHRcdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cdFx0XHRcdFx0XHRsZXQgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7IC8vIGhhbGYgb2YgdGhlIGZvdiBpcyBjZW50ZXIgdG8gdG9wIG9mIHNjcmVlblxuXG5cdFx0XHRcdFx0XHR0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbiggc2NvcGUub2JqZWN0LmZvdiAvIDIgKiBNYXRoLlBJIC8gMTgwLjAgKTsgLy8gd2UgdXNlIG9ubHkgY2xpZW50SGVpZ2h0IGhlcmUgc28gYXNwZWN0IHJhdGlvIGRvZXMgbm90IGRpc3RvcnQgc3BlZWRcblxuXHRcdFx0XHRcdFx0cGFuTGVmdCggMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblx0XHRcdFx0XHRcdHBhblVwKCAyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0XHQvLyBvcnRob2dyYXBoaWNcblx0XHRcdFx0XHRcdHBhbkxlZnQoIGRlbHRhWCAqICggc2NvcGUub2JqZWN0LnJpZ2h0IC0gc2NvcGUub2JqZWN0LmxlZnQgKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRXaWR0aCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXHRcdFx0XHRcdFx0cGFuVXAoIGRlbHRhWSAqICggc2NvcGUub2JqZWN0LnRvcCAtIHNjb3BlLm9iamVjdC5ib3R0b20gKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIGNhbWVyYSBuZWl0aGVyIG9ydGhvZ3JhcGhpYyBub3IgcGVyc3BlY3RpdmVcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHBhbiBkaXNhYmxlZC4nICk7XG5cdFx0XHRcdFx0XHRzY29wZS5lbmFibGVQYW4gPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9KCk7XG5cblx0XHRcdGZ1bmN0aW9uIGRvbGx5T3V0KCBkb2xseVNjYWxlICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHRzY2FsZSAvPSBkb2xseVNjYWxlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRcdHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoIHNjb3BlLm1pblpvb20sIE1hdGgubWluKCBzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAqIGRvbGx5U2NhbGUgKSApO1xuXHRcdFx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRcdFx0em9vbUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBkb2xseS96b29tIGRpc2FibGVkLicgKTtcblx0XHRcdFx0XHRzY29wZS5lbmFibGVab29tID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGRvbGx5SW4oIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0XHRcdHNjYWxlICo9IGRvbGx5U2NhbGU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCggc2NvcGUubWluWm9vbSwgTWF0aC5taW4oIHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tIC8gZG9sbHlTY2FsZSApICk7XG5cdFx0XHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdFx0XHR6b29tQ2hhbmdlZCA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRcdHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gLy9cblx0XHRcdC8vIGV2ZW50IGNhbGxiYWNrcyAtIHVwZGF0ZSB0aGUgb2JqZWN0IHN0YXRlXG5cdFx0XHQvL1xuXG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duRG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0XHRcdGRvbGx5U3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duUGFuKCBldmVudCApIHtcblxuXHRcdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblx0XHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApLm11bHRpcGx5U2NhbGFyKCBzY29wZS5yb3RhdGVTcGVlZCApO1xuXHRcdFx0XHRjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcblx0XHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTsgLy8geWVzLCBoZWlnaHRcblxuXHRcdFx0XHRyb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblx0XHRcdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdFx0XHRkb2xseUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblx0XHRcdFx0ZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG5cdFx0XHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcblxuXHRcdFx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGRvbGx5RGVsdGEueSA8IDAgKSB7XG5cblx0XHRcdFx0XHRkb2xseUluKCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVBhbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0cGFuRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXHRcdFx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICkubXVsdGlwbHlTY2FsYXIoIHNjb3BlLnBhblNwZWVkICk7XG5cdFx0XHRcdHBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXHRcdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VVcCggKSB7IC8vIG5vLW9wXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0XHRcdGlmICggZXZlbnQuZGVsdGFZIDwgMCApIHtcblxuXHRcdFx0XHRcdGRvbGx5SW4oIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggZXZlbnQuZGVsdGFZID4gMCApIHtcblxuXHRcdFx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVLZXlEb3duKCBldmVudCApIHtcblxuXHRcdFx0XHRsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBldmVudC5jb2RlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLlVQOlxuXHRcdFx0XHRcdFx0cGFuKCAwLCBzY29wZS5rZXlQYW5TcGVlZCApO1xuXHRcdFx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuXHRcdFx0XHRcdFx0cGFuKCAwLCAtIHNjb3BlLmtleVBhblNwZWVkICk7XG5cdFx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2Ugc2NvcGUua2V5cy5MRUZUOlxuXHRcdFx0XHRcdFx0cGFuKCBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xuXHRcdFx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIHNjb3BlLmtleXMuUklHSFQ6XG5cdFx0XHRcdFx0XHRwYW4oIC0gc2NvcGUua2V5UGFuU3BlZWQsIDAgKTtcblx0XHRcdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdFx0Ly8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZyBvbiBjdXJzb3Iga2V5c1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoKSB7XG5cblx0XHRcdFx0aWYgKCBwb2ludGVycy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0XHRyb3RhdGVTdGFydC5zZXQoIHBvaW50ZXJzWyAwIF0ucGFnZVgsIHBvaW50ZXJzWyAwIF0ucGFnZVkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc3QgeCA9IDAuNSAqICggcG9pbnRlcnNbIDAgXS5wYWdlWCArIHBvaW50ZXJzWyAxIF0ucGFnZVggKTtcblx0XHRcdFx0XHRjb25zdCB5ID0gMC41ICogKCBwb2ludGVyc1sgMCBdLnBhZ2VZICsgcG9pbnRlcnNbIDEgXS5wYWdlWSApO1xuXHRcdFx0XHRcdHJvdGF0ZVN0YXJ0LnNldCggeCwgeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0UGFuKCkge1xuXG5cdFx0XHRcdGlmICggcG9pbnRlcnMubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdFx0cGFuU3RhcnQuc2V0KCBwb2ludGVyc1sgMCBdLnBhZ2VYLCBwb2ludGVyc1sgMCBdLnBhZ2VZICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnN0IHggPSAwLjUgKiAoIHBvaW50ZXJzWyAwIF0ucGFnZVggKyBwb2ludGVyc1sgMSBdLnBhZ2VYICk7XG5cdFx0XHRcdFx0Y29uc3QgeSA9IDAuNSAqICggcG9pbnRlcnNbIDAgXS5wYWdlWSArIHBvaW50ZXJzWyAxIF0ucGFnZVkgKTtcblx0XHRcdFx0XHRwYW5TdGFydC5zZXQoIHgsIHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5KCkge1xuXG5cdFx0XHRcdGNvbnN0IGR4ID0gcG9pbnRlcnNbIDAgXS5wYWdlWCAtIHBvaW50ZXJzWyAxIF0ucGFnZVg7XG5cdFx0XHRcdGNvbnN0IGR5ID0gcG9pbnRlcnNbIDAgXS5wYWdlWSAtIHBvaW50ZXJzWyAxIF0ucGFnZVk7XG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXHRcdFx0XHRkb2xseVN0YXJ0LnNldCggMCwgZGlzdGFuY2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0RG9sbHlQYW4oKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tICkgaGFuZGxlVG91Y2hTdGFydERvbGx5KCk7XG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuICkgaGFuZGxlVG91Y2hTdGFydFBhbigpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSgpIHtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gKSBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoKTtcblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgKSBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUm90YXRlKCBldmVudCApIHtcblxuXHRcdFx0XHRpZiAoIHBvaW50ZXJzLmxlbmd0aCA9PSAxICkge1xuXG5cdFx0XHRcdFx0cm90YXRlRW5kLnNldCggZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKCBldmVudCApO1xuXHRcdFx0XHRcdGNvbnN0IHggPSAwLjUgKiAoIGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueCApO1xuXHRcdFx0XHRcdGNvbnN0IHkgPSAwLjUgKiAoIGV2ZW50LnBhZ2VZICsgcG9zaXRpb24ueSApO1xuXHRcdFx0XHRcdHJvdGF0ZUVuZC5zZXQoIHgsIHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApLm11bHRpcGx5U2NhbGFyKCBzY29wZS5yb3RhdGVTcGVlZCApO1xuXHRcdFx0XHRjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcblx0XHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTsgLy8geWVzLCBoZWlnaHRcblxuXHRcdFx0XHRyb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblx0XHRcdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUGFuKCBldmVudCApIHtcblxuXHRcdFx0XHRpZiAoIHBvaW50ZXJzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdHBhbkVuZC5zZXQoIGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbiggZXZlbnQgKTtcblx0XHRcdFx0XHRjb25zdCB4ID0gMC41ICogKCBldmVudC5wYWdlWCArIHBvc2l0aW9uLnggKTtcblx0XHRcdFx0XHRjb25zdCB5ID0gMC41ICogKCBldmVudC5wYWdlWSArIHBvc2l0aW9uLnkgKTtcblx0XHRcdFx0XHRwYW5FbmQuc2V0KCB4LCB5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKS5tdWx0aXBseVNjYWxhciggc2NvcGUucGFuU3BlZWQgKTtcblx0XHRcdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cdFx0XHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbiggZXZlbnQgKTtcblx0XHRcdFx0Y29uc3QgZHggPSBldmVudC5wYWdlWCAtIHBvc2l0aW9uLng7XG5cdFx0XHRcdGNvbnN0IGR5ID0gZXZlbnQucGFnZVkgLSBwb3NpdGlvbi55O1xuXHRcdFx0XHRjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcblx0XHRcdFx0ZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXHRcdFx0XHRkb2xseURlbHRhLnNldCggMCwgTWF0aC5wb3coIGRvbGx5RW5kLnkgLyBkb2xseVN0YXJ0LnksIHNjb3BlLnpvb21TcGVlZCApICk7XG5cdFx0XHRcdGRvbGx5T3V0KCBkb2xseURlbHRhLnkgKTtcblx0XHRcdFx0ZG9sbHlTdGFydC5jb3B5KCBkb2xseUVuZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5UGFuKCBldmVudCApIHtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gKSBoYW5kbGVUb3VjaE1vdmVEb2xseSggZXZlbnQgKTtcblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gKSBoYW5kbGVUb3VjaE1vdmVQYW4oIGV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHlSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSApIGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApO1xuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSApIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCggKSB7IC8vIG5vLW9wXG5cdFx0XHR9IC8vXG5cdFx0XHQvLyBldmVudCBoYW5kbGVycyAtIEZTTTogbGlzdGVuIGZvciBldmVudHMgYW5kIHJlc2V0IHN0YXRlXG5cdFx0XHQvL1xuXG5cblx0XHRcdGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKCBwb2ludGVycy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5kb21FbGVtZW50LnNldFBvaW50ZXJDYXB0dXJlKCBldmVudC5wb2ludGVySWQgKTtcblx0XHRcdFx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUgKTtcblx0XHRcdFx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVydXAnLCBvblBvaW50ZXJVcCApO1xuXG5cdFx0XHRcdH0gLy9cblxuXG5cdFx0XHRcdGFkZFBvaW50ZXIoIGV2ZW50ICk7XG5cblx0XHRcdFx0aWYgKCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyApIHtcblxuXHRcdFx0XHRcdG9uVG91Y2hTdGFydCggZXZlbnQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0b25Nb3VzZURvd24oIGV2ZW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoIGV2ZW50ICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyApIHtcblxuXHRcdFx0XHRcdG9uVG91Y2hNb3ZlKCBldmVudCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRvbk1vdXNlTW92ZSggZXZlbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25Qb2ludGVyVXAoIGV2ZW50ICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyApIHtcblxuXHRcdFx0XHRcdG9uVG91Y2hFbmQoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0b25Nb3VzZVVwKCBldmVudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZW1vdmVQb2ludGVyKCBldmVudCApOyAvL1xuXG5cdFx0XHRcdGlmICggcG9pbnRlcnMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoIGV2ZW50LnBvaW50ZXJJZCApO1xuXHRcdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSApO1xuXHRcdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uUG9pbnRlckNhbmNlbCggZXZlbnQgKSB7XG5cblx0XHRcdFx0cmVtb3ZlUG9pbnRlciggZXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBvbk1vdXNlRG93biggZXZlbnQgKSB7XG5cblx0XHRcdFx0bGV0IG1vdXNlQWN0aW9uO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGV2ZW50LmJ1dHRvbiApIHtcblxuXHRcdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRcdG1vdXNlQWN0aW9uID0gc2NvcGUubW91c2VCdXR0b25zLkxFRlQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdG1vdXNlQWN0aW9uID0gc2NvcGUubW91c2VCdXR0b25zLk1JRERMRTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0bW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuUklHSFQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRtb3VzZUFjdGlvbiA9IC0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3dpdGNoICggbW91c2VBY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLk1PVVNFLkRPTExZOlxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdFx0XHRcdGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApO1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5ET0xMWTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5NT1VTRS5ST1RBVEU6XG5cdFx0XHRcdFx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdFx0XHRcdGhhbmRsZU1vdXNlRG93blBhbiggZXZlbnQgKTtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5QQU47XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICk7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5NT1VTRS5QQU46XG5cdFx0XHRcdFx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdFx0XHRcdGhhbmRsZU1vdXNlRG93blJvdGF0ZSggZXZlbnQgKTtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5ST1RBVEU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICk7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIF9zdGFydEV2ZW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCBldmVudCApIHtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdHN3aXRjaCAoIHN0YXRlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBTVEFURS5ST1RBVEU6XG5cdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVSb3RhdGUoIGV2ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgU1RBVEUuRE9MTFk6XG5cdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlRG9sbHkoIGV2ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgU1RBVEUuUEFOOlxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlUGFuKCBldmVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uTW91c2VVcCggZXZlbnQgKSB7XG5cblx0XHRcdFx0aGFuZGxlTW91c2VVcCggZXZlbnQgKTtcblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX2VuZEV2ZW50ICk7XG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBvbk1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgfHwgc3RhdGUgIT09IFNUQVRFLk5PTkUgJiYgc3RhdGUgIT09IFNUQVRFLlJPVEFURSApIHJldHVybjtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX3N0YXJ0RXZlbnQgKTtcblx0XHRcdFx0aGFuZGxlTW91c2VXaGVlbCggZXZlbnQgKTtcblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX2VuZEV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25LZXlEb3duKCBldmVudCApIHtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdGhhbmRsZUtleURvd24oIGV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCBldmVudCApIHtcblxuXHRcdFx0XHR0cmFja1BvaW50ZXIoIGV2ZW50ICk7XG5cblx0XHRcdFx0c3dpdGNoICggcG9pbnRlcnMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0c3dpdGNoICggc2NvcGUudG91Y2hlcy5PTkUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSBUSFJFRS5UT1VDSC5ST1RBVEU6XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoKTtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIFRIUkVFLlRPVUNILlBBTjpcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydFBhbigpO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUEFOO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0c3dpdGNoICggc2NvcGUudG91Y2hlcy5UV08gKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSBUSFJFRS5UT1VDSC5ET0xMWV9QQU46XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnREb2xseVBhbigpO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFlfUEFOO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgVEhSRUUuVE9VQ0guRE9MTFlfUk9UQVRFOlxuXHRcdFx0XHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgJiYgc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0RG9sbHlSb3RhdGUoKTtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZX1JPVEFURTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfc3RhcnRFdmVudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBvblRvdWNoTW92ZSggZXZlbnQgKSB7XG5cblx0XHRcdFx0dHJhY2tQb2ludGVyKCBldmVudCApO1xuXG5cdFx0XHRcdHN3aXRjaCAoIHN0YXRlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBTVEFURS5UT1VDSF9ST1RBVEU6XG5cdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVSb3RhdGUoIGV2ZW50ICk7XG5cdFx0XHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBTVEFURS5UT1VDSF9QQU46XG5cdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVQYW4oIGV2ZW50ICk7XG5cdFx0XHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBTVEFURS5UT1VDSF9ET0xMWV9QQU46XG5cdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseVBhbiggZXZlbnQgKTtcblx0XHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFNUQVRFLlRPVUNIX0RPTExZX1JPVEFURTpcblx0XHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgJiYgc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdFx0XHRcdGhhbmRsZVRvdWNoTW92ZURvbGx5Um90YXRlKCBldmVudCApO1xuXHRcdFx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uVG91Y2hFbmQoIGV2ZW50ICkge1xuXG5cdFx0XHRcdGhhbmRsZVRvdWNoRW5kKCBldmVudCApO1xuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfZW5kRXZlbnQgKTtcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoIGV2ZW50ICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYWRkUG9pbnRlciggZXZlbnQgKSB7XG5cblx0XHRcdFx0cG9pbnRlcnMucHVzaCggZXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZW1vdmVQb2ludGVyKCBldmVudCApIHtcblxuXHRcdFx0XHRkZWxldGUgcG9pbnRlclBvc2l0aW9uc1sgZXZlbnQucG9pbnRlcklkIF07XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwb2ludGVyc1sgaSBdLnBvaW50ZXJJZCA9PSBldmVudC5wb2ludGVySWQgKSB7XG5cblx0XHRcdFx0XHRcdHBvaW50ZXJzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB0cmFja1BvaW50ZXIoIGV2ZW50ICkge1xuXG5cdFx0XHRcdGxldCBwb3NpdGlvbiA9IHBvaW50ZXJQb3NpdGlvbnNbIGV2ZW50LnBvaW50ZXJJZCBdO1xuXG5cdFx0XHRcdGlmICggcG9zaXRpb24gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHRcdFx0XHRwb2ludGVyUG9zaXRpb25zWyBldmVudC5wb2ludGVySWQgXSA9IHBvc2l0aW9uO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwb3NpdGlvbi5zZXQoIGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Y29uc3QgcG9pbnRlciA9IGV2ZW50LnBvaW50ZXJJZCA9PT0gcG9pbnRlcnNbIDAgXS5wb2ludGVySWQgPyBwb2ludGVyc1sgMSBdIDogcG9pbnRlcnNbIDAgXTtcblx0XHRcdFx0cmV0dXJuIHBvaW50ZXJQb3NpdGlvbnNbIHBvaW50ZXIucG9pbnRlcklkIF07XG5cblx0XHRcdH0gLy9cblxuXG5cdFx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUgKTtcblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biApO1xuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcmNhbmNlbCcsIG9uUG9pbnRlckNhbmNlbCApO1xuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbk1vdXNlV2hlZWwsIHtcblx0XHRcdFx0cGFzc2l2ZTogZmFsc2Vcblx0XHRcdH0gKTsgLy8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XG5cblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0fSAvLyBUaGlzIHNldCBvZiBjb250cm9scyBwZXJmb3JtcyBvcmJpdGluZywgZG9sbHlpbmcgKHpvb21pbmcpLCBhbmQgcGFubmluZy5cblx0Ly8gVW5saWtlIFRyYWNrYmFsbENvbnRyb2xzLCBpdCBtYWludGFpbnMgdGhlIFwidXBcIiBkaXJlY3Rpb24gb2JqZWN0LnVwICgrWSBieSBkZWZhdWx0KS5cblx0Ly8gVGhpcyBpcyB2ZXJ5IHNpbWlsYXIgdG8gT3JiaXRDb250cm9scywgYW5vdGhlciBzZXQgb2YgdG91Y2ggYmVoYXZpb3Jcblx0Ly9cblx0Ly8gICAgT3JiaXQgLSByaWdodCBtb3VzZSwgb3IgbGVmdCBtb3VzZSArIGN0cmwvbWV0YS9zaGlmdEtleSAvIHRvdWNoOiB0d28tZmluZ2VyIHJvdGF0ZVxuXHQvLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3by1maW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuXHQvLyAgICBQYW4gLSBsZWZ0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IG9uZS1maW5nZXIgbW92ZVxuXG5cblx0Y2xhc3MgTWFwQ29udHJvbHMgZXh0ZW5kcyBPcmJpdENvbnRyb2xzIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XG5cblx0XHRcdHN1cGVyKCBvYmplY3QsIGRvbUVsZW1lbnQgKTtcblx0XHRcdHRoaXMuc2NyZWVuU3BhY2VQYW5uaW5nID0gZmFsc2U7IC8vIHBhbiBvcnRob2dvbmFsIHRvIHdvcmxkLXNwYWNlIGRpcmVjdGlvbiBjYW1lcmEudXBcblxuXHRcdFx0dGhpcy5tb3VzZUJ1dHRvbnMuTEVGVCA9IFRIUkVFLk1PVVNFLlBBTjtcblx0XHRcdHRoaXMubW91c2VCdXR0b25zLlJJR0hUID0gVEhSRUUuTU9VU0UuUk9UQVRFO1xuXHRcdFx0dGhpcy50b3VjaGVzLk9ORSA9IFRIUkVFLlRPVUNILlBBTjtcblx0XHRcdHRoaXMudG91Y2hlcy5UV08gPSBUSFJFRS5UT1VDSC5ET0xMWV9ST1RBVEU7XG5cblx0XHR9XG5cblx0fVxuXG5cdFRIUkVFLk1hcENvbnRyb2xzID0gTWFwQ29udHJvbHM7XG5cdFRIUkVFLk9yYml0Q29udHJvbHMgPSBPcmJpdENvbnRyb2xzO1xuXG59ICkoKTtcbiIsIlxuZ2xvYmFsLkNBTlZBU19TS0VUQ0hfREVGQVVMVF9TVE9SQUdFX0tFWSA9IFwiRDpcXFxcTWFudWVsXFxcXGNhbnZhcy1za2V0Y2hcXFxcZXhhbXBsZXNcXFxcYW5pbWF0ZWQtdGhyZWUtYmFzaWMtY3ViZS5qc1wiO1xuIl19
